<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Javascript namespace 创建方法 | Jenna233</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="全局变量的使用应该引起注意，只有系统范围相关的对象才声明为全局变量， 并且避免命名冲突。 比较好的减少全局变量的策略是创建少量的全局对象，这些对象将用作基础模块和子系统的namespace(命名空间)。下面将介绍几种namespace的创建方法。 静态namespace静态namespace是hard coded， 可以将一个namespace赋值给另一个namespace， 两个namespac">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript namespace 创建方法">
<meta property="og:url" content="https://jenna233.github.io/2020/11/23/Javascript-namespace-%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95/index.html">
<meta property="og:site_name" content="Jenna233">
<meta property="og:description" content="全局变量的使用应该引起注意，只有系统范围相关的对象才声明为全局变量， 并且避免命名冲突。 比较好的减少全局变量的策略是创建少量的全局对象，这些对象将用作基础模块和子系统的namespace(命名空间)。下面将介绍几种namespace的创建方法。 静态namespace静态namespace是hard coded， 可以将一个namespace赋值给另一个namespace， 两个namespac">
<meta property="og:locale">
<meta property="article:published_time" content="2020-11-23T02:12:28.000Z">
<meta property="article:modified_time" content="2020-11-23T02:28:56.000Z">
<meta property="article:author" content="Jenna233">
<meta property="article:tag" content="Javascript">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jenna233" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/tocas.css">

  
<link rel="stylesheet" href="/css/animate.css">

  
<link rel="stylesheet" href="/css/style.css">

  <style type="text/css">
    a.title-link:hover{
        color: #34b2db !important;
    }

    a.title-link:active{
        color: #2075c1 !important;
    }

    #menu-color-id{
        background : #f7f7f7;
    }

    #menu-color-id a{
        color: #5a5a5a;
    }
  </style>
  
<script src="/js/tocas.js"></script>

  

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
<!-- navigation -->

<div class="ts fluid basic link big menu" id="menu-color-id">

    <!-- ejs : align to post page or index page -->
        
            <div class="ts very narrow container">
        

        
            <a class="item" href="/">Home</a>
        
            <a class="item" href="/archives">Archives</a>
        
    </div>
</div>
<!-- the end of navigation -->

<!-- big bang title -->
<div class="ts padded horizontally fitted fluid slate" style="background-color: #f7f7f7;">
    <!-- ejs : align to post page or index page -->
    
        <div class="ts very narrow container">
    
        <!-- Title -->
        <h1 class="ts eleven wide column header be-center-h1">
            <span style="color: #404040;" id="big-title">Jenna233</span>
            <div class="sub header" id="slogan-bar" style=" margin-top: 15px; color: #404040;"></div>
        </h1>
        <!-- the end of title -->
    </div>
</div>
<!-- the end of big bang title -->


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">

<!-- main section -->
<div class="ts text container">
        <!-- left section -->
        <div class="column" style=" padding: 35px; ">
            <!-- Articles -->
                
                <h1 class="ts header">
                    <span style="color: #333;">Javascript namespace 创建方法</span>
                    <div class="sub header" style="color: #808080;">Publish: 2020/11/23 
                     &nbsp;&nbsp;
                        <ul class="unstyled radius-tag -list" itemprop="keywords"><li class="unstyled radius-tag -list-item"><a class="unstyled radius-tag -list-link" href="/tags/Javascript/" rel="tag">Javascript</a></li></ul>
                    
                    </div>
                </h1>

                <p>全局变量的使用应该引起注意，只有系统范围相关的对象才声明为全局变量， 并且避免命名冲突。 比较好的减少全局变量的策略是创建少量的全局对象，这些对象将用作基础模块和子系统的namespace(命名空间)。下面将介绍几种namespace的创建方法。</p>
<h1 id="静态namespace"><a href="#静态namespace" class="headerlink" title="静态namespace"></a>静态namespace</h1><p>静态namespace是hard coded， 可以将一个namespace赋值给另一个namespace， 两个namespace将引用相同的对象。</p>
<h2 id="1-直接赋值"><a href="#1-直接赋值" class="headerlink" title="1.直接赋值"></a>1.直接赋值</h2><p>直接赋值是最基本的方法，这种方法比较费时费力，如果想重新命名，需要花费一番功夫。 但是这种方法却很安全和明确。方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var myApp &#x3D; &#123;&#125;</span><br><span class="line"> </span><br><span class="line">myApp.id &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">myApp.next &#x3D; function() &#123;</span><br><span class="line">    return myApp.id++;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myApp.reset &#x3D; function() &#123;</span><br><span class="line">    myApp.id &#x3D; 0;   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">); &#x2F;&#x2F;0, 1, undefined, 0 </span><br></pre></td></tr></table></figure>
<p>通过使用它来引用同级属性，可以使以后的维护更容易，但是这有点冒险，因为没有什么可以阻止重新分配name space的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var myApp &#x3D; &#123;&#125;</span><br><span class="line"> </span><br><span class="line">myApp.id &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">myApp.next &#x3D; function() &#123;</span><br><span class="line">    return this.id++;   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myApp.reset &#x3D; function() &#123;</span><br><span class="line">    this.id &#x3D; 0;    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myApp.next(); &#x2F;&#x2F;0</span><br><span class="line">myApp.next(); &#x2F;&#x2F;1</span><br><span class="line">var getNextId &#x3D; myApp.next;</span><br><span class="line">getNextId(); &#x2F;&#x2F;NaN whoops!</span><br></pre></td></tr></table></figure>
<h2 id="2-使用object-literal表示法"><a href="#2-使用object-literal表示法" class="headerlink" title="2.使用object literal表示法"></a>2.使用object literal表示法</h2><p>如果我们只使用一次命名空间，切换命名空间就比较容易，但有时候命名空间的值还是会出乎意料。我们可以假设定义在命名空间构造函数里面的对象的值不会被重新赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var myApp &#x3D; &#123;</span><br><span class="line"> </span><br><span class="line">    id: 0,</span><br><span class="line"> </span><br><span class="line">    next: function() &#123;</span><br><span class="line">        return this.id++;   </span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    reset: function() &#123;</span><br><span class="line">        this.id &#x3D; 0;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">) &#x2F;&#x2F;0, 1, undefined, 0</span><br></pre></td></tr></table></figure>

<h2 id="3-模块模式"><a href="#3-模块模式" class="headerlink" title="3.模块模式"></a>3.模块模式</h2><p>通过函数包装器（通常是自调用）将逻辑与全局范围隔离开，该函数包装器返回表示模块公共接口的对象。 通过立即调用该函数并将结果分配给名称空间变量，我们将模块的API锁定在名称空间中。 此外，未包含在返回值中的所有变量将永远保持私有状态，仅对引用它们的公共函数可见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var myApp &#x3D; (function() &#123;</span><br><span class="line"> </span><br><span class="line">    var id&#x3D; 0;</span><br><span class="line"> </span><br><span class="line">    return &#123;</span><br><span class="line">        next: function() &#123;</span><br><span class="line">            return id++;    </span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        reset: function() &#123;</span><br><span class="line">            id &#x3D; 0;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;)();   </span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">) &#x2F;&#x2F;0, 1, undefined, 0  </span><br></pre></td></tr></table></figure>
<p>像上面的object literal 示例一样，可以很容易地切换接收名称空间，还有其他优点：object literal 是固定的–它全部与属性分配有关，没有空间支持逻辑, 此外，object literal 必须初始化所有属性，并且属性值不能轻易相互引用（因此，内部闭包是不可能的）。 模块模式不受这些限制，并为我们带来了私有性的额外好处。</p>
<h1 id="动态namespace"><a href="#动态namespace" class="headerlink" title="动态namespace"></a>动态namespace</h1><p>我们也可以称此部分为namespace注入。 namespace由在函数包装器内直接引用的代理表示–这意味着我们不再需要捆绑返回值来分配给名称空间。 这使名称空间定义更加灵活，并使在独立的名称空间（甚至在全局上下文中）存在模块的多个独立实例变得非常容易。 动态命名空间支持模块模式的所有功能，并具有直观易读的附加优势。</p>
<h2 id="4-提供name-space参数"><a href="#4-提供name-space参数" class="headerlink" title="4.提供name space参数"></a>4.提供name space参数</h2><p>在这里，我们只是将namespace作为参数传递给自调用函数。 id变量是私有的，因为它没有分配给context。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var myApp &#x3D; &#123;&#125;;</span><br><span class="line">(function(context) &#123; </span><br><span class="line">    var id &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">    context.next &#x3D; function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    context.reset &#x3D; function() &#123;</span><br><span class="line">        id &#x3D; 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(myApp);  </span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">) &#x2F;&#x2F;0, 1, undefined, 0  </span><br></pre></td></tr></table></figure>
<p>我们甚至可以将context设置为全局对象（只需更改一个单词！）。 对于图书馆供应商来说，这是一笔巨大的财富–他们可以将其功能包装在一个自调用功能中，然后由用户决定是否应该是全局的（John Resig在编写JQuery时就是这个概念的早期采用者）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var myApp &#x3D; &#123;&#125;;</span><br><span class="line">(function(context) &#123; </span><br><span class="line">    var id &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">    context.next &#x3D; function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    context.reset &#x3D; function() &#123;</span><br><span class="line">        id &#x3D; 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(this);   </span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    next(),</span><br><span class="line">    next(),</span><br><span class="line">    reset(),</span><br><span class="line">    next()</span><br><span class="line">) &#x2F;&#x2F;0, 1, undefined, 0  </span><br></pre></td></tr></table></figure>
<h2 id="5-将this用作namespace代理"><a href="#5-将this用作namespace代理" class="headerlink" title="5.将this用作namespace代理"></a>5.将this用作namespace代理</h2><p>詹姆斯·爱德华兹（James Edwards）发表的一篇文章。 “我最喜欢的JavaScript设计模式”显然被许多人误解了，他们认为他最好还是采用模块模式。<br>模式的优点在于它仅使用设计的语言，仅此而已。 而且，由于名称空间是通过this关键字注入的（在给定的执行上下文中是静态的），因此不能修改它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var myApp &#x3D; &#123;&#125;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    var id &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">    this.next &#x3D; function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    this.reset &#x3D; function() &#123;</span><br><span class="line">        id &#x3D; 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;).apply(myApp);    </span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">); &#x2F;&#x2F;0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>更好的是，apply（和call）API提供了上下文和参数的自然分隔–因此，将附加参数传递给模块创建者是非常干净的。 下面的示例演示了这一点，还显示了如何在多个名称空间上独立运行模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var subsys1 &#x3D; &#123;&#125;, subsys2 &#x3D; &#123;&#125;;</span><br><span class="line">var nextIdMod &#x3D; function(startId) &#123;</span><br><span class="line">    var id &#x3D; startId || 0;</span><br><span class="line"> </span><br><span class="line">    this.next &#x3D; function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    this.reset &#x3D; function() &#123;</span><br><span class="line">        id &#x3D; 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">nextIdMod.call(subsys1);    </span><br><span class="line">nextIdMod.call(subsys2,1000);   </span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    subsys1.next(),</span><br><span class="line">    subsys1.next(),</span><br><span class="line">    subsys2.next(),</span><br><span class="line">    subsys1.reset(),</span><br><span class="line">    subsys2.next(),</span><br><span class="line">    subsys1.next()</span><br><span class="line">) &#x2F;&#x2F;0, 1, 1000, undefined, 1001, 0</span><br></pre></td></tr></table></figure>
<p>当然，如果我们想要一个全局id生成器，那么轻而易举……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nextIdMod();    </span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    next(),</span><br><span class="line">    next(),</span><br><span class="line">    reset(),</span><br><span class="line">    next()</span><br><span class="line">) &#x2F;&#x2F;0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>我们一直以id生成器工具为例，无法充分发挥这种模式的潜力。 通过包装整个库并使用this关键字作为namespace的代表，我们使用户可以轻松地在他们选择的任何context（包括全局context）中运行该库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;library code</span><br><span class="line">var protoQueryMooJo &#x3D; function() &#123;  </span><br><span class="line">    &#x2F;&#x2F;everything</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;user code</span><br><span class="line">var thirdParty &#x3D; &#123;&#125;;</span><br><span class="line">protoQueryMooJo.apply(thirdParty);</span><br></pre></td></tr></table></figure>
<h1 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h1><p>尽量避免嵌套名称空间。 它们更难维护（对于人和计算机而言），并且会使代码可读性变差。 正如Peter Michaux指出的那样，深层嵌套的名称空间可能是怀旧Java开发人员试图重新创建他们熟悉和喜爱的冗长包链的遗产。</p>
<p>可以跨.js文件跨越单个namespace（尽管只能通过名称空间注入或每个变量的直接分配），但是应谨慎使用依赖项。 此外，将命名空间绑定到文件可以帮助读者更轻松地浏览代码行。</p>
<p>由于JavaScript没有正式的namespace构造，因此存在大量的本地解决方案。 这篇文章仅详细介绍了其中一些。</p>
<h1 id="Further-reading"><a href="#Further-reading" class="headerlink" title="Further reading"></a>Further reading</h1><p>James Edwards: <a target="_blank" rel="noopener" href="http://blogs.sitepoint.com/2010/11/30/my-favorite-javascript-design-pattern/">My Favorite JavaScript Design Pattern</a><br>Peter Michaux: <a target="_blank" rel="noopener" href="http://michaux.ca/articles/javascript-namespacing">JavaScript Namespacing</a></p>

            <!-- / the end of articles -->
        </div>
        <!-- / left section -->
        
        
            <hr/>
            <div id="disqus_thread" style=" margin-top: 15px; margin-bottom: 25px; "></div>
            <script>
                /**
                *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
                /*
                var disqus_config = function () {
                this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
                this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                };
                */
                (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');
                s.src = 'https://morgan-hexo-theme.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        

        <!-- Next Post and Prev Post -->
        
        <hr/>
        <div class="next-prev-post-section">
            
                <a href="/2020/11/23/Javascript%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E6%B3%95/" class="styled-border">
                    ←
                    Javascript全局变量的声明方法
                    
                </a>
            
            
                <a href="/2020/10/25/Google-Firebase-%E4%BB%8B%E7%BB%8D/" class="styled-border">
                    
                    Google Firebase 介绍
                    →
                </a>
            
        </div>
        
</div>
<script type="text/javascript">
    let img = document.getElementsByTagName("img");
    for(let i = 0; i < img.length; i++){
        img[i].className += " ts fluid image";
    }
</script>
<!-- / main section -->

<!-- copyright -->
<div class="ts attached secondary segment">
    <div class="ts narrow container">
        <br>
        <div class="ts large center aligned header">
            Powered by Hexo, Theme designs by @hpcslag.
            <div class="smaller sub header">
                Style-Framework Tocas-UI designs by @yamioldmel 
            </div>
        </div>
        <br>
    </div>
</div>
<!-- / copyright -->
<script type="text/javascript">
    
    const slogans = ["Hallo, dit is mijn blog","嗨，這是我的博客!","안녕하세요, 제 블로그입니다.","Hi, This is my blog!","こんにちは、私のブログへようこそ!","مرحبا، مرحبا بك في مدونتي"];
</script>

<script src="/js/script.js"></script>

</body>
</html>