<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>EventBus 使用及原理 | Jenna233</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="转自Android面试之EventBus原理分析【Bugly分享】老司机教你 “飙” EventBus 3 简介众所周知，EventBus 是一款用在 Android 开发中的发布&#x2F;订阅事件总线框架，基于观察者模式，将事件的接收者和发送者分开，简化了组件之间的通信操作，使用简单、效率高、体积小！ EventBus使用了典型的发布&#x2F;订阅事件模式，下面是 EventBus官方给出的原理示意图。  安装">
<meta property="og:type" content="article">
<meta property="og:title" content="EventBus 使用及原理">
<meta property="og:url" content="https://jenna233.github.io/2021/01/02/EventBus-%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Jenna233">
<meta property="og:description" content="转自Android面试之EventBus原理分析【Bugly分享】老司机教你 “飙” EventBus 3 简介众所周知，EventBus 是一款用在 Android 开发中的发布&#x2F;订阅事件总线框架，基于观察者模式，将事件的接收者和发送者分开，简化了组件之间的通信操作，使用简单、效率高、体积小！ EventBus使用了典型的发布&#x2F;订阅事件模式，下面是 EventBus官方给出的原理示意图。  安装">
<meta property="og:locale">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-266dddd763829800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-da2c13649a8cacb4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-818dbf28cf72aa43.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-547c9e75975c3b2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2021-01-01T16:58:31.000Z">
<meta property="article:modified_time" content="2021-01-01T16:59:09.000Z">
<meta property="article:author" content="Jenna233">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/15531792-266dddd763829800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="Jenna233" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/tocas.css">

  
<link rel="stylesheet" href="/css/animate.css">

  
<link rel="stylesheet" href="/css/style.css">

  <style type="text/css">
    a.title-link:hover{
        color: #34b2db !important;
    }

    a.title-link:active{
        color: #2075c1 !important;
    }

    #menu-color-id{
        background : #f7f7f7;
    }

    #menu-color-id a{
        color: #5a5a5a;
    }
  </style>
  
<script src="/js/tocas.js"></script>

  

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
<!-- navigation -->

<div class="ts fluid basic link big menu" id="menu-color-id">

    <!-- ejs : align to post page or index page -->
        
            <div class="ts very narrow container">
        

        
            <a class="item" href="/">Home</a>
        
            <a class="item" href="/archives">Archives</a>
        
    </div>
</div>
<!-- the end of navigation -->

<!-- big bang title -->
<div class="ts padded horizontally fitted fluid slate" style="background-color: #f7f7f7;">
    <!-- ejs : align to post page or index page -->
    
        <div class="ts very narrow container">
    
        <!-- Title -->
        <h1 class="ts eleven wide column header be-center-h1">
            <span style="color: #404040;" id="big-title">Jenna233</span>
            <div class="sub header" id="slogan-bar" style=" margin-top: 15px; color: #404040;"></div>
        </h1>
        <!-- the end of title -->
    </div>
</div>
<!-- the end of big bang title -->


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">

<!-- main section -->
<div class="ts text container">
        <!-- left section -->
        <div class="column" style=" padding: 35px; ">
            <!-- Articles -->
                
                <h1 class="ts header">
                    <span style="color: #333;">EventBus 使用及原理</span>
                    <div class="sub header" style="color: #808080;">Publish: 2021/1/2 
                     &nbsp;&nbsp;
                        <ul class="unstyled radius-tag -list" itemprop="keywords"><li class="unstyled radius-tag -list-item"><a class="unstyled radius-tag -list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>
                    
                    </div>
                </h1>

                <p>转自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/77809630">Android面试之EventBus原理分析</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20871335">【Bugly分享】老司机教你 “飙” EventBus 3</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>众所周知，EventBus 是一款用在 Android 开发中的发布/订阅事件总线框架，基于观察者模式，将事件的接收者和发送者分开，简化了组件之间的通信操作，使用简单、效率高、体积小！</p>
<p>EventBus使用了典型的发布/订阅事件模式，下面是 EventBus官方给出的原理示意图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15531792-266dddd763829800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>使用EventBus之前，需要先添加EventBus依赖，EventBus支持gradle和maven两种方式依赖，gradle依赖的脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#39;org.greenrobot:eventbus:3.1.1&#39;</span><br></pre></td></tr></table></figure>

<p>maven依赖的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.greenrobot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;eventbus&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>EventBus的使用步骤分为定义事件、订阅事件、发送事件、处理事件、取消订阅五步。 1，首先，定义一个事件类，里面添加需要发送的数据内容，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static class MessageEvent &#123;</span><br><span class="line"> &#x2F;* Additional fields if needed *&#x2F; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>2，然后，在需要接收事件的地方订阅事件，可以选择注册事件订阅方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.MAIN)  </span><br><span class="line">public void onMessageEvent(MessageEvent event) &#123;</span><br><span class="line">&#x2F;* Do something *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了不造成资源的浪费或其他问题，需要在onStart函数中注册订阅事件，然后再onStop函数中取消订阅事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public void onStart() &#123;</span><br><span class="line">     super.onStart();</span><br><span class="line">     EventBus.getDefault().register(this);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public void onStop() &#123;</span><br><span class="line">     super.onStop();</span><br><span class="line">     EventBus.getDefault().unregister(this);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>3，最后，将处理完成的数据发送出去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(new MessageEvent());</span><br></pre></td></tr></table></figure>

<h2 id="EventBus原理剖析"><a href="#EventBus原理剖析" class="headerlink" title="EventBus原理剖析"></a>EventBus原理剖析</h2><p>要理解EventBus背后的原理，可以从以下几个方面着手： - Subscribe注解 - 注册事件订阅方法 - 取消注册 - 发送事件 - 事件处理 - 粘性事件 - Subscriber Index - 流程梳理</p>
<h2 id="Subscribe注解"><a href="#Subscribe注解" class="headerlink" title="Subscribe注解"></a>Subscribe注解</h2><p>EventBus从3.0开始使用Subscribe注解配置事件订阅方法，不再使用方法名，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe</span><br><span class="line">public void handleEvent(String event) &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，事件类型可以是 Java 中已有的类型或者自定义的类型。下面是Subscribe注解的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">public @interface Subscribe &#123;</span><br><span class="line">    &#x2F;&#x2F; 指定事件订阅方法的线程模式，即在那个线程执行事件订阅方法处理事件，默认为POSTING</span><br><span class="line">    ThreadMode threadMode() default ThreadMode.POSTING;</span><br><span class="line">    &#x2F;&#x2F; 是否支持粘性事件，默认为false</span><br><span class="line">    boolean sticky() default false;</span><br><span class="line">    &#x2F;&#x2F; 指定事件订阅方法的优先级，默认为0，如果多个事件订阅方法可以接收相同事件的，则优先级高的先接收到事件</span><br><span class="line">    int priority() default 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，在使用Subscribe注解时可以根据需求指定threadMode、sticky、priority三个属性。其中，threadMode属性有如下几个可选值：</p>
<ul>
<li>ThreadMode.POSTING，默认的线程模式，在那个线程发送事件就在对应线程处理事件，避免了线程切换，效率高。 <ul>
<li>ThreadMode.MAIN，如在主线程（UI线程）发送事件，则直接在主线程处理事件；如果在子线程发送事件，则先将事件入队列，然后通过 Handler 切换到主线程，依次处理事件。</li>
<li>ThreadMode.MAIN_ORDERED，无论在那个线程发送事件，都先将事件入队列，然后通过 Handler 切换到主线程，依次处理事件。 </li>
<li>ThreadMode.BACKGROUND，如果在主线程发送事件，则先将事件入队列，然后通过线程池依次处理事件；如果在子线程发送事件，则直接在发送事件的线程处理事件。 </li>
<li>ThreadMode.ASYNC，无论在那个线程发送事件，都将事件入队列，然后通过线程池处理。</li>
</ul>
</li>
</ul>
<h2 id="注册事件订阅方法"><a href="#注册事件订阅方法" class="headerlink" title="注册事件订阅方法"></a>注册事件订阅方法</h2><p>使用EventBus时，需要在在需要接收事件的地方订阅事件，注册事件的方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(this);</span><br></pre></td></tr></table></figure>

<p>点击打开getDefault()会发现，getDefault()是一个单例方法，保证当前只有一个EventBus实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static EventBus getDefault() &#123;</span><br><span class="line">        if (defaultInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (EventBus.class) &#123;</span><br><span class="line">                if (defaultInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    defaultInstance &#x3D; new EventBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return defaultInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>getDefault()最终调用了new EventBus()，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public EventBus() &#123;</span><br><span class="line">        this(DEFAULT_BUILDER);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后，EventBus调用它的另一个构造函数来完成它相关属性的初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">        logger &#x3D; builder.getLogger();</span><br><span class="line">        subscriptionsByEventType &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        typesBySubscriber &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        stickyEvents &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        mainThreadSupport &#x3D; builder.getMainThreadSupport();</span><br><span class="line">        mainThreadPoster &#x3D; mainThreadSupport !&#x3D; null ? mainThreadSupport.createPoster(this) : null;</span><br><span class="line">        backgroundPoster &#x3D; new BackgroundPoster(this);</span><br><span class="line">        asyncPoster &#x3D; new AsyncPoster(this);</span><br><span class="line">        indexCount &#x3D; builder.subscriberInfoIndexes !&#x3D; null ? builder.subscriberInfoIndexes.size() : 0;</span><br><span class="line">        subscriberMethodFinder &#x3D; new SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">                builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">        logSubscriberExceptions &#x3D; builder.logSubscriberExceptions;</span><br><span class="line">        logNoSubscriberMessages &#x3D; builder.logNoSubscriberMessages;</span><br><span class="line">        sendSubscriberExceptionEvent &#x3D; builder.sendSubscriberExceptionEvent;</span><br><span class="line">        sendNoSubscriberEvent &#x3D; builder.sendNoSubscriberEvent;</span><br><span class="line">        throwSubscriberException &#x3D; builder.throwSubscriberException;</span><br><span class="line">        eventInheritance &#x3D; builder.eventInheritance;</span><br><span class="line">        executorService &#x3D; builder.executorService;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中，DEFAULT_BUILDER就是一个默认的EventBusBuilder，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final EventBusBuilder DEFAULT_BUILDER &#x3D; new EventBusBuilder();</span><br></pre></td></tr></table></figure>

<p>如果有需要的话，我们也可以通过配置EventBusBuilder来更改EventBus的属性，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder()</span><br><span class="line">        .eventInheritance(false)</span><br><span class="line">        .logSubscriberExceptions(false)</span><br><span class="line">        .build()</span><br><span class="line">        .register(this);</span><br></pre></td></tr></table></figure>

<p>有了EventBus的实例，接下来就可以进行注册了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">        &#x2F;&#x2F; 得到当前要注册类的Class对象</span><br><span class="line">        Class&lt;?&gt; subscriberClass &#x3D; subscriber.getClass();</span><br><span class="line">        &#x2F;&#x2F; 根据Class查找当前类中订阅了事件的方法集合，即使用了Subscribe注解、有public修饰符、一个参数的方法</span><br><span class="line">        &#x2F;&#x2F; SubscriberMethod类主要封装了符合条件方法的相关信息：</span><br><span class="line">        &#x2F;&#x2F; Method对象、线程模式、事件类型、优先级、是否是粘性事等</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            &#x2F;&#x2F; 循环遍历订阅了事件的方法集合，以完成注册</span><br><span class="line">            for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">                subscribe(subscriber, subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，register()方法主要分为查找和注册两部分，首先来看查找的过程，主要是findSubscriberMethods()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        &#x2F;&#x2F; METHOD_CACHE是一个ConcurrentHashMap，直接保存了subscriberClass和对应SubscriberMethod的集合，以提高注册效率，赋值重复查找。</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; METHOD_CACHE.get(subscriberClass);</span><br><span class="line">        if (subscriberMethods !&#x3D; null) &#123;</span><br><span class="line">            return subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 由于使用了默认的EventBusBuilder，则ignoreGeneratedIndex属性默认为false，即是否忽略注解生成器</span><br><span class="line">        if (ignoreGeneratedIndex) &#123;</span><br><span class="line">            subscriberMethods &#x3D; findUsingReflection(subscriberClass);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            subscriberMethods &#x3D; findUsingInfo(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果对应类中没有符合条件的方法，则抛出异常</span><br><span class="line">        if (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">            throw new EventBusException(&quot;Subscriber &quot; + subscriberClass</span><br><span class="line">                    + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 保存查找到的订阅事件的方法</span><br><span class="line">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">            return subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>findSubscriberMethods()流程很清晰，即先从缓存中查找，如果找到则直接返回，否则去做下一步的查找过程，然后缓存查找到的集合，根据上边的注释可知findUsingInfo()方法会被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        FindState findState &#x3D; prepareFindState();</span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line">        &#x2F;&#x2F; 初始状态下findState.clazz就是subscriberClass</span><br><span class="line">        while (findState.clazz !&#x3D; null) &#123;</span><br><span class="line">            findState.subscriberInfo &#x3D; getSubscriberInfo(findState);</span><br><span class="line">            &#x2F;&#x2F; 条件不成立</span><br><span class="line">            if (findState.subscriberInfo !&#x3D; null) &#123;</span><br><span class="line">                SubscriberMethod[] array &#x3D; findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">                for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 通过反射查找订阅事件的方法</span><br><span class="line">                findUsingReflectionInSingleClass(findState);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 修改findState.clazz为subscriberClass的父类Class，即需要遍历父类</span><br><span class="line">            findState.moveToSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 查找到的方法保存在了FindState实例的subscriberMethods集合中。</span><br><span class="line">        &#x2F;&#x2F; 使用subscriberMethods构建一个新的List&lt;SubscriberMethod&gt;</span><br><span class="line">        &#x2F;&#x2F; 释放掉findState</span><br><span class="line">        return getMethodsAndRelease(findState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>findUsingInfo()方法会在当前要注册的类以及其父类中查找订阅事件的方法，这里出现了一个FindState类，它是SubscriberMethodFinder的内部类，用来辅助查找订阅事件的方法，具体的查找过程在findUsingReflectionInSingleClass()方法里，它主要通过反射来查找订阅事件的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private void findUsingReflectionInSingleClass(FindState findState) &#123;</span><br><span class="line">        Method[] methods;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; This is faster than getMethods, especially when subscribers are fat classes like Activities</span><br><span class="line">            methods &#x3D; findState.clazz.getDeclaredMethods();</span><br><span class="line">        &#125; catch (Throwable th) &#123;</span><br><span class="line">            &#x2F;&#x2F; Workaround for java.lang.NoClassDefFoundError, see https:&#x2F;&#x2F;github.com&#x2F;greenrobot&#x2F;EventBus&#x2F;issues&#x2F;149</span><br><span class="line">            methods &#x3D; findState.clazz.getMethods();</span><br><span class="line">            findState.skipSuperClasses &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 循环遍历当前类的方法，筛选出符合条件的</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获得方法的修饰符</span><br><span class="line">            int modifiers &#x3D; method.getModifiers();</span><br><span class="line">            &#x2F;&#x2F; 如果是public类型，但非abstract、static等</span><br><span class="line">            if ((modifiers &amp; Modifier.PUBLIC) !&#x3D; 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 获得当前方法所有参数的类型</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes &#x3D; method.getParameterTypes();</span><br><span class="line">                &#x2F;&#x2F; 如果当前方法只有一个参数</span><br><span class="line">                if (parameterTypes.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    Subscribe subscribeAnnotation &#x3D; method.getAnnotation(Subscribe.class);</span><br><span class="line">                    &#x2F;&#x2F; 如果当前方法使用了Subscribe注解</span><br><span class="line">                    if (subscribeAnnotation !&#x3D; null) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 得到该参数的类型</span><br><span class="line">                        Class&lt;?&gt; eventType &#x3D; parameterTypes[0];</span><br><span class="line">                        &#x2F;&#x2F; checkAdd()方法用来判断FindState的anyMethodByEventType map是否已经添加过以当前eventType为key的键值对，没添加过则返回true</span><br><span class="line">                        if (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                             &#x2F;&#x2F; 得到Subscribe注解的threadMode属性值，即线程模式</span><br><span class="line">                            ThreadMode threadMode &#x3D; subscribeAnnotation.threadMode();</span><br><span class="line">                            &#x2F;&#x2F; 创建一个SubscriberMethod对象，并添加到subscriberMethods集合</span><br><span class="line">                            findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                    String methodName &#x3D; method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                    throw new EventBusException(&quot;@Subscribe method &quot; + methodName +</span><br><span class="line">                            &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName &#x3D; method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                throw new EventBusException(methodName +</span><br><span class="line">                        &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到此register()方法中findSubscriberMethods()流程就分析完了，我们已经找到了当前注册类及其父类中订阅事件的方法的集合。 接下来，我们分析下具体的注册流程，即register()中的subscribe()方法。首先，我们看一下subscribe()方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">        &#x2F;&#x2F; 得到当前订阅了事件的方法的参数类型</span><br><span class="line">        Class&lt;?&gt; eventType &#x3D; subscriberMethod.eventType;</span><br><span class="line">        &#x2F;&#x2F; Subscription类保存了要注册的类对象以及当前的subscriberMethod</span><br><span class="line">        Subscription newSubscription &#x3D; new Subscription(subscriber, subscriberMethod);</span><br><span class="line">        &#x2F;&#x2F; subscriptionsByEventType是一个HashMap，保存了以eventType为key,Subscription对象集合为value的键值对</span><br><span class="line">        &#x2F;&#x2F; 先查找subscriptionsByEventType是否存在以当前eventType为key的值</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions &#x3D; subscriptionsByEventType.get(eventType);</span><br><span class="line">        &#x2F;&#x2F; 如果不存在，则创建一个subscriptions，并保存到subscriptionsByEventType</span><br><span class="line">        if (subscriptions &#x3D;&#x3D; null) &#123;</span><br><span class="line">            subscriptions &#x3D; new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;</span><br><span class="line">                        + eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 添加上边创建的newSubscription对象到subscriptions中</span><br><span class="line">        int size &#x3D; subscriptions.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; size; i++) &#123;</span><br><span class="line">            if (i &#x3D;&#x3D; size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">                subscriptions.add(i, newSubscription);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; typesBySubscribere也是一个HashMap，保存了以当前要注册类的对象为key，注册类中订阅事件的方法的参数类型的集合为value的键值对</span><br><span class="line">        &#x2F;&#x2F; 查找是否存在对应的参数类型集合</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents &#x3D; typesBySubscriber.get(subscriber);</span><br><span class="line">        &#x2F;&#x2F; 不存在则创建一个subscribedEvents，并保存到typesBySubscriber</span><br><span class="line">        if (subscribedEvents &#x3D;&#x3D; null) &#123;</span><br><span class="line">            subscribedEvents &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 保存当前订阅了事件的方法的参数类型</span><br><span class="line">        subscribedEvents.add(eventType);</span><br><span class="line">        &#x2F;&#x2F; 粘性事件相关的，后边具体分析</span><br><span class="line">        if (subscriberMethod.sticky) &#123;</span><br><span class="line">            if (eventInheritance) &#123;</span><br><span class="line">                &#x2F;&#x2F; Existing sticky events of all subclasses of eventType have to be considered.</span><br><span class="line">                &#x2F;&#x2F; Note: Iterating over all events may be inefficient with lots of sticky events,</span><br><span class="line">                &#x2F;&#x2F; thus data structure should be changed to allow a more efficient lookup</span><br><span class="line">                &#x2F;&#x2F; (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries &#x3D; stickyEvents.entrySet();</span><br><span class="line">                for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType &#x3D; entry.getKey();</span><br><span class="line">                    if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        Object stickyEvent &#x3D; entry.getValue();</span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Object stickyEvent &#x3D; stickyEvents.get(eventType);</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，subscribe()方法主要是得到了subscriptionsByEventType、typesBySubscriber两个 HashMap。其中，发送事件的时候要用到subscriptionsByEventType，完成事件的处理。当取消 EventBus 注册的时候要用到typesBySubscriber、subscriptionsByEventType，完成相关资源的释放。</p>
<h2 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册"></a>取消注册</h2><p>接下来，我们看一下EventBus 取消事件注册的流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(this);</span><br></pre></td></tr></table></figure>

<p>其中，unregister()的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void unregister(Object subscriber) &#123;</span><br><span class="line">        &#x2F;&#x2F; 得到当前注册类对象 对应的 订阅事件方法的参数类型 的集合</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedTypes &#x3D; typesBySubscriber.get(subscriber);</span><br><span class="line">        if (subscribedTypes !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历参数类型集合，释放之前缓存的当前类中的Subscription</span><br><span class="line">            for (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">                unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 删除以subscriber为key的键值对</span><br><span class="line">            typesBySubscriber.remove(subscriber);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>unregister()方法调用了unsubscribeByEventType()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">        &#x2F;&#x2F; 得到当前参数类型对应的Subscription集合</span><br><span class="line">        List&lt;Subscription&gt; subscriptions &#x3D; subscriptionsByEventType.get(eventType);</span><br><span class="line">        if (subscriptions !&#x3D; null) &#123;</span><br><span class="line">            int size &#x3D; subscriptions.size();</span><br><span class="line">            &#x2F;&#x2F; 遍历Subscription集合</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                Subscription subscription &#x3D; subscriptions.get(i);</span><br><span class="line">                &#x2F;&#x2F; 如果当前subscription对象对应的注册类对象 和 要取消注册的注册类对象相同，则删除当前subscription对象</span><br><span class="line">                if (subscription.subscriber &#x3D;&#x3D; subscriber) &#123;</span><br><span class="line">                    subscription.active &#x3D; false;</span><br><span class="line">                    subscriptions.remove(i);</span><br><span class="line">                    i--;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以，在unregister()方法中，最主要的就是释放typesBySubscriber、subscriptionsByEventType中缓存的资源。</p>
<h2 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h2><p>在EventBus中，我们发送一个事件使用的是如下的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(&quot;Hello World!&quot;)</span><br></pre></td></tr></table></figure>

<p>可以看到，发送事件就是通过post()方法完成的，post()方法的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void post(Object event) &#123;</span><br><span class="line">        &#x2F;&#x2F; currentPostingThreadState是一个PostingThreadState类型的ThreadLocal</span><br><span class="line">        &#x2F;&#x2F; PostingThreadState类保存了事件队列和线程模式等信息</span><br><span class="line">        PostingThreadState postingState &#x3D; currentPostingThreadState.get();</span><br><span class="line">        List&lt;Object&gt; eventQueue &#x3D; postingState.eventQueue;</span><br><span class="line">        &#x2F;&#x2F; 将要发送的事件添加到事件队列</span><br><span class="line">        eventQueue.add(event);</span><br><span class="line">        &#x2F;&#x2F; isPosting默认为false</span><br><span class="line">        if (!postingState.isPosting) &#123;</span><br><span class="line">            &#x2F;&#x2F; 是否为主线程</span><br><span class="line">            postingState.isMainThread &#x3D; isMainThread();</span><br><span class="line">            postingState.isPosting &#x3D; true;</span><br><span class="line">            if (postingState.canceled) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 遍历事件队列</span><br><span class="line">                while (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 发送单个事件</span><br><span class="line">                    &#x2F;&#x2F; eventQueue.remove(0)，从事件队列移除事件</span><br><span class="line">                    postSingleEvent(eventQueue.remove(0), postingState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                postingState.isPosting &#x3D; false;</span><br><span class="line">                postingState.isMainThread &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，post()方法先将发送的事件保存到List的事件队列，然后通过循环出队列，将事件交给postSingleEvent()方法处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123;</span><br><span class="line">        Class&lt;?&gt; eventClass &#x3D; event.getClass();</span><br><span class="line">        boolean subscriptionFound &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F; eventInheritance默认为true，表示是否向上查找事件的父类</span><br><span class="line">        if (eventInheritance) &#123;</span><br><span class="line">            &#x2F;&#x2F; 查找当前事件类型的Class，连同当前事件类型的Class保存到集合</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; eventTypes &#x3D; lookupAllEventTypes(eventClass);</span><br><span class="line">            int countTypes &#x3D; eventTypes.size();</span><br><span class="line">            &#x2F;&#x2F; 遍历Class集合，继续处理事件</span><br><span class="line">            for (int h &#x3D; 0; h &lt; countTypes; h++) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz &#x3D; eventTypes.get(h);</span><br><span class="line">                subscriptionFound |&#x3D; postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            subscriptionFound &#x3D; postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!subscriptionFound) &#123;</span><br><span class="line">            if (logNoSubscriberMessages) &#123;</span><br><span class="line">                logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass);</span><br><span class="line">            &#125;</span><br><span class="line">            if (sendNoSubscriberEvent &amp;&amp; eventClass !&#x3D; NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                    eventClass !&#x3D; SubscriberExceptionEvent.class) &#123;</span><br><span class="line">                post(new NoSubscriberEvent(this, event));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>postSingleEvent()方法中，根据eventInheritance属性，决定是否向上遍历事件的父类型，然后用postSingleEventForEventType()方法进一步处理事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取事件类型对应的Subscription集合</span><br><span class="line">            subscriptions &#x3D; subscriptionsByEventType.get(eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果已订阅了对应类型的事件</span><br><span class="line">        if (subscriptions !&#x3D; null &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">            for (Subscription subscription : subscriptions) &#123;</span><br><span class="line">                &#x2F;&#x2F; 记录事件</span><br><span class="line">                postingState.event &#x3D; event;</span><br><span class="line">                &#x2F;&#x2F; 记录对应的subscription</span><br><span class="line">                postingState.subscription &#x3D; subscription;</span><br><span class="line">                boolean aborted &#x3D; false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 最终的事件处理</span><br><span class="line">                    postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                    aborted &#x3D; postingState.canceled;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    postingState.event &#x3D; null;</span><br><span class="line">                    postingState.subscription &#x3D; null;</span><br><span class="line">                    postingState.canceled &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">                if (aborted) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，postSingleEventForEventType()方法核心就是遍历发送的事件类型对应的Subscription集合，然后调用postToSubscription()方法处理事件。</p>
<h2 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h2><p>接着上面的postToSubscription()方法，postToSubscription()内部会根据订阅事件方法的线程模式，间接或直接的以发送的事件为参数，通过反射执行订阅事件的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断订阅事件方法的线程模式</span><br><span class="line">        switch (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">            &#x2F;&#x2F; 默认的线程模式，在那个线程发送事件就在那个线程处理事件</span><br><span class="line">            case POSTING:</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">                break;</span><br><span class="line">            &#x2F;&#x2F; 在主线程处理事件</span><br><span class="line">            case MAIN:</span><br><span class="line">                &#x2F;&#x2F; 如果在主线程发送事件，则直接在主线程通过反射处理事件</span><br><span class="line">                if (isMainThread) &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                     &#x2F;&#x2F; 如果是在子线程发送事件，则将事件入队列，通过Handler切换到主线程执行处理事件</span><br><span class="line">                    &#x2F;&#x2F; mainThreadPoster 不为空</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#x2F;&#x2F; 无论在那个线程发送事件，都先将事件入队列，然后通过 Handler 切换到主线程，依次处理事件。</span><br><span class="line">            &#x2F;&#x2F; mainThreadPoster 不为空</span><br><span class="line">            case MAIN_ORDERED:</span><br><span class="line">                if (mainThreadPoster !&#x3D; null) &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case BACKGROUND:</span><br><span class="line">                &#x2F;&#x2F; 如果在主线程发送事件，则先将事件入队列，然后通过线程池依次处理事件</span><br><span class="line">                if (isMainThread) &#123;</span><br><span class="line">                    backgroundPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 如果在子线程发送事件，则直接在发送事件的线程通过反射处理事件</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#x2F;&#x2F; 无论在那个线程发送事件，都将事件入队列，然后通过线程池处理。</span><br><span class="line">            case ASYNC:</span><br><span class="line">                asyncPoster.enqueue(subscription, event);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，postToSubscription()方法就是根据订阅事件方法的线程模式、以及发送事件的线程来判断如何处理事件，至于处理方式主要有两种：一种是在相应线程直接通过invokeSubscriber()方法，用反射来执行订阅事件的方法，这样发送出去的事件就被订阅者接收并做相应处理了。 首先，我们来看一下invokeSubscriber()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void invokeSubscriber(Subscription subscription, Object event) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Unexpected exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果在子线程发送事件，则直接在发送事件的线程通过反射处理事件。 另外一种是先将事件入队列（其实底层是一个List），然后做进一步处理，我们以mainThreadPoster.enqueue(subscription, event)为例简单的分析下，其中mainThreadPoster是HandlerPoster类的一个实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class HandlerPoster extends Handler implements Poster &#123;</span><br><span class="line">    private final PendingPostQueue queue;</span><br><span class="line">    private boolean handlerActive;</span><br><span class="line">    ......</span><br><span class="line">    public void enqueue(Subscription subscription, Object event) &#123;</span><br><span class="line">        &#x2F;&#x2F; 用subscription和event封装一个PendingPost对象</span><br><span class="line">        PendingPost pendingPost &#x3D; PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            &#x2F;&#x2F; 入队列</span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            if (!handlerActive) &#123;</span><br><span class="line">                handlerActive &#x3D; true;</span><br><span class="line">                &#x2F;&#x2F; 发送开始处理事件的消息，handleMessage()方法将被执行，完成从子线程到主线程的切换</span><br><span class="line">                if (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    throw new EventBusException(&quot;Could not send handler message&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        boolean rescheduled &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            long started &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">            &#x2F;&#x2F; 死循环遍历队列</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                &#x2F;&#x2F; 出队列</span><br><span class="line">                PendingPost pendingPost &#x3D; queue.poll();</span><br><span class="line">                ......</span><br><span class="line">                &#x2F;&#x2F; 进一步处理pendingPost</span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            handlerActive &#x3D; rescheduled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，HandlerPoster的enqueue()方法主要就是将subscription、event对象封装成一个PendingPost对象，然后保存到队列里，之后通过Handler切换到主线程，在handleMessage()方法将中将PendingPost对象循环出队列，交给invokeSubscriber()方法做进一步处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void invokeSubscriber(PendingPost pendingPost) &#123;</span><br><span class="line">        Object event &#x3D; pendingPost.event;</span><br><span class="line">        Subscription subscription &#x3D; pendingPost.subscription;</span><br><span class="line">        &#x2F;&#x2F; 释放pendingPost引用的资源</span><br><span class="line">        PendingPost.releasePendingPost(pendingPost);</span><br><span class="line">        if (subscription.active) &#123;</span><br><span class="line">            &#x2F;&#x2F; 用反射来执行订阅事件的方法</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>invokeSubscriber方法比较简单，主要就是从pendingPost中取出之前保存的event、subscription，然后用反射来执行订阅事件的方法，又回到了第一种处理方式。所以mainThreadPoster.enqueue(subscription, event)的核心就是先将将事件入队列，然后通过Handler从子线程切换到主线程中去处理事件。</p>
<p>backgroundPoster.enqueue()和asyncPoster.enqueue也类似，内部都是先将事件入队列，然后再出队列，但是会通过线程池去进一步处理事件。</p>
<h2 id="粘性事件"><a href="#粘性事件" class="headerlink" title="粘性事件"></a>粘性事件</h2><p>一般情况，我们使用 EventBus 都是准备好订阅事件的方法，然后注册事件，最后在发送事件，即要先有事件的接收者。但粘性事件却恰恰相反，我们可以先发送事件，后续再准备订阅事件的方法、注册事件。</p>
<p>首先，我们看一下EventBus的粘性事件是如何使用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(&quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure>

<p>粘性事件使用了postSticky()方法，postSticky()方法的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void postSticky(Object event) &#123;</span><br><span class="line">        synchronized (stickyEvents) &#123;</span><br><span class="line">            stickyEvents.put(event.getClass(), event);</span><br><span class="line">        &#125;</span><br><span class="line">        post(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>postSticky()方法主要做了两件事：先将事件类型和对应事件保存到stickyEvents中，方便后续使用；然后执行post(event)继续发送事件，这个post()方法就是之前发送的post()方法。所以，如果在发送粘性事件前，已经有了对应类型事件的订阅者，及时它是非粘性的，依然可以接收到发送出的粘性事件。</p>
<p>发送完粘性事件后，再准备订阅粘性事件的方法，并完成注册。核心的注册事件流程还是我们之前的register()方法中的subscribe()方法，前边分析subscribe()方法时，有一段没有分析的代码，就是用来处理粘性事件的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line">        &#x2F;&#x2F; 如果当前订阅事件的方法的Subscribe注解的sticky属性为true，即该方法可接受粘性事件</span><br><span class="line">        if (subscriberMethod.sticky) &#123;</span><br><span class="line">            &#x2F;&#x2F; 默认为true，表示是否向上查找事件的父类</span><br><span class="line">            if (eventInheritance) &#123;</span><br><span class="line">                &#x2F;&#x2F; stickyEvents就是发送粘性事件时，保存了事件类型和对应事件</span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries &#x3D; stickyEvents.entrySet();</span><br><span class="line">                for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType &#x3D; entry.getKey();</span><br><span class="line">                    &#x2F;&#x2F; 如果candidateEventType是eventType的子类或</span><br><span class="line">                    if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 获得对应的事件</span><br><span class="line">                        Object stickyEvent &#x3D; entry.getValue();</span><br><span class="line">                        &#x2F;&#x2F; 处理粘性事件</span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Object stickyEvent &#x3D; stickyEvents.get(eventType);</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，处理粘性事件就是在 EventBus 注册时，遍历stickyEvents，如果当前要注册的事件订阅方法是粘性的，并且该方法接收的事件类型和stickyEvents中某个事件类型相同或者是其父类，则取出stickyEvents中对应事件类型的具体事件，做进一步处理。</p>
<p>subscribe()方法最核心的就是checkPostStickyEventToSubscription()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) &#123;</span><br><span class="line">        if (stickyEvent !&#x3D; null) &#123;</span><br><span class="line">            postToSubscription(newSubscription, stickyEvent, isMainThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Subscriber-索引"><a href="#Subscriber-索引" class="headerlink" title="Subscriber 索引"></a>Subscriber 索引</h2><p>回顾上面对 EventBus 注册事件流程的分析，EventBus主要是在项目运行时通过反射来查找订事件的方法信息，如果项目中有大量的订阅事件的方法，必然会对项目运行时的性能产生影响。其实除了在项目运行时通过反射查找订阅事件的方法信息，EventBus 还提供了在项目编译时通过注解处理器查找订阅事件方法信息的方式，生成一个辅助的索引类来保存这些信息，这个索引类就是Subscriber Index，和 ButterKnife 的原理是类似的。</p>
<p>所以，我们在添加EventBus依赖的时候通常是下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &#39;org.greenrobot:eventbus:3.1.1&#39;</span><br><span class="line">    &#x2F;&#x2F; 引入注解处理器</span><br><span class="line">    annotationProcessor &#39;org.greenrobot:eventbus-annotation-processor:3.1.1&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在项目的 Application 中添加如下配置，可以生成一个默认的 EventBus 单例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();</span><br></pre></td></tr></table></figure>

<h4 id="索引生成"><a href="#索引生成" class="headerlink" title="索引生成"></a>索引生成</h4><p>addIndex方法 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public EventBusBuilder addIndex(SubscriberInfoIndex index) &#123;</span><br><span class="line">    if(subscriberInfoIndexes &#x3D;&#x3D; null) &#123;</span><br><span class="line">        subscriberInfoIndexes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    subscriberInfoIndexes.add(index);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，传进来的索引信息会保存在subscriberInfoIndexes这个List中，后续会通过EventBusBuilder传到相应EventBus的SubscriberMethodFinder实例中。我们先来分析SubscriberInfoIndex这个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SubscriberInfoIndex &#123;</span><br><span class="line">    SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见索引只需要做一件事情——就是能拿到订阅者的信息。而实现这个接口的类如果我们没有编译过，是找不到的。这里就得看我们在一开始在配置gradle时导入的EventBusAnnotationProcessor：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@SupportedAnnotationTypes(&quot;org.greenrobot.eventbus.Subscribe&quot;)</span><br><span class="line">@SupportedOptions(value &#x3D; &#123;&quot;eventBusIndex&quot;, &quot;verbose&quot;&#125;)</span><br><span class="line">public class EventBusAnnotationProcessor extends AbstractProcessor &#123;</span><br><span class="line">    &#x2F;** Found subscriber methods for a class (without superclasses). 被注解表示的方法信息 *&#x2F; </span><br><span class="line">    private final ListMap&lt;TypeElement, ExecutableElement&gt; methodsByClass &#x3D; new ListMap&lt;&gt;();</span><br><span class="line">    private final Set&lt;TypeElement&gt; classesToSkip &#x3D; new HashSet&lt;&gt;(); &#x2F;&#x2F; checkHasErrors检查出来的异常方法</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) &#123;</span><br><span class="line">        Messager messager &#x3D; processingEnv.getMessager();</span><br><span class="line">        try &#123;</span><br><span class="line">            String index &#x3D; processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX);</span><br><span class="line">            if (index &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 如果没有在gradle中配置apt的argument，编译就会在这里报错</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.ERROR, &quot;No option &quot; + OPTION_EVENT_BUS_INDEX +</span><br><span class="line">                        &quot; passed to annotation processor&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;** ... *&#x2F;</span><br><span class="line">            collectSubscribers(annotations, env, messager); &#x2F;&#x2F; 根据注解拿到所有订阅者的回调方法信息</span><br><span class="line">            checkForSubscribersToSkip(messager, indexPackage); &#x2F;&#x2F; 筛掉不符合规则的订阅者</span><br><span class="line">            if (!methodsByClass.isEmpty()) &#123;</span><br><span class="line">                createInfoIndexFile(index); &#x2F;&#x2F; 生成索引类</span><br><span class="line">            &#125; </span><br><span class="line">            &#x2F;** 打印错误 *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 下面这些方法就不再贴出具体实现了，我们了解它们的功能就行 *&#x2F;</span><br><span class="line">    private void collectSubscribers &#x2F;&#x2F; 遍历annotations，找出所有被注解标识的方法，以初始化methodsByClass</span><br><span class="line">    private boolean checkHasNoErrors &#x2F;&#x2F; 过滤掉static，非public和参数大于1的方法</span><br><span class="line">    private void checkForSubscribersToSkip &#x2F;&#x2F; 检查methodsByClass中的各个类，是否存在非public的父类和方法参数</span><br><span class="line">    &#x2F;** 下面这三个方法会把methodsByClass中的信息写到相应的类中 *&#x2F;</span><br><span class="line">    private void writeCreateSubscriberMethods</span><br><span class="line">    private void createInfoIndexFile</span><br><span class="line">    private void writeIndexLines</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此便揭开了索引生成的秘密，是在编译时apt插件通过EventBusAnnotationProcessor分析注解，并利用注解标识的相关类的信息去生成相关的类。writeCreateSubscriberMethods中调用了很多IO函数，很容易理解，这里就不贴了，我们直接看生成出来的类：<br>其中，MyEventBusIndex()方法的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MyEventBusIndex implements SubscriberInfoIndex &#123;</span><br><span class="line">    private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        SUBSCRIBER_INDEX &#x3D; new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class="line"></span><br><span class="line">        putIndex(new SimpleSubscriberInfo(MainActivity.class, true, new SubscriberMethodInfo[] &#123;</span><br><span class="line">            new SubscriberMethodInfo(&quot;changeText&quot;, String.class),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void putIndex(SubscriberInfo info) &#123;</span><br><span class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        SubscriberInfo info &#x3D; SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        if (info !&#x3D; null) &#123;</span><br><span class="line">            return info;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中SUBSCRIBER_INDEX是一个HashMap，保存了当前注册类的 Class 类型和其中事件订阅方法的信息。</p>
<h4 id="Subscribes-索引注册流程"><a href="#Subscribes-索引注册流程" class="headerlink" title="Subscribes 索引注册流程"></a>Subscribes 索引注册流程</h4><p>接下来，我们再来分析下使用 Subscriber 索引时 EventBus 的注册流程。首先，创建一个EventBusBuilder，然后通过addIndex()方法添加索引类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public EventBusBuilder addIndex(SubscriberInfoIndex index) &#123;</span><br><span class="line">        if (subscriberInfoIndexes &#x3D;&#x3D; null) &#123;</span><br><span class="line">            subscriberInfoIndexes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        subscriberInfoIndexes.add(index);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>即把生成的索引类的实例保存在subscriberInfoIndexes集合中，然后用installDefaultEventBus()创建默认的 EventBus实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public EventBus installDefaultEventBus() &#123;</span><br><span class="line">        synchronized (EventBus.class) &#123;</span><br><span class="line">            if (EventBus.defaultInstance !&#x3D; null) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Default instance already exists.&quot; +</span><br><span class="line">                        &quot; It may be only set once before it&#39;s used the first time to ensure consistent behavior.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            EventBus.defaultInstance &#x3D; build();</span><br><span class="line">            return EventBus.defaultInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>即用当前EventBusBuilder对象创建一个 EventBus 实例，这样我们通过EventBusBuilder配置的 Subscriber Index 也就传递到了EventBus实例中，然后赋值给EventBus的 defaultInstance成员变量。</p>
<p>所以在 Application 中生成了 EventBus 的默认单例，这样就保证了在项目其它地方执行EventBus.getDefault()就能得到唯一的 EventBus 实例！</p>
<p>由于我们现在使用了 Subscriber Index 所以不会通过findUsingReflectionInSingleClass()来反射解析订阅事件的方法。我们重点来看getSubscriberInfo()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private SubscriberInfo getSubscriberInfo(FindState findState) &#123;</span><br><span class="line">        &#x2F;&#x2F; 该条件不成立</span><br><span class="line">        if (findState.subscriberInfo !&#x3D; null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() !&#x3D; null) &#123;</span><br><span class="line">            SubscriberInfo superclassInfo &#x3D; findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">            if (findState.clazz &#x3D;&#x3D; superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">                return superclassInfo;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 该条件成立</span><br><span class="line">        if (subscriberInfoIndexes !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历索引类实例集合</span><br><span class="line">            for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">                &#x2F;&#x2F; 根据注册类的 Class 类查找SubscriberInfo</span><br><span class="line">                SubscriberInfo info &#x3D; index.getSubscriberInfo(findState.clazz);</span><br><span class="line">                if (info !&#x3D; null) &#123;</span><br><span class="line">                    return info;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>subscriberInfoIndexes就是在前边addIndex()方法中创建的，保存了项目中的索引类实例，即MyEventBusIndex的实例，继续看索引类的getSubscriberInfo()方法，来到了MyEventBusIndex类中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        SubscriberInfo info &#x3D; SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        if (info !&#x3D; null) &#123;</span><br><span class="line">            return info;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>即根据注册类的 Class 类型从 SUBSCRIBER_INDEX 查找对应的SubscriberInfo，如果我们在注册类中定义了订阅事件的方法，则 info不为空，进而上边findUsingInfo()方法中findState.subscriberInfo != null成立，到这里主要的内容就分析完了，其它的和之前的注册流程一样。</p>
<p>所以 Subscriber Index 的核心就是项目编译时使用注解处理器生成保存事件订阅方法信息的索引类，然后项目运行时将索引类实例设置到 EventBus 中，这样当注册 EventBus 时，从索引类取出当前注册类对应的事件订阅方法信息，以完成最终的注册，避免了运行时反射处理的过程，所以在性能上会有质的提高。项目中可以根据实际的需求决定是否使用 Subscriber Index。</p>
<h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><p>下面我们再来看一下EventBus的完成流程，可以用以下的几张图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15531792-da2c13649a8cacb4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15531792-818dbf28cf72aa43.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15531792-547c9e75975c3b2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>

            <!-- / the end of articles -->
        </div>
        <!-- / left section -->
        
        
            <hr/>
            <div id="disqus_thread" style=" margin-top: 15px; margin-bottom: 25px; "></div>
            <script>
                /**
                *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
                /*
                var disqus_config = function () {
                this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
                this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                };
                */
                (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');
                s.src = 'https://morgan-hexo-theme.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        

        <!-- Next Post and Prev Post -->
        
        <hr/>
        <div class="next-prev-post-section">
            
                <a href="/2021/01/07/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAreact-%E9%A1%B9%E7%9B%AE/" class="styled-border">
                    ←
                    创建一个react 项目
                    
                </a>
            
            
                <a href="/2021/01/02/Electron-Preload-%E9%A2%84%E5%8A%A0%E8%BD%BD/" class="styled-border">
                    
                    Electron Preload 预加载
                    →
                </a>
            
        </div>
        
</div>
<script type="text/javascript">
    let img = document.getElementsByTagName("img");
    for(let i = 0; i < img.length; i++){
        img[i].className += " ts fluid image";
    }
</script>
<!-- / main section -->

<!-- copyright -->
<div class="ts attached secondary segment">
    <div class="ts narrow container">
        <br>
        <div class="ts large center aligned header">
            Powered by Hexo, Theme designs by @hpcslag.
            <div class="smaller sub header">
                Style-Framework Tocas-UI designs by @yamioldmel 
            </div>
        </div>
        <br>
    </div>
</div>
<!-- / copyright -->
<script type="text/javascript">
    
    const slogans = ["Hallo, dit is mijn blog","嗨，這是我的博客!","안녕하세요, 제 블로그입니다.","Hi, This is my blog!","こんにちは、私のブログへようこそ!","مرحبا، مرحبا بك في مدونتي"];
</script>

<script src="/js/script.js"></script>

</body>
</html>