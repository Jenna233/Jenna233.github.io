<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeetCode 最长回文子串 | Jenna233</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="转自LeetCode 第 5 题：最长回文子串（超详细的解法！！！） 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 12345678910示例 1：输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。示例 2：输入: &quot;cbbd&quot;输出: &quot;">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode 最长回文子串">
<meta property="og:url" content="https://jenna233.github.io/2021/07/02/LeetCode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/index.html">
<meta property="og:site_name" content="Jenna233">
<meta property="og:description" content="转自LeetCode 第 5 题：最长回文子串（超详细的解法！！！） 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 12345678910示例 1：输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。示例 2：输入: &quot;cbbd&quot;输出: &quot;">
<meta property="og:locale">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-0801d4502cf76c7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-10a31bc6f4bd476d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-8ee1499078fe2050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-9ef1619027d75ad3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-3fbea673e0e06e78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-b23ff151efd6b458.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-9e8b4d8441b2ae4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-dd7655d32565a3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-3990b56d84c9ba4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-aa75fe2d9406f2e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-0fefc1245b8edf6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-dadfbaca596314de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-f69b5f778ae6746d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-4c9bd7d1a1a5e196.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-881768cc45948088.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-03e4f6e57709a3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-a96d524e914bc1c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2021-07-02T06:48:51.000Z">
<meta property="article:modified_time" content="2021-07-02T06:49:21.000Z">
<meta property="article:author" content="Jenna233">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/15531792-0801d4502cf76c7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="Jenna233" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/tocas.css">

  
<link rel="stylesheet" href="/css/animate.css">

  
<link rel="stylesheet" href="/css/style.css">

  <style type="text/css">
    a.title-link:hover{
        color: #34b2db !important;
    }

    a.title-link:active{
        color: #2075c1 !important;
    }

    #menu-color-id{
        background : #f7f7f7;
    }

    #menu-color-id a{
        color: #5a5a5a;
    }
  </style>
  
<script src="/js/tocas.js"></script>

  

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
<!-- navigation -->

<div class="ts fluid basic link big menu" id="menu-color-id">

    <!-- ejs : align to post page or index page -->
        
            <div class="ts very narrow container">
        

        
            <a class="item" href="/">Home</a>
        
            <a class="item" href="/archives">Archives</a>
        
    </div>
</div>
<!-- the end of navigation -->

<!-- big bang title -->
<div class="ts padded horizontally fitted fluid slate" style="background-color: #f7f7f7;">
    <!-- ejs : align to post page or index page -->
    
        <div class="ts very narrow container">
    
        <!-- Title -->
        <h1 class="ts eleven wide column header be-center-h1">
            <span style="color: #404040;" id="big-title">Jenna233</span>
            <div class="sub header" id="slogan-bar" style=" margin-top: 15px; color: #404040;"></div>
        </h1>
        <!-- the end of title -->
    </div>
</div>
<!-- the end of big bang title -->


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">

<!-- main section -->
<div class="ts text container">
        <!-- left section -->
        <div class="column" style=" padding: 35px; ">
            <!-- Articles -->
                
                <h1 class="ts header">
                    <span style="color: #333;">LeetCode 最长回文子串</span>
                    <div class="sub header" style="color: #808080;">Publish: 2021/7/2 
                     &nbsp;&nbsp;
                        <ul class="unstyled radius-tag -list" itemprop="keywords"><li class="unstyled radius-tag -list-item"><a class="unstyled radius-tag -list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
                    
                    </div>
                </h1>

                <p>转自<a target="_blank" rel="noopener" href="https://www.cxyxiaowu.com/2869.html">LeetCode 第 5 题：最长回文子串（超详细的解法！！！）</a></p>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<h1 id="方法一：暴力匹配-（Brute-Force）"><a href="#方法一：暴力匹配-（Brute-Force）" class="headerlink" title="方法一：暴力匹配 （Brute Force）"></a>方法一：暴力匹配 （Brute Force）</h1><p>根据回文子串的定义，枚举所有长度大于等于2 的子串，依次判断它们是否是回文。在具体实现时，可以只针对大于“当前得到的最长回文子串长度”的子串进行“回文验证”。<br><strong>参考代码1</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;www.cxyxiaowu.com</span><br><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int maxLen &#x3D; 1;</span><br><span class="line">        String res &#x3D; s.substring(0, 1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 枚举所有长度大于等于 2 的子串</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; len; j++) &#123;</span><br><span class="line">                if (j - i + 1 &gt; maxLen &amp;&amp; valid(s, i, j)) &#123;</span><br><span class="line">                    maxLen &#x3D; j - i + 1;</span><br><span class="line">                    res &#x3D; s.substring(i, j + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean valid(String s, int left, int right) &#123;</span><br><span class="line">        &#x2F;&#x2F; 验证子串 s[left, right] 是否为回文串</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            if (s.charAt(left) !&#x3D; s.charAt(right)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力解法时间复杂度高，但是思路清晰、编写简单，因为编写的正确性的可能性很大，可以使用暴力匹配算法检验我们编写的其它算法是否正确。<br><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(N<em>N</em>N) ，这里N  是字符串的长度，枚举字符串的左边界、右边界，然后继续验证子串是否是回文子串，这三种操作都与 N 相关</li>
<li>空间复杂度：O(1) ，只使用到常数个临时变量，与字符串长度无关。</li>
</ul>
<h1 id="方法二：中心扩散法"><a href="#方法二：中心扩散法" class="headerlink" title="方法二：中心扩散法"></a>方法二：中心扩散法</h1><p>暴力法采用双指针两边夹，验证是否是回文子串，时间复杂度比较高，除了枚举字符串的左右边界以外，比较容易想到的是<strong>枚举可能出现的回文子串的“中心位置”，从“中心位置”尝试尽可能扩散出去，得到一个回文串</strong>。</p>
<p>因此，中心扩散法的思路是：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。</p>
<p>枚举“中心位置”时间复杂度为O(N) ，从“中心位置”扩散得到“回文子串”的时间复杂度为O(N) ，因此时间复杂度可以降到 O(N*N) 。</p>
<p>在这里要注意一个细节：回文串在长度为奇数和偶数的时候，“回文中心”的形式是不一样的。</p>
<ul>
<li>奇数回文串的“中心”是一个具体的字符，例如：回文串 <code>&quot;aba&quot;</code> 的中心是字符 <code>&quot;a&quot;</code>；</li>
<li>偶数回文串的“中心”是位于中间的两个字符的“空隙”，例如：回文串串 <code>&quot;abba&quot;</code> 的中心是两个 <code>&quot;b&quot;</code> 中间的那个“空隙”。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-0801d4502cf76c7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们看一下一个字符串可能的回文子串的中心在哪里？<br><img src="https://upload-images.jianshu.io/upload_images/15531792-10a31bc6f4bd476d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们可以设计一个方法，兼容以上两种情况：</li>
</ul>
<ol>
<li>如果传入重合的索引编码，进行中心扩散，此时得到的回文子串的长度是奇数；</li>
<li>如果传入相邻的索引编码，进行中心扩散，此时得到的回文子串的长度是偶数。<br>具体编码细节在以下的代码的注释中体现。</li>
</ol>
<p><strong>参考代码2</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;www.cxyxiaowu.com</span><br><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        int maxLen &#x3D; 1;</span><br><span class="line">        String res &#x3D; s.substring(0, 1);</span><br><span class="line">        &#x2F;&#x2F; 中心位置枚举到 len - 2 即可</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">            String oddStr &#x3D; centerSpread(s, i, i);</span><br><span class="line">            String evenStr &#x3D; centerSpread(s, i, i + 1);</span><br><span class="line">            String maxLenStr &#x3D; oddStr.length() &gt; evenStr.length() ? oddStr : evenStr;</span><br><span class="line">            if (maxLenStr.length() &gt; maxLen) &#123;</span><br><span class="line">                maxLen &#x3D; maxLenStr.length();</span><br><span class="line">                res &#x3D; maxLenStr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String centerSpread(String s, int left, int right) &#123;</span><br><span class="line">        &#x2F;&#x2F; left &#x3D; right 的时候，此时回文中心是一个空隙，回文串的长度是奇数</span><br><span class="line">        &#x2F;&#x2F; right &#x3D; left + 1 的时候，此时回文中心是任意一个字符，回文串的长度是偶数</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        int i &#x3D; left;</span><br><span class="line">        int j &#x3D; right;</span><br><span class="line">        while (i &gt;&#x3D; 0 &amp;&amp; j &lt; len) &#123;</span><br><span class="line">            if (s.charAt(i) &#x3D;&#x3D; s.charAt(j)) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) !&#x3D; s.charAt(j)，因此不能取 i，不能取 j</span><br><span class="line">        return s.substring(i + 1, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N*N) ，理由已经叙述。</li>
<li>空间复杂度：O(1) ，只使用到常数个临时变量，与字符串长度无关。</li>
</ul>
<p>事实上，还有时间复杂度更优的算法，是由计算机科学家 Manacher 发明的，下面介绍这种算法。</p>
<h1 id="方法三：Manacher-算法"><a href="#方法三：Manacher-算法" class="headerlink" title="方法三：Manacher 算法"></a>方法三：Manacher 算法</h1><p>Manacher 算法，被中国程序员戏称为“马拉车”算法。它专门用于解决“最长回文子串”问题，时间复杂度为O(N) 。</p>
<p>维基百科中对于 Manacher 算法是这样描述的：<br>**[Manacher(1975)] 发现了一种线性时间算法，可以在列出给定字符串中从字符串头部开始的所有回文。并且，Apostolico, Breslauer &amp; Galil (1995) 发现，同样的算法也可以在任意位置查找全部最大回文子串，并且时间复杂度是线性的。因此，他们提供了一种时间复杂度为线性的最长回文子串解法。替代性的线性时间解决 Jeuring (1994), Gusfield (1997)提供的，基于后缀树(suffix trees)。也存在已知的高效并行算法。**</p>
<p>Manacher 算法本质上还是中心扩散法，只不过它使用了类似 KMP 算法的技巧，充分挖掘了已经进行回文判定的子串的特点，在遍历的过程中，记录了已经遍历过的子串的信息，也是典型的以空间换时间思想的体现。</p>
<p>下面介绍 Manacher 算法的具体流程。</p>
<h2 id="第-1-步：对原始字符串进行预处理（添加分隔符"><a href="#第-1-步：对原始字符串进行预处理（添加分隔符" class="headerlink" title="第 1 步：对原始字符串进行预处理（添加分隔符)"></a>第 1 步：对原始字符串进行预处理（添加分隔符)</h2><p>首先在字符串的首尾、相邻的字符中插入分隔符，例如 “babad” 添加分隔符 “#” 以后得到 “#b#a#b#a#d#”。</p>
<p>对这一点有如下说明：</p>
<p>1、分隔符是一个字符，种类也只有一个，并且这个字符一定不能是原始字符串中出现过的字符；</p>
<p>2、加入了分隔符以后，使得“间隙”有了具体的位置，方便后续的讨论，并且新字符串中的任意一个回文子串在原始字符串中的一定能找到唯一的一个回文子串与之对应，因此对新字符串的回文子串的研究就能得到原始字符串的回文子串；</p>
<p>3、新字符串的回文子串的长度一定是奇数；</p>
<p>4、新字符串的回文子串一定以分隔符作为两边的边界，因此分隔符起到“哨兵”的作用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15531792-8ee1499078fe2050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原始字符串与新字符串的对应关系"></p>
<h2 id="第-2-步：计算辅助数组-p"><a href="#第-2-步：计算辅助数组-p" class="headerlink" title="第 2 步：计算辅助数组 p"></a>第 2 步：计算辅助数组 p</h2><p>辅助数组 p 记录了新字符串中以每个字符为中心的回文子串的信息。</p>
<p>手动的计算方法仍然是“中心扩散法”，此时记录以当前字符为中心，向左右两边同时扩散，记录能够扩散的最大步数。</p>
<p>以字符串 “abbabb” 为例，说明如何手动计算得到辅助数组 p ，我们要填的就是下面这张表。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-9ef1619027d75ad3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>第 1 行数组 <code>char</code> ：原始字符串<strong>加上分隔符以后</strong>的每个字符。</p>
<p>第 2 行数组 <code>index</code> ：这个数组是新字符串的索引数组，它的值是从<strong>0</strong> 开始的索引编号。</p>
<ul>
<li>我们首先填 <code>p[0]</code>。</li>
</ul>
<p>以 <code>char[0] = &#39;#&#39;</code> 为中心，同时向左边向右扩散，走 <strong>1</strong> 步就碰到边界了，因此能扩散的步数为 <strong>0</strong> ，因此 <code>p[0] = 0</code>；<br><img src="https://upload-images.jianshu.io/upload_images/15531792-3fbea673e0e06e78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P0"></p>
<ul>
<li><p>下面填写 <code>p[1]</code> 。<br>以 <code>char[1] = &#39;a&#39;</code> 为中心，同时向左边向右扩散，走<strong>1</strong> 步，左右都是 <code>&quot;#&quot;</code>，构成回文子串，于是再继续同时向左边向右边扩散，左边就碰到边界了，最多能扩散的步数”为<strong>1</strong>，因此 <code>p[1] = 1</code>；<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b23ff151efd6b458.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P1"></p>
</li>
<li><p>下面填写 <code>p[2]</code> 。</p>
</li>
</ul>
<p>以 <code>char[2] = &#39;#&#39;</code> 为中心，同时向左边向右扩散，走<strong>1</strong>步，左边是 <code>&quot;a&quot;</code>，右边是 <code>&quot;b&quot;</code>，不匹配，最多能扩散的步数为 <strong>0</strong>，因此 <code>p[2] = 0</code>；<br><img src="https://upload-images.jianshu.io/upload_images/15531792-9e8b4d8441b2ae4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P2"></p>
<ul>
<li>下面填写 <code>p[3]</code>。</li>
</ul>
<p>以 <code>char[3] = &#39;b&#39;</code> 为中心，同时向左边向右扩散，走<strong>1</strong> 步，左右两边都是 <code>“#”</code>，构成回文子串，继续同时向左边向右扩散，左边是 <code>&quot;a&quot;</code>，右边是 <code>&quot;b&quot;</code>，不匹配，最多能扩散的步数为<strong>1</strong> ，因此 <code>p[3] = 1</code>；<br><img src="https://upload-images.jianshu.io/upload_images/15531792-dd7655d32565a3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P3"></p>
<ul>
<li>下面填写 <code>p[4]</code>。</li>
</ul>
<p>以 <code>char[4] = &#39;#&#39;</code> 为中心，同时向左边向右扩散，最多可以走 <strong>4</strong> 步，左边到达左边界，因此 <code>p[4] = 4</code>。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-3990b56d84c9ba4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p4"></p>
<ul>
<li>继续填完 p 数组剩下的部分。</li>
</ul>
<p>分析到这里，后面的数字不难填出，最后写成如下表格：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-aa75fe2d9406f2e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="完整表格"></p>
<p><strong>说明</strong>：有些资料将辅助数组 <code>p</code> 定义为回文半径数组，即 <code>p[i]</code> 记录了以新字符串第 <code>i</code> 个字符为中心的回文字符串的半径（包括第 <code>i</code> 个字符），与我们这里定义的辅助数组 <code>p</code> 有一个字符的偏差，本质上是一样的。</p>
<p>下面是辅助数组 <code>p</code> 的结论：辅助数组 <code>p</code> 的最大值是<strong>5</strong> ，对应了原字符串 <code>&quot;abbabb&quot;</code> 的 “最长回文子串” ：<code>&quot;bbabb&quot;</code>。这个结论具有一般性，即：<br><code>辅助数组 p 的最大值就是“最长回文子串”的长度。</code><br>因此，我们可以在计算辅助数组 p 的过程中记录这个最大值，并且记录最长回文子串。</p>
<p>简单说明一下这是为什么：</p>
<p>如果新回文子串的中心是一个字符，那么原始回文子串的中心也是一个字符，在新回文子串中，向两边扩散的特点是：“先分隔符，后字符”，同样扩散的步数因为有分隔符 # 的作用，在新字符串中每扩散两步，虽然实际上只扫到一个有效字符，但是相当于在原始字符串中相当于计算了两个字符。因为最后一定以分隔符结尾，还要计算一个，正好这个就可以把原始回文子串的中心算进去；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15531792-0fefc1245b8edf6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="理解辅助数组的数值与原始字符串回文子串的等价性-1"></p>
<ol>
<li>如果新回文子串的中心是 <code>#</code>，那么原始回文子串的中心就是一个“空隙”。在新回文子串中，向两边扩散的特点是：“先字符，后分隔符”，扩散的步数因为有分隔符 <code>#</code> 的作用，在新字符串中每扩散两步，虽然实际上只扫到一个有效字符，但是相当于在原始字符串中相当于计算了两个字符。</li>
</ol>
<p>因此，“辅助数组 <code>p</code> 的最大值就是“最长回文子串”的长度”这个结论是成立的，可以看下面的图理解上面说的 <strong>2</strong>  点。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-dadfbaca596314de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="理解辅助数组的数值与原始字符串回文子串的等价性-2"></p>
<p>写到这里，其实已经能写出一版代码，把这一版代码提交到 LeetCode 是可以通过的，这同样也可以验证我们上面的结论是正确的。</p>
<p><strong>参考代码3</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;www.cxyxiaowu.com</span><br><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        String str &#x3D; addBoundaries(s, &#39;#&#39;);</span><br><span class="line">        int sLen &#x3D; 2 * len + 1;</span><br><span class="line">        int maxLen &#x3D; 1;</span><br><span class="line"></span><br><span class="line">        int start &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sLen; i++) &#123;</span><br><span class="line">            int curLen &#x3D; centerSpread(str, i);</span><br><span class="line">            if (curLen &gt; maxLen) &#123;</span><br><span class="line">                maxLen &#x3D; curLen;</span><br><span class="line">                start &#x3D; (i - maxLen) &#x2F; 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int centerSpread(String s, int center) &#123;</span><br><span class="line">        &#x2F;&#x2F; left &#x3D; right 的时候，此时回文中心是一个空隙，回文串的长度是奇数</span><br><span class="line">        &#x2F;&#x2F; right &#x3D; left + 1 的时候，此时回文中心是任意一个字符，回文串的长度是偶数</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        int i &#x3D; center - 1;</span><br><span class="line">        int j &#x3D; center + 1;</span><br><span class="line">        int step &#x3D; 0;</span><br><span class="line">        while (i &gt;&#x3D; 0 &amp;&amp; j &lt; len &amp;&amp; s.charAt(i) &#x3D;&#x3D; s.charAt(j)) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        return step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建预处理字符串</span><br><span class="line">     *</span><br><span class="line">     * @param s      原始字符串</span><br><span class="line">     * @param divide 分隔字符</span><br><span class="line">     * @return 使用分隔字符处理以后得到的字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String addBoundaries(String s, char divide) &#123;</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        if (len &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s.indexOf(divide) !&#x3D; -1) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;参数错误，您传递的分割字符，在输入字符串中存在！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            stringBuilder.append(divide);</span><br><span class="line">            stringBuilder.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(divide);</span><br><span class="line">        return stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度: O(N<em>N)，这里 N 是原始字符串的长度。新字符串的长度是(2</em>N+1)，不计系数与常数项，因此时间复杂度仍为O(N*N)</li>
<li>空间复杂度：O(N) 。</li>
</ul>
<h2 id="科学家的工作：充分利用新字符串的回文性质，计算辅助数组-p"><a href="#科学家的工作：充分利用新字符串的回文性质，计算辅助数组-p" class="headerlink" title="科学家的工作：充分利用新字符串的回文性质，计算辅助数组 p"></a>科学家的工作：充分利用新字符串的回文性质，计算辅助数组 p</h2><p>上面的代码不太智能的地方是，对新字符串每一个位置进行中心扩散，会导致原始字符串的每一个字符被访问多次，一个比较极端的情况就是：<code>#a#a#a#a#a#a#a#a#</code>。事实上，计算机科学家 Manacher 就改进了这种算法，使得在填写新的辅助数组 <code>p</code> 的值的时候，能够参考已经填写过的辅助数组 <code>p</code> 的值，使得新字符串每个字符只访问了一次，整体时间复杂度由O(N*N)  改进到 O(N)。</p>
<p>具体做法是：在遍历的过程中，除了循环变量 <code>i</code> 以外，我们还需要记录两个变量，它们是 <code>maxRight</code> 和 <code>center</code> ，它们分别的含义如下：</p>
<ul>
<li><code>maxRight</code>：记录当前向右扩展的最远边界，即从开始到现在使用“中心扩散法”能得到的回文子串，它能延伸到的最右端的位置 。对于 <code>maxRight</code> 我们说明 3 点：</li>
</ul>
<ol>
<li>“向右最远”是在计算辅助数组 <code>p</code> 的过程中，向右边扩散能走的索引最大的位置，注意：得到一个 <code>maxRight</code> 所对应的回文子串，并不一定是当前得到的“最长回文子串”，很可能的一种情况是，某个回文子串可能比较短，但是它正好在整个字符串比较靠后的位置；</li>
<li><code>maxRight</code> 的下一个位置可能是被程序看到的，停止的原因有 2 点：（1）左边界不能扩散，导致右边界受限制也不能扩散，<code>maxRight</code> 的下一个位置看不到；（2）正是因为看到了 <code>maxRight</code> 的下一个位置，导致 <code>maxRight</code> 不能继续扩散。</li>
<li>为什么 <code>maxRight</code> 很重要？因为扫描是从左向右进行的， <code>maxRight</code> 能够提供的信息最多，它是一个重要的分类讨论的标准，因此我们需要一个变量记录它。</li>
</ol>
<ul>
<li><code>center</code>：<code>center</code> 是与 <code>maxRight</code> 相关的一个变量，它是上述 <code>maxRight</code> 的回文中心的索引值。对于 <code>center</code> 的说明如下：</li>
</ul>
<ol>
<li><code>center</code> 的形式化定义：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-f69b5f778ae6746d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="center 定义"></li>
</ol>
<p>说明：x + p[x] 的最大值就是我们定义的 maxRight，i 是循环变量，0&lt;= x&lt; i 表示是在 i 之前的所有索引里得到的最大值 maxRight，它对应的回文中心索引就是上述式子。</p>
<p>maxRight 与 center 是一一对应的关系，即一个 center 的值唯一对应了一个 maxRight 的值；因此 maxRight 与 center 必须要同时更新。<br>下面的讨论就根据循环变量 i 与 maxRight 的关系展开讨论：</p>
<p>情况 1：当 i &gt;= maxRight 的时候，这就是一开始，以及刚刚把一个回文子串扫描完的情况，此时只能够根据“中心扩散法”一个一个扫描，逐渐扩大 maxRight；</p>
<p>情况 2：当 i &lt; maxRight 的时候，根据新字符的回文子串的性质，循环变量关于 center 对称的那个索引（记为 mirror）的 p 值就很重要。</p>
<p>我们先看 mirror 的值是多少，因为 center 是中心，i 和 mirror 关于 center 中心对称，因此 (mirror + i) / 2 = center ，所以 mirror = 2 * center - i。</p>
<p>根据 p[mirror] 的数值从小到大，具体可以分为如下 3 种情况：</p>
<p>情况 2（1）：p[mirror] 的数值比较小，不超过 maxRight - i。</p>
<p>说明：maxRight - i 的值，就是从 i 关于 center 的镜像点开始向左走（不包括它自己），到 maxRight 关于 center 的镜像点的步数</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15531792-4c9bd7d1a1a5e196.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Manacher 算法分类讨论情况 2（1）"></p>
<p>从图上可以看出，由于“以 center 为中心的回文子串”的对称性，导致了“以 i 为中心的回文子串”与“以 center 为中心的回文子串”也具有对称性，“以 i 为中心的回文子串”与“以 center 为中心的回文子串”不能再扩散了，此时，直接把数值抄过来即可，即 p[i] = p[mirror]。</p>
<p>情况 2（2）：p[mirror] 的数值恰好等于 maxRight - i。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15531792-881768cc45948088.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Manacher 算法分类讨论情况 2（2）"></p>
<p>说明：仍然是依据“以 center 为中心的回文子串”的对称性，导致了“以 i 为中心的回文子串”与“以 center 为中心的回文子串”也具有对称性。</p>
<p>因为靠左边的 f 与靠右边的 g 的原因，导致“以 center 为中心的回文子串”不能继续扩散；<br>但是“以 i 为中心的回文子串” 还可以继续扩散。<br>因此，可以先把 p[mirror] 的值抄过来，然后继续“中心扩散法”，继续增加 maxRight。</p>
<p>情况 2（3）：p[mirror] 的数值大于 maxRight - i。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15531792-03e4f6e57709a3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Manacher 算法分类讨论情况 2（3）"><br>说明：仍然是依据“以 center 为中心的回文子串”的对称性，导致了“以 i 为中心的回文子串”与“以 center 为中心的回文子串”也具有对称性。<br>下面证明，p[i] = maxRight - i ，证明的方法还是利用三个回文子串的对称性。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15531792-a96d524e914bc1c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Manacher 算法分类讨论情况 2（3）的证明"><br>① 由于“以 <code>center</code> 为中心的回文子串”的对称性， 黄色箭头对应的字符 <code>c</code> 和 <code>e</code> 一定不相等；</p>
<p>② 由于“以 <code>mirror</code> 为中心的回文子串”的对称性， 绿色箭头对应的字符 <code>c</code> 和 <code>c</code> 一定相等；</p>
<p>③ 又由于“以 <code>center</code> 为中心的回文子串”的对称性， 蓝色箭头对应的字符 <code>c</code> 和 <code>c</code> 一定相等；</p>
<p>推出“以 <code>i</code> 为中心的回文子串”的对称性， 红色箭头对应的字符 <code>c</code> 和 <code>e</code> 一定不相等。</p>
<p>因此，<code>p[i] = maxRight - i</code>，不可能再大。上面是因为我画的图，可能看的朋友会觉得理所当然。事实上，可以使用反证法证明：</p>
<p>如果“以 <code>i</code> 为中心的回文子串” 再向两边扩散的两个字符 <code>c</code> 和 <code>e</code> 相等，就能够推出黄色、绿色、蓝色、红色箭头所指向的 8 个变量的值都相等，此时“以 <code>center</code> 为中心的回文子串” 就可以再同时向左边和右边扩散 <strong>1</strong>  格，与 <code>maxRight</code> 的最大性矛盾。</p>
<p>综合以上 3 种情况，当 <code>i &lt; maxRight</code> 的时候，<code>p[i]</code> 可以参考 <code>p[mirror]</code> 的信息，以 <code>maxRight - i</code> 作为参考标准，<code>p[i]</code> 的值应该是保守的，即二者之中较小的那个值：</p>
<p><code>p[i] = min(maxRight - i, p[mirror]);</code></p>
<p><strong>参考代码4</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 特判</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 得到预处理字符串</span><br><span class="line">        String str &#x3D; addBoundaries(s, &#39;#&#39;);</span><br><span class="line">        &#x2F;&#x2F; 新字符串的长度</span><br><span class="line">        int sLen &#x3D; 2 * len + 1;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 数组 p 记录了扫描过的回文子串的信息</span><br><span class="line">        int[] p &#x3D; new int[sLen];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 双指针，它们是一一对应的，须同时更新</span><br><span class="line">        int maxRight &#x3D; 0;</span><br><span class="line">        int center &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度</span><br><span class="line">        int maxLen &#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; 原始字符串的最长回文子串的起始位置，与 maxLen 必须同时更新        </span><br><span class="line">        int start &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; sLen; i++) &#123;</span><br><span class="line">            if (i &lt; maxRight) &#123;</span><br><span class="line">                int mirror &#x3D; 2 * center - i;</span><br><span class="line">                &#x2F;&#x2F; 这一行代码是 Manacher 算法的关键所在，要结合图形来理解</span><br><span class="line">                p[i] &#x3D; Math.min(maxRight - i, p[mirror]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中</span><br><span class="line">            int left &#x3D; i - (1 + p[i]);</span><br><span class="line">            int right &#x3D; i + (1 + p[i]);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; left &gt;&#x3D; 0 &amp;&amp; right &lt; sLen 保证不越界</span><br><span class="line">            &#x2F;&#x2F; str.charAt(left) &#x3D;&#x3D; str.charAt(right) 表示可以扩散 1 次</span><br><span class="line">            while (left &gt;&#x3D; 0 &amp;&amp; right &lt; sLen &amp;&amp; str.charAt(left) &#x3D;&#x3D; str.charAt(right)) &#123;</span><br><span class="line">                p[i]++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 根据 maxRight 的定义，它是遍历过的 i 的 i + p[i] 的最大者</span><br><span class="line">            &#x2F;&#x2F; 如果 maxRight 的值越大，进入上面 i &lt; maxRight 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了</span><br><span class="line">            if (i + p[i] &gt; maxRight) &#123;</span><br><span class="line">                &#x2F;&#x2F; maxRight 和 center 需要同时更新</span><br><span class="line">                maxRight &#x3D; i + p[i];</span><br><span class="line">                center &#x3D; i;</span><br><span class="line">            &#125;</span><br><span class="line">            if (p[i] &gt; maxLen) &#123;</span><br><span class="line">                &#x2F;&#x2F; 记录最长回文子串的长度和相应它在原始字符串中的起点</span><br><span class="line">                maxLen &#x3D; p[i];</span><br><span class="line">                start &#x3D; (i - maxLen) &#x2F; 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建预处理字符串</span><br><span class="line">     *</span><br><span class="line">     * @param s      原始字符串</span><br><span class="line">     * @param divide 分隔字符</span><br><span class="line">     * @return 使用分隔字符处理以后得到的字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String addBoundaries(String s, char divide) &#123;</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        if (len &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s.indexOf(divide) !&#x3D; -1) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;参数错误，您传递的分割字符，在输入字符串中存在！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            stringBuilder.append(divide);</span><br><span class="line">            stringBuilder.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(divide);</span><br><span class="line">        return stringBuilder.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，由于 Manacher 算法只有在遇到还未匹配的位置时才进行匹配，已经匹配过的位置不再匹配，因此对于字符串 <code>S</code> 的每一个位置，都只进行一次匹配，算法的复杂度为O(N)。</li>
<li>空间复杂度：O(N) 。</li>
</ul>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>Manacher 算法我个人觉得没有必要记住，如果真有遇到，查资料就可以了。“最长回文子串”问题最通用的做法是动态规划，它的时间复杂度为O(N*N)，大家可以自己动手试试，或者查阅相关资料，把它做出来。</p>

            <!-- / the end of articles -->
        </div>
        <!-- / left section -->
        
        
            <hr/>
            <div id="disqus_thread" style=" margin-top: 15px; margin-bottom: 25px; "></div>
            <script>
                /**
                *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
                /*
                var disqus_config = function () {
                this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
                this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                };
                */
                (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');
                s.src = 'https://morgan-hexo-theme.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        

        <!-- Next Post and Prev Post -->
        
        <hr/>
        <div class="next-prev-post-section">
            
                <a href="/2021/07/02/Git-rebase-%E4%B8%8Emege-%E7%9A%84%E5%8C%BA%E5%88%AB/" class="styled-border">
                    ←
                    Git rebase 与mege 的区别
                    
                </a>
            
            
                <a href="/2021/07/02/leetcode-3SUM-%E4%B8%89%E6%95%B0%E7%9B%B8%E5%8A%A0%E7%AD%89%E4%BA%8E0/" class="styled-border">
                    
                    leetcode-3SUM(三数相加等于0)
                    →
                </a>
            
        </div>
        
</div>
<script type="text/javascript">
    let img = document.getElementsByTagName("img");
    for(let i = 0; i < img.length; i++){
        img[i].className += " ts fluid image";
    }
</script>
<!-- / main section -->

<!-- copyright -->
<div class="ts attached secondary segment">
    <div class="ts narrow container">
        <br>
        <div class="ts large center aligned header">
            Powered by Hexo, Theme designs by @hpcslag.
            <div class="smaller sub header">
                Style-Framework Tocas-UI designs by @yamioldmel 
            </div>
        </div>
        <br>
    </div>
</div>
<!-- / copyright -->
<script type="text/javascript">
    
    const slogans = ["Hallo, dit is mijn blog","嗨，這是我的博客!","안녕하세요, 제 블로그입니다.","Hi, This is my blog!","こんにちは、私のブログへようこそ!","مرحبا، مرحبا بك في مدونتي"];
</script>

<script src="/js/script.js"></script>

</body>
</html>