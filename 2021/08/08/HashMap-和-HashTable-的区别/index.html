<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>HashMap 和 HashTable 的区别 | Jenna233</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="[转]HashMap和Hashtable的详细区别 简述1.安全性Hashtable是线程安全，HashMap是非线程安全。HashMap的性能会高于Hashtable，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedM">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap 和 HashTable 的区别">
<meta property="og:url" content="https://jenna233.github.io/2021/08/08/HashMap-%E5%92%8C-HashTable-%E7%9A%84%E5%8C%BA%E5%88%AB/index.html">
<meta property="og:site_name" content="Jenna233">
<meta property="og:description" content="[转]HashMap和Hashtable的详细区别 简述1.安全性Hashtable是线程安全，HashMap是非线程安全。HashMap的性能会高于Hashtable，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedM">
<meta property="og:locale">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-b36d62cfcf07cd35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-abcb9bfaadcb4394.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15531792-3ba0c29f9a46e000.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2021-08-08T06:25:45.000Z">
<meta property="article:modified_time" content="2021-08-08T06:27:08.967Z">
<meta property="article:author" content="Jenna233">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/15531792-b36d62cfcf07cd35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="Jenna233" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/tocas.css">

  
<link rel="stylesheet" href="/css/animate.css">

  
<link rel="stylesheet" href="/css/style.css">

  <style type="text/css">
    a.title-link:hover{
        color: #34b2db !important;
    }

    a.title-link:active{
        color: #2075c1 !important;
    }

    #menu-color-id{
        background : #f7f7f7;
    }

    #menu-color-id a{
        color: #5a5a5a;
    }
  </style>
  
<script src="/js/tocas.js"></script>

  

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
<!-- navigation -->

<div class="ts fluid basic link big menu" id="menu-color-id">

    <!-- ejs : align to post page or index page -->
        
            <div class="ts very narrow container">
        

        
            <a class="item" href="/">Home</a>
        
            <a class="item" href="/archives">Archives</a>
        
    </div>
</div>
<!-- the end of navigation -->

<!-- big bang title -->
<div class="ts padded horizontally fitted fluid slate" style="background-color: #f7f7f7;">
    <!-- ejs : align to post page or index page -->
    
        <div class="ts very narrow container">
    
        <!-- Title -->
        <h1 class="ts eleven wide column header be-center-h1">
            <span style="color: #404040;" id="big-title">Jenna233</span>
            <div class="sub header" id="slogan-bar" style=" margin-top: 15px; color: #404040;"></div>
        </h1>
        <!-- the end of title -->
    </div>
</div>
<!-- the end of big bang title -->


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">

<!-- main section -->
<div class="ts text container">
        <!-- left section -->
        <div class="column" style=" padding: 35px; ">
            <!-- Articles -->
                
                <h1 class="ts header">
                    <span style="color: #333;">HashMap 和 HashTable 的区别</span>
                    <div class="sub header" style="color: #808080;">Publish: 2021/8/8 
                     &nbsp;&nbsp;
                        <ul class="unstyled radius-tag -list" itemprop="keywords"><li class="unstyled radius-tag -list-item"><a class="unstyled radius-tag -list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>
                    
                    </div>
                </h1>

                <p>[转]<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903925460500487">HashMap和Hashtable的详细区别</a></p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><h4 id="1-安全性"><a href="#1-安全性" class="headerlink" title="1.安全性"></a>1.安全性</h4><p>Hashtable是线程安全，HashMap是非线程安全。HashMap的性能会高于Hashtable，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步</p>
<h4 id="2-是否可以使用null作为key"><a href="#2-是否可以使用null作为key" class="headerlink" title="2. 是否可以使用null作为key"></a>2. 是否可以使用null作为key</h4><p>HashMap可以使用null作为key，不过建议还是尽量避免这样使用。HashMap以null作为key时，总是存储在table数组的第一个节点上。而Hashtable则不允许null作为key</p>
<h4 id="3-继承了什么，实现了什么"><a href="#3-继承了什么，实现了什么" class="headerlink" title="3. 继承了什么，实现了什么"></a>3. 继承了什么，实现了什么</h4><p>HashMap继承了AbstractMap，HashTable继承Dictionary抽象类，两者均实现Map接口</p>
<h4 id="4-默认容量及如何扩容"><a href="#4-默认容量及如何扩容" class="headerlink" title="4.默认容量及如何扩容"></a>4.默认容量及如何扩容</h4><p>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。HashMap扩容时是当前容量翻倍即:capacity  2，Hashtable扩容时是容量翻倍+1即:capacity  (2+1)</p>
<h4 id="5-底层实现"><a href="#5-底层实现" class="headerlink" title="5.底层实现"></a>5.底层实现</h4><p>HashMap和Hashtable的底层实现都是<code>数组+链表</code>结构实现</p>
<h4 id="6-计算hash的方法不同"><a href="#6-计算hash的方法不同" class="headerlink" title="6.计算hash的方法不同"></a>6.计算hash的方法不同</h4><p>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模<br>HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取模</p>
<h1 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h1><p>参考文章：<a href="https://link.juejin.cn/?target=https://www.cnblogs.com/xinzhao/p/5644175.html" title="https://www.cnblogs.com/xinzhao/p/5644175.html">www.cnblogs.com/xinzhao/p/5…</a></p>
<p>HashMap和HashTable有什么不同？在面试和被面试的过程中，我问过也被问过这个问题，也见过了不少回答，今天决定写一写自己心目中的理想答案。</p>
<h4 id="代码版本"><a href="#代码版本" class="headerlink" title="代码版本"></a>代码版本</h4><p>JDK每一版本都在改进。本文讨论的HashMap和HashTable基于JDK 1.7.0_67。源码见<a target="_blank" rel="noopener" href="https://github.com/ZhaoX/jdk-1.7-annotated">这里</a></p>
<h4 id="1-时间"><a href="#1-时间" class="headerlink" title="1. 时间"></a>1. 时间</h4><p>HashTable产生于JDK 1.1，而HashMap产生于JDK 1.2。从时间的维度上来看，HashMap要比HashTable出现得晚一些。</p>
<h4 id="2-作者"><a href="#2-作者" class="headerlink" title="2. 作者"></a>2. 作者</h4><p>以下是HashTable的作者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line">* @author  Arthur van Hoff</span><br><span class="line">* @author  Josh Bloch</span><br><span class="line">* @author  Neal Gafter</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下是HashMap的作者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashMap</span><br><span class="line"></span><br><span class="line"> * @author  Doug Lea</span><br><span class="line"> * @author  Josh Bloch</span><br><span class="line"> * @author  Arthur van Hoff</span><br><span class="line"> * @author  Neal Gafter</span><br></pre></td></tr></table></figure>
<p>可以看到HashMap的作者多了大神Doug Lea。不了解Doug Lea的，可以看<a href="https://link.juejin.cn/?target=https://en.wikipedia.org/wiki/Doug_Lea" title="https://en.wikipedia.org/wiki/Doug_Lea">这里</a>。</p>
<h4 id="3-对外的接口（API）"><a href="#3-对外的接口（API）" class="headerlink" title="3. 对外的接口（API）"></a>3. 对外的接口（API）</h4><p>HashMap和HashTable都是基于哈希表来实现键值映射的工具类。讨论他们的不同，我们首先来看一下他们暴露在外的API有什么不同。</p>
<h5 id="3-1-Public-Method"><a href="#3-1-Public-Method" class="headerlink" title="3.1 Public Method"></a>3.1 Public Method</h5><p>下面两张图，我画出了HashMap和HashTable的类继承体系，并列出了这两个类的可供外部调用的公开方法。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b36d62cfcf07cd35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15531792-abcb9bfaadcb4394.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从图中可以看出，两个类的继承体系有些不同。虽然都实现了Map、Cloneable、Serializable三个接口。但是HashMap继承自抽象类AbstractMap，而HashTable继承自抽象类Dictionary。其中Dictionary类是一个已经被废弃的类，这一点我们可以从它代码的注释中看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下代码及注释来自java.util.Dictionary</span><br><span class="line"></span><br><span class="line"> * &lt;strong&gt;NOTE: This class is obsolete.  New implementations should</span><br><span class="line"> * implement the Map interface, rather than extending this class.&lt;&#x2F;strong&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同时我们看到HashTable比HashMap多了两个公开方法。一个是elements，这来自于抽象类Dictionary，鉴于该类已经废弃，所以这个方法也就没什么用处了。另一个多出来的方法是contains，这个多出来的方法也没什么用，因为它跟containsValue方法功能是一样的。代码为证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line"> public synchronized boolean contains(Object value) &#123;</span><br><span class="line">     if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">         throw new NullPointerException();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Entry tab[] &#x3D; table;</span><br><span class="line">     for (int i &#x3D; tab.length ; i-- &gt; 0 ;) &#123;</span><br><span class="line">         for (Entry&lt;K,V&gt; e &#x3D; tab[i] ; e !&#x3D; null ; e &#x3D; e.next) &#123;</span><br><span class="line">             if (e.value.equals(value)) &#123;</span><br><span class="line">                 return true;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return false;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public boolean containsValue(Object value) &#123;</span><br><span class="line">     return contains(value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>所以从公开的方法上来看，这两个类提供的，是一样的功能。都提供键值映射的服务，可以增、删、查、改键值对，可以对建、值、键值对提供遍历视图。支持浅拷贝，支持序列化。</p>
<h4 id="3-2-Null-Key-amp-Null-Value"><a href="#3-2-Null-Key-amp-Null-Value" class="headerlink" title="3.2 Null Key &amp; Null Value"></a>3.2 Null Key &amp; Null Value</h4><p>HashMap是支持null键和null值的，而HashTable在遇到null时，会抛出NullPointerException异常。这并不是因为HashTable有什么特殊的实现层面的原因导致不能支持null键和null值，这仅仅是因为HashMap在实现时对null做了特殊处理，将null的hashCode值定为了0，从而将其存放在哈希表的第0个bucket中。我们一put方法为例，看一看代码的细节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果value为null，抛出NullPointerException</span><br><span class="line">    if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果key为null，在调用key.hashCode()时抛出NullPointerException</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HasMap</span><br><span class="line"></span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 当key为null时，调用putForNullKey特殊处理</span><br><span class="line">    if (key &#x3D;&#x3D; null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private V putForNullKey(V value) &#123;</span><br><span class="line">    &#x2F;&#x2F; key为null时，放到table[0]也就是第0个bucket中</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[0]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        if (e.key &#x3D;&#x3D; null) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(0, null, value, 0);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-实现原理"><a href="#4-实现原理" class="headerlink" title="4. 实现原理"></a>4. 实现原理</h4><p>本节讨论HashMap和HashTable在数据结构和算法层面，有什么不同。</p>
<h5 id="4-1-数据结构"><a href="#4-1-数据结构" class="headerlink" title="4.1 数据结构"></a>4.1 数据结构</h5><p>HashMap和HashTable都使用哈希表来存储键值对。在数据结构上是基本相同的，都创建了一个继承自Map.Entry的私有的内部类Entry，每一个Entry对象表示存储在哈希表中的一个键值对。<br>Entry对象唯一表示一个键值对，有四个属性：</p>
<ul>
<li>K key 键对象</li>
<li>V value 值对象</li>
<li>int hash 键对象的hash值</li>
<li>Entry entry 指向链表中下一个Entry对象，可为null，表示当前Entry对象在链表尾部</li>
</ul>
<p>可以说，有多少个键值对，就有多少个Entry对象，那么在HashMap和HashTable中是怎么存储这些Entry对象，以方便我们快速查找和修改的呢？请看下图。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-3ba0c29f9a46e000.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>上图画出的是一个桶数量为8，存有5个键值对的HashMap/HashTable的内存布局情况。可以看到HashMap/HashTable内部创建有一个Entry类型的引用数组，用来表示哈希表，数组的长度，即是哈希桶的数量。而数组的每一个元素都是一个Entry引用，从Entry对象的属性里，也可以看出其是链表的节点，每一个Entry对象内部又含有另一个Entry对象的引用。<br>这样就可以得出结论，HashMap/HashTable内部用Entry数组实现哈希表，而对于映射到同一个哈希桶（数组的同一个位置）的键值对，使用Entry链表来存储(解决hash冲突)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The hash table data.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private transient Entry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashMap</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The table, resized as necessary. Length MUST Always be a power of two.</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient Entry&lt;K,V&gt;[] table &#x3D; (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从代码可以看到，对于哈希桶的内部表示，两个类的实现是一致的。</p>
<h5 id="4-2-算法"><a href="#4-2-算法" class="headerlink" title="4.2 算法"></a>4.2 算法</h5><p>上一小节已经说了用来表示哈希表的内部数据结构。HashMap/HashTable还需要有算法来将给定的键key，映射到确定的hash桶（数组位置）。需要有算法在哈希桶内的键值对多到一定程度时，扩充哈希表的大小（数组的大小）。本小节比较这两个类在算法层面有哪些不同。<br>初始容量大小和每次扩充容量大小的不同。先看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 哈希表默认初始大小为11</span><br><span class="line">public Hashtable() &#123;</span><br><span class="line">    this(11, 0.75f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void rehash() &#123;</span><br><span class="line">    int oldCapacity &#x3D; table.length;</span><br><span class="line">    Entry&lt;K,V&gt;[] oldMap &#x3D; table;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 每次扩容为原来的2n+1</span><br><span class="line">    int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashMap</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 哈希表默认初始大小为2^4&#x3D;16</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line"></span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    &#x2F;&#x2F; 每次扩充为原来的2n </span><br><span class="line">    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;</span><br><span class="line">       resize(2 * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。HashMap默认的初始化大小为16，之后每次扩充为原来的2倍。还有我没列出代码的一点，就是如果在创建时给定了初始化大小，那么HashTable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。</p>
<p>也就是说HashTable会尽量使用素数、奇数。而HashMap则总是使用2的幂作为哈希表的大小。我们知道当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀（具体证明，见这篇<a href="https://link.juejin.cn/?target=http://zhaox.github.io/algorithm/2015/06/29/hash" title="http://zhaox.github.io/algorithm/2015/06/29/hash">文章</a>），所以单从这一点上看，HashTable的哈希表大小选择，似乎更高明些。但另一方面我们又知道，在取模计算时，如果模数是2的幂，那么我们可以直接使用位运算来得到结果，效率要大大高于做除法。所以从hash计算的效率上，又是HashMap更胜一筹。</p>
<p>所以，事实就是HashMap为了加快hash的速度，将哈希表的大小固定为了2的幂。当然这引入了哈希分布不均匀的问题，所以HashMap为解决这问题，又对hash算法做了一些改动。具体我们来看看，在获取了key对象的hashCode之后，HashTable和HashMap分别是怎样将他们hash到确定的哈希桶（Entry数组位置）中的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; hash 不能超过Integer.MAX_VALUE 所以要取其最小的31个bit</span><br><span class="line">int hash &#x3D; hash(key);</span><br><span class="line">int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 直接计算key.hashCode()</span><br><span class="line">private int hash(Object k) &#123;</span><br><span class="line">    &#x2F;&#x2F; hashSeed will be zero if alternative hashing is disabled.</span><br><span class="line">    return hashSeed ^ k.hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashMap</span><br><span class="line">int hash &#x3D; hash(key);</span><br><span class="line">int i &#x3D; indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在计算了key.hashCode()之后，做了一些位运算来减少哈希冲突</span><br><span class="line">final int hash(Object k) &#123;</span><br><span class="line">    int h &#x3D; hashSeed;</span><br><span class="line">    if (0 !&#x3D; h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">        return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^&#x3D; k.hashCode();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; This function ensures that hashCodes that differ only by</span><br><span class="line">    &#x2F;&#x2F; constant multiples at each bit position have a bounded</span><br><span class="line">    &#x2F;&#x2F; number of collisions (approximately 8 at default load factor).</span><br><span class="line">    h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取模不再需要做除法</span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert Integer.bitCount(length) &#x3D;&#x3D; 1 : &quot;length must be a non-zero power of 2&quot;;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如我们所言，HashMap由于使用了2的幂次方，所以在取模运算时不需要做除法，只需要位的与运算就可以了。但是由于引入的hash冲突加剧问题，HashMap在调用了对象的hashCode方法之后，又做了一些位运算在打散数据。关于这些位计算为什么可以打散数据的问题，本文不再展开了。感兴趣的可以看<a href="https://link.juejin.cn/?target=http://stackoverflow.com/questions/9413966/why-initialcapacity-of-hashtable-is-11-while-the-default-initial-capacity-in-has" title="http://stackoverflow.com/questions/9413966/why-initialcapacity-of-hashtable-is-11-while-the-default-initial-capacity-in-has">这里</a>。</p>
<p>如果你有细心读代码，还可以发现一点，就是HashMap和HashTable在计算hash时都用到了一个叫hashSeed的变量。这是因为映射到同一个hash桶内的Entry对象，是以链表的形式存在的，而链表的查询效率比较低，所以HashMap/HashTable的效率对哈希冲突非常敏感，所以可以额外开启一个可选hash（hashSeed），从而减少哈希冲突。因为这是两个类相同的一点，所以本文不再展开了，感兴趣的看<a href="https://link.juejin.cn/?target=http://stackoverflow.com/questions/29918624/what-is-the-use-of-holder-class-in-hashmap" title="http://stackoverflow.com/questions/29918624/what-is-the-use-of-holder-class-in-hashmap">这里</a>。事实上，这个优化在JDK 1.8中已经去掉了，因为JDK 1.8中，映射到同一个哈希桶（数组位置）的Entry对象，使用了红黑树来存储，从而大大加速了其查找效率。</p>
<h4 id="5-线程安全"><a href="#5-线程安全" class="headerlink" title="5. 线程安全"></a>5. 线程安全</h4><p>我们说HashTable是同步的，HashMap不是，也就是说HashTable在多线程使用的情况下，不需要做额外的同步，而HashMap则不行。那么HashTable是怎么做到的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line">public synchronized V get(Object key) &#123;</span><br><span class="line">    Entry tab[] &#x3D; table;</span><br><span class="line">    int hash &#x3D; hash(key);</span><br><span class="line">    int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; tab[index] ; e !&#x3D; null ; e &#x3D; e.next) &#123;</span><br><span class="line">        if ((e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Set&lt;K&gt; keySet() &#123;</span><br><span class="line">    if (keySet &#x3D;&#x3D; null)</span><br><span class="line">        keySet &#x3D; Collections.synchronizedSet(new KeySet(), this);</span><br><span class="line">    return keySet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，也比较简单，就是公开的方法比如get都使用了synchronized描述符。而遍历视图比如keySet都使用了Collections.synchronizedXXX进行了同步包装。</p>
<h4 id="6-代码风格"><a href="#6-代码风格" class="headerlink" title="6. 代码风格"></a>6. 代码风格</h4><p>从我的品位来看，HashMap的代码要比HashTable整洁很多。下面这段HashTable的代码，我就觉着有点混乱，不太能接受这种代码复用的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * A hashtable enumerator class.  This class implements both the</span><br><span class="line"> * Enumeration and Iterator interfaces, but individual instances</span><br><span class="line"> * can be created with the Iterator methods disabled.  This is necessary</span><br><span class="line"> * to avoid unintentionally increasing the capabilities granted a user</span><br><span class="line"> * by passing an Enumeration.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; &#123;</span><br><span class="line">    Entry[] table &#x3D; Hashtable.this.table;</span><br><span class="line">    int index &#x3D; table.length;</span><br><span class="line">    Entry&lt;K,V&gt; entry &#x3D; null;</span><br><span class="line">    Entry&lt;K,V&gt; lastReturned &#x3D; null;</span><br><span class="line">    int type;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Indicates whether this Enumerator is serving as an Iterator</span><br><span class="line">     * or an Enumeration.  (true -&gt; Iterator).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean iterator;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The modCount value that the iterator believes that the backing</span><br><span class="line">     * Hashtable should have.  If this expectation is violated, the iterator</span><br><span class="line">     * has detected concurrent modification.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected int expectedModCount &#x3D; modCount;</span><br><span class="line"></span><br><span class="line">    Enumerator(int type, boolean iterator) &#123;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">        this.iterator &#x3D; iterator;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-HashTable已经被淘汰了，不要在代码中再使用它。"><a href="#7-HashTable已经被淘汰了，不要在代码中再使用它。" class="headerlink" title="7. HashTable已经被淘汰了，不要在代码中再使用它。"></a>7. HashTable已经被淘汰了，不要在代码中再使用它。</h4><p>以下描述来自于HashTable的类注释：<br><code>If a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable. If a thread-safe highly-concurrent implementation is desired, then it is recommended to use java.util.concurrent.ConcurrentHashMap in place of Hashtable.</code></p>
<p>简单来说就是，如果你不需要线程安全，那么使用HashMap，如果需要线程安全，那么使用ConcurrentHashMap。HashTable已经被淘汰了，不要在新的代码中再使用它。</p>
<h4 id="8-持续优化"><a href="#8-持续优化" class="headerlink" title="8. 持续优化"></a>8. 持续优化</h4><p>虽然HashMap和HashTable的公开接口应该不会改变，或者说改变不频繁。但每一版本的JDK，都会对HashMap和HashTable的内部实现做优化，比如上文曾提到的JDK 1.8的红黑树优化。所以，尽可能的使用新版本的JDK吧，除了那些炫酷的新功能，普通的API也会有性能上有提升。<br>为什么HashTable已经淘汰了，还要优化它？因为有老的代码还在使用它，所以优化了它之后，这些老的代码也能获得性能提升。</p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul>
<li><a href="https://link.juejin.cn/?target=https://github.com/ZhaoX/jdk-1.7-annotated/blob/master/src/java/util/HashMap.java" title="https://github.com/ZhaoX/jdk-1.7-annotated/blob/master/src/java/util/HashMap.java">github.com/ZhaoX/jdk-1…</a></li>
<li><a href="https://link.juejin.cn/?target=https://github.com/ZhaoX/jdk-1.7-annotated/blob/master/src/java/util/Hashtable.java" title="https://github.com/ZhaoX/jdk-1.7-annotated/blob/master/src/java/util/Hashtable.java">github.com/ZhaoX/jdk-1…</a></li>
</ul>

            <!-- / the end of articles -->
        </div>
        <!-- / left section -->
        
        
            <hr/>
            <div id="disqus_thread" style=" margin-top: 15px; margin-bottom: 25px; "></div>
            <script>
                /**
                *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
                /*
                var disqus_config = function () {
                this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
                this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                };
                */
                (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');
                s.src = 'https://morgan-hexo-theme.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        

        <!-- Next Post and Prev Post -->
        
        <hr/>
        <div class="next-prev-post-section">
            
                <a href="/2021/08/08/Jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B5%81%E7%A8%8B/" class="styled-border">
                    ←
                    Jvm 类加载机制和流程
                    
                </a>
            
            
                <a href="/2021/07/11/Selenium%E5%92%8CProtractor-%E7%AE%80%E4%BB%8B/" class="styled-border">
                    
                    Selenium和Protractor 简介
                    →
                </a>
            
        </div>
        
</div>
<script type="text/javascript">
    let img = document.getElementsByTagName("img");
    for(let i = 0; i < img.length; i++){
        img[i].className += " ts fluid image";
    }
</script>
<!-- / main section -->

<!-- copyright -->
<div class="ts attached secondary segment">
    <div class="ts narrow container">
        <br>
        <div class="ts large center aligned header">
            Powered by Hexo, Theme designs by @hpcslag.
            <div class="smaller sub header">
                Style-Framework Tocas-UI designs by @yamioldmel 
            </div>
        </div>
        <br>
    </div>
</div>
<!-- / copyright -->
<script type="text/javascript">
    
    const slogans = ["Hallo, dit is mijn blog","嗨，這是我的博客!","안녕하세요, 제 블로그입니다.","Hi, This is my blog!","こんにちは、私のブログへようこそ!","مرحبا، مرحبا بك في مدونتي"];
</script>

<script src="/js/script.js"></script>

</body>
</html>