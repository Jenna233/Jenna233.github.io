<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android系统启动流程（一）解析init进程启动过程 | Jenna233</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="[转]Android系统启动流程（一）解析init进程启动过程 前言作为“Android框架层”这个大系列中的第一个系列，我们首先要了解的是Android系统启动流程，在这个流程中会涉及到很多重要的知识点，这个系列我们就来一一讲解它们，这一篇我们就来学习init进程。 1.init简介init进程是Android系统中用户空间的第一个进程，作为第一个进程，它被赋予了很多极其重要的工作职责，比如创建">
<meta property="og:type" content="article">
<meta property="og:title" content="Android系统启动流程（一）解析init进程启动过程">
<meta property="og:url" content="https://jenna233.github.io/2021/09/21/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E8%A7%A3%E6%9E%90init%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/index.html">
<meta property="og:site_name" content="Jenna233">
<meta property="og:description" content="[转]Android系统启动流程（一）解析init进程启动过程 前言作为“Android框架层”这个大系列中的第一个系列，我们首先要了解的是Android系统启动流程，在这个流程中会涉及到很多重要的知识点，这个系列我们就来一一讲解它们，这一篇我们就来学习init进程。 1.init简介init进程是Android系统中用户空间的第一个进程，作为第一个进程，它被赋予了很多极其重要的工作职责，比如创建">
<meta property="og:locale">
<meta property="article:published_time" content="2021-09-21T07:08:59.000Z">
<meta property="article:modified_time" content="2021-09-21T07:09:35.754Z">
<meta property="article:author" content="Jenna233">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jenna233" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/tocas.css">

  
<link rel="stylesheet" href="/css/animate.css">

  
<link rel="stylesheet" href="/css/style.css">

  <style type="text/css">
    a.title-link:hover{
        color: #34b2db !important;
    }

    a.title-link:active{
        color: #2075c1 !important;
    }

    #menu-color-id{
        background : #f7f7f7;
    }

    #menu-color-id a{
        color: #5a5a5a;
    }
  </style>
  
<script src="/js/tocas.js"></script>

  

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
<!-- navigation -->

<div class="ts fluid basic link big menu" id="menu-color-id">

    <!-- ejs : align to post page or index page -->
        
            <div class="ts very narrow container">
        

        
            <a class="item" href="/">Home</a>
        
            <a class="item" href="/archives">Archives</a>
        
    </div>
</div>
<!-- the end of navigation -->

<!-- big bang title -->
<div class="ts padded horizontally fitted fluid slate" style="background-color: #f7f7f7;">
    <!-- ejs : align to post page or index page -->
    
        <div class="ts very narrow container">
    
        <!-- Title -->
        <h1 class="ts eleven wide column header be-center-h1">
            <span style="color: #404040;" id="big-title">Jenna233</span>
            <div class="sub header" id="slogan-bar" style=" margin-top: 15px; color: #404040;"></div>
        </h1>
        <!-- the end of title -->
    </div>
</div>
<!-- the end of big bang title -->


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">

<!-- main section -->
<div class="ts text container">
        <!-- left section -->
        <div class="column" style=" padding: 35px; ">
            <!-- Articles -->
                
                <h1 class="ts header">
                    <span style="color: #333;">Android系统启动流程（一）解析init进程启动过程</span>
                    <div class="sub header" style="color: #808080;">Publish: 2021/9/21 
                     &nbsp;&nbsp;
                        <ul class="unstyled radius-tag -list" itemprop="keywords"><li class="unstyled radius-tag -list-item"><a class="unstyled radius-tag -list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>
                    
                    </div>
                </h1>

                <p>[转]<a target="_blank" rel="noopener" href="http://liuwangshu.cn/framework/booting/1-init.html">Android系统启动流程（一）解析init进程启动过程</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为“Android框架层”这个大系列中的第一个系列，我们首先要了解的是Android系统启动流程，在这个流程中会涉及到很多重要的知识点，这个系列我们就来一一讲解它们，这一篇我们就来学习init进程。</p>
<h1 id="1-init简介"><a href="#1-init简介" class="headerlink" title="1.init简介"></a>1.init简介</h1><p>init进程是Android系统中用户空间的第一个进程，作为第一个进程，它被赋予了很多极其重要的工作职责，比如创建zygote(孵化器)和属性服务等。init进程是由多个源文件共同组成的，这些文件位于源码目录system/core/init。本文将基于Android7.0源码来分析Init进程。</p>
<h1 id="2-引入init进程"><a href="#2-引入init进程" class="headerlink" title="2.引入init进程"></a>2.引入init进程</h1><p>说到init进程，首先要提到Android系统启动流程的前几步：</p>
<ol>
<li>启动电源以及系统启动<br>当电源按下时引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序Bootloader到RAM，然后执行。</li>
<li>引导程序Bootloader<br>引导程序是在Android操作系统开始运行前的一个小程序，它的主要作用是把系统OS拉起来并运行。</li>
<li>linux内核启动<br>内核启动时，设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。</li>
<li>init进程启动</li>
</ol>
<p>讲到第四步就发现我们这一节要讲的init进程了。关于Android系统启动流程的所有步骤会在本系列的最后一篇做讲解。</p>
<h1 id="3-init入口函数"><a href="#3-init入口函数" class="headerlink" title="3.init入口函数"></a>3.init入口函数</h1><p>init的入口函数为main，代码如下所示。<br><strong>system/core/init/init.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    if (!strcmp(basename(argv[0]), &quot;ueventd&quot;)) &#123;</span><br><span class="line">        return ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!strcmp(basename(argv[0]), &quot;watchdogd&quot;)) &#123;</span><br><span class="line">        return watchdogd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    umask(0);</span><br><span class="line">    add_environment(&quot;PATH&quot;, _PATH_DEFPATH);</span><br><span class="line">    bool is_first_stage &#x3D; (argc &#x3D;&#x3D; 1) || (strcmp(argv[1], &quot;--second-stage&quot;) !&#x3D; 0);</span><br><span class="line">    &#x2F;&#x2F;创建文件并挂载</span><br><span class="line">    if (is_first_stage) &#123;</span><br><span class="line">        mount(&quot;tmpfs&quot;, &quot;&#x2F;dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode&#x3D;0755&quot;);</span><br><span class="line">        mkdir(&quot;&#x2F;dev&#x2F;pts&quot;, 0755);</span><br><span class="line">        mkdir(&quot;&#x2F;dev&#x2F;socket&quot;, 0755);</span><br><span class="line">        mount(&quot;devpts&quot;, &quot;&#x2F;dev&#x2F;pts&quot;, &quot;devpts&quot;, 0, NULL);</span><br><span class="line">        #define MAKE_STR(x) __STRING(x)</span><br><span class="line">        mount(&quot;proc&quot;, &quot;&#x2F;proc&quot;, &quot;proc&quot;, 0, &quot;hidepid&#x3D;2,gid&#x3D;&quot; MAKE_STR(AID_READPROC));</span><br><span class="line">        mount(&quot;sysfs&quot;, &quot;&#x2F;sys&quot;, &quot;sysfs&quot;, 0, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    open_devnull_stdio();</span><br><span class="line">    klog_init();</span><br><span class="line">    klog_set_level(KLOG_NOTICE_LEVEL);</span><br><span class="line">    NOTICE(&quot;init %s started!\n&quot;, is_first_stage ? &quot;first stage&quot; : &quot;second stage&quot;);</span><br><span class="line">    if (!is_first_stage) &#123;</span><br><span class="line">        &#x2F;&#x2F; Indicate that booting is in progress to background fw loaders, etc.</span><br><span class="line">        close(open(&quot;&#x2F;dev&#x2F;.booting&quot;, O_WRONLY | O_CREAT | O_CLOEXEC, 0000));</span><br><span class="line">        &#x2F;&#x2F;初始化属性相关资源</span><br><span class="line">        property_init();&#x2F;&#x2F;1</span><br><span class="line">        process_kernel_dt();</span><br><span class="line">        process_kernel_cmdline();</span><br><span class="line">        export_kernel_boot_props();</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">    &#x2F;&#x2F;启动属性服务</span><br><span class="line">    start_property_service();&#x2F;&#x2F;2</span><br><span class="line">    const BuiltinFunctionMap function_map;</span><br><span class="line">    Action::set_function_map(&amp;function_map);</span><br><span class="line">    Parser&amp; parser &#x3D; Parser::GetInstance();</span><br><span class="line">    parser.AddSectionParser(&quot;service&quot;,std::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">    parser.AddSectionParser(&quot;on&quot;, std::make_unique&lt;ActionParser&gt;());</span><br><span class="line">    parser.AddSectionParser(&quot;import&quot;, std::make_unique&lt;ImportParser&gt;());</span><br><span class="line">    &#x2F;&#x2F;解析init.rc配置文件</span><br><span class="line">    parser.ParseConfig(&quot;&#x2F;init.rc&quot;);&#x2F;&#x2F;3</span><br><span class="line">   ...   </span><br><span class="line">       while (true) &#123;</span><br><span class="line">        if (!waiting_for_exec) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">            restart_processes();</span><br><span class="line">        &#125;</span><br><span class="line">        int timeout &#x3D; -1;</span><br><span class="line">        if (process_needs_restart) &#123;</span><br><span class="line">            timeout &#x3D; (process_needs_restart - gettime()) * 1000;</span><br><span class="line">            if (timeout &lt; 0)</span><br><span class="line">                timeout &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (am.HasMoreCommands()) &#123;</span><br><span class="line">            timeout &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bootchart_sample(&amp;timeout);</span><br><span class="line">        epoll_event ev;</span><br><span class="line">        int nr &#x3D; TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout));</span><br><span class="line">        if (nr &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            ERROR(&quot;epoll_wait failed: %s\n&quot;, strerror(errno));</span><br><span class="line">        &#125; else if (nr &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            ((void (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init的main方法做了很多事情，我们只需要关注主要的几点，在注释1处调用 property_init来对属性进行初始化并在注释2处的 调用start_property_service启动属性服务，关于属性服务，后面会讲到。注释3处 parser.ParseConfig(“/init.rc”)用来解析init.rc。解析init.rc的文件为system/core/init/init_parse.cpp文件，接下来我们查看init.rc里做了什么。</p>
<h1 id="4-init-rc"><a href="#4-init-rc" class="headerlink" title="4.init.rc"></a>4.init.rc</h1><p>init.rc是一个配置文件，内部由Android初始化语言编写（Android Init Language）编写的脚本，它主要包含五种类型语句：<br>Action、Commands、Services、Options和Import。init.rc的配置代码如下所示。<br><strong>system/core/rootdir/init.rc</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">on init</span><br><span class="line">    sysclktz 0</span><br><span class="line">    # Mix device-specific information into the entropy pool</span><br><span class="line">    copy &#x2F;proc&#x2F;cmdline &#x2F;dev&#x2F;urandom</span><br><span class="line">    copy &#x2F;default.prop &#x2F;dev&#x2F;urandom</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">on boot</span><br><span class="line">    # basic network init</span><br><span class="line">    ifup lo</span><br><span class="line">    hostname localhost</span><br><span class="line">    domainname localdomain</span><br><span class="line">    # set RLIMIT_NICE to allow priorities from 19 to -20</span><br><span class="line">    setrlimit 13 40 40</span><br><span class="line">...    </span><br></pre></td></tr></table></figure>
<p>这里只截取了一部分代码，其中#是注释符号。on init和on boot是Action类型语句，它的格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]*     &#x2F;&#x2F;设置触发器  </span><br><span class="line">   &lt;command&gt;  </span><br><span class="line">   &lt;command&gt;      &#x2F;&#x2F;动作触发之后要执行的命令  </span><br></pre></td></tr></table></figure>
<p>为了分析如何创建zygote，我们主要查看Services类型语句，它的格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*   &#x2F;&#x2F;&lt;service的名字&gt;&lt;执行程序路径&gt;&lt;传递参数&gt;  </span><br><span class="line">   &lt;option&gt;       &#x2F;&#x2F;option是service的修饰词，影响什么时候、如何启动services  </span><br><span class="line">   &lt;option&gt;  </span><br><span class="line">   ...  </span><br></pre></td></tr></table></figure>
<p>需要注意的是在Android 7.0中对init.rc文件进行了拆分，每个服务一个rc文件。我们要分析的zygote服务的启动脚本则在init.zygoteXX.rc中定义，这里拿64位处理器为例，init.zygote64.rc的代码如下所示。<br><strong>system/core/rootdir/init.zygote64.rc</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks &#x2F;dev&#x2F;stune&#x2F;foreground&#x2F;tasks</span><br></pre></td></tr></table></figure>
<p>其中service用于通知init进程创建名zygote的进程，这个zygote进程执行程序的路径为/system/bin/app_process64，后面的则是要传给app_process64的参数。class main指的是zygote的class name为main，后文会用到它。</p>
<h1 id="5-解析service"><a href="#5-解析service" class="headerlink" title="5.解析service"></a>5.解析service</h1><p>接下来我们来解析service，会用到两个函数，一个是ParseSection，它会解析service的rc文件，比如上文讲到的init.zygote64.rc，ParseSection函数主要用来搭建service的架子。另一个是ParseLineSection，用于解析子项。代码如下所示。<br><strong>system/core/init/service.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool ServiceParser::ParseSection(const std::vector&lt;std::string&gt;&amp; args,</span><br><span class="line">                                 std::string* err) &#123;</span><br><span class="line">    if (args.size() &lt; 3) &#123;</span><br><span class="line">        *err &#x3D; &quot;services must have a name and a program&quot;;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    const std::string&amp; name &#x3D; args[1];</span><br><span class="line">    if (!IsValidName(name)) &#123;</span><br><span class="line">        *err &#x3D; StringPrintf(&quot;invalid service name &#39;%s&#39;&quot;, name.c_str());</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;std::string&gt; str_args(args.begin() + 2, args.end());</span><br><span class="line">    service_ &#x3D; std::make_unique&lt;Service&gt;(name, &quot;default&quot;, str_args);&#x2F;&#x2F;1</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool ServiceParser::ParseLineSection(const std::vector&lt;std::string&gt;&amp; args,</span><br><span class="line">                                     const std::string&amp; filename, int line,</span><br><span class="line">                                     std::string* err) const &#123;</span><br><span class="line">    return service_ ? service_-&gt;HandleLine(args, err) : false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释1处，根据参数，构造出一个service对象，它的classname为”default”。当解析完毕时会调用EndSection：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void ServiceParser::EndSection() &#123;</span><br><span class="line">    if (service_) &#123;</span><br><span class="line">        ServiceManager::GetInstance().AddService(std::move(service_));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着查看AddService做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void ServiceManager::AddService(std::unique_ptr&lt;Service&gt; service) &#123;</span><br><span class="line">    Service* old_service &#x3D; FindServiceByName(service-&gt;name());</span><br><span class="line">    if (old_service) &#123;</span><br><span class="line">        ERROR(&quot;ignored duplicate definition of service &#39;%s&#39;&quot;,</span><br><span class="line">              service-&gt;name().c_str());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    services_.emplace_back(std::move(service));&#x2F;&#x2F;1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释1处的代码将service对象加入到services链表中。上面的解析过程总体来讲就是根据参数创建出service对象，然后根据选项域的内容填充service对象，最后将service对象加入到vector类型的services链表中。，</p>
<h1 id="6-init启动zygote"><a href="#6-init启动zygote" class="headerlink" title="6.init启动zygote"></a>6.init启动zygote</h1><p>讲完了解析service，接下来该讲init是如何启动service，在这里我们主要讲解启动zygote这个service。在zygote的启动脚本中我们得知zygote的class name为main。在init.rc有如下配置代码：<br><strong>system/core/rootdir/init.rc</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">on nonencrypted    </span><br><span class="line">    # A&#x2F;B update verifier that marks a successful boot.  </span><br><span class="line">    exec - root -- &#x2F;system&#x2F;bin&#x2F;update_verifier nonencrypted  </span><br><span class="line">    class_start main         </span><br><span class="line">    class_start late_start </span><br><span class="line">...    </span><br></pre></td></tr></table></figure>
<p>其中class_start是一个COMMAND，对应的函数为do_class_start。我们知道main指的就是zygote，因此class_start main用来启动zygote。do_class_start函数在builtins.cpp中定义，如下所示。<br><strong>system/core/init/builtins.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static int do_class_start(const std::vector&lt;std::string&gt;&amp; args) &#123;</span><br><span class="line">        &#x2F;* Starting a class does not start services</span><br><span class="line">         * which are explicitly disabled.  They must</span><br><span class="line">         * be started individually.</span><br><span class="line">         *&#x2F;</span><br><span class="line">    ServiceManager::GetInstance().</span><br><span class="line">        ForEachServiceInClass(args[1], [] (Service* s) &#123; s-&gt;StartIfNotDisabled(); &#125;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来查看StartIfNotDisabled做了什么：<br><strong>system/core/init/service.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool Service::StartIfNotDisabled() &#123;</span><br><span class="line">    if (!(flags_ &amp; SVC_DISABLED)) &#123;</span><br><span class="line">        return Start();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        flags_ |&#x3D; SVC_DISABLED_START;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着查看Start方法，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">bool Service::Start() &#123;</span><br><span class="line">    flags_ &amp;&#x3D; (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START));</span><br><span class="line">    time_started_ &#x3D; 0;</span><br><span class="line">    if (flags_ &amp; SVC_RUNNING) &#123;&#x2F;&#x2F;如果Service已经运行，则不启动</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool needs_console &#x3D; (flags_ &amp; SVC_CONSOLE);</span><br><span class="line">    if (needs_console &amp;&amp; !have_console) &#123;</span><br><span class="line">        ERROR(&quot;service &#39;%s&#39; requires console\n&quot;, name_.c_str());</span><br><span class="line">        flags_ |&#x3D; SVC_DISABLED;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F;判断需要启动的Service的对应的执行文件是否存在，不存在则不启动该Service</span><br><span class="line">    struct stat sb;</span><br><span class="line">    if (stat(args_[0].c_str(), &amp;sb) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        ERROR(&quot;cannot find &#39;%s&#39; (%s), disabling &#39;%s&#39;\n&quot;,</span><br><span class="line">              args_[0].c_str(), strerror(errno), name_.c_str());</span><br><span class="line">        flags_ |&#x3D; SVC_DISABLED;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    pid_t pid &#x3D; fork();&#x2F;&#x2F;1.fork函数创建子进程</span><br><span class="line">    if (pid &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;运行在子进程中</span><br><span class="line">        umask(077);</span><br><span class="line">        for (const auto&amp; ei : envvars_) &#123;</span><br><span class="line">            add_environment(ei.name.c_str(), ei.value.c_str());</span><br><span class="line">        &#125;</span><br><span class="line">        for (const auto&amp; si : sockets_) &#123;</span><br><span class="line">            int socket_type &#x3D; ((si.type &#x3D;&#x3D; &quot;stream&quot; ? SOCK_STREAM :</span><br><span class="line">                                (si.type &#x3D;&#x3D; &quot;dgram&quot; ? SOCK_DGRAM :</span><br><span class="line">                                 SOCK_SEQPACKET)));</span><br><span class="line">            const char* socketcon &#x3D;</span><br><span class="line">                !si.socketcon.empty() ? si.socketcon.c_str() : scon.c_str();</span><br><span class="line"></span><br><span class="line">            int s &#x3D; create_socket(si.name.c_str(), socket_type, si.perm,</span><br><span class="line">                                  si.uid, si.gid, socketcon);</span><br><span class="line">            if (s &gt;&#x3D; 0) &#123;</span><br><span class="line">                PublishSocket(si.name, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        &#x2F;&#x2F;2.通过execve执行程序</span><br><span class="line">        if (execve(args_[0].c_str(), (char**) &amp;strs[0], (char**) ENV) &lt; 0) &#123;</span><br><span class="line">            ERROR(&quot;cannot execve(&#39;%s&#39;): %s\n&quot;, args_[0].c_str(), strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _exit(127);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过注释1和2的代码，我们得知在Start方法中调用fork函数来创建子进程，并在子进程中调用execve执行system/bin/app_process，这样就会进入framework/cmds/app_process/app_main.cpp的main函数，如下所示。<br><strong>frameworks/base/cmds/app_process/app_main.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* const argv[])</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    if (zygote) &#123;</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);&#x2F;&#x2F;1</span><br><span class="line">    &#125; else if (className) &#123;</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从注释1处的代码可以得知调用runtime(AppRuntime)的start来启动zygote。</p>
<h1 id="7-属性服务"><a href="#7-属性服务" class="headerlink" title="7.属性服务"></a>7.属性服务</h1><p>Windows平台上有一个注册表管理器，注册表的内容采用键值对的形式来记录用户、软件的一些使用信息。即使系统或者软件重启，它还是能够根据之前在注册表中的记录，进行相应的初始化工作。Android也提供了一个类似的机制，叫做属性服务。<br>在本文的开始，我们提到在init.cpp代码中和属性服务相关的代码有：<br><strong>system/core/init/init.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">property_init();</span><br><span class="line">start_property_service();</span><br></pre></td></tr></table></figure>
<p>这两句代码用来初始化属性服务配置并启动属性服务。首先我们来学习服务配置的初始化和启动。</p>
<p><strong>属性服务初始化与启动</strong></p>
<p>property_init函数具体实现的代码如下所示。<br><strong>system/core/init/property_service.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void property_init() &#123;</span><br><span class="line">    if (__system_property_area_init()) &#123;</span><br><span class="line">        ERROR(&quot;Failed to initialize property area\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__system_property_area_init函数用来初始化属性内存区域。接下来查看start_property_service函数的具体代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void start_property_service() &#123;</span><br><span class="line">    property_set_fd &#x3D; create_socket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,</span><br><span class="line">                                    0666, 0, 0, NULL);&#x2F;&#x2F;1</span><br><span class="line">    if (property_set_fd &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        ERROR(&quot;start_property_service socket creation failed: %s\n&quot;, strerror(errno));</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    listen(property_set_fd, 8);&#x2F;&#x2F;2</span><br><span class="line">    register_epoll_handler(property_set_fd, handle_property_set_fd);&#x2F;&#x2F;3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释1处用来创建非阻塞的socket。注释2处调用listen函数对property_set_fd进行监听，这样创建的socket就成为了server，也就是属性服务；listen函数的第二个参数设置8意味着属性服务最多可以同时为8个试图设置属性的用户提供服务。注释3处的代码将property_set_fd放入了epoll句柄中，用epoll来监听property_set_fd：当property_set_fd中有数据到来时，init进程将用handle_property_set_fd函数进行处理。<br>在linux新的内核中，epoll用来替换select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为内核中的select实现是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。</p>
<p><strong>属性服务处理请求</strong><br>从上文我们得知，属性服务接收到客户端的请求时，会调用handle_property_set_fd函数进行处理：<br><strong>system/core/init/property_service.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void handle_property_set_fd()</span><br><span class="line">&#123;  </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        if(memcmp(msg.name,&quot;ctl.&quot;,4) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            close(s);</span><br><span class="line">            if (check_control_mac_perms(msg.value, source_ctx, &amp;cr)) &#123;</span><br><span class="line">                handle_control_message((char*) msg.name + 4, (char*) msg.value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ERROR(&quot;sys_prop: Unable to %s service ctl [%s] uid:%d gid:%d pid:%d\n&quot;,</span><br><span class="line">                        msg.name + 4, msg.value, cr.uid, cr.gid, cr.pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;检查客户端进程权限</span><br><span class="line">            if (check_mac_perms(msg.name, source_ctx, &amp;cr)) &#123;&#x2F;&#x2F;1</span><br><span class="line">                property_set((char*) msg.name, (char*) msg.value);&#x2F;&#x2F;2</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ERROR(&quot;sys_prop: permission denied uid:%d  name:%s\n&quot;,</span><br><span class="line">                      cr.uid, msg.name);</span><br><span class="line">            &#125;</span><br><span class="line">            close(s);</span><br><span class="line">        &#125;</span><br><span class="line">        freecon(source_ctx);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        close(s);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释1处的代码用来检查客户端进程权限，在注释2处则调用property_set函数对属性进行修改，代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int property_set(const char* name, const char* value) &#123;</span><br><span class="line">    int rc &#x3D; property_set_impl(name, value);</span><br><span class="line">    if (rc &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        ERROR(&quot;property_set(\&quot;%s\&quot;, \&quot;%s\&quot;) failed\n&quot;, name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>property_set函数主要调用了property_set_impl函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static int property_set_impl(const char* name, const char* value) &#123;</span><br><span class="line">    size_t namelen &#x3D; strlen(name);</span><br><span class="line">    size_t valuelen &#x3D; strlen(value);</span><br><span class="line">    if (!is_legal_property_name(name, namelen)) return -1;</span><br><span class="line">    if (valuelen &gt;&#x3D; PROP_VALUE_MAX) return -1;</span><br><span class="line">    if (strcmp(&quot;selinux.reload_policy&quot;, name) &#x3D;&#x3D; 0 &amp;&amp; strcmp(&quot;1&quot;, value) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (selinux_reload_policy() !&#x3D; 0) &#123;</span><br><span class="line">            ERROR(&quot;Failed to reload policy\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (strcmp(&quot;selinux.restorecon_recursive&quot;, name) &#x3D;&#x3D; 0 &amp;&amp; valuelen &gt; 0) &#123;</span><br><span class="line">        if (restorecon_recursive(value) !&#x3D; 0) &#123;</span><br><span class="line">            ERROR(&quot;Failed to restorecon_recursive %s\n&quot;, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;从属性存储空间查找该属性</span><br><span class="line">    prop_info* pi &#x3D; (prop_info*) __system_property_find(name);</span><br><span class="line">    &#x2F;&#x2F;如果属性存在</span><br><span class="line">    if(pi !&#x3D; 0) &#123;</span><br><span class="line">       &#x2F;&#x2F;如果属性以&quot;ro.&quot;开头，则表示是只读，不能修改，直接返回</span><br><span class="line">        if(!strncmp(name, &quot;ro.&quot;, 3)) return -1;</span><br><span class="line">       &#x2F;&#x2F;更新属性值</span><br><span class="line">        __system_property_update(pi, value, valuelen);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       &#x2F;&#x2F;如果属性不存在则添加该属性</span><br><span class="line">        int rc &#x3D; __system_property_add(name, namelen, value, valuelen);</span><br><span class="line">        if (rc &lt; 0) &#123;</span><br><span class="line">            return rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* If name starts with &quot;net.&quot; treat as a DNS property. *&#x2F;</span><br><span class="line">    if (strncmp(&quot;net.&quot;, name, strlen(&quot;net.&quot;)) &#x3D;&#x3D; 0)  &#123;</span><br><span class="line">        if (strcmp(&quot;net.change&quot;, name) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">      &#x2F;&#x2F;以net.开头的属性名称更新后，需要将属性名称写入net.change中  </span><br><span class="line">        property_set(&quot;net.change&quot;, name);</span><br><span class="line">    &#125; else if (persistent_properties_loaded &amp;&amp;</span><br><span class="line">            strncmp(&quot;persist.&quot;, name, strlen(&quot;persist.&quot;)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Don&#39;t write properties to disk until after we have read all default properties</span><br><span class="line">         * to prevent them from being overwritten by default values.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        write_persistent_property(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    property_changed(name, value);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>property_set_impl函数主要用来对属性进行修改，并对以ro、net和persist开头的属性进行相应的处理。到这里，属性服务处理请求的源码就讲到这。</p>
<h1 id="8-init进程总结"><a href="#8-init进程总结" class="headerlink" title="8.init进程总结"></a>8.init进程总结</h1><p>讲到这，总结起来init进程主要做了三件事：</p>
<ol>
<li>创建一些文件夹并挂载设备</li>
<li>初始化和启动属性服务</li>
<li>解析init.rc配置文件并启动zygote进程</li>
</ol>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>《深入理解Android系统》<br>《深入理解Android卷I》<br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/nokiaguy/archive/2013/04/14/3020774.html">Android的init过程详解（一）</a><br><a target="_blank" rel="noopener" href="http://blog.jobbole.com/67931/">Android启动过程深入解析</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/fu_kevin0606/article/details/53383031">Android7.0解析Init.rc文件</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/sunao2002002/article/details/52454878">Android 7.0 init.rc的一点改变</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/gaugamela/article/details/52133186">Android7.0 init进程源码分析</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/hu3167343/article/details/38230271">Android情景分析之属性服务</a></p>

            <!-- / the end of articles -->
        </div>
        <!-- / left section -->
        
        
            <hr/>
            <div id="disqus_thread" style=" margin-top: 15px; margin-bottom: 25px; "></div>
            <script>
                /**
                *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
                /*
                var disqus_config = function () {
                this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
                this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                };
                */
                (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');
                s.src = 'https://morgan-hexo-theme.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        

        <!-- Next Post and Prev Post -->
        
        <hr/>
        <div class="next-prev-post-section">
            
                <a href="#"></a>
            
            
                <a href="/2021/09/21/Android-AMS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8CAMS%E5%AE%B6%E6%97%8F/" class="styled-border">
                    
                    Android AMS启动流程和AMS家族
                    →
                </a>
            
        </div>
        
</div>
<script type="text/javascript">
    let img = document.getElementsByTagName("img");
    for(let i = 0; i < img.length; i++){
        img[i].className += " ts fluid image";
    }
</script>
<!-- / main section -->

<!-- copyright -->
<div class="ts attached secondary segment">
    <div class="ts narrow container">
        <br>
        <div class="ts large center aligned header">
            Powered by Hexo, Theme designs by @hpcslag.
            <div class="smaller sub header">
                Style-Framework Tocas-UI designs by @yamioldmel 
            </div>
        </div>
        <br>
    </div>
</div>
<!-- / copyright -->
<script type="text/javascript">
    
    const slogans = ["Hallo, dit is mijn blog","嗨，這是我的博客!","안녕하세요, 제 블로그입니다.","Hi, This is my blog!","こんにちは、私のブログへようこそ!","مرحبا، مرحبا بك في مدونتي"];
</script>

<script src="/js/script.js"></script>

</body>
</html>