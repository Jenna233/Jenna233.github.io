<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android 轻量级缓存 SharedPreference 源码解析 | Jenna233</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="[转]Android 轻量级缓存 SharedPreference 源码解析SharedPreference 是一个 Android 开发自带的适合保存轻量级数据的 K-V 存储库，它使用了 XML 的方式来存储数据，比如我就经常用它保存一些如用户登录信息等轻量级数据。那么今天就让我们来分析一下它的源码，研究一下其内部实现。 获取SharedPreferences我们在使用 SharedPrefe">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 轻量级缓存 SharedPreference 源码解析">
<meta property="og:url" content="https://jenna233.github.io/2021/10/30/Android-%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BC%93%E5%AD%98-SharedPreference-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Jenna233">
<meta property="og:description" content="[转]Android 轻量级缓存 SharedPreference 源码解析SharedPreference 是一个 Android 开发自带的适合保存轻量级数据的 K-V 存储库，它使用了 XML 的方式来存储数据，比如我就经常用它保存一些如用户登录信息等轻量级数据。那么今天就让我们来分析一下它的源码，研究一下其内部实现。 获取SharedPreferences我们在使用 SharedPrefe">
<meta property="og:locale">
<meta property="article:published_time" content="2021-10-30T08:40:35.000Z">
<meta property="article:modified_time" content="2021-10-30T08:41:12.000Z">
<meta property="article:author" content="Jenna233">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jenna233" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/tocas.css">

  
<link rel="stylesheet" href="/css/animate.css">

  
<link rel="stylesheet" href="/css/style.css">

  <style type="text/css">
    a.title-link:hover{
        color: #34b2db !important;
    }

    a.title-link:active{
        color: #2075c1 !important;
    }

    #menu-color-id{
        background : #f7f7f7;
    }

    #menu-color-id a{
        color: #5a5a5a;
    }
  </style>
  
<script src="/js/tocas.js"></script>

  

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
<!-- navigation -->

<div class="ts fluid basic link big menu" id="menu-color-id">

    <!-- ejs : align to post page or index page -->
        
            <div class="ts very narrow container">
        

        
            <a class="item" href="/">Home</a>
        
            <a class="item" href="/archives">Archives</a>
        
    </div>
</div>
<!-- the end of navigation -->

<!-- big bang title -->
<div class="ts padded horizontally fitted fluid slate" style="background-color: #f7f7f7;">
    <!-- ejs : align to post page or index page -->
    
        <div class="ts very narrow container">
    
        <!-- Title -->
        <h1 class="ts eleven wide column header be-center-h1">
            <span style="color: #404040;" id="big-title">Jenna233</span>
            <div class="sub header" id="slogan-bar" style=" margin-top: 15px; color: #404040;"></div>
        </h1>
        <!-- the end of title -->
    </div>
</div>
<!-- the end of big bang title -->


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">

<!-- main section -->
<div class="ts text container">
        <!-- left section -->
        <div class="column" style=" padding: 35px; ">
            <!-- Articles -->
                
                <h1 class="ts header">
                    <span style="color: #333;">Android 轻量级缓存 SharedPreference 源码解析</span>
                    <div class="sub header" style="color: #808080;">Publish: 2021/10/30 
                     &nbsp;&nbsp;
                        <ul class="unstyled radius-tag -list" itemprop="keywords"><li class="unstyled radius-tag -list-item"><a class="unstyled radius-tag -list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>
                    
                    </div>
                </h1>

                <p>[转]<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fa8cd904ed36">Android 轻量级缓存 SharedPreference 源码解析</a><br>SharedPreference 是一个 Android 开发自带的适合保存轻量级数据的 K-V 存储库，它使用了 XML 的方式来存储数据，比如我就经常用它保存一些如用户登录信息等轻量级数据。那么今天就让我们来分析一下它的源码，研究一下其内部实现。</p>
<h1 id="获取SharedPreferences"><a href="#获取SharedPreferences" class="headerlink" title="获取SharedPreferences"></a>获取SharedPreferences</h1><p>我们在使用 SharedPreferences 时首先是需要获取到这个 SharedPreferences 的，因此我们首先从 SharedPreferences 的获取入手，来分析其源码。</p>
<h1 id="根据名称获取-SP"><a href="#根据名称获取-SP" class="headerlink" title="根据名称获取 SP"></a>根据名称获取 SP</h1><p>不论是在 Activity 中调用 getPreferences() 方法还是调用 Context 的 getSharedPreferences 方法，最终都是调用到了 ContextImpl 的 getSharedPreferences(String name, int mode) 方法。我们先看看它的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</span><br><span class="line">    &#x2F;&#x2F; At least one application in the world actually passes in a null</span><br><span class="line">    &#x2F;&#x2F; name.  This happened to work because when we generated the file name</span><br><span class="line">    &#x2F;&#x2F; we would stringify it to &quot;null.xml&quot;.  Nice.</span><br><span class="line">    if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">            Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        if (name &#x3D;&#x3D; null) &#123;</span><br><span class="line">            name &#x3D; &quot;null&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    File file;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        if (mSharedPrefsPaths &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mSharedPrefsPaths &#x3D; new ArrayMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        file &#x3D; mSharedPrefsPaths.get(name);</span><br><span class="line">        if (file &#x3D;&#x3D; null) &#123;</span><br><span class="line">            file &#x3D; getSharedPreferencesPath(name);</span><br><span class="line">            mSharedPrefsPaths.put(name, file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return getSharedPreferences(file, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，它首先对 Android 4.4 以下的设备做了特殊处理，之后将对 mSharedPrefsPaths 的操作加了锁。mSharedPrefsPaths 的声明如下：</p>
<p><code>private ArrayMap&lt;String, File&gt; mSharedPrefsPaths;</code></p>
<p>可以看到它是一个以 name 为 key，name 对应的 File 为 value 的 HashMap。首先调用了 getSharedPreferencesPath 方法构建出了 name 对应的 File，将其放入 map 后再调用了 getSharedPreferences(File file, int mode) 方法。</p>
<h1 id="获取-SP-名称对应的-File-对象"><a href="#获取-SP-名称对应的-File-对象" class="headerlink" title="获取 SP 名称对应的 File 对象"></a>获取 SP 名称对应的 File 对象</h1><p>我们先看看是如何构建出 name 对应的 File 的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public File getSharedPreferencesPath(String name) &#123;</span><br><span class="line">    return makeFilename(getPreferencesDir(), name + &quot;.xml&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，调用了 makeFilename 方法来创建一个名为 name.xml 的 File。makeFilename 中仅仅是做了一些判断，之后 new 出了这个 File 对象并返回。</p>
<p>可以看到，SharedPreference 确实是使用 xml 来保存其中的 K-V 数据的，而具体存储的路径我们这里就不再关心了，有兴趣的可以点进去看看。</p>
<h1 id="根据创建的-File-对象获取-SP"><a href="#根据创建的-File-对象获取-SP" class="headerlink" title="根据创建的 File 对象获取 SP"></a>根据创建的 File 对象获取 SP</h1><p>我们接着看到获取到 File 并放入 Map 后调用的 getSharedPreferences(file, mode) 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(File file, int mode) &#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache &#x3D; getSharedPreferencesCacheLocked();  &#x2F;&#x2F; 1</span><br><span class="line">        sp &#x3D; cache.get(file);</span><br><span class="line">        if (sp &#x3D;&#x3D; null) &#123;</span><br><span class="line">            checkMode(mode);</span><br><span class="line">            if (getApplicationInfo().targetSdkVersion &gt;&#x3D; android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">                if (isCredentialProtectedStorage()</span><br><span class="line">                        &amp;&amp; !getSystemService(UserManager.class)</span><br><span class="line">                                .isUserUnlockingOrUnlocked(UserHandle.myUserId())) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;SharedPreferences in credential encrypted &quot;</span><br><span class="line">                            + &quot;storage are not available until after user is unlocked&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sp &#x3D; new SharedPreferencesImpl(file, mode); &#x2F;&#x2F; 2</span><br><span class="line">            cache.put(file, sp);</span><br><span class="line">            return sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((mode &amp; Context.MODE_MULTI_PROCESS) !&#x3D; 0 ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        &#x2F;&#x2F; If somebody else (some other process) changed the prefs</span><br><span class="line">        &#x2F;&#x2F; file behind our back, we reload it.  This has been the</span><br><span class="line">        &#x2F;&#x2F; historical (if undocumented) behavior.</span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    return sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先可以看到注释 1 处，这里调用了 getSharedPreferencesCacheLocked 来获取到了一个 ArrayMap&lt;File, SharedPreferencesImpl&gt;，之后再从这个 Map 中尝试获取到对应的 SharedPreferencesImpl 实现类（简称 SPI)。</p>
<p>之后看到注释 2 处，当获取不到对应 SPI 时，再创建一个对应的 SPI，并将其加入这个 ArrayMap 中。</p>
<p>这里很明显是一个缓存机制的实现，以加快之后获取 SP 的速度，同时可以发现，SP 其实只是一个接口，而 SPI 才是其具体的实现类。</p>
<h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><p>那么我们先来看看其缓存机制，进入 getSharedPreferencesCacheLocked 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123;</span><br><span class="line">    if (sSharedPrefsCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sSharedPrefsCache &#x3D; new ArrayMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    final String packageName &#x3D; getPackageName();</span><br><span class="line">    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs &#x3D; sSharedPrefsCache.get(packageName);</span><br><span class="line">    if (packagePrefs &#x3D;&#x3D; null) &#123;</span><br><span class="line">        packagePrefs &#x3D; new ArrayMap&lt;&gt;();</span><br><span class="line">        sSharedPrefsCache.put(packageName, packagePrefs);</span><br><span class="line">    &#125;</span><br><span class="line">    return packagePrefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，这里有个全局的 ArrayMap：sSharedPrefsCache。</p>
<p>它是一个 ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; 类型的 Map，而从代码中可以看出，它是根据 PackageName 来保存不同的 SP 缓存 Map 的，通过这样的方式，就保证了不同 PackageName 中相同 name 的 SP 从缓存中拿到的数据是不同的。</p>
<h1 id="SharedPreferencesImpl"><a href="#SharedPreferencesImpl" class="headerlink" title="SharedPreferencesImpl"></a>SharedPreferencesImpl</h1><p>那么终于到了我们 SPI 的创建了，在 cache 中找不到对应的 SPI 时，就会 new 出一个 SPI，看看它的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferencesImpl(File file, int mode) &#123;</span><br><span class="line">    mFile &#x3D; file;</span><br><span class="line">    mBackupFile &#x3D; makeBackupFile(file); &#x2F;&#x2F; 1</span><br><span class="line">    mMode &#x3D; mode;</span><br><span class="line">    mLoaded &#x3D; false;</span><br><span class="line">    mMap &#x3D; null;</span><br><span class="line">    startLoadFromDisk();    &#x2F;&#x2F; 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到注释 1 处它调用了 makeBackupFile 来进行备份文件的创建。</p>
<p>之后在注释 2 处则调用了 startLoadFromDisk 来开始从 Disk 载入信息。</p>
<p>首先我们看看 makeBackupFile 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static File makeBackupFile(File prefsFile) &#123;</span><br><span class="line">    return new File(prefsFile.getPath() + &quot;.bak&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，返回了一个同目录下的后缀名为 .bak 的同名文件对象。</p>
<h1 id="从-Disk-加载数据"><a href="#从-Disk-加载数据" class="headerlink" title="从 Disk 加载数据"></a>从 Disk 加载数据</h1><p>接着，我们看看 startLoadFromDisk 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void startLoadFromDisk() &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mLoaded &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            loadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，首先在加锁的情况下对 mLoaded 进行了修改，之后则开了个名为「SharedPreferencesImpl-load」的线程来加载数据。</p>
<p>我们看到 loadFromDisk 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private void loadFromDisk() &#123;</span><br><span class="line">    synchronized (mLock) &#123;  &#x2F;&#x2F; 1</span><br><span class="line">        if (mLoaded) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Debugging</span><br><span class="line">    if (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;</span><br><span class="line">        Log.w(TAG, &quot;Attempt to read preferences file &quot; + mFile + &quot; without permission&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Map map &#x3D; null;</span><br><span class="line">    StructStat stat &#x3D; null;</span><br><span class="line">    try &#123; &#x2F;&#x2F; 2</span><br><span class="line">        stat &#x3D; Os.stat(mFile.getPath());</span><br><span class="line">        if (mFile.canRead()) &#123;</span><br><span class="line">            BufferedInputStream str &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                str &#x3D; new BufferedInputStream(</span><br><span class="line">                        new FileInputStream(mFile), 16*1024);</span><br><span class="line">                map &#x3D; XmlUtils.readMapXml(str);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Cannot read &quot; + mFile.getAbsolutePath(), e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                IoUtils.closeQuietly(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (ErrnoException e) &#123;</span><br><span class="line">        &#x2F;* ignore *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (mLock) &#123;  &#x2F;&#x2F; 3</span><br><span class="line">        mLoaded &#x3D; true;</span><br><span class="line">        if (map !&#x3D; null) &#123;</span><br><span class="line">            mMap &#x3D; map;</span><br><span class="line">            mStatTimestamp &#x3D; stat.st_mtim;</span><br><span class="line">            mStatSize &#x3D; stat.st_size;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        mLock.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较长，我们慢慢分析</p>
<p>首先在注释 1 处，如果已经加载过，则不再进行加载，之后又开始判断是否存在备份文件，若存在则直接将备份文件直接修改为数据文件 ${name}.xml。</p>
<p>之后在注释 2 处，通过 XmlUtils 将 xml 中的数据读取为一个 Map。由于本文主要是对 SP 的大致流程的解读，因此关于 XML 文件的具体读取部分，有兴趣的读者可以自己进入源码研究。</p>
<p>之后在注释 3 处，进行了一些收尾处理，将 mLoaded 置为 true，并对 mMap 进行了判空处理，以保证在 xml 没有数据的情况下其仍不为 null，最后释放了这个读取的锁，表示读取成功。</p>
<h1 id="编辑-SharedPreferences"><a href="#编辑-SharedPreferences" class="headerlink" title="编辑 SharedPreferences"></a>编辑 SharedPreferences</h1><p>我们都知道，真正对 SP 的操作其实都是在 Editor 中的，它其实是一个接口，具体的实现类为 EditorImpl。让我们先看看 Editor 的获取：</p>
<p>获取 Editor<br>看到 SharedPreferencesImpl 的 edit 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Editor edit() &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: remove the need to call awaitLoadedLocked() when</span><br><span class="line">    &#x2F;&#x2F; requesting an editor.  will require some work on the</span><br><span class="line">    &#x2F;&#x2F; Editor, but then we should be able to do:</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F;      context.getSharedPreferences(..).edit().putString(..).apply()</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ... all without blocking.</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    return new EditorImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里首先先调用了 awaitLoadedLocked() 方法来等待读取的完成，当读取完成后才会真正创建并返回 EditorImpl 对象。</p>
<h1 id="等待读取机制"><a href="#等待读取机制" class="headerlink" title="等待读取机制"></a>等待读取机制</h1><p>由于读取过程是一个异步的过程，很有可能导致读取还没结束，我们就开始编辑，因此这里用到了一个 awaitLoadedLocked 方法来阻塞线程，直到读取过程完成，下面我们可以先看看 awaitLoadedLocked 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void awaitLoadedLocked() &#123;</span><br><span class="line">    if (!mLoaded) &#123;</span><br><span class="line">        &#x2F;&#x2F; Raise an explicit StrictMode onReadFromDisk for th</span><br><span class="line">        &#x2F;&#x2F; thread, since the real read will be in a different</span><br><span class="line">        &#x2F;&#x2F; thread and otherwise ignored by StrictMode.</span><br><span class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    while (!mLoaded) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; catch (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里会阻塞直到 mLoaded 为 true，这样就保证了该方法后的方法都会在读取操作进行后执行。</p>
<h1 id="EditorImpl"><a href="#EditorImpl" class="headerlink" title="EditorImpl"></a>EditorImpl</h1><p>前面我们提到了 Edit 的真正实现类是 EditorImpl，它其实是 SPI 的一个内部类。它内部维护了一个Map&lt;String, Object&gt;： mModified，通过 mModified 来存放对 SP 进行的操作，此时还不会提交到 SPI 中的 mMap，我们做的操作都是在改变 mModified。</p>
<p>下面列出一些 EditorImpl 对外提供的修改接口，其实都是在对 mModified 这个 Map 进行修改，具体代码就不再讲解，比较简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public Editor putString(String key, @Nullable String val</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mModified.put(key, value);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public Editor putStringSet(String key, @Nullable Set&lt;Str</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mModified.put(key,</span><br><span class="line">                (values &#x3D;&#x3D; null) ? null : new HashSet&lt;St</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public Editor putInt(String key, int value) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mModified.put(key, value);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public Editor putLong(String key, long value) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mModified.put(key, value);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public Editor putFloat(String key, float value) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mModified.put(key, value);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public Editor putBoolean(String key, boolean value) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mModified.put(key, value);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public Editor remove(String key) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mModified.put(key, this);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public Editor clear() &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mClear &#x3D; true;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="提交-SharedPreferences"><a href="#提交-SharedPreferences" class="headerlink" title="提交 SharedPreferences"></a>提交 SharedPreferences</h1><p>提交本来可以放到编辑中的，但因为它才是重头戏，因此我们单独拎出来讲一下。</p>
<p>我们都知道 SP 的提交有两种方式——apply 和 commit。下面我们来分别分析：</p>
<h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void apply() &#123;</span><br><span class="line">    final long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    final MemoryCommitResult mcr &#x3D; commitToMemory();    &#x2F;&#x2F; 1</span><br><span class="line">    final Runnable awaitCommit &#x3D; new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                if (DEBUG &amp;&amp; mcr.wasWritten) &#123;</span><br><span class="line">                    Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                            + &quot; applied after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                            + &quot; ms&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line">    Runnable postWriteRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);    &#x2F;&#x2F; 2</span><br><span class="line">    &#x2F;&#x2F; Okay to notify the listeners before it&#39;s hit disk</span><br><span class="line">    &#x2F;&#x2F; because the listeners should always get the same</span><br><span class="line">    &#x2F;&#x2F; SharedPreferences instance back, which has the</span><br><span class="line">    &#x2F;&#x2F; changes reflected in memory.</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看到注释 1 处，调用了 commitToMemory 方法，它内部就是<strong>将原先读取进来的 mMap 与刚刚修改过的 mModified 进行合并，并存储于返回的 MemoryCommitResult mcr中。</strong></p>
<p>而在注释 2 处，调用了 enqueueDiskWrite 方法，传入了之前构造的 Runnable 对象，这里的目的是进行一个异步的写操作。</p>
<p>前面提到的两个方法，我们放到后面分析。</p>
<p>也就是说，<strong>apply 方法会将数据先提交到内存，再开启一个异步过程来将数据写入硬盘。</strong></p>
<h1 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean commit() &#123;</span><br><span class="line">    long startTime &#x3D; 0;</span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">        startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    MemoryCommitResult mcr &#x3D; commitToMemory();  &#x2F;&#x2F; 1</span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(    &#x2F;&#x2F; 2</span><br><span class="line">        mcr, null &#x2F;* sync write on this thread okay *&#x2F;);    </span><br><span class="line">    try &#123;</span><br><span class="line">        mcr.writtenToDiskLatch.await();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                    + &quot; committed after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                    + &quot; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">    return mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到注释 1 处，可以发现，同样调用了 commitToMemory 方法进行了合并。</p>
<p>之后看到 2 处，同样调用了 enqueueDiskWrite 方法，不过传入的第二个不再是 Runnable 方法。这里提一下，如果 enqueueDiskWrite 方法传入的第二个参数为 null，则会在当前线程执行写入操作。</p>
<p>也就是说，<strong>commit 方法会将数据先提交到内存，但之后则是一个同步的过程写入硬盘。</strong></p>
<h1 id="同步数据至内存"><a href="#同步数据至内存" class="headerlink" title="同步数据至内存"></a>同步数据至内存</h1><p>下面我们来看看两个方法中都调用了的 commitToMemory 的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private MemoryCommitResult commitToMemory() &#123;</span><br><span class="line">        ...</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            boolean changesMade &#x3D; false;</span><br><span class="line">            if (mClear) &#123;</span><br><span class="line">                if (!mMap.isEmpty()) &#123;</span><br><span class="line">                    changesMade &#x3D; true;</span><br><span class="line">                    mMap.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                mClear &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;</span><br><span class="line">                String k &#x3D; e.getKey();</span><br><span class="line">                Object v &#x3D; e.getValue();</span><br><span class="line">                if (v &#x3D;&#x3D; this || v &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    if (!mMap.containsKey(k)) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mMap.remove(k);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (mMap.containsKey(k)) &#123;</span><br><span class="line">                        Object existingValue &#x3D; mMap.get(k);</span><br><span class="line">                        if (existingValue !&#x3D; null &amp;&amp; existingValue.equals(v)) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mMap.put(k, v);</span><br><span class="line">                &#125;</span><br><span class="line">                changesMade &#x3D; true;</span><br><span class="line">                if (hasListeners) &#123;</span><br><span class="line">                    keysModified.add(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mModified.clear();</span><br><span class="line">            if (changesMade) &#123;</span><br><span class="line">                mCurrentMemoryStateGeneration++;</span><br><span class="line">            &#125;</span><br><span class="line">            memoryStateGeneration &#x3D; mCurrentMemoryStateGeneration;</span><br><span class="line">        &#125;</span><br><span class="line">    return new MemoryCommitResult(memoryStateGeneration, keysModified, listeners,</span><br><span class="line">            mapToWriteToDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，具体的代码就如同我们之前所说的一样，将 mMap 的数据与 mModified 的数据进行了整合，之后将 mModified 重新清空。最后将合并的数据放入了 MemoryCommitResult 中。</p>
<h1 id="写入数据至硬盘"><a href="#写入数据至硬盘" class="headerlink" title="写入数据至硬盘"></a>写入数据至硬盘</h1><p>我们同样看到 apply 和 commit 都调用了的方法 enqueueDiskWrite：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</span><br><span class="line">                              final Runnable postWriteRunnable) &#123;</span><br><span class="line">    final boolean isFromSyncCommit &#x3D; (postWriteRunnable &#x3D;&#x3D; null);   &#x2F;&#x2F; 1</span><br><span class="line">    final Runnable writeToDiskRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (mWritingToDiskLock) &#123;</span><br><span class="line">                    writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    mDiskWritesInFlight--;</span><br><span class="line">                &#125;</span><br><span class="line">                if (postWriteRunnable !&#x3D; null) &#123;</span><br><span class="line">                    postWriteRunnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#x2F;&#x2F; Typical #commit() path with fewer allocations, doing a write on</span><br><span class="line">    &#x2F;&#x2F; the current thread.</span><br><span class="line">    if (isFromSyncCommit) &#123;</span><br><span class="line">        boolean wasEmpty &#x3D; false;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            wasEmpty &#x3D; mDiskWritesInFlight &#x3D;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (wasEmpty) &#123;</span><br><span class="line">            writeToDiskRunnable.run();  &#x2F;&#x2F; 2 </span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 1 处，若第二个 Runnable 为 null 的话，则会将 isFromSyncCommit 置为 true，也就是写入会是一个同步的过程。之后在注释 2 处便进行了同步写入。否则会构造一个 Runnable 来提供给 QueueWork 进行异步写入。</p>
<p>QueueWork 类内部维护了一个 single 线程池，这样可以达到我们异步写入的目的。</p>
<p>而 writeToFile 方法中其实就是又调用了之前的 XmlUtils 来进行 XML 的写入。</p>
<p>#总结<br>SharedPreferences 其实就是一个用使用 XML 进行保存的 K-V 存储库。</p>
<p>在获取 SP 时会进行数据的加载，将 name 对应的 xml 文件以 Map 的形式读入到内存。</p>
<p>而 SP 的编辑操作其实都是在 Editor 内实现，它内部维护了一个新的 Map，所有的编辑操作其实都是在操作这个 Map，只有提交时才会与之前读取的数据进行合并。</p>
<p>其提交分为两种，apply 和 commit，它们的特性如下</p>
<ul>
<li><p>apply</p>
<ul>
<li>会将数据先提交到内存，再开启一个异步过程来将数据写入硬盘。</li>
<li>返回值时可能写入操作还没有结束<ul>
<li>写入失败时不会有任何提示</li>
</ul>
</li>
</ul>
</li>
<li><p>commit</p>
<ul>
<li>会将数据先提交到内存，但之后则是一个同步的过程写入硬盘。</li>
<li>写入操作结束后才会返回值=</li>
<li>写入失败会有提示</li>
</ul>
</li>
</ul>
<p>因此，当我们对写入的结果不那么关心的情况下，可以使用 apply 进行异步写入，而当我们对写入结果十分关心且提交后有后续操作的话最好使用 commit 来进行同步写入。</p>

            <!-- / the end of articles -->
        </div>
        <!-- / left section -->
        
        
            <hr/>
            <div id="disqus_thread" style=" margin-top: 15px; margin-bottom: 25px; "></div>
            <script>
                /**
                *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
                /*
                var disqus_config = function () {
                this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
                this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                };
                */
                (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');
                s.src = 'https://morgan-hexo-theme.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        

        <!-- Next Post and Prev Post -->
        
        <hr/>
        <div class="next-prev-post-section">
            
                <a href="/2021/10/30/SharedPreferences-%E7%9A%84%E7%BC%BA%E9%99%B7%E5%8F%8A%E4%B8%80%E7%82%B9%E7%82%B9%E6%80%9D%E8%80%83/" class="styled-border">
                    ←
                    SharedPreferences 的缺陷及一点点思考
                    
                </a>
            
            
                <a href="/2021/09/21/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E8%A7%A3%E6%9E%90init%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" class="styled-border">
                    
                    Android系统启动流程（一）解析init进程启动过程
                    →
                </a>
            
        </div>
        
</div>
<script type="text/javascript">
    let img = document.getElementsByTagName("img");
    for(let i = 0; i < img.length; i++){
        img[i].className += " ts fluid image";
    }
</script>
<!-- / main section -->

<!-- copyright -->
<div class="ts attached secondary segment">
    <div class="ts narrow container">
        <br>
        <div class="ts large center aligned header">
            Powered by Hexo, Theme designs by @hpcslag.
            <div class="smaller sub header">
                Style-Framework Tocas-UI designs by @yamioldmel 
            </div>
        </div>
        <br>
    </div>
</div>
<!-- / copyright -->
<script type="text/javascript">
    
    const slogans = ["Hallo, dit is mijn blog","嗨，這是我的博客!","안녕하세요, 제 블로그입니다.","Hi, This is my blog!","こんにちは、私のブログへようこそ!","مرحبا، مرحبا بك في مدونتي"];
</script>

<script src="/js/script.js"></script>

</body>
</html>