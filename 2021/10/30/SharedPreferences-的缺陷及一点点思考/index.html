<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SharedPreferences 的缺陷及一点点思考 | Jenna233</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="[转]一文读懂 SharedPreferences 的缺陷及一点点思考SharedPreferences 是系统提供的一个适合用于存储少量键值对数据的持久化存储方案，结构简单，使用方便，很多应用都会使用到。另一方面，SharedPreferences 存在的问题也挺多的，当中 ANR 问题就屡见不鲜，字节跳动技术团队就曾经发布过一篇文章专门来阐述该问题：剖析 SharedPreference ap">
<meta property="og:type" content="article">
<meta property="og:title" content="SharedPreferences 的缺陷及一点点思考">
<meta property="og:url" content="https://jenna233.github.io/2021/10/30/SharedPreferences-%E7%9A%84%E7%BC%BA%E9%99%B7%E5%8F%8A%E4%B8%80%E7%82%B9%E7%82%B9%E6%80%9D%E8%80%83/index.html">
<meta property="og:site_name" content="Jenna233">
<meta property="og:description" content="[转]一文读懂 SharedPreferences 的缺陷及一点点思考SharedPreferences 是系统提供的一个适合用于存储少量键值对数据的持久化存储方案，结构简单，使用方便，很多应用都会使用到。另一方面，SharedPreferences 存在的问题也挺多的，当中 ANR 问题就屡见不鲜，字节跳动技术团队就曾经发布过一篇文章专门来阐述该问题：剖析 SharedPreference ap">
<meta property="og:locale">
<meta property="article:published_time" content="2021-10-30T08:41:30.000Z">
<meta property="article:modified_time" content="2021-10-30T08:41:57.400Z">
<meta property="article:author" content="Jenna233">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jenna233" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/tocas.css">

  
<link rel="stylesheet" href="/css/animate.css">

  
<link rel="stylesheet" href="/css/style.css">

  <style type="text/css">
    a.title-link:hover{
        color: #34b2db !important;
    }

    a.title-link:active{
        color: #2075c1 !important;
    }

    #menu-color-id{
        background : #f7f7f7;
    }

    #menu-color-id a{
        color: #5a5a5a;
    }
  </style>
  
<script src="/js/tocas.js"></script>

  

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
<!-- navigation -->

<div class="ts fluid basic link big menu" id="menu-color-id">

    <!-- ejs : align to post page or index page -->
        
            <div class="ts very narrow container">
        

        
            <a class="item" href="/">Home</a>
        
            <a class="item" href="/archives">Archives</a>
        
    </div>
</div>
<!-- the end of navigation -->

<!-- big bang title -->
<div class="ts padded horizontally fitted fluid slate" style="background-color: #f7f7f7;">
    <!-- ejs : align to post page or index page -->
    
        <div class="ts very narrow container">
    
        <!-- Title -->
        <h1 class="ts eleven wide column header be-center-h1">
            <span style="color: #404040;" id="big-title">Jenna233</span>
            <div class="sub header" id="slogan-bar" style=" margin-top: 15px; color: #404040;"></div>
        </h1>
        <!-- the end of title -->
    </div>
</div>
<!-- the end of big bang title -->


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">

<!-- main section -->
<div class="ts text container">
        <!-- left section -->
        <div class="column" style=" padding: 35px; ">
            <!-- Articles -->
                
                <h1 class="ts header">
                    <span style="color: #333;">SharedPreferences 的缺陷及一点点思考</span>
                    <div class="sub header" style="color: #808080;">Publish: 2021/10/30 
                     &nbsp;&nbsp;
                        <ul class="unstyled radius-tag -list" itemprop="keywords"><li class="unstyled radius-tag -list-item"><a class="unstyled radius-tag -list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>
                    
                    </div>
                </h1>

                <p>[转]<a target="_blank" rel="noopener" href="https://juejin.cn/post/6932277268110639112">一文读懂 SharedPreferences 的缺陷及一点点思考</a><br>SharedPreferences 是系统提供的一个适合用于存储少量键值对数据的持久化存储方案，结构简单，使用方便，很多应用都会使用到。另一方面，SharedPreferences 存在的问题也挺多的，当中 ANR 问题就屡见不鲜，字节跳动技术团队就曾经发布过一篇文章专门来阐述该问题：<a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247484387&idx=1&sn=e3c8d6ef52520c51b5e07306d9750e70&scene=21%23wechat_redirect" title="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;mid=2247484387&amp;idx=1&amp;sn=e3c8d6ef52520c51b5e07306d9750e70&amp;scene=21#wechat_redirect">剖析 SharedPreference apply 引起的 ANR 问题</a>。到了现在，Google Jetpack 也推出了一套新的持久化存储方案：DataStore，大有取代 SharedPreferences 的趋势</p>
<p>本文就结合源码来剖析 SharedPreferences 存在的缺陷以及背后的具体原因，基于 SDK 30 进行分析，让读者做到知其然也知其所以然，并在最后介绍下我个人的一种存储机制设计方案，希望对你有所帮助.</p>
<h1 id="不得不说的坑"><a href="#不得不说的坑" class="headerlink" title="不得不说的坑"></a>不得不说的坑</h1><blockquote>
<p>会一直占用内存</p>
</blockquote>
<p>SharedPreferences 本身是一个接口，具体的实现类是 SharedPreferencesImpl，Context 中各个和 SP 相关的方法都是由 ContextImpl 来实现的。我们项目中的每个 SP 或多或少都是保存着一些键值对，而每当我们获取到一个 SP 对象时，其对应的数据就会一直被保留在内存中，直到应用进程被终结，因为每个 SP 对象都被系统作为静态变量缓存起来了，对应 ContextImpl 中的静态变量 <code>sSharedPrefsCache</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ContextImpl extends Context &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;先根据应用包名缓存所有 SharedPreferences</span><br><span class="line">    &#x2F;&#x2F;再根据 xmlFile 和具体的 SharedPreferencesImpl 对应上</span><br><span class="line">    private static ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据 fileName 拿到对应的 xmlFile</span><br><span class="line">    private ArrayMap&lt;String, File&gt; mSharedPrefsPaths;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 SP 都对应一个本地磁盘中的 xmlFile，fileName 则是由开发者来显式指定的，每个 xmlFile 都对应一个 SharedPreferencesImpl。所以 ContextImpl 的逻辑是先根据 fileName 拿到 xmlFile，再根据 xmlFile 拿到 SharedPreferencesImpl，最终应用内所有的 SharedPreferencesImpl 就都会被缓存在 <code>sSharedPrefsCache</code> 这个静态变量中。此外，由于 SharedPreferencesImpl 在初始化后就会自动去加载 xmlFile 中的所有键值对数据，而 ContextImpl 内部并没有看到有清理 <code>sSharedPrefsCache</code> 缓存的逻辑，所以 <code>sSharedPrefsCache</code> 会被一直保留在内存中直到进程终结，其内存大小会随着我们引用到的 SP 增多而加大，这就可能会持续占用很大一块内存空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</span><br><span class="line">    ···</span><br><span class="line">    File file;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        if (mSharedPrefsPaths &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mSharedPrefsPaths &#x3D; new ArrayMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        file &#x3D; mSharedPrefsPaths.get(name);</span><br><span class="line">        if (file &#x3D;&#x3D; null) &#123;</span><br><span class="line">            file &#x3D; getSharedPreferencesPath(name);</span><br><span class="line">            mSharedPrefsPaths.put(name, file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return getSharedPreferences(file, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(File file, int mode) &#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache &#x3D; getSharedPreferencesCacheLocked();</span><br><span class="line">        sp &#x3D; cache.get(file);</span><br><span class="line">        if (sp &#x3D;&#x3D; null) &#123;</span><br><span class="line">            ···</span><br><span class="line">            sp &#x3D; new SharedPreferencesImpl(file, mode);</span><br><span class="line">            cache.put(file, sp);</span><br><span class="line">            return sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    return sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GuardedBy(&quot;ContextImpl.class&quot;)</span><br><span class="line">private ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123;</span><br><span class="line">    if (sSharedPrefsCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sSharedPrefsCache &#x3D; new ArrayMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    final String packageName &#x3D; getPackageName();</span><br><span class="line">    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs &#x3D; sSharedPrefsCache.get(packageName);</span><br><span class="line">    if (packagePrefs &#x3D;&#x3D; null) &#123;</span><br><span class="line">        packagePrefs &#x3D; new ArrayMap&lt;&gt;();</span><br><span class="line">        sSharedPrefsCache.put(packageName, packagePrefs);</span><br><span class="line">    &#125;</span><br><span class="line">    return packagePrefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>GetValue 可能导致线程阻塞</p>
</blockquote>
<p>SharedPreferencesImpl 在构造函数中直接就启动了一个子线程去加载磁盘文件，这意味着该操作是一个异步操作（我好像在说废话），如果文件很大或者线程调度系统没有马上启动该线程的话，那么该操作就需要一小段时间后才能执行完毕</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">final class SharedPreferencesImpl implements SharedPreferences &#123;</span><br><span class="line">    </span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    SharedPreferencesImpl(File file, int mode) &#123;</span><br><span class="line">        mFile &#x3D; file;</span><br><span class="line">        mBackupFile &#x3D; makeBackupFile(file);</span><br><span class="line">        mMode &#x3D; mode;</span><br><span class="line">        mLoaded &#x3D; false;</span><br><span class="line">        mMap &#x3D; null;</span><br><span class="line">        mThrowable &#x3D; null;</span><br><span class="line">        startLoadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    private void startLoadFromDisk() &#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            mLoaded &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F;加载磁盘文件</span><br><span class="line">                loadFromDisk();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而如果我们在初始化 SharedPreferencesImpl 后紧接着就去 getValue 的话，势必也需要确保子线程已经加载完成后才去进行取值操作，所以 SharedPreferencesImpl 就通过在每个 getValue 方法中调用 <code>awaitLoadedLocked()</code>方法来判断是否需要阻塞外部线程，确保取值操作一定会在子线程执行完毕后才执行。<code>loadFromDisk()</code>方法会在任务执行完毕后调用 <code>mLock.notifyAll()</code>唤醒所有被阻塞的线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public String getString(String key, @Nullable String defValue) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        &#x2F;&#x2F;判断是否需要让外部线程等待</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        String v &#x3D; (String)mMap.get(key);</span><br><span class="line">        return v !&#x3D; null ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GuardedBy(&quot;mLock&quot;)</span><br><span class="line">private void awaitLoadedLocked() &#123;</span><br><span class="line">    if (!mLoaded) &#123;</span><br><span class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    while (!mLoaded) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;还未加载线程，让外部线程暂停等待</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; catch (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mThrowable !&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalStateException(mThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void loadFromDisk() &#123;</span><br><span class="line">    ···</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mLoaded &#x3D; true;</span><br><span class="line">        mThrowable &#x3D; thrown;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (thrown &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (map !&#x3D; null) &#123;</span><br><span class="line">                    mMap &#x3D; map;</span><br><span class="line">                    mStatTimestamp &#x3D; stat.st_mtim;</span><br><span class="line">                    mStatSize &#x3D; stat.st_size;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            mThrowable &#x3D; t;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F;唤醒所有被阻塞的线程</span><br><span class="line">            mLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以说，如果 SP 存储的数据量很大的话，那么就有可能导致外部的调用者线程被阻塞，严重时甚至可能导致 ANR。当然，这种可能性也只是发生在加载磁盘文件完成之前，当加载完成后 <code>awaitLoadedLocked()</code>方法自然不会阻塞线程</p>
<blockquote>
<p>GetValue 不保证数据类型安全</p>
</blockquote>
<p>以下代码在编译阶段是完全正常的，但在运行时就会抛出异常：<code>java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</code>。很明显，这是由于同个 key 先后对应了不同数据类型导致的，SharedPreferences 没有办法对这种操作做出限制，完全需要依赖于开发者自己的代码规范来进行限制</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sharedPreferences: SharedPreferences = getSharedPreferences(<span class="string">&quot;UserInfo&quot;</span>, Context.MODE_PRIVATE)</span><br><span class="line"><span class="keyword">val</span> key = <span class="string">&quot;userName&quot;</span></span><br><span class="line"><span class="keyword">val</span> edit = sharedPreferences.edit()</span><br><span class="line">edit.putInt(key, <span class="number">11</span>)</span><br><span class="line">edit.apply()</span><br><span class="line"><span class="keyword">val</span> name = sharedPreferences.getString(key, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不支持多进程数据共享</p>
</blockquote>
<p>在获取 SP 实例的时候需要传入一个 int 类型的 mode 标记位参数，存在一个和多进程相关的标记位 MODE_MULTI_PROCESS，该标记位能起到一定程度的多进程数据同步的保障，但作用不大，且并不保证多进程并发安全性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val sharedPreferences: SharedPreferences &#x3D; getSharedPreferences(&quot;UserInfo&quot;, Context.MODE_MULTI_PROCESS)</span><br></pre></td></tr></table></figure>
<p>上文有讲到，SharedPreferencesImpl 在被加载后就会一直保留在内存中，之后每次获取都是直接使用缓存数据，通常情况下也不会再次去加载磁盘文件。而 MODE_MULTI_PROCESS 起到的作用就是每当再一次去获取 SP 实例时，会判断当前磁盘文件相对最后一次内存修改是否被改动过了，如果是的话就主动去重新加载磁盘文件，从而可以做到在多进程环境下一定的数据同步<br>但是，这种同步本身作用不大，因为即使此时重新加载磁盘文件了，后续修改 SP 值时不同进程中的内存数据也不会实时同步，且多进程同时修改 SP 值也存在数据丢失和数据覆盖的可能。所以说，SP 并不支持多进程数据共享，MODE_MULTI_PROCESS 也已经被废弃了，其注释也推荐使用 ContentProvider 来实现跨进程通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class ContextImpl extends Context &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public SharedPreferences getSharedPreferences(File file, int mode) &#123;</span><br><span class="line">        SharedPreferencesImpl sp;</span><br><span class="line">        synchronized (ContextImpl.class) &#123;</span><br><span class="line">            ···</span><br><span class="line">        &#125;</span><br><span class="line">        if ((mode &amp; Context.MODE_MULTI_PROCESS) !&#x3D; 0 ||</span><br><span class="line">            getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">            &#x2F;&#x2F;重新去加载磁盘文件</span><br><span class="line">            sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">        &#125;</span><br><span class="line">        return sp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不支持增量更新</p>
</blockquote>
<p>我们知道，SP 提交数据的方法有两个：<code>commit()</code> 和 <code>apply()</code>，分别对应着同步修改和异步修改，而这两种方式对应的都是全量更新，SP 以文件为最小单位进行修改，即使我们只修改了一个键值对，这两个方法也会将所有键值对数据重新写入到磁盘文件中，即 SP 只支持全量更新<br>我们平时获取到的 Editor 对象，对应的都是 SharedPreferencesImpl 的内部类 EditorImpl。EditorImpl 的每个 putValue 方法都会将传进来的 key-value 保存在 <code>mModified</code> 中，暂时还没有涉及任何文件改动。比较特殊的是 <code>remove</code> 和 <code>clear</code> 两个方法，<code>remove</code> 方法会将 this 作为键值对的 value，后续就通过对比 value 的相等性来知道是要移除键值对还是修改键值对，<code>clear</code> 方法则只是将 mClear 标记位置为 true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public final class EditorImpl implements Editor &#123;</span><br><span class="line">    </span><br><span class="line">        private final Object mEditorLock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">        @GuardedBy(&quot;mEditorLock&quot;)</span><br><span class="line">        private final Map&lt;String, Object&gt; mModified &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        @GuardedBy(&quot;mEditorLock&quot;)</span><br><span class="line">        private boolean mClear &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    	@Override</span><br><span class="line">        public Editor putString(String key, @Nullable String value) &#123;</span><br><span class="line">            synchronized (mEditorLock) &#123;</span><br><span class="line">                mModified.put(key, value);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public Editor remove(String key) &#123;</span><br><span class="line">            synchronized (mEditorLock) &#123;</span><br><span class="line">                &#x2F;&#x2F;存入当前的 EditorImpl 对象</span><br><span class="line">                mModified.put(key, this);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Editor clear() &#123;</span><br><span class="line">            synchronized (mEditorLock) &#123;</span><br><span class="line">                mClear &#x3D; true;</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>commit()</code> 和<code>apply()</code>两个方法都会通过调用 <code>commitToMemory()</code>方法拿到修改后的全量数据<code>commitToMemory()</code>采用了 diff 算法，SP 包含的所有键值对数据都存储在 mapToWriteToDisk 中，Editor 改动到的所有键值对数据都存储在 mModified 中。如果  mClear 为 true，则会先清空 mapToWriteToDisk，然后再遍历 mModified，将 mModified 中的所有改动都同步给 mapToWriteToDisk。最终 mapToWriteToDisk 就保存了要重新写入到磁盘文件中的全量数据，SP 会根据 mapToWriteToDisk 完全覆盖掉旧的 xml 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Returns true if any changes were made</span><br><span class="line">private MemoryCommitResult commitToMemory() &#123;</span><br><span class="line">    long memoryStateGeneration;</span><br><span class="line">    boolean keysCleared &#x3D; false;</span><br><span class="line">    List&lt;String&gt; keysModified &#x3D; null;</span><br><span class="line">    Set&lt;OnSharedPreferenceChangeListener&gt; listeners &#x3D; null;</span><br><span class="line">    Map&lt;String, Object&gt; mapToWriteToDisk;</span><br><span class="line">    synchronized (SharedPreferencesImpl.this.mLock) &#123;</span><br><span class="line">        &#x2F;&#x2F; We optimistically don&#39;t make a deep copy until</span><br><span class="line">        &#x2F;&#x2F; a memory commit comes in when we&#39;re already</span><br><span class="line">        &#x2F;&#x2F; writing to disk.</span><br><span class="line">        if (mDiskWritesInFlight &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; We can&#39;t modify our mMap as a currently</span><br><span class="line">            &#x2F;&#x2F; in-flight write owns it.  Clone it before</span><br><span class="line">            &#x2F;&#x2F; modifying it.</span><br><span class="line">            &#x2F;&#x2F; noinspection unchecked</span><br><span class="line">            mMap &#x3D; new HashMap&lt;String, Object&gt;(mMap);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;拿到内存中的全量数据</span><br><span class="line">        mapToWriteToDisk &#x3D; mMap;</span><br><span class="line">        mDiskWritesInFlight++;</span><br><span class="line">        boolean hasListeners &#x3D; mListeners.size() &gt; 0;</span><br><span class="line">        if (hasListeners) &#123;</span><br><span class="line">            keysModified &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">            listeners &#x3D; new HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (mEditorLock) &#123;</span><br><span class="line">            &#x2F;&#x2F;用于标记最终是否改动到了 mapToWriteToDisk</span><br><span class="line">            boolean changesMade &#x3D; false;</span><br><span class="line">            if (mClear) &#123;</span><br><span class="line">                if (!mapToWriteToDisk.isEmpty()) &#123;</span><br><span class="line">                    changesMade &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F;清空所有在内存中的数据</span><br><span class="line">                    mapToWriteToDisk.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                keysCleared &#x3D; true;</span><br><span class="line">                &#x2F;&#x2F;恢复状态，避免二次修改时状态错位</span><br><span class="line">                mClear &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;</span><br><span class="line">                String k &#x3D; e.getKey();</span><br><span class="line">                Object v &#x3D; e.getValue();</span><br><span class="line">                &#x2F;&#x2F; &quot;this&quot; is the magic value for a removal mutation. In addition,</span><br><span class="line">                &#x2F;&#x2F; setting a value to &quot;null&quot; for a given key is specified to be</span><br><span class="line">                &#x2F;&#x2F; equivalent to calling remove on that key.</span><br><span class="line">                if (v &#x3D;&#x3D; this || v &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;意味着要移除该键值对</span><br><span class="line">                    if (!mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mapToWriteToDisk.remove(k);</span><br><span class="line">                &#125; else &#123; &#x2F;&#x2F;对应修改键值对值的情况</span><br><span class="line">                    if (mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                        Object existingValue &#x3D; mapToWriteToDisk.get(k);</span><br><span class="line">                        if (existingValue !&#x3D; null &amp;&amp; existingValue.equals(v)) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;只有在的确是修改了或新插入键值对的情况才需要保存值</span><br><span class="line">                    mapToWriteToDisk.put(k, v);</span><br><span class="line">                &#125;</span><br><span class="line">                changesMade &#x3D; true;</span><br><span class="line">                if (hasListeners) &#123;</span><br><span class="line">                    keysModified.add(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;恢复状态，避免二次修改时状态错位</span><br><span class="line">            mModified.clear();</span><br><span class="line">            if (changesMade) &#123;</span><br><span class="line">                mCurrentMemoryStateGeneration++;</span><br><span class="line">            &#125;</span><br><span class="line">            memoryStateGeneration &#x3D; mCurrentMemoryStateGeneration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new MemoryCommitResult(memoryStateGeneration, keysCleared, keysModified,</span><br><span class="line">            listeners, mapToWriteToDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Clear 的反直觉用法</p>
</blockquote>
<p>看以下例子。按照语义分析的话，最终 SP 中应该是只剩下 blog 一个键值对才符合直觉，而实际上最终两个键值对都会被保留，且只有这两个键值对被保留下来</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sharedPreferences: SharedPreferences = getSharedPreferences(<span class="string">&quot;UserInfo&quot;</span>, Context.MODE_PRIVATE)</span><br><span class="line"><span class="keyword">val</span> edit = sharedPreferences.edit()</span><br><span class="line">edit.putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;业志陈&quot;</span>).clear().putString(<span class="string">&quot;blog&quot;</span>, <span class="string">&quot;https://juejin.cn/user/923245496518439&quot;</span>)</span><br><span class="line">edit.apply()</span><br></pre></td></tr></table></figure>
<p>造成该问题的原因还需要看<code>commitToMemory()</code>方法。<code>clear()</code>会将 mClear 置为 true，所以在执行到第一步的时候就会将内存中的所有键值对数据 mapToWriteToDisk 清空。当执行到第二步的时候，mModified 中的所有数据就都会同步到 mapToWriteToDisk 中，从而导致最终 name 和 blog 两个键值对都会被保留下来，其它键值对都被移除了<br>所以说，<code>Editor.clear()</code> 之前不应该连贯调用 putValue 语句，这会造成理解和实际效果之间的偏差</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Returns true if any changes were made</span><br><span class="line">private MemoryCommitResult commitToMemory() &#123;</span><br><span class="line">    long memoryStateGeneration;</span><br><span class="line">    boolean keysCleared &#x3D; false;</span><br><span class="line">    List&lt;String&gt; keysModified &#x3D; null;</span><br><span class="line">    Set&lt;OnSharedPreferenceChangeListener&gt; listeners &#x3D; null;</span><br><span class="line">    Map&lt;String, Object&gt; mapToWriteToDisk;</span><br><span class="line">    synchronized (SharedPreferencesImpl.this.mLock) &#123;</span><br><span class="line">        &#x2F;&#x2F; We optimistically don&#39;t make a deep copy until</span><br><span class="line">        &#x2F;&#x2F; a memory commit comes in when we&#39;re already</span><br><span class="line">        &#x2F;&#x2F; writing to disk.</span><br><span class="line">        if (mDiskWritesInFlight &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; We can&#39;t modify our mMap as a currently</span><br><span class="line">            &#x2F;&#x2F; in-flight write owns it.  Clone it before</span><br><span class="line">            &#x2F;&#x2F; modifying it.</span><br><span class="line">            &#x2F;&#x2F; noinspection unchecked</span><br><span class="line">            mMap &#x3D; new HashMap&lt;String, Object&gt;(mMap);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;拿到内存中的全量数据</span><br><span class="line">        mapToWriteToDisk &#x3D; mMap;</span><br><span class="line">        mDiskWritesInFlight++;</span><br><span class="line">        boolean hasListeners &#x3D; mListeners.size() &gt; 0;</span><br><span class="line">        if (hasListeners) &#123;</span><br><span class="line">            keysModified &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">            listeners &#x3D; new HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (mEditorLock) &#123;</span><br><span class="line">            boolean changesMade &#x3D; false;</span><br><span class="line">            if (mClear) &#123; &#x2F;&#x2F;第一步</span><br><span class="line">                if (!mapToWriteToDisk.isEmpty()) &#123;</span><br><span class="line">                    changesMade &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F;清空所有在内存中的数据</span><br><span class="line">                    mapToWriteToDisk.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                keysCleared &#x3D; true;</span><br><span class="line">                &#x2F;&#x2F;恢复状态，避免二次修改时状态错位</span><br><span class="line">                mClear &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123; &#x2F;&#x2F;第二步</span><br><span class="line">                String k &#x3D; e.getKey();</span><br><span class="line">                Object v &#x3D; e.getValue();</span><br><span class="line">                &#x2F;&#x2F; &quot;this&quot; is the magic value for a removal mutation. In addition,</span><br><span class="line">                &#x2F;&#x2F; setting a value to &quot;null&quot; for a given key is specified to be</span><br><span class="line">                &#x2F;&#x2F; equivalent to calling remove on that key.</span><br><span class="line">                if (v &#x3D;&#x3D; this || v &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;意味着要移除该键值对</span><br><span class="line">                    if (!mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mapToWriteToDisk.remove(k);</span><br><span class="line">                &#125; else &#123; &#x2F;&#x2F;对应修改键值对值的情况</span><br><span class="line">                    if (mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                        Object existingValue &#x3D; mapToWriteToDisk.get(k);</span><br><span class="line">                        if (existingValue !&#x3D; null &amp;&amp; existingValue.equals(v)) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;只有在的确是修改了或新插入键值对的情况才需要保存值</span><br><span class="line">                    mapToWriteToDisk.put(k, v);</span><br><span class="line">                &#125;</span><br><span class="line">                changesMade &#x3D; true;</span><br><span class="line">                if (hasListeners) &#123;</span><br><span class="line">                    keysModified.add(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;恢复状态，避免二次修改时状态错位</span><br><span class="line">            mModified.clear();</span><br><span class="line">            if (changesMade) &#123;</span><br><span class="line">                mCurrentMemoryStateGeneration++;</span><br><span class="line">            &#125;</span><br><span class="line">            memoryStateGeneration &#x3D; mCurrentMemoryStateGeneration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new MemoryCommitResult(memoryStateGeneration, keysCleared, keysModified,</span><br><span class="line">            listeners, mapToWriteToDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Commit、apply 可能导致 ANR</p>
</blockquote>
<p><code>commit()</code> 方法会通过 <code>commitToMemory()</code> 方法拿到本次修改后的全量数据，即 MemoryCommitResult，然后向 <code>enqueueDiskWrite</code> 方法提交将全量数据写入磁盘文件的任务，在写入完成前调用者线程都会由于 CountDownLatch 一直阻塞等待着，方法返回值即本次修改操作的成功状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">   public boolean commit() &#123;</span><br><span class="line">       long startTime &#x3D; 0;</span><br><span class="line">       if (DEBUG) &#123;</span><br><span class="line">           startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">       &#125;</span><br><span class="line">&#x2F;&#x2F;拿到修改后的全量数据</span><br><span class="line">       MemoryCommitResult mcr &#x3D; commitToMemory();</span><br><span class="line">&#x2F;&#x2F;提交写入磁盘文件的任务</span><br><span class="line">       SharedPreferencesImpl.this.enqueueDiskWrite(</span><br><span class="line">           mcr, null &#x2F;* sync write on this thread okay *&#x2F;);</span><br><span class="line">       try &#123;</span><br><span class="line">           &#x2F;&#x2F;阻塞等待，直到 xml 文件写入完成（不管成功与否）</span><br><span class="line">           mcr.writtenToDiskLatch.await();</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (DEBUG) &#123;</span><br><span class="line">               Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                       + &quot; committed after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                       + &quot; ms&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       notifyListeners(mcr);</span><br><span class="line">       return mcr.writeToDiskResult;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>enqueueDiskWrite</code> 方法就是包含了具体的磁盘写入逻辑的地方了，由于外部可能存在多个线程在同时执行 <code>apply()</code> 和 <code>commit()</code> 两个方法，而对应的磁盘文件只有一个，所以 <code>enqueueDiskWrite</code> 方法就必须保证写入操作的有序性，避免数据丢失或者覆盖，甚至是文件损坏<br><code>enqueueDiskWrite</code> 方法的具体逻辑：</p>
<ol>
<li>writeToDiskRunnable 使用到了内部锁 mWritingToDiskLock 来保证 writeToFile 操作的有序性，避免多线程竞争</li>
<li>对于 commit 操作，如果当前只有一个线程在执行提交修改的操作的话，那么直接在该线程上执行 writeToDiskRunnable，流程结束</li>
<li>对于其他情况（apply 操作、多线程同时 commit 或者 apply），都会将 writeToDiskRunnable 提交给 QueuedWork 执行</li>
<li>QueuedWork 内部使用到了 HandlerThread 来执行 writeToDiskRunnable，HandlerThread 本身也可以保证多个任务执行时的有序性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</span><br><span class="line">                              final Runnable postWriteRunnable) &#123;</span><br><span class="line">    final boolean isFromSyncCommit &#x3D; (postWriteRunnable &#x3D;&#x3D; null);</span><br><span class="line">    final Runnable writeToDiskRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (mWritingToDiskLock) &#123;</span><br><span class="line">                    &#x2F;&#x2F;写入磁盘文件</span><br><span class="line">                    writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    mDiskWritesInFlight--;</span><br><span class="line">                &#125;</span><br><span class="line">                if (postWriteRunnable !&#x3D; null) &#123;</span><br><span class="line">                    postWriteRunnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#x2F;&#x2F; Typical #commit() path with fewer allocations, doing a write on</span><br><span class="line">    &#x2F;&#x2F; the current thread.</span><br><span class="line">    if (isFromSyncCommit) &#123; &#x2F;&#x2F;commit() 方法会走进这里面</span><br><span class="line">        boolean wasEmpty &#x3D; false;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            wasEmpty &#x3D; mDiskWritesInFlight &#x3D;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (wasEmpty) &#123;</span><br><span class="line">            &#x2F;&#x2F;wasEmpty 为 true 说明当前只有一个线程在执行提交操作，那么就直接在此线程上完成任务</span><br><span class="line">            writeToDiskRunnable.run();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还有一个比较重要的知识点需要注意下。在 writeToFile 方法中会对本次任务进行校验，避免连续多次执行无效的磁盘任务。当中，mDiskStateGeneration 代表的是最后一次成功写入磁盘文件时的任务版本号，mCurrentMemoryStateGeneration 是当前内存中最新的修改记录版本号，mcr.memoryStateGeneration 是本次要执行的任务的版本号。通过两次版本号的对比，就避免了在连续多次 commit 或者 apply 时造成重复执行 I/O 操作的情况，而是只会执行最后一次，避免了无效的 I/O 任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;mWritingToDiskLock&quot;)</span><br><span class="line">private void writeToFile(MemoryCommitResult mcr, boolean isFromSyncCommit) &#123;</span><br><span class="line">    ···</span><br><span class="line">    if (fileExists) &#123;</span><br><span class="line">        boolean needsWrite &#x3D; false;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Only need to write if the disk state is older than this commit</span><br><span class="line">        &#x2F;&#x2F;判断版本号</span><br><span class="line">        if (mDiskStateGeneration &lt; mcr.memoryStateGeneration) &#123;</span><br><span class="line">            if (isFromSyncCommit) &#123;</span><br><span class="line">                needsWrite &#x3D; true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    &#x2F;&#x2F; No need to persist intermediate states. Just wait for the latest state to</span><br><span class="line">                    &#x2F;&#x2F; be persisted.</span><br><span class="line">                    &#x2F;&#x2F;判断版本号</span><br><span class="line">                    if (mCurrentMemoryStateGeneration &#x3D;&#x3D; mcr.memoryStateGeneration) &#123;</span><br><span class="line">                        needsWrite &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">			</span><br><span class="line">        if (!needsWrite) &#123;</span><br><span class="line">            &#x2F;&#x2F;当前版本号并非最新，无需执行，直接返回即可</span><br><span class="line">            mcr.setDiskWriteResult(false, true);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回过头看 <code>commit()</code> 方法。不管该方法关联的 writeToDiskRunnable 最终是在本线程还是 HandlerThread 中执行，<code>await()</code>方法都会使得本线程阻塞等待直到 writeToDiskRunnable 执行完毕，从而实现了 <code>commit()</code>同步提交的效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">   public boolean commit() &#123;</span><br><span class="line">       long startTime &#x3D; 0;</span><br><span class="line">       if (DEBUG) &#123;</span><br><span class="line">           startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">       &#125;</span><br><span class="line">&#x2F;&#x2F;拿到修改后的全量数据</span><br><span class="line">       MemoryCommitResult mcr &#x3D; commitToMemory();</span><br><span class="line">&#x2F;&#x2F;提交写入磁盘文件的任务</span><br><span class="line">       SharedPreferencesImpl.this.enqueueDiskWrite(</span><br><span class="line">           mcr, null &#x2F;* sync write on this thread okay *&#x2F;);</span><br><span class="line">       try &#123;</span><br><span class="line">           &#x2F;&#x2F;阻塞等待，直到 xml 文件写入完成（不管成功与否）</span><br><span class="line">           mcr.writtenToDiskLatch.await();</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (DEBUG) &#123;</span><br><span class="line">               Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                       + &quot; committed after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                       + &quot; ms&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       notifyListeners(mcr);</span><br><span class="line">       return mcr.writeToDiskResult;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>而对于 <code>apply()</code> 方法，其本身具有异步提交的含义，I/O 操作应该都是交由给了子线程来执行才对，按道理来说只需要调用 <code>enqueueDiskWrite</code> 方法提交任务且不等待任务完成即可，可实际上<code>apply()</code>方法反而要比<code>commit()</code>方法复杂得多<br><code>apply()</code>方法包含一个 awaitCommit 任务，用于阻塞其执行线程直到磁盘任务执行完毕，而 awaitCommit 又被包裹在 postWriteRunnable 中一起提交给了 <code>enqueueDiskWrite</code> 方法，<code>enqueueDiskWrite</code> 方法又会在 writeToDiskRunnable 执行完毕后执行 enqueueDiskWrite</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void apply() &#123;</span><br><span class="line">    final long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    final MemoryCommitResult mcr &#x3D; commitToMemory();</span><br><span class="line">    final Runnable awaitCommit &#x3D; new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F;阻塞线程直到磁盘任务执行完毕</span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (DEBUG &amp;&amp; mcr.wasWritten) &#123;</span><br><span class="line">                    Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                            + &quot; applied after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                            + &quot; ms&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;提交任务</span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Okay to notify the listeners before it&#39;s hit disk</span><br><span class="line">    &#x2F;&#x2F; because the listeners should always get the same</span><br><span class="line">    &#x2F;&#x2F; SharedPreferences instance back, which has the</span><br><span class="line">    &#x2F;&#x2F; changes reflected in memory.</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单独看以上逻辑会显得十分奇怪，从上文就可以得知 writeToDiskRunnable 最终是会交由 HandlerThread 来执行的，那按照流程看 awaitCommit 最终也是会由 HandlerThread 调用，那么 awaitCommit 的等待操作就显得十分奇怪了，因为 awaitCommit 肯定是会在磁盘任务执行完毕才被调用，就相当于 HandlerThread  在自己等待自己执行完毕。此外，HandlerThread 属于子线程，按道理来说子线程即使执行了耗时操作也不会导致主线程 ANR 才对<br>要理解以上操作，还需要再看看 ActivityThread 这个类。当 Service 和 Activity 的生命周期处于 <code>handleStopService()</code> 、<code>handlePauseActivity()</code> 、<code>handleStopActivity()</code> 的时候，ActivityThread 会调用 <code>QueuedWork.waitToFinish()</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void handleStopService(IBinder token) &#123;</span><br><span class="line">    Service s &#x3D; mServices.remove(token);</span><br><span class="line">    if (s !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ···</span><br><span class="line">            &#x2F;&#x2F;重点</span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">            ···</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ···</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Slog.i(TAG, &quot;handleStopService: token&#x3D;&quot; + token + &quot; not found.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;Slog.i(TAG, &quot;Running services: &quot; + mServices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>QueuedWork.waitToFinish() </code>方法会主动去执行所有的磁盘写入任务，并执行所有的 postWriteRunnable，这就造成了 Activity 或 Service 在切换生命周期的过程中有可能因为存在大量的磁盘写入任务而被阻塞住，最终导致 ANR</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public static void waitToFinish() &#123;</span><br><span class="line">    long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    boolean hadMessages &#x3D; false;</span><br><span class="line">    Handler handler &#x3D; getHandler();</span><br><span class="line">    synchronized (sLock) &#123;</span><br><span class="line">        if (handler.hasMessages(QueuedWorkHandler.MSG_RUN)) &#123;</span><br><span class="line">            &#x2F;&#x2F; Delayed work will be processed at processPendingWork() below</span><br><span class="line">            handler.removeMessages(QueuedWorkHandler.MSG_RUN);</span><br><span class="line">            if (DEBUG) &#123;</span><br><span class="line">                hadMessages &#x3D; true;</span><br><span class="line">                Log.d(LOG_TAG, &quot;waiting&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; We should not delay any work as this might delay the finishers</span><br><span class="line">        sCanDelay &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    StrictMode.ThreadPolicy oldPolicy &#x3D; StrictMode.allowThreadDiskWrites();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;执行所有的磁盘写入任务</span><br><span class="line">        processPendingWork();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;执行所有的 postWriteRunnable</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Runnable finisher;</span><br><span class="line">            synchronized (sLock) &#123;</span><br><span class="line">                finisher &#x3D; sFinishers.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            if (finisher &#x3D;&#x3D; null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            finisher.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        sCanDelay &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (sLock) &#123;</span><br><span class="line">        long waitTime &#x3D; System.currentTimeMillis() - startTime;</span><br><span class="line">        if (waitTime &gt; 0 || hadMessages) &#123;</span><br><span class="line">            mWaitTimes.add(Long.valueOf(waitTime).intValue());</span><br><span class="line">            mNumWaits++;</span><br><span class="line">            if (DEBUG || mNumWaits % 1024 &#x3D;&#x3D; 0 || waitTime &gt; MAX_WAIT_TIME_MILLIS) &#123;</span><br><span class="line">                mWaitTimes.log(LOG_TAG, &quot;waited: &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityThread 为什么要主动去触发执行所有的磁盘写入任务我无从得知，字节技术跳动团队给出的猜测是：<strong>Google 在 Activity 和 Service 调用 onStop 之前阻塞主线程来处理 SP，我们能猜到的唯一原因是尽可能的保证数据的持久化。因为如果在运行过程中产生了 crash，也会导致 SP 未持久化，持久化本身是 IO 操作，也会失败</strong><br>综上所述，由于 SP 本身只支持全量更新，如果 SP 文件很大，即使是小数据量的 apply/commit 操作也有可能导致 ANR</p>
<h1 id="正反面"><a href="#正反面" class="headerlink" title="正反面"></a>正反面</h1><p>SharedPreferencesImpl 在不同的系统版本中有着比较大的差别，例如 writeToFile 方法对于任务版本号的校验也是从 8.0 系统开始的，在 8.0 系统之前对于连续的 commit 和 apply 每次都会触发 I/O 操作，所以在 8.0 系统之前 ANR 问题会更加容易复现。我们需要根据系统版本来看待以上列举出来的各个缺陷</p>
<p>需要强调的是，SP 本身的定位是轻量级数据存储，设计初衷是用于存储简单的数据结构（基本数据类型），且提供了按模块分区存储的功能。如果开发者能够严格遵守这一个规范的话，那么其实以上所述的很多“缺陷”都是可以避免的。而 SP 之所以现在看起来问题很多，也是因为如今大部分应用的业务比以前复杂太多了，有些时候为了方便就直接用来存储非常复杂的数据结构，或者是没有做好数据分区存储，导致单个文件过大，这才是造成问题的主要原因</p>
<h1 id="如何做好持久化"><a href="#如何做好持久化" class="headerlink" title="如何做好持久化"></a>如何做好持久化</h1><p>以下的示例代码估计是很多开发者的噩梦</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sharedPreference = getSharedPreferences(<span class="string">&quot;user_preference&quot;</span>, Context.MODE_PRIVATE)</span><br><span class="line"><span class="keyword">val</span> name = sharedPreference.getString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>以上代码存在什么问题呢？我觉得至少有五点：</p>
<ul>
<li>强引用到了 SP，导致后续需要切换存储库时需要全局搜索替换，工作量非常大</li>
<li>key 值难维护，每次获取 value 时都需要显式声明 key 值</li>
<li>可读性差，键值对的含义基本只能靠 key 值进行表示</li>
<li>只支持基本数据类型，在存取自定义数据类型时存在很多重复工作。要向 SP 存入自定义的 - JavaBean 对象时，只能将 Bean 对象转为 Json 字符串后存入 SP，在取值时再手动反序列化</li>
<li>数据类型不明确，基本只能靠注释来引导开发者使用正确的数据类型</li>
</ul>
<p>开发者往往是会声明出各种 SpUtils 类进行多一层封装，但也没法彻底解决以上问题。SP 的确是存在着一些设计缺陷，但对于大部分应用开发者来说其实并没有多少选择，我们只能选择用或者不用，并没有多少余地可以来解决或者避免其存在的问题，我们往往只能在遇到问题后切换到其它的持久化存储方案<br>目前有两个比较知名的持久化存储方案：Jetpack DataStore 和腾讯的 MMKV，我们当然可以选择将项目中的 SP 切换为这两个库之一，但这也不禁让人想到一个问题，如果以后这两个库也遇到了问题甚至是直接被废弃了，难道我们又需要再来全局替换一遍吗？我们应该如何设计才能使得每次的替换成本降到最低呢？<br>在我看来，开发者在为项目引入一个新的依赖库之前就应该为以后移除该库做好准备，做好接口隔离，屏蔽具体的底层逻辑（当然，也不是每个依赖库都可以做到）。笔者的项目之前也是使用 SP 来存储配置信息，后来我也将其切换到了 MMKV，下面就来介绍下笔者当时是如何设计存储结构避免硬编码的</p>
<blockquote>
<p>目前的效果</p>
</blockquote>
<p>我将应用内所有需要存储的键值对数据分为了三类：用户强关联数据、应用配置数据、不可二次变更的数据。每一类数据的存储区域各不相同，互不影响。进行数据分组的好处就在于可以根据需要来清除特定数据，例如当用户退登后我们可以只清除 UserKVHolder，而 PreferenceKVHolder 和 FinalKVHolder 则可以一直保留<br>IKVHolder 接口定义了基本的存取方法，MMKVKVHolder 通过 MMKV 实现了具体的存储逻辑</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和用户强绑定的数据，在退出登录时需要全部清除，例如 UserBean</span></span><br><span class="line"><span class="comment">//设置 encryptKey 以便加密存储</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> UserKVHolder: IKVHolder = MMKVKVHolder(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;加密key&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//和用户不强关联的数据，在退出登录时无需清除，例如夜间模式、字体大小等</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> PreferenceKVHolder: IKVHolder = MMKVKVHolder(<span class="string">&quot;preference&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于存储不会二次变更只用于历史溯源的数据，例如应用首次安装的时间、版本号、版本名等</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> FinalKVHolder: IKVHolder = MMKVKVFinalHolder(<span class="string">&quot;final&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>之后我们就可以利用 Kotlin 强大的语法特性来定义键值对了<br>例如，对于和用户强关联的数据，每个键值对都定义为 UserKV 的一个属性字段，键值对的含义和作用通过属性名来进行标识，且键值对的 key 必须和属性名保持一致，这样可以避免 key 值重复。每个 getValue 操作也都支持设置默认值。IKVHolder 内部通过 Gson 来实现序列化和反序列化，这样 UserKV 就可以直接存储 JavaBean、JavaBeanList，Map 等数据结构了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> UserKV : IKVHolder <span class="keyword">by</span> UserKVHolder &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">get</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">set</span>(value) = <span class="keyword">set</span>(<span class="string">&quot;name&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> blog: String</span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">get</span>(<span class="string">&quot;blog&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">set</span>(value) = <span class="keyword">set</span>(<span class="string">&quot;blog&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> userBean: UserBean?</span><br><span class="line">        <span class="keyword">get</span>() = getBeanOrNull(<span class="string">&quot;userBean&quot;</span>)</span><br><span class="line">        <span class="keyword">set</span>(value) = <span class="keyword">set</span>(<span class="string">&quot;userBean&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> userBeanOfDefault: UserBean</span><br><span class="line">        <span class="keyword">get</span>() = getBeanOrDefault(</span><br><span class="line">            <span class="string">&quot;userBeanOfDefault&quot;</span>,</span><br><span class="line">            UserBean(<span class="string">&quot;业志陈&quot;</span>, <span class="string">&quot;https://juejin.cn/user/923245496518439&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">set</span>(value) = <span class="keyword">set</span>(<span class="string">&quot;userBeanOfDefault&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> userBeanList: List&lt;UserBean&gt;</span><br><span class="line">        <span class="keyword">get</span>() = getBean(<span class="string">&quot;userBeanList&quot;</span>)</span><br><span class="line">        <span class="keyword">set</span>(value) = <span class="keyword">set</span>(<span class="string">&quot;userBeanList&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> map: Map&lt;<span class="built_in">Int</span>, String&gt;</span><br><span class="line">        <span class="keyword">get</span>() = getBean(<span class="string">&quot;map&quot;</span>)</span><br><span class="line">        <span class="keyword">set</span>(value) = <span class="keyword">set</span>(<span class="string">&quot;map&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，我们也可以在 setValue 方法中对 value 进行校验，避免无效值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> UserKV : IKVHolder <span class="keyword">by</span> UserKVHolder &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">get</span>(<span class="string">&quot;age&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span>(<span class="string">&quot;age&quot;</span>, value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后我们在存取值时，就相当于在直接读写 UserKV 的属性值，也支持动态指定 Key 进行赋值取值，在易用性和可读性上相比 SharedPreferences 都有很大的提升，且对于外部来说完全屏蔽了具体的存储实现逻辑</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存值</span></span><br><span class="line">UserKV.name = <span class="string">&quot;xxxxx&quot;</span></span><br><span class="line">UserKV.blog = <span class="string">&quot;https://juejin.cn/user/923245496518439&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line"><span class="keyword">val</span> name = UserKV.name</span><br><span class="line"><span class="keyword">val</span> blog = UserKV.blog</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态指定 Key 进行赋值和取值</span></span><br><span class="line">UserKV.<span class="keyword">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;xxx&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> name = UserKV.<span class="keyword">get</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何设计的</p>
</blockquote>
<p>首先，IKVHolder 定义了基本的存取方法，除了需要支持基本数据类型外，还需要支持自定义的数据类型。依靠 Kotlin 的 <strong>扩展函数</strong> 和 <strong>内联函数</strong> 这两个语法特性，我们在存取自定义类型时都无需声明泛型类型，使用上十分简洁。JsonHolder 则是通过 Gson 实现了基本的序列化和反序列化方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IKVHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> IKVHolder.<span class="title">getBean</span><span class="params">(key: <span class="type">String</span>)</span></span>: T &#123;</span><br><span class="line">            <span class="keyword">return</span> JsonHolder.toBean(<span class="keyword">get</span>(key, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> IKVHolder.<span class="title">getBeanOrNull</span><span class="params">(key: <span class="type">String</span>)</span></span>: T? &#123;</span><br><span class="line">            <span class="keyword">return</span> JsonHolder.toBeanOrNull(<span class="keyword">get</span>(key, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> IKVHolder.<span class="title">getBeanOrDefault</span><span class="params">(key: <span class="type">String</span>, defaultValue: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">            <span class="keyword">return</span> JsonHolder.toBeanOrDefault(<span class="keyword">get</span>(key, <span class="string">&quot;&quot;</span>), defaultValue)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">toJson</span><span class="params">(ob: <span class="type">Any</span>?)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> JsonHolder.toJson(ob)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据分组，用于标明不同范围内的数据缓存</span></span><br><span class="line">    <span class="keyword">val</span> keyGroup: String</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">verifyBeforePut</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">String</span>, default: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">Int</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">set</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">T</span>?)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">containsKey</span><span class="params">(key: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">vararg</span> keys: <span class="type">String</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">allKeyValue</span><span class="params">()</span></span>: Map&lt;String, Any?&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">    ···</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BaseMMKVKVHolder 实现了 IKVHolder 接口，内部引入了 MMKV 作为具体的持久化存储方案</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> selfGroup 用于指定数据分组，不同分组下的数据互不关联</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encryptKey 加密 key，如果为空则表示不进行加密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseMMKVKVHolder</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    selfGroup: String,</span><br><span class="line">    encryptKey: String</span><br><span class="line">) : IKVHolder &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">val</span> keyGroup: String = selfGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">verifyBeforePut</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> kv: MMKV? = <span class="keyword">if</span> (encryptKey.isBlank()) MMKV.mmkvWithID(</span><br><span class="line">        keyGroup,</span><br><span class="line">        MMKV.MULTI_PROCESS_MODE</span><br><span class="line">    ) <span class="keyword">else</span> MMKV.mmkvWithID(keyGroup, MMKV.MULTI_PROCESS_MODE, encryptKey)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (verifyBeforePut(key, value)) &#123;</span><br><span class="line">            kv?.putInt(key, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">set</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">T</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (verifyBeforePut(key, value)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                removeKey(key)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">set</span>(key, toJson(value))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">String</span>, default: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> kv?.getInt(key, default) ?: default</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsKey</span><span class="params">(key: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> kv?.containsKey(key) ?: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">vararg</span> keys: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        kv?.removeValuesForKeys(keys)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">allKeyValue</span><span class="params">()</span></span>: Map&lt;String, Any?&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> map = mutableMapOf&lt;String, Any?&gt;()</span><br><span class="line">        kv?.allKeys()?.forEach &#123;</span><br><span class="line">            map[it] = getObjectValue(kv, it)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        kv?.clearAll()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	···</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>BaseMMKVKVHolder 有两个子类，其区别只在于 MMKVKVFinalHolder 保存键值对后无法再次更改值，用于存储不会二次变更只用于历史溯源的数据，例如应用首次安装时的时间戳、版本号、版本名等</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> selfGroup 用于指定数据分组，不同分组下的数据互不关联</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encryptKey 加密 key，如果为空则表示不进行加密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MMKVKVHolder</span> <span class="keyword">constructor</span></span>(selfGroup: String, encryptKey: String = <span class="string">&quot;&quot;</span>) :</span><br><span class="line">    BaseMMKVKVHolder(selfGroup, encryptKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储后值无法二次变更</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> selfGroup 用于指定数据分组，不同分组下的数据互不关联</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encryptKey 加密 key，如果为空则表示不进行加密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MMKVKVFinalHolder</span> <span class="keyword">constructor</span></span>(selfGroup: String, encryptKey: String = <span class="string">&quot;&quot;</span>) :</span><br><span class="line">    BaseMMKVKVHolder(selfGroup, encryptKey) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">verifyBeforePut</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !containsKey(key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过接口隔离，UserKV 就完全不会接触到具体的存储实现机制了，对于开发者来说也只是在读写 UserKV 的一个属性字段而已，当后续我们需要替换存储方案时，也只需要去改动 MMKVKVHolder 的内部实现即可，上层应用完全不需要进行任何改动</p>
<blockquote>
<p>KVHolder</p>
</blockquote>
<p>KVHolder 的实现思路还是十分简单的，再加上 Kotlin 本身强大的语法特性就进一步提高了易用性和可读性 😇😇 我也将其发布为开源库，感兴趣的读者可以直接远程导入依赖</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url <span class="string">&quot;https://jitpack.io&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;com.github.leavesC:KVHolder:latest_version&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GitHub 点击这里：<a href="https://link.juejin.cn/?target=https://github.com/leavesC/KVHolder" title="https://github.com/leavesC/KVHolder">KVHolder</a></p>

            <!-- / the end of articles -->
        </div>
        <!-- / left section -->
        
        
            <hr/>
            <div id="disqus_thread" style=" margin-top: 15px; margin-bottom: 25px; "></div>
            <script>
                /**
                *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
                /*
                var disqus_config = function () {
                this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
                this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                };
                */
                (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');
                s.src = 'https://morgan-hexo-theme.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        

        <!-- Next Post and Prev Post -->
        
        <hr/>
        <div class="next-prev-post-section">
            
                <a href="#"></a>
            
            
                <a href="/2021/10/30/Android-%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BC%93%E5%AD%98-SharedPreference-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="styled-border">
                    
                    Android 轻量级缓存 SharedPreference 源码解析
                    →
                </a>
            
        </div>
        
</div>
<script type="text/javascript">
    let img = document.getElementsByTagName("img");
    for(let i = 0; i < img.length; i++){
        img[i].className += " ts fluid image";
    }
</script>
<!-- / main section -->

<!-- copyright -->
<div class="ts attached secondary segment">
    <div class="ts narrow container">
        <br>
        <div class="ts large center aligned header">
            Powered by Hexo, Theme designs by @hpcslag.
            <div class="smaller sub header">
                Style-Framework Tocas-UI designs by @yamioldmel 
            </div>
        </div>
        <br>
    </div>
</div>
<!-- / copyright -->
<script type="text/javascript">
    
    const slogans = ["Hallo, dit is mijn blog","嗨，這是我的博客!","안녕하세요, 제 블로그입니다.","Hi, This is my blog!","こんにちは、私のブログへようこそ!","مرحبا، مرحبا بك في مدونتي"];
</script>

<script src="/js/script.js"></script>

</body>
</html>