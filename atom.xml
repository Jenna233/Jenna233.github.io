<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jenna233</title>
  
  
  <link href="https://jenna233.github.io/atom.xml" rel="self"/>
  
  <link href="https://jenna233.github.io/"/>
  <updated>2023-04-07T12:31:11.071Z</updated>
  <id>https://jenna233.github.io/</id>
  
  <author>
    <name>Jenna233</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入浅出 React -- 生命周期</title>
    <link href="https://jenna233.github.io/2023/04/07/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://jenna233.github.io/2023/04/07/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2023-04-07T12:30:34.000Z</published>
    <updated>2023-04-07T12:31:11.071Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://zhuanlan.zhihu.com/p/333822652">深入浅出 React – 生命周期</a><br>这里通过对 React15 和 React16 两个版本的生命周期进行对比总结，来建立系统而完善的生命周期知识体系.</p><h1 id="生命周期背后的设计思想"><a href="#生命周期背后的设计思想" class="headerlink" title="生命周期背后的设计思想"></a>生命周期背后的设计思想</h1><p>React 设计的两个核心概念：“组件” 和 “虚拟 DOM”</p><h3 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h3><p>当组件初始化时，通过调用生命周期中的 render 方法，生成虚拟 DOM；再通过调用 <code>ReactDOM.render</code> 方法，将虚拟 DOM 转换为真实 DOM。</p><p>当组件更新时，会再次调用生命周期中的 render 方法，生成新的虚拟 DOM；然后通过 diff 算法定位两次虚拟 DOM 的差异，对发生变化的真实 DOM 做定向更新。</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>在一个 React 项目中，几乎所有的内容都可以抽离为各种各样的组件，每个组件既是 “封闭” 的，也是 “开放” 的。</p><p>所谓 “封闭”，是针对<strong>组件数据改变到组件实际发生更新</strong>的过程。在组件自身的渲染过程中，每个组件都只会处理它自身内部的渲染逻辑。在没有数据交流的情况下，组件之间互不干扰。</p><p>所谓 “开放”，是针对组件间<strong>通信</strong>的。React 允许开发者基于<strong>单向数据流</strong>的原则来完成组件之间的通信。组件之间的通信可能使通信组件的渲染结果产生影响。所以说组件之间是相互开放的，可以相互影响的。</p><p>React 组件的 “开放” 与 “封闭” 特性，使得 React 的组件具备高可重用性和可维护性。</p><h3 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h3><p>生命周期的 render 方法将<strong>虚拟 DOM</strong>和<strong>组件</strong>两者结合到了一起。</p><p>虚拟 DOM 的生成依赖 render，而组件的渲染过程也离不开 render。所以可以将 render 方法比作组件的<strong>“灵魂”</strong>。</p><p>render 之外的生命周期方法可以理解为组件的<strong>“躯干”</strong>。</p><p>我们可以省略 render 之外的任何生命周期方法内容的编写，但是 render 函数不能省略；但是 render 之外的生命周期方法的编写，通常是为 render 服务；“灵魂” 和 “躯干” 共同构成了 React 组件完整的生命时间轴。</p><h1 id="React15-生命周期"><a href="#React15-生命周期" class="headerlink" title="React15 生命周期"></a>React15 生命周期</h1><p>在 React15 中，需要关注以下生命周期方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">constructor()</span><br><span class="line">componentWillReceiveProps()</span><br><span class="line">shouldComponentUpdate()</span><br><span class="line">componentWillMount()</span><br><span class="line">componentWillUpdate()</span><br><span class="line">componentDidUpdate()</span><br><span class="line">componentDidMount()</span><br><span class="line">render()</span><br><span class="line">componentWillUnmount()</span><br></pre></td></tr></table></figure><p>这些生命周期方法的关系：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-d8135157f8c54e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lifecycle"></p><p>下面的示例可以验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代码源自 “深入浅出搞定 React -- 修言”</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义子组件</span><br><span class="line">class LifeCycle extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    console.log(&quot;进入constructor&quot;)</span><br><span class="line"></span><br><span class="line">    super(props)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; state 可以在 constructor 里初始化</span><br><span class="line">    this.state &#x3D; &#123; text: &quot;子组件的文本&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 初始化渲染时调用</span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    console.log(&quot;componentWillMount方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化渲染时调用</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    console.log(&quot;componentDidMount方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 父组件修改组件的props时会调用</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    console.log(&quot;componentWillReceiveProps方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 组件更新时调用</span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    console.log(&quot;shouldComponentUpdate方法执行&quot;)</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件更新时调用</span><br><span class="line">  componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line">    console.log(&quot;componentWillUpdate方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 组件更新后调用</span><br><span class="line">  componentDidUpdate(nextProps, nextState) &#123;</span><br><span class="line">    console.log(&quot;componentDidUpdate方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 组件卸载时调用</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    console.log(&quot;子组件的componentWillUnmount方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 点击按钮，修改子组件文本内容的方法</span><br><span class="line">  changeText &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      text: &quot;修改后的子组件文本&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&quot;render方法执行&quot;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className&#x3D;&quot;container&quot;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.changeText&#125; className&#x3D;&quot;changeText&quot;&gt;</span><br><span class="line">          修改子组件文本内容</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;p className&#x3D;&quot;textContent&quot;&gt;&#123;this.state.text&#125;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p className&#x3D;&quot;fatherContent&quot;&gt;&#123;this.props.text&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义 LifeCycle 组件的父组件</span><br><span class="line">class LifeCycleContainer extends React.Component &#123;</span><br><span class="line">  &#x2F;&#x2F; state 也可以像这样用属性声明的形式初始化</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    text: &quot;父组件的文本&quot;,</span><br><span class="line">    hideChild: false</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 点击按钮，修改父组件文本的方法</span><br><span class="line">  changeText &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      text: &quot;修改后的父组件文本&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 点击按钮，隐藏（卸载）LifeCycle 组件的方法</span><br><span class="line">  hideChild &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      hideChild: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className&#x3D;&quot;fatherContainer&quot;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.changeText&#125; className&#x3D;&quot;changeText&quot;&gt;</span><br><span class="line">          修改父组件文本内容</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.hideChild&#125; className&#x3D;&quot;hideChild&quot;&gt;</span><br><span class="line">          隐藏子组件</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        &#123;this.state.hideChild ? null : &lt;LifeCycle text&#x3D;&#123;this.state.text&#125; &#x2F;&gt;&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;LifeCycleContainer &#x2F;&gt;, document.getElementById(&quot;root&quot;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><p>组件挂载在一个 React 组件的生命周期中只会发生一次，在这个过程中，组件被初始化，最后被渲染到真实 DOM；</p><p>挂载阶段，一个 React 组件所经历的生命周期：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b59d20d9452ce35c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="load"></p><ul><li><code>constructor() </code>：对 this.state 初始化。</li><li><code>componentWillMount()</code> ：在 <code>render</code> 方法前被触发。</li><li><code> render()</code> ：生成需要渲染的内容并返回，不会操作真实 DOM。真实 DOM 的渲染由 ReactDOM.render 完成。</li><li><code>componentDidMount()</code> ：在渲染结束后被触发，此时可以访问真实 DOM 。在这个生命周期中也可以做类似于异步请求、数据初始化的操作。</li></ul><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><p>更新阶段，一个 React 组件所经历的生命周期：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-abeb1ef4f13b2211.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="update"></p><h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h4><p>从图中可以看出，由父组件触发的更新和由组件自身触发的更新对比，多出了一个生命周期方法：<code>componentWillReceiveProps(nextProps)</code>。</p><p><code>nextProps</code> 表示新 <code>props</code> 内容，而现有的 <code>props</code> 可以通过 <code>this.props</code> 获取，从而对比 <code>props</code> 的变化。</p><blockquote><p>如果父组件导致组件重新渲染，即使 props 没有更改，也会调用此方法（componentWillReceiveProps）。如果只想处理更改，请确保进行当前值与变更值的比较。</p></blockquote><p><strong>componentWillReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的</strong></p><h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState)</span><br></pre></td></tr></table></figure><p>由于 <code>render</code> 方法会进行虚拟 DOM 的构建和对比，比较耗时。为了避免不必要的 <code>render</code> 调用，React 提供了 <code>shouldComponentUpdate</code> 生命周期方法。</p><p>根据 <code>shouldComponentUpdate()</code> 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。</p><p>此方法仅作为**<a href="https://link.zhihu.com/?target=https://zh-hans.reactjs.org/docs/optimizing-performance.html">性能优化的方式</a><strong>而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 **<a href="https://link.zhihu.com/?target=https://zh-hans.reactjs.org/docs/react-api.html%23reactpurecomponent">PureComponent</a></strong> 组件，而不是手动编写 <code>shouldComponentUpdate()</code>。<code>PureComponent</code> 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。</p><h4 id="componentWillUpdate-和-componentDidUpdate"><a href="#componentWillUpdate-和-componentDidUpdate" class="headerlink" title="componentWillUpdate 和 componentDidUpdate"></a>componentWillUpdate 和 componentDidUpdate</h4><p> <code>componentWillUpdate</code> 在 <code>render</code> 前触发，和 <code>componentWillMount </code>类似，可以在里面做一些与真实 DOM 不相关的操作。<br><code>componentDidUpdate</code> 在组件更新完成后触发，和 <code>componentDidMount</code> 类似，可以在里面处理 DOM 操作；作为子组件更新完毕通知父组件的标志。</p><h3 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h3><p>组件销毁，只有 <code>componentWillUnmount()</code> 生命周期，可以在里面做一些释放内存，清理定时器等操作。</p><h1 id="React16-生命周期"><a href="#React16-生命周期" class="headerlink" title="React16 生命周期"></a>React16 生命周期</h1><p><strong><a href="https://link.zhihu.com/?target=https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">React 16.3</a></strong> 生命周期：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-57657b484fefd006.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="React16"></p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代码源自 “深入浅出搞定 React -- 修言”</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义子组件</span><br><span class="line">class LifeCycle extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    console.log(&quot;进入constructor&quot;)</span><br><span class="line"></span><br><span class="line">    super(props)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; state 可以在 constructor 里初始化</span><br><span class="line">    this.state &#x3D; &#123; text: &quot;子组件的文本&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化&#x2F;更新时调用</span><br><span class="line">  static getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    console.log(&quot;getDerivedStateFromProps方法执行&quot;)</span><br><span class="line">    return &#123;</span><br><span class="line">      fatherText: props.text</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 初始化渲染时调用</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    console.log(&quot;componentDidMount方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 组件更新时调用</span><br><span class="line">  shouldComponentUpdate(prevProps, nextState) &#123;</span><br><span class="line">    console.log(&quot;shouldComponentUpdate方法执行&quot;)</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件更新时调用</span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    console.log(&quot;getSnapshotBeforeUpdate方法执行&quot;)</span><br><span class="line">    return &quot;haha&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 组件更新后调用</span><br><span class="line">  componentDidUpdate(nextProps, nextState, valueFromSnapshot) &#123;</span><br><span class="line">    console.log(&quot;componentDidUpdate方法执行&quot;)</span><br><span class="line">    console.log(&quot;从 getSnapshotBeforeUpdate 获取到的值是&quot;, valueFromSnapshot)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 组件卸载时调用</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    console.log(&quot;子组件的componentWillUnmount方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 点击按钮，修改子组件文本内容的方法</span><br><span class="line">  changeText &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      text: &quot;修改后的子组件文本&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&quot;render方法执行&quot;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className&#x3D;&quot;container&quot;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.changeText&#125; className&#x3D;&quot;changeText&quot;&gt;</span><br><span class="line">          修改子组件文本内容</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;p className&#x3D;&quot;textContent&quot;&gt;&#123;this.state.text&#125;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p className&#x3D;&quot;fatherContent&quot;&gt;&#123;this.props.text&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义 LifeCycle 组件的父组件</span><br><span class="line">class LifeCycleContainer extends React.Component &#123;</span><br><span class="line">  &#x2F;&#x2F; state 也可以像这样用属性声明的形式初始化</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    text: &quot;父组件的文本&quot;,</span><br><span class="line">    hideChild: false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 点击按钮，修改父组件文本的方法</span><br><span class="line">  changeText &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      text: &quot;修改后的父组件文本&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 点击按钮，隐藏（卸载）LifeCycle 组件的方法</span><br><span class="line">  hideChild &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      hideChild: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className&#x3D;&quot;fatherContainer&quot;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.changeText&#125; className&#x3D;&quot;changeText&quot;&gt;</span><br><span class="line">          修改父组件文本内容</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.hideChild&#125; className&#x3D;&quot;hideChild&quot;&gt;</span><br><span class="line">          隐藏子组件</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        &#123;this.state.hideChild ? null : &lt;LifeCycle text&#x3D;&#123;this.state.text&#125; &#x2F;&gt;&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;LifeCycleContainer &#x2F;&gt;, document.getElementById(&quot;root&quot;))</span><br></pre></td></tr></table></figure><h3 id="挂载阶段-1"><a href="#挂载阶段-1" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><p><img src="https://upload-images.jianshu.io/upload_images/15531792-6c543cf535ed8878.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LoadCompare"></p><h4 id="componentWillMount-vs-getDerivedStateFromProps"><a href="#componentWillMount-vs-getDerivedStateFromProps" class="headerlink" title="componentWillMount vs getDerivedStateFromProps"></a>componentWillMount vs getDerivedStateFromProps</h4><p>对比于 React 15 废弃了 <code>componentWillMount</code> ，新增了 <code>getDerivedStateFromProps</code>。</p><p><code>componentWillMount</code> 的存在不仅“鸡肋”而且危险，因此它不值得被“替代”，而应该直接废弃。</p><p><code>getDerivedStateFromProps</code> 的设计初衷是替换 <code>componentWillReceiveProps </code>，它有且仅有一个作用：让组件在 <code>props</code> 变化时派生/更新 <code>state</code>。</p><p><code>getDerivedStateFromProps</code> 的方法签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static getDerivedStateFromProps(props, state)</span><br></pre></td></tr></table></figure><ul><li><code>getDerivedStateFromProps</code> 是一个静态方法；不依赖组件实例；在这个方法里不能访问 <code>this</code>。</li><li>两个参数：<code>props</code> 和 <code>state</code>，分别表示组件接收的来自父组件的 <code>props</code> 和自身的 <code>state</code>。</li><li>需要一个对象作为返回值；如果没有指定返回值，React 会发出警告；**React 需要用这个返回值来更新/派生组件的 <code>stat</code>**；如果不需要，最好直接省略这个方法，否则需要返回 <code>null</code>。</li><li><strong>对 <code>state</code> 的更新不是“覆盖”，而是针对属性的定向更新。</strong></li></ul><h3 id="更新阶段-1"><a href="#更新阶段-1" class="headerlink" title="更新阶段"></a>更新阶段</h3><p><img src="https://upload-images.jianshu.io/upload_images/15531792-42090d46eee62fec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UpdateCompare"></p><p>React 16.4 的挂载和卸载和 React 16.3 保持一致，更新阶段不同：</p><p><strong><a href="https://link.zhihu.com/?target=https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">React 16.4</a></strong> 生命周期：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-6cc2b797e68472af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="React16.4"></p><ul><li>在 React 16.4 中，任何因素触发的组件更新都会触发 <code>getDerivedStateFromProps</code>。</li><li>在 React 16.3 中，只有父组件的更新才会触发 <code>getDerivedStateFromProps</code>。</li></ul><h4 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h4><ul><li><code>getDerivedStateFromProps</code> 是为了试图替换 <code>componentWillReceiveProp</code> 而出现的。</li><li><code>getDerivedStateFromProps</code> 不能完全等同于 <code>componentWillReceiveProps</code>。<ul><li>代替实现基于 props 派生 state。</li><li>原则上，它能且只能做这一件事。</li></ul></li></ul><p><strong>为什么要用 <code>getDerivedStateFromProps </code>替换 <code>componentWillReceiveProps</code></strong></p><p>做 <strong>“合理的减法”</strong><br><code>getDerivedStateFromProps</code> 直接被定义为 <code>static </code>方法，使得在其方法内部无法拿到组件实例的 <code>this</code>，也就不能在里面执行类似不合理的 <code>this.setState</code> （可能会导致死循环）这类会产生副作用的操作。</p><p>确保生命周期函数的行为可控可预测，从源头上帮助开发者避免不合理的编码，同时也是为新的Fiber 架构铺路。</p><h4 id="componentWillUpdate-vs-getSnapshotBeforeUpdate"><a href="#componentWillUpdate-vs-getSnapshotBeforeUpdate" class="headerlink" title="componentWillUpdate vs getSnapshotBeforeUpdate"></a>componentWillUpdate vs getSnapshotBeforeUpdate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行时机在 <code>render</code> 方法之后，真实 DOM 更新之前</li><li>可以获得 DOM 更新前后的 <code>state</code> 和 <code>props</code> 信息</li><li>返回值将作为<code> componentDidUpdate</code> 的第三个参数</li></ul><p>在实际编程中很少用到，但也有特殊场景需要。</p><p>例如：实现一个内容会发生变化的滚动列表，要求根据滚动列表的内容是否发生变化，来决定是否要记录滚动条的当前位置。</p><p>这个例子中要求我们对比更新前后的数据是否发生变化，还需要获取真实的 DOM 位置信息。</p><p>与<code> componentDidUpdate</code> 配合编程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 组件更新时调用</span><br><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">  console.log(&quot;getSnapshotBeforeUpdate方法执行&quot;)</span><br><span class="line">  return &quot;haha&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件更新后调用</span><br><span class="line">componentDidUpdate(prevProps, prevState, valueFromSnapshot) &#123;</span><br><span class="line">  console.log(&quot;componentDidUpdate方法执行&quot;)</span><br><span class="line">  console.log(&quot;从 getSnapshotBeforeUpdate 获取到的值是&quot;, valueFromSnapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getSnapshotBeforeUpdate</code> 的设计初衷是为了 “与 <code>componentDidUpdate</code> 一起，覆盖过时的<code> componentWillUpdate</code>”。</p><p>**为什么废除 <code>componentWillUpdate</code>**，是因为它不适合 Fiber 架构。</p><h3 id="卸载阶段-1"><a href="#卸载阶段-1" class="headerlink" title="卸载阶段"></a>卸载阶段</h3><p>与 React 15 完全一致</p><h1 id="React-16-为何做出两次改变"><a href="#React-16-为何做出两次改变" class="headerlink" title="React 16 为何做出两次改变"></a>React 16 为何做出两次改变</h1><p><strong>Fiber 架构简析</strong></p><blockquote><p>使 Virtual DOM 可以进行增量式渲染</p></blockquote><p><strong>Fiber 会使原本同步的渲染过程变成异步的</strong></p><p>在 React 16 之前，每次组件更新，React 都会构建虚拟 DOM，再与旧虚拟 DOM 对比 diff，最后对真实 DOM 定向更新。</p><p><strong>同步调用的调用栈非常深</strong>，需要等到递归调用都返回后，整个渲染才算结束。</p><p>这个“漫长”的同步渲染过程不可被打断，存在巨大风险；同步渲染一旦开始，会占据主线程，直到彻底完成；在这个过程中，浏览器无法处理其他任务包括用户交互，甚至可能出现卡顿至卡死的风险。</p><p>React 16 引入的 Fiber 架构，可以解决这个风险：<strong>Fiber 会将一个大的更新任务拆解为多个小任务</strong>；每次执行完成一个小任务，渲染线程都会交还主线程给浏览器，然后处理优先级更高的工作，进而避免同步渲染导致的卡顿。</p><blockquote><p>React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。</p></blockquote><h3 id="从-Fiber-架构角度看生命周期"><a href="#从-Fiber-架构角度看生命周期" class="headerlink" title="从 Fiber 架构角度看生命周期"></a>从 Fiber 架构角度看生命周期</h3><p>Fiber 架构的重要特征就是渲染过程<strong>可以被中断</strong>。根据这个特征，React 16 的生命周期被划分为 Render 和 Commit 两个阶段，而 Commit 阶段又被细分为 Pre-commit 和 Commit 阶段。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-e4166579fdeb8f55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fiber"></p><ul><li>Render 阶段：纯净且不包含副作用。可能会被 React 暂停，中止或重新启动。</li><li>Pre-commit 阶段：可以读取 DOM。</li><li>Commit 阶段：可以使用 DOM，运行副作用，安排更新。</li></ul><p>也就是说在 Render 阶段允许被中断，而 Commit 阶段不能。原因很简单，Render 阶段的操作对于用户不可感知，所以中断、重启对于用户而言是不可见的。而 Commit 阶段的操作是对真实 DOM 的渲染，不能随意中断、重渲染。</p><h3 id="React-16-“废旧立新”背后的思考"><a href="#React-16-“废旧立新”背后的思考" class="headerlink" title="React 16 “废旧立新”背后的思考"></a>React 16 “废旧立新”背后的思考</h3><p>Fiber 架构下，<strong>Render 阶段允许被暂停、终止和重启</strong>。当一个任务执行一段后被中断，下一次抢回渲染线程时，这个任务会“重复执行一遍整个任务”而不是接着上一次执行的地方。这导致了 Render 阶段的生命周期方法有可能重复执行。</p><p>React 16 废弃的生命周期方法：</p><ul><li>componentWillMount</li><li>componentWillUpdate</li><li>componentWillReceiveProps</li></ul><p>这些方法都处于 Render 阶段，而且这些方法常年被滥用，在重复执行的过程中存在很大的风险。</p><p>我们的编码中的一些不好的习惯，在 “componentWill” 开头的生命周期里做一些事情：</p><ul><li>setState()</li><li>fetch 异步请求</li><li>操作真实 DOM</li><li>…</li></ul><p>这些操作的问题：</p><ol><li>可以转移到其他生命周期（componentDid…）里去做</li><li>Fiber 架构下，可能导致非常严重的 Bug</li><li>在 React 15 中也有出现过问题（在 <code>componentWillReceiveProps </code>和 <code>componentWillUpdate </code>里滥用 setState 导致重渲染死循环）</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>React 16 改造生命周期的主要原因是为了配合 Fiber 架构带来的异步渲染机制。</li><li>针对生命周期中长期被滥用的部分推出了具有强制性的最佳实践。</li><li>确保了 Fiber 架构下的数据和视图的安全，以及确保了生命周期方法的行为更加可控、可预测。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://zhuanlan.zhihu.com/p/333822652&quot;&gt;深入浅出 React – 生命周期&lt;/a&gt;&lt;br&gt;这里通过对 React15 和 React16 两个版本的生命周期进行对比总结，来建立系统而完善的生命周期知识体系.&lt;/</summary>
      
    
    
    
    
    <category term="React &amp; JS" scheme="https://jenna233.github.io/tags/React-JS/"/>
    
  </entry>
  
  <entry>
    <title>Android架构之MVC、MVP、MVVM详解</title>
    <link href="https://jenna233.github.io/2023/04/07/Android%E6%9E%B6%E6%9E%84%E4%B9%8BMVC%E3%80%81MVP%E3%80%81MVVM%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jenna233.github.io/2023/04/07/Android%E6%9E%B6%E6%9E%84%E4%B9%8BMVC%E3%80%81MVP%E3%80%81MVVM%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-04-07T12:28:40.000Z</published>
    <updated>2023-04-07T12:30:01.297Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://qwerhuan.gitee.io/2020/08/16/android/android-jia-gou-zhi-mvc-mvp-mvvm-xiang-jie/">Android架构之MVC、MVP、MVVM详解</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>你好！<br>我是一只修仙的猿，欢迎阅读我的文章，希望能让你有所收获。</p><p>MVC、MVP、MVVM均为架构模式，应用在Android上，称为Android架构模式。可能你会觉得我在讲废话，清楚他的定义非常重要。这样会有几个问题：</p><blockquote><p>什么是架构模式？什么是android架构模式？<br>MVC、MVP、MVVM的本质区别是什么？<br>他们在android上的应用是怎么样的？<br>我们该如何选择？</p></blockquote><p>弄清楚这几个问题，可以帮助我们更好地理解这三种架构模式，继而更好地运用它们。</p><p>这篇文章主要的内容是带你了解什么是架构以及android架构，以及详解三种架构模式的本质。</p><p>笔者才疏学浅，有不同观点欢迎评论区或私信讨论。如需转载私信告知即可。<br>另外欢迎阅读笔者的个人博客一只修仙的猿的个人博客，更精美的UI，拥有更好的阅读体验。</p><h3 id="本文目录"><a href="#本文目录" class="headerlink" title="本文目录"></a>本文目录</h3><p><img src="https://upload-images.jianshu.io/upload_images/15531792-0275fc695899a7fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="架构以及Android架构"><a href="#架构以及Android架构" class="headerlink" title="架构以及Android架构"></a>架构以及Android架构</h1><p>架构，即为骨架，是指导开发的关键。例如一个人，身体的骨骼即为身体的架构，有了基本骨架之后，才可以决定在头颅里开发大脑，在肋骨中开发肺部等。软件开发也是如此，也需要一个“骨架”，即架构。他可以指引我们什么地方该做什么事情，让整个软件的开发思路非常清晰。</p><p>Android架构，即为开发android时使用的架构。Android的开发一般分为三部分：UI逻辑，业务逻辑和数据操作逻辑。这里可以举个例子</p><blockquote><p>获取天气详情并展示。首先要写布局xml，接着在Activity中获取到view实例。此为UI逻辑。然后需要通过网络请求获得数据，此为数据操作逻辑。接着获取到数据后，需要将数据进行缓存，解析，再set到view上进行展示，此为业务逻辑。</p></blockquote><p>Android架构，就是为了更好地协调这三者的关系。达到：</p><blockquote><p>1.各模块高内聚低耦合的状态，方便进行团队分工合作开发。<br>2.代码思路清晰，提高代码的可维护性与可测试性。<br>3.减少样板代码，提高开发效率，减少开发错误。</p></blockquote><p>为了达到这些目的，所以才有各种架构不断涌现，却没有一个统一的开发框架。不同于移动端，web端开发有成熟的SpringMVC框架，可以快速规范地开发一个项目。而移动端缺乏框架的支撑，各路大神各显神通，不断涌现了不同的架构模式来适应不同的开发情景，如MVC，MVP等等。但由于没有历史的沉淀，各种架构模式的弊端也渐渐浮出水面。在这种情境下，谷歌退出了架构组件，用成熟的框架来减少样板代码，提高开发效率，有如SpringMVC的风范，这就是MVVM的框架实现。下面我们就详细展开讲这些架构模式。</p><h1 id="详解三种架构模式"><a href="#详解三种架构模式" class="headerlink" title="详解三种架构模式"></a>详解三种架构模式</h1><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>Android上的MVC架构我认为是来源于web开发的SpringMVC，MVC全名为Model-View-Controller，图解如下<br><img src="https://upload-images.jianshu.io/upload_images/15531792-81893c39a9b553d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>View：负责与用户交汇，显示界面。</li><li>Controller：负责接收来自view的请求，处理业务逻辑。</li><li>Model：负责数据逻辑，网络请求数据以及本地数据库操作数据等。</li></ul><p>在MVC架构中，Controller是业务的主要承载者，几乎所有的业务逻辑都在Controller中进行编写。而View主要负责UI逻辑，而Model是数据逻辑，彼此分工。</p><blockquote><p>MVC的本质就是按照UI逻辑、业务逻辑、数据逻辑不同的职责分三大模块，彼此分工。</p></blockquote><p>在Android中，view一般使用xml进行编写，但xml的能力不全面，需要Activity进行一些UI逻辑的编写，因而MVC中的V即为xml+Activity。Model数据层，在Android中负责网络请求和数据库操作，并向外暴露接口。Controller是争议比较多的写法：一种是直接把Activity当成Controller；一种是独立出Controller类，进行逻辑分离。比较符合MVC思想的笔者认为是后者。因为前者直接在Activity中进行书写业务逻辑就会和UI逻辑混合在一起了，达不到模块分工的效果。MVC架构的处理流程一般是：</p><ul><li>view接收用户的点击</li><li>view请求controller进行处理或直接去model获取数据</li><li>controller请求model获取数据，进行其他的业务操作</li><li>这一步可以有多种做法：</li></ul><p>1.利用callBack从controller进行回调<br>2.把view实例给controller，让controller进行处理<br>3.通知view去model获取数据</p><blockquote><p>举个栗子。<br>现在有一个获取天气详情的功能。我需要在xml中写ui，在Activity中给控件设置监听事件和写方法给控件set数据，如textView.setText()。当点击界面按钮时，会调用首先会调用onClickListener，然后再调用Controller的方法让model获取数据，获取完成后通知view，view去Model获取数据更新自己。或者Activity直接给Controller一个callBack，controller就可以在业务处理完成后进行回调；或者直接把view给controller让controller直接去更新ui。</p></blockquote><p>MVC可能是我们第一次开发安卓的时候就会使用的架构模式。直接在Activity中书写业务逻辑，只抽离出Model层。（笔者第一次开发时连Model层都没抽离，全部在Activity中写，一千多行的MainActivity）这样看起来很美好，但是有严重的问题。MVC的核心就是按照职责分离代码。但几乎所有的业务逻辑代码都在controller中，当项目越来越大时会导致controller极度臃肿，难以维护。view与model直接依赖，模块之间依赖不单一，view因直接通过model获取数据，不可避免的会耦合一些业务代码。</p><blockquote><ul><li>几乎所有的业务逻辑代码都在controller中进行，会导致非常臃肿，降低项目的可测试性与可维护性。</li><li>view直接持有controller和model实例，不同职责的代码进行耦合，导致代码耦合性高，模块分工不清晰。</li></ul></blockquote><p>但MVC也有他的好处：简单。他不需要写很多的代码来让代码解耦，这在小型项目非常有用。小型项目总体的代码就不多，所以这样可以提高开发效率。但是最好不要尝试维护他，不是怕你崩溃，而是怕你砸了电脑对电脑不好。<br>因为可以发现MVC的改进方向就是：</p><blockquote><ul><li>对模块进行更加彻底的分离，不要让view和model直接联系。</li><li>对controller进行减压。</li></ul></blockquote><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>相比MVC，MVP的更加的完善。MVP全名是Model-View-Presenter。图解如下：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-307983c80c12283f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>View：UI模块，负责界面显示和与用户交汇。</li><li>Presenter：负责业务逻辑，起着连接View和Model桥梁的作用。</li><li>Model：专注于数据逻辑。</li></ul><p>MVP和MVC的区别很明显就在这个Presenter中。为了解决MVC中代码的耦合严重性，把业务逻辑都抽离到了Presenter中。这样View和Model完全被隔离，实现了单向依赖，大大减少了耦合度。view和prensenter之间通过接口来通信，只要定义好接口，那么团队可以合作同时开发不同的模块，同时不同的模块也可以进行独立测试。也因各模块独立了，所以要只要符合接口规范，即可做到动态更换模块而不需要修改其他的模块。</p><p>在Android中，需要让Activity提供控件的更新接口，prensenter提供业务逻辑接口，Activity持有presenter的实例，prensenter持有Activity的弱引用（不用直接引用是为了避免内存泄露），Activity直接调用prensenter的方法更新界面，prensenter去model获取数据之后，通过view的接口更新view。如下图：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-183973153fce5dc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>不同的view可以通过实现相同的接口来共享prensenter。presenter也可以通过实现接口来实现动态更换逻辑。Model是完全独立开发的，向外暴露的方法参数中含有callBack参数，可以直接调用callBack进行回调。<br>总结一下：</p><blockquote><ul><li>MVP通过模块职责分工，抽离业务逻辑，降低代码的耦合性</li><li>实现模块间的单向依赖，代码思路清晰，提高可维护性</li><li>模块间通过接口进行通信，降低了模块间的耦合度，可以实现不同模块独立开发或动态更换</li></ul></blockquote><p>MVP的最大特点就是接口通信，接口的作用是为了实现模块间的独立开发，模块代码复用以及模块的动态更换。但是我们会发现后两个特性，在Android开发中使用的机会非常少。presenter的作用就是接受view的请求，然后再model中获取数据后调用view的方法进行展示，但是每个界面都是不同的，很少可以共用模块的情景出现。这就导致了每个Activity/Fragment都必须写一个IView接口，然后还需要再写个IPresenter接口，从而产生了非常多的接口，需要编写大量的代码来进行解耦。如果在小型的项目，这样反而会大大降低了开发效率。<br>其次，prensenter并没有真正解耦，他还需要调用view的接口进行UI操作，解耦没有彻底。MVP也没有解决MVC中Controller代码臃肿的问题，甚至还把部分的UI操作带到了Presenter中。</p><p>因此，由于MVP有：</p><blockquote><ul><li>过度设计导致接口过多，编写大量的代码来实现模块解耦，降低了开发效率</li><li>并没有彻底进行解耦，prensenter需要同时处理UI逻辑和业务逻辑，presenter臃肿</li></ul></blockquote><p>这样的缺点，android开发者都在寻找一个更加完善的架构模式。当然读者知道下面我要讲MVVM了，但我想要说的是其实还有如AAC等结构模式的存在，但因他们的局限性以及上手难度，并没有被广泛使用。而到了MVVM，谷歌通过一系列的架构组件来让开发者可以简单地实现MVVM架构。</p><p>MVVM<br>终于到了MVVM，可能很多人都感觉“卧槽这么牛逼的架构我肯定学不会”然后被劝退了继续使用MVC或者MVP。在我看来，MVVM和上面两种架构模式一样都是一种架构思想，只是谷歌推出了jetpack架构组件来让我们更好的使用这种架构模式。</p><h3 id="MVVM，全名为Model-View-ViewModel。图解："><a href="#MVVM，全名为Model-View-ViewModel。图解：" class="headerlink" title="MVVM，全名为Model-View-ViewModel。图解："></a>MVVM，全名为Model-View-ViewModel。图解：</h3><p><img src="https://upload-images.jianshu.io/upload_images/15531792-5dcad5d347b8ea58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>View：和前面的MVP、MVC中的View一样，负责UI界面的显示以及与用户的交汇。</li><li>Model：同样是负责网络数据获取或者本地数据库数据获取。</li><li>ViewModel：负责存储view的数据映像以及业务逻辑。</li></ul><p>MVVM的view和model和前面的两种架构模式是差不多的，重点在ViewModel。viewModel通过将数据和view进行绑定，修改数据会直接反映到view上，通过数据驱动型思想，彻底把MVP中的Presenter的UI操作逻辑给去掉了。而viewModel是绑定于单独的view的，也就不需要进行编写接口了。但viewModel中依旧有很多的业务逻辑，但是因为把view和数据进行绑定，这样可以让view和业务彻底的解耦了。view可以专注于UI操作，而viewModel可以专注于业务操作。因而：</p><blockquote><ul><li>MVVM通过数据驱动型思想，彻底把业务和UI逻辑进行解耦，各模块分工职责明确。</li></ul></blockquote><p>View只需要关注Viewmodel的数据部分，而无需知道数据是怎么来的；而ViewModel只需要关注数据逻辑，而不需要知道UI是如何实现的。View可以随意更换UI实现，但ViewModel却完全不需要改变。</p><p>但依旧存在的问题是：viewModel会依旧很臃肿；需要一个绑定框架来对view和数据对象进行绑定。这是MVVM的两大弊端。上面的两种架构模式都是不需要框架的，但MVVM必须要有一个view-data绑定框架，来实现对data的更改可以实时反映到view上，这就造成了需要有一定的上手难度：学习框架。</p><blockquote><ul><li>MVVM的viewModel依旧很臃肿。</li><li>MVVM需要学习数据绑定框架，具有一定的上手难度。</li></ul></blockquote><p>为了解决上面两个问题，需要：1.简单易用的框架；2.为viewModel减少压力。所以谷歌推出了适合android开发的MVVM架构模式：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-56f7407722fca66b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>做个简单的解析：</p><ul><li>View对应的就是Activity和Fragment，在这里进行UI操作。</li><li>ViewModel中包含了LiveData，这是一种可观察数据类型框架。View通过向LIveData注册观察者，当LiveData发生改变时，就会直接调用观察者的逻辑把数据更新到view上。</li><li>ViewModel完全不需要关心UI操作，只需要专注于数据与业务操作。</li><li>Repository代表了Model层，Repository对ViewModel进行了减压，把业务操作般到了Repository中，避免了viewModel臃肿。</li><li>Repository对请求进行判断是要到本地数据库获取还是网络请求获取分别调用不同的模块。</li></ul><p>这样，谷歌通过推出简单易用的架构框架，解决了我们上面讲的MVVM的两大问题，让MVVM架构达到了一种非常“完美”的境界。也是谷歌推荐的架构模式。</p><p>但为什么好像，MVVM使用的人还是那么少呢？因为jetpack的架构组件库，可不止是一个LiveData这么简单，他是一整套完整的架构组件库，包括了：DataBinding，LiveData，ViewModel，Navigation，Lifecycle。下面我们简单了解一下每个组件的功能：</p><blockquote><p><strong>DataBinding：</strong></p><ul><li>解基于数据驱动思想，决视图调用一致性问题，实现双向绑定</li><li>避免编写样板式代码，提高效率</li></ul><p><strong>LiveData：</strong></p><ul><li>通过唯一可信源获取数据，正确分发数据</li><li>与Lifecycle结合，拥有生命周期感知能力，配合viewModel实现作用域可控</li><li>实现模块的单向依赖，抛弃接口回调</li></ul><p><strong>ViewModel：</strong></p><ul><li>托管界面状态，解决状态管理问题</li><li>实现跨页面数据分享，并为数据设置作用域，做到作用域可控</li><li>实现单向依赖，避免内存泄露</li></ul><p><strong>Lifecycle：</strong></p><ul><li>以简便地方式解决生命周期管理的一致性问题</li><li>避免内存泄露的情况下让第三方组件随时获取生命周期状态，追踪事故所在的生命周期源，对错过时机的异步操作及时停止</li></ul><p><strong>Navigation</strong></p><ul><li>通过遵循导航定则实现对Fragment的管理</li></ul><p>感觉对上面的作用没看懂，没关系，这不是本文的重点。通过列举这些组件的作用，我想表达的是：此时的MVVM已经不只是架构意义上的MVVM，而是框架层次上的。谷歌针对android开发的各种问题，定制各种各样的架构组件，结合MVVM思想，让我们的开发更加的简便和代码更加的健壮。</p></blockquote><p>我们只需要遵循他的开发规范，使用他的架构框架，就可以开发出非常健壮的项目，有如Spring全家桶的风范。而众多的库，则足以劝退很多的开发者，而在公司的项目，对于框架的不熟悉与不可预期，不知道框架中会不会有什么坑，所以导致了公司项目使用的MVVM的人非常少，至少在我目前了解到的公司，均没有使用此架构。</p><blockquote><ul><li>框架众多，学习成本高。</li><li>框架使用少，对框架不熟悉，容易产生不可预期的异常且无法处理。</li></ul></blockquote><p>到这里我们会发现我们平常讲的MVVM并不只是简单的MVVM架构思想，更多的是指谷歌推出的一系列架构组件。MVVM的本质是什么？</p><blockquote><p>一种基于数据驱动型，将UI逻辑和业务逻辑彻底分离的架构模式。</p></blockquote><p>而我们平常说的“MVVM”是什么？</p><blockquote><p>基于软件工程背景下，谷歌官方推出的一整套结合MVVM使用的架构组件。让开发者可以更简便，更高效率开发出非常健壮的代码。</p></blockquote><p>关于如何实现谷歌意义上的MVVM架构模式，这涉及到框架组件的使用，这里不深入讲解。本文的目的是讲解架构思想，框架的使用，读者可前往官网自行学习。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><blockquote><p>从应用范围来说，MVC和MVP属于广义上的架构模式，MVVM属于专用于页面开发的架构模式。</p></blockquote><p>MVC是不同职责代码的解耦，MVP在MVC的基础上实现了模块间的进一步解耦。在生活中很多地方可以看到他们的影子</p><blockquote><p>MVC举个洗衣机的例子。我们看到的操作面板就是View；里面的智能预定流程漂洗等属于Controller；洗衣机里的洗衣功能是model。这样我们通过view来请求controller设置洗衣流程，然后点击启动直接让model开始运作。这就可以看成一个MVC的例子。</p><p>MVP举个充电线的例子。我们的手机可以看成是View；充电线是Presenter；插座是Model。手机向充电线暴露Type-c接口，而充电线向手机暴露对应的type-c插口。只要两者都符合这个接口规范即可，而不管具体是如何实现的。我们可以随意更换充电线，只要是type-c类型的就可以。我们也可以让一根充电线给不同的手机充电， 只要都是type-c接口就行。而插座和充电线之间的关系也是如此，但是插座会更加独立，因为全世界的插座都是这样，就像我们使用callBack一样。这些就体现了MVP的特点：不同职责模块分离，接口通信。</p></blockquote><p>是吧，可以看到这两套思想是广义上的架构思想，但MVVM则不是。MVVM是专注于页面开发的。为什么这么说？MVVM的本质是把View和view要显示的数据对象进行分离绑定，通过数据驱动型思想彻底解耦UI和业务逻辑。前提要有view也就是页面，还有数据。所以他的应用场景就被限制到页面开发中来了。我们不可能在洗衣机充电线上运用MVVM。因为没有页面和数据对象可言。所以：</p><blockquote><p>MVC是不同职责代码分离，MVP是在MVC的基础上通过接口通信降低模块间的耦合性，MVC，MVP都是广义上的架构模式，Android只是他们的一个应用场景。MVVM是专注于页面开发的架构模式，更加契合页面开发模式。</p></blockquote><p>相信读者们都有一个问题：哪个架构模式是最好的？我应该选择哪个架构模式？是不是MVVM更加契合页面开发所以MVVM一定是最优解？</p><blockquote><p>没有一定是最好的架构模式，只有特定情景下最适合的架构模式。</p></blockquote><p>架构模式都是对于特定情景应运而生的，他是为了解决某个情景下的开发架构问题。例如android的问题是UI与业务逻辑的解耦，但充电线却是需要模块间的解耦。</p><p>那对于Android这个情景来说MVVM一定是最优解吗？当然不是。Android开发也是有很多的情景的，项目的大小，是否要进行维护，对时间有没有要求，项目紧急程度等等。首先要了解得是各大架构模式的优缺点。MVVM由于架构的加持，导致入手成本高，前期投入架构设计代码量多。如果只是一个微型项目，需要在一天内完成（别问我一天怎么完成）那么此时采用mvvm就有点不太适合了，可能搭完架构就已经过去半天了。这个时候因为项目代码很少，且要快速开发，使用MVC就是最合适的了。如果是中型项目，且涉及到团队开发，但是团队对于MVVM的框架并不熟悉，这个时候去学习MVVM再进行开发也是不太实际的，因为框架越多，可能出错的地方就越多，更何况是刚学的。这个时候模块间分离的MVP架构模式就似乎更加的适合了。所以，要根据不同的情景选择最适合的架构模式。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章我们讲了是什么是架构和三种架构模式MVC、MVP、MVVM的架构思想，最后再讲了三种架构的区别与选择。相信通过这篇文章读者可能对这三种架构有了一定的认识。一个完美的架构模式是一个架构师一生的追求，在使用的时候我们可以多多思考这些架构模式的本质以及背景，想想架构师为什么这么设计，可以帮我们更好地理解架构。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>《第一行代码》第三版</li><li>完全解析Android项目架构(1) - MVC</li><li>完全解析Android项目架构(2) - MVP</li><li>完全解析Android项目架构(3) - MVVM</li><li>是让人耳目一新的 Jetpack MVVM 精讲啊！</li><li>是让人提神醒脑的 MVP、MVVM 关系精讲！</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://qwerhuan.gitee.io/2020/08/16/android/android-jia-gou-zhi-mvc-mvp-mvvm-xiang-jie/&quot;&gt;Android架构之MVC、MVP、MVVM详解&lt;/a&gt;&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    
    <category term="Android" scheme="https://jenna233.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>代码之上：我们落地 GraphQL 背后的故事</title>
    <link href="https://jenna233.github.io/2023/04/07/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A%EF%BC%9A%E6%88%91%E4%BB%AC%E8%90%BD%E5%9C%B0-GraphQL-%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <id>https://jenna233.github.io/2023/04/07/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A%EF%BC%9A%E6%88%91%E4%BB%AC%E8%90%BD%E5%9C%B0-GraphQL-%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B/</id>
    <published>2023-04-07T12:27:45.000Z</published>
    <updated>2023-04-07T12:28:15.785Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://zhuanlan.zhihu.com/p/141629697">代码之上：我们落地 GraphQL 背后的故事</a></p><p>GraphQL 经常被打上“好东西，但是难以落地”的标签，很多尝试 GraphQL 的团队也经历了“从入门到放弃”的痛苦。而我们能够在过去一年多的时间里让 GraphQL 在项目中平稳落地，其背后是一个技术决策、工程管理和代码相结合的有趣故事。</p><p>在这篇文章中我会按照故事的时间顺序讲述：</p><p>启蒙期：为什么我们需要 GraphQL<br>原型期：熟悉 GraphQL，熟悉社区<br>蜜月期：在内部系统中应用 GraphQL 并快速收获成果<br>接入期：做个浏览器内运行的 GraphQL 网关<br>痛点期：前、后端同时遭遇挫折<br>落地期：把握机会，真正的 GraphQL</p><h3 id="为什么我们需要-GraphQL"><a href="#为什么我们需要-GraphQL" class="headerlink" title="为什么我们需要 GraphQL"></a>为什么我们需要 GraphQL</h3><p>在谈“为什么”之前，首先说说“我们”是谁。</p><p>我们是 SmartX 的前端团队。相信和我们一样，很多公司内引入 GraphQL 都是由前端团队发起的。不同之处在于从最开始我们就不希望给后端团队带来任何额外工作量，下文中我们会逐步讲述我们如何做到这一点，但毫无疑问这是我们最终成功的重要基础。</p><p>再说我们“为什么需要”。2019 年 1 月，GraphQL 第一次在组内讨论中被写到了白板上，当时组内没有任何一个人对 GraphQL 有实质性的了解，提起只是因为我们想要解决前端项目中复杂的数据拼接问题，而 GraphQL 在我们的印象中是一个擅长数据拼接的技术方案。</p><p>在我们的前端项目中数据拼接有多复杂？可以从以下这个不完全真实（但复杂程度是接近的）的示意图里感受一下：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-3d68b1372edc25d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>一个看起来并不复杂的 UI 内使用了多个服务的 API，并且这些 API 可能由多个组开发，在格式、语义、异常处理上都有一定的差异性，因此一个“可以拼接数据、按需获取的规范”就成为了我们最初的诉求。</p><h3 id="不止拼接，GraphQL-的工程价值"><a href="#不止拼接，GraphQL-的工程价值" class="headerlink" title="不止拼接，GraphQL 的工程价值"></a>不止拼接，GraphQL 的工程价值</h3><p>在后续各个阶段的实践中，我们很快意识到 GraphQL 提供的远不止减少网络请求数量、按需获取数据这么简单，它还为我们带来更多工程价值。</p><h4 id="强类型接口定义避免前后端不一致"><a href="#强类型接口定义避免前后端不一致" class="headerlink" title="强类型接口定义避免前后端不一致"></a>强类型接口定义避免前后端不一致</h4><p>在 GraphQL 的规范中，前后端都需要静态的声明接口和请求的结构。例如后端提供 User 接口，声明其中包含 name 和 email 两个字段。</p><p>如果前端对 User 发起请求，错误地请求了不存在的字段 age 字段，那么在静态阶段（编译、lint 等）我们就有能力发现这个错误。</p><p>同样地，如果后端在某一个版本中引入了一个 breaking change，将 email 字段重命名为 email_address，前端项目中使用了 User.email 的请求也可以在静态阶段发现问题，而不需要在运行时通过测试暴露。</p><p>虽然这些问题都可以通过人为的沟通、联调来避免，但效率和可靠程度显然不是一个层次的。</p><p>另一方面，如果前端项目中使用了 Typescript 等强类型语言，也可以通过工具链从 GraphQL 接口定义中生成 Typescript 类型声明，让整个数据请求的链路上处处都是类型安全的，并且没有额外的维护成本。</p><h4 id="响应式的级联缓存"><a href="#响应式的级联缓存" class="headerlink" title="响应式的级联缓存"></a>响应式的级联缓存</h4><p>UI 里的数据管理是一个更复杂的话题，值得一篇<a href="https://link.zhihu.com/?target=http://www.myriptide.com/smart-cache-cn/">文章</a>单独讨论。这里我尝试用一个简单的示例说明基于 GraphQL 为什么更容易实现一个好用的客户端缓存。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-ccb10934a0a6b9ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>上图中有一个 Tab、一个 User 表格和一个 User 表单。如果从表单中修改了 Adam 的 Email 地址，我们期望通过 API 把最新的 Email 发给后端，并且把表格和表单中 Adam 的 Email 地址都显示为修改后的最新值。</p><p>如果我们希望 UI 的变化自动（而不是通过额外的业务逻辑）发生，就应该实现这样的一个缓存：</p><ol><li>响应式。<br>缓存既要知道 Adam 的 Email 地址对应的是 id 为 1 的 User 这条数据，也要知道有一个表格和一个表单正在”依赖“这条数据。当数据发生变化时，缓存要”通知“这些依赖了对应数据的 UI 重新渲染一次，更新到最新状态。 当 UI 不再”依赖“这条数据时（例如通过 Tab 切换到了 Todo Tab，User 表格不再展示），该数据再发生变化时也不会再触发渲染。</li><li>级联<br>UI 对数据的使用可能来自不同的入口，例如获取所有 User 的 API、获取单个 User 的 API、获取一个 Todo 的创建者的 API。但不论入口来自哪里，缓存都能够通过 id 为 1 的 User 这条数据层层追溯，将它们关联在一起。</li></ol><p>GraphQL 可以让这一切更容易发生，因为：</p><ul><li>数据之间的关联关系在静态的 schema 中已经完整声明。</li><li>可以精确到字段级别的响应式。</li></ul><h4 id="好处都是前端的，工作量大部分是后端的"><a href="#好处都是前端的，工作量大部分是后端的" class="headerlink" title="好处都是前端的，工作量大部分是后端的"></a>好处都是前端的，工作量大部分是后端的</h4><p>从上文的描述中可以看出，很多工程价值都在于前端可以基于 GraphQL 更好的组织代码，但要提供一个 GraphQL API 的主要工作量却在于后端。</p><p>我们很早就认清了这一事实，并且做出了一个判断：GraphQL 对于网络请求的优化（数量、数据量）不是我们最看重的价值，我们可以在前端项目中实现一个运行在浏览器内的 GraphQL 网关，获得 GraphQL 带来的其它好处。这样的方式不需要后端的配合就可以独立完成，并且可以在足够成熟后快速转化为一个独立的 NodeJS 服务，完整享受 GraphQL 的所有优点。</p><p>不过在这么做之前，我们还有很多调研工作需要完成。</p><h3 id="快速取得成果"><a href="#快速取得成果" class="headerlink" title="快速取得成果"></a>快速取得成果</h3><p>2019 年春节过后，我们正式开始了对 GraphQL 的调研工作。为了加速调研的过程，我们同时开展了两方面的工作：</p><ol><li>熟悉 GraphQL 本身以及它的社区。</li><li>在严肃程度不那么高、但又有一定复杂度的项目中使用 GraphQL。</li></ol><h4 id="GraphQL-社区"><a href="#GraphQL-社区" class="headerlink" title="GraphQL 社区"></a>GraphQL 社区</h4><p>尽管 GraphQL 最初是由 Facebook 开源的，但发展至今已经成为了典型的社区驱动项目。由社区主导的项目容易产生以下特点：</p><ul><li>方向经常变化，每一小段时间就有新的明星项目产生，但也经常有项目停止维护甚至废弃。</li><li>对于一些长期存在的设计缺陷缺乏修复的动力，往往要在下一个大版本重构时才被解决。</li></ul><p>为了在尽可能使用社区成果的同时避免“踩坑”，我们首先对各类项目及其维护者做了分类。从功能上分类，我们把这些项目分为 3 层：</p><ul><li>Spec 层面。<a href="https://link.zhihu.com/?target=https://spec.graphql.org/">GraphQL Spec</a> 是核心的部分，与语言无关，描述的是 GraphQL 的标准行为。本身由 GraphQL Working Group 维护，每一到两年发布一个新版本。本身非常稳定，在考察其它项目时我们会以对 Spec 的实现程度作为重要的评判标准。</li><li>实现层面。目前很多编程语言都对 GraphQL Spec 进行了实现，JavaScript 对应的 <a href="https://link.zhihu.com/?target=https://github.com/graphql/graphql-js">graphql-js</a> 是由官方维护的，目前也基本不存在替代品。</li><li>应用层面。和以上两个层面的稳定不同，社区在应用层面有层出不穷的项目，包含后端 server、前端 client、数据库 ORM 封装等很多方向。</li><li>工具链层面。同样有很多的项目，包含 lint、编译、测试各个方面。</li></ul><p>在调研的过程中我们每接触到一个新的项目，就会将其放在对应的层面，和同层同功能的其它项目进行比较，在比较的过程中更容易找到每个项目的优势和不足。</p><p>另一方面我们对项目背后的维护者也做出了描述性的判断，以我们最终采用的项目对应维护者为例：</p><ul><li>Apollo 是社区中的重要成员，本身也有商业化的 GraphQL 产品。在应用层面和工具链层面都维护了很多项目，但是对于解决项目中长期存在的设计缺陷动力比较匮乏。</li><li>Prisma 和 Apollo 类似，也有自己的商业化产品。相比之下 Prisma 更为激进，喜欢不断推出新的版本、项目来替代自己过去的项目。</li><li>The Guild，由社区组织，非常活跃地维护了几个高质量的项目。</li></ul><p>熟悉维护者的风格，阅读项目中长期存在的 issue，让我们提前了解到各个项目存在的“坑”和可能解决的时间点。再结合我们自己的接入计划，大大降低了后期实际使用时的风险。</p><h4 id="在内部系统里练习"><a href="#在内部系统里练习" class="headerlink" title="在内部系统里练习"></a>在内部系统里练习</h4><p>和很多公司一样，SmartX 也有一些内部系统的需求。这类系统大部分是 Web Service + Web UI 的形态，不涉及底层（虚拟化、分布式存储）的技术，所以交由前端组进行开发。</p><p>与产品主线相比，这些内部系统是验证新技术栈绝佳的试验田，因为它们：</p><ul><li>交付周期更灵活，有一定的试错空间。</li><li>自动化测试较少，Code Review 更侧重整体设计，代码合入速度快。</li><li>不需要过多考虑升级、兼容性等问题。</li><li>有一定的业务逻辑，一些系统里业务逻辑甚至相当复杂，更容易验证技术栈在各种场景下的表现。</li></ul><p>从 2019 年上半年开始，我们所有的内部系统都开始采用 GraphQL 作为 API 接口规范。其中最为突出的成果是我们用 1.5 个人力在 2 个月的时间里完成了售后系统的开发，不论在开发效率还是用户体验上都有令人满意的表现。</p><p>经过在内部系统里的实践，我们在 2019 年 6 月时做到了：</p><ol><li>熟悉 GraphQL 社区的进展，从众多项目中挑选出了几个适用于我们使用场景的进行长期投入。</li><li>拥有两名非常熟悉 GraphQL 的组员。</li></ol><h3 id="Data-Layer-浏览器内的-GraphQL-网关"><a href="#Data-Layer-浏览器内的-GraphQL-网关" class="headerlink" title="Data Layer: 浏览器内的 GraphQL 网关"></a>Data Layer: 浏览器内的 GraphQL 网关</h3><p>2019 年 5 月份，我们带着在内部系统中积累的经验回到产品主线的前端项目中，开始设计代号为 data layer 的纯前端 GraphQL 方案。</p><p>事实上 GraphQL Spec 从来没有限制 server 部分的运行环境，所以我们完全可以在浏览器内实现一个 GraphQL server 运行时。</p><h4 id="GraphQL-的执行方式"><a href="#GraphQL-的执行方式" class="headerlink" title="GraphQL 的执行方式"></a>GraphQL 的执行方式</h4><p>以一段 GraphQL schema 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># [] 代表数组，! 表示不能为 null</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">  users: [User!]!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type User &#123;</span><br><span class="line">  name: String!</span><br><span class="line">  posts: [Post!]!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Post &#123;</span><br><span class="line">  title: String!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要查询所有用户的姓名以及每个人写的文章的标题，就可以发起一个这样的查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  users &#123;</span><br><span class="line">    name</span><br><span class="line">    posts &#123;</span><br><span class="line">      title</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照 GraphQL spec 的要求，server 在处理这个查询时的顺序依次是：</p><ol><li>以 query 作为入口，对应 schema 中的 type Query</li><li>向下执行 query.users。所谓执行（resolve）就是执行 server 中定义的对应 schema 节点的 resolver 函数。</li><li>继续向下依次执行 query.users.name，query.users.posts，query.users.posts.title。</li></ol><p>每个 schema 节点的 resolver 函数都会接收上层节点的返回值、查询输入的变量、当前上下文和一些额外信息作为参数，并返回一个符合 schema 类型定义的结果供下层节点继续执行。所有节点执行完毕后，最终的完整结果会返回给 client。</p><p>由此可见，resolver 函数的灵活性非常高，例如我们可能在 query.users 节点执行一次数据库查询得到结果，在 query.users.posts 中通过一次 HTTP 请求得到结果，在 query.users.posts.title 中从文件系统中读取结果，只要返回值符合 GraphQL schema 的定义即可。</p><h4 id="Data-Layer-的设计"><a href="#Data-Layer-的设计" class="headerlink" title="Data Layer 的设计"></a>Data Layer 的设计</h4><p>Data layer 运行在浏览器内，同时我们也希望前端 UI 代码通过标准的 GraphQL API 和它进行交互，这样我们可以随时将 data layer 迁移为独立的 NodeJS 服务。因此 data layer 的设计始终需要满足：</p><p>只使用 JavaScript 的标准 API，不使用任何浏览器 API，保证在 NodeJS 运行时中也可以正常工作。<br>UI 和 data layer 之间的通信必须是可以序列化的，而不能直接通过内存传递数据，保证远程调用的能力。<br>当 data layer 运行在浏览器内时，整体形态如图所示：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b037803f10d010ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在 data layer 内每个 GraphQL 请求执行时，会在对应的 resolver 函数内发出 HTTP 请求，从已有的后端服务中获取数据。</p><p>在这样的实现下，我们已经可以让我们的前端项目获得 GraphQL 带来的各种好处，只不过在网络请求方面不会比之前的 Restful API 有数量和数据量上的节省（因为 data layer 还是会发出基本等量的请求）。</p><p>需要注意的是，即使没有网络请求上的优势，data layer 依然帮助我们的前端代码很好地解决了长久存在的数据拼接抽象、数据缓存一致性、UI 正确更新等问题，这也说明数据裁剪绝对不是 GraphQL 唯一的价值。</p><p>在我们的计划中，如果 data layer 稳定的实现完我们 UI 代码中所有的数据请求代码，我们就可以将它迁移为独立的 NodeJS 服务，变成这样的形态：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-8ee1b251257ad78d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>进一步获得以下收益：</p><ul><li>数据裁剪，减少前后端的请求数量和数据量。</li><li>减少浏览器内的开销，提升用户体验。</li><li>data layer 离数据源（后端服务）更近，整体响应时间缩短。</li></ul><h3 id="阵痛：意料之中的挫折"><a href="#阵痛：意料之中的挫折" class="headerlink" title="阵痛：意料之中的挫折"></a>阵痛：意料之中的挫折</h3><p>时间来到 2019 年 8 月份，GraphQL 在我们的内部系统中已经使用了半年以上，data layer 也在产品主线的前端项目中加以应用。</p><p>在这个阶段我们开始遇到一些问题，值得庆幸的是这些问题在前期调研的过程中我们已经有所了解，因此尽管解决起来不太容易，但也不至于毫无头绪。</p><h4 id="Apollo-Client-缓存管理"><a href="#Apollo-Client-缓存管理" class="headerlink" title="Apollo Client 缓存管理"></a>Apollo Client 缓存管理</h4><p>在上文中提到的“响应式的级联缓存”并不是我们独创的概念，GraphQL 社区中最流行的客户端 Apollo Client 就一直在深度使用这一实现。</p><p>但是在 Apollo Client v2 的实现中，这层缓存一直存在一个致命的缺陷：缺少易用的缓存失效方式。官方文档中描述的 refectch 和 write cache 等方式在项目规模稍大时就会难以维护，而在社区中相关的讨论已经持续长达两年之久，直到今天 Apollo Client v3 的 RC 版本中给出的缓存失效方案仍然不能完全解决问题。</p><p>这一问题在我们的内部系统迭代半年之后也开始出现。当时我们有两个选择：</p><ol><li>等待官方承诺在 2019 年 10 月发布的 v3 版本解决这一问题。</li><li>在 Apollo Client 的基础上自行设计实现一个缓存失效方案。</li></ol><p>最终我们选择花半个月的时间完整理解 Apollo Client 的代码，再经过一周的设计之后完成了一个包含依赖追踪、UI 自动响应的缓存失效方案。我们之所以可以比社区更快地解决问题，是因为：</p><ul><li>我们可以不考虑向前、向后的兼容性问题，设计只为我们使用场景服务的方案。</li><li>我们可以在短时间内投入充足的人力，集中解决这一个问题。</li></ul><p>从这个过程中也可以看出，使用开源社区的方案并不代表永远不能出现分岔、无限制地等待 upstream 给出方案。</p><p>事实上我们甚至没有使用一个 fork 版本的 Apollo Client，而只是在上层代码中进行了封装，使用了一些 private API 就解决了问题。</p><h4 id="GraphQL-schema-也需要设计"><a href="#GraphQL-schema-也需要设计" class="headerlink" title="GraphQL schema 也需要设计"></a>GraphQL schema 也需要设计</h4><p>在应用 data layer 的过程中我们遭遇了另一个问题：怎么设计出“好用”的 GraphQL schema。</p><p>和任何一种 API 规范一样，GraphQL schema 也需要设计，而且与 RESTful API 等规范相比，GraphQL 最佳实践相关的资料还是非常少的。</p><p>在我们的 data layer 中，背后的数据源也不是非常灵活的数据库查询，而是几套比较复杂的 HTTP API。所以在实际的开发中，我们一边摸索最佳实践，一边在 schema 的易用性、请求数量、性能等方面做取舍，并且应用了相当复杂的批量处理和缓存策略进行优化，导致后期 data layer 的开发变成了一项技巧性工作。</p><p>严格来说这不是一个阻碍开发的问题，但确实限制了我们的效率。这也促使我们想在下一阶段在两方面做出改进：</p><ol><li>以独立后端服务的形式运行 GraphQL 网关，最好还能够使用数据库作为数据源。</li><li>从成熟的项目中借鉴一套 GraphQL schema 设计的最佳实践。</li></ol><h3 id="把握机会，真正的-GraphQL"><a href="#把握机会，真正的-GraphQL" class="headerlink" title="把握机会，真正的 GraphQL"></a>把握机会，真正的 GraphQL</h3><p>2019 年第四季度，在思考 data layer 的下一步方向时，我们突然获得了一个更好的机会：产品主线中会新增一个管理面产品。考虑到后端的同学需要将精力投入到其它更具挑战性的任务中，准备让前端组来负责新的管理面产品 Web 前、后端的开发。</p><p>这个机会不仅完美的贴合我们上一阶段总结出的改进方向，而且带来更大的发挥空间。在随后半年多的时间里，我们实现了：</p><ul><li>用数据库缓存所需数据，以独立后端服务的形式运行 GraphQL 网关，彻底解决了 data layer 中难以避免的性能问题，显著提升了用户体验。</li><li>基于 Prisma ORM 封装了一套功能完整、表达能力强的 GraphQL schema，降低 API 的设计和实现成本，提升了 API 的使用体验。</li><li>数据库、网关、UI 全链路的类型安全，让大多数问题在编译阶段暴露。同时开发代码生成工具，让一些数据交互复杂的 UI 组件可以直接通过数据库 schema 生成。</li><li>后端的同学可以全情投入底层的开发工作，不再需要为 UI 设计 API，也减少了很多联调的工作。</li></ul><p>2019 年 1 月，我们还是没有任何一名成员了解 GraphQL 的前端团队。</p><p>2020 年 5 月，我们已经是所有成员非常熟悉 GraphQL 使用、并且有 2 名成员精通 GraphQL 细节的管理产品团队。</p><p>这一过程中固然有机会和运气的作用，但如果我们从一开始就只是推动后端团队去帮助我们进行 GraphQL 改造，那么想必这一切也都不会发生。</p><p>如果你也认可我们处理工程问题的思路和方式，也欢迎<a href="https://link.zhihu.com/?target=https://www.smartx.com/jobs/">加入我们</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://zhuanlan.zhihu.com/p/141629697&quot;&gt;代码之上：我们落地 GraphQL 背后的故事&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GraphQL 经常被打上“好东西，但是难以落地”的标签，很多尝试 GraphQL 的团队也经历了“</summary>
      
    
    
    
    
    <category term="服务器" scheme="https://jenna233.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>《2018年中国大数据BI行业分析报告》（全文）</title>
    <link href="https://jenna233.github.io/2023/04/07/%E3%80%8A2018%E5%B9%B4%E4%B8%AD%E5%9B%BD%E5%A4%A7%E6%95%B0%E6%8D%AEBI%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%E3%80%8B%EF%BC%88%E5%85%A8%E6%96%87%EF%BC%89/"/>
    <id>https://jenna233.github.io/2023/04/07/%E3%80%8A2018%E5%B9%B4%E4%B8%AD%E5%9B%BD%E5%A4%A7%E6%95%B0%E6%8D%AEBI%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%E3%80%8B%EF%BC%88%E5%85%A8%E6%96%87%EF%BC%89/</id>
    <published>2023-04-07T12:26:51.000Z</published>
    <updated>2023-04-07T12:27:21.414Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://www.secrss.com/articles/1114">《2018年中国大数据BI行业分析报告》（全文）</a></p><p>近年来，随着人们的数据意识和数据素养不断提升，商业智能（BI，Business Intelligence）和数据分析领域迎来了快速发展期，据Gartner商业智能报告统计，到2020年全球的商业智能市场容量预计将达到228亿美元。</p><p>近年来，随着人们的数据意识和数据素养不断提升，商业智能（BI，Business Intelligence）和数据分析领域迎来了快速发展期，据Gartner商业智能报告统计，到2020年全球的商业智能市场容量预计将达到228亿美元。同时，大数据、人工智能、机器学习、深度学习等技术的快速发展，也促进了商业智能和数据分析产品的新一轮进化。</p><p>Gartner分析师认为，到2020年，自然语言生成和人工智能将是90%的新BI平台的标准特征，50%的分析查询将使用搜索、自然语言处理，或语音生成，或将自动生成。但我们必须认识到，我国商业智能的市场特征、企业需求、关注点、发展阶段均与国外有所不同，以Gartner为代表的分析机构并不能准确描述我国商业智能行业的实际状况。</p><p>针对这一问题，帆软数据应用研究院调研了规模不一的216家企事业单位，了解到他们的大数据BI应用状态、需求情况、对大数据BI产品功能的期待，同时基于帆软数据应用研究院对行业的长期观察和思考，形成了该篇报告。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-b1ee891e9260feb5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><strong>主要预测</strong></p><p>2018年，中国大数据 BI 产品将主要在自助分析的可操作性和功能丰富度、平台的安全性、数据管理能力、分析的共享能力、数据挖掘能力、大数据处理能力六大功能模块进行提升。</p><p><strong>2018年中国商业智能行业发展分析</strong></p><h1 id="一-行业总体形势向好"><a href="#一-行业总体形势向好" class="headerlink" title="(一) 行业总体形势向好"></a>(一) 行业总体形势向好</h1><p>在当前经济环境下，企业盈利的压力和难度不断增加，越来越多的企业，尤其是一、二线稍具业务规模的企业，其高层都希望通过精细化运营提升市场竞争力，降低企业的运营成本。这些企业绝大多数都已经在2008年<del>2015年间上线了各种业务系统，存储了大量管理和运营数据，具备应用大数据BI进行数据分析和数据化管理的各种条件，这些需求将在2018年</del>2022年继续爆发。值得注意的是，艾瑞咨询在《2017年中国商业智能行业研究报告》中指出，我国已经进入商业智能领域第一方阵，成为发展最快的国家之一，但和美国还有比较大的差距。所以未来中国大数据BI行业总体将呈现加速度增长，市场容量将不断扩大。</p><h1 id="二-大数据BI厂商马太效应显现"><a href="#二-大数据BI厂商马太效应显现" class="headerlink" title="(二) 大数据BI厂商马太效应显现"></a>(二) 大数据BI厂商马太效应显现</h1><p>马太效应是指强者越强，弱者越弱的现象，国内BI行业的马太效应已经显现。据帆软品牌部调研数据显示，处于行业第一梯队的帆软、Tableau、微软PowerBI的品牌知名度和市场份额与其他厂商进一步拉大。帆软2017年全年营收2.77亿，远超其他国内厂商之和。同时帆软销售部反映，2017年度销售跟单中遇到的竞品种类和数量均较2016年有相当大幅度的下降。BI行业出现马太效应实属必然，综合实力强大的厂商更能投入资源做好产品、服务，解决更多用户的需求和问题。可以预见，2018年中国BI行业马太效应将进一步增强，逐步淘汰掉实力弱、规模小、产品差的企业。</p><h1 id="三-新型自助式BI与传统型BI平分秋色"><a href="#三-新型自助式BI与传统型BI平分秋色" class="headerlink" title="(三) 新型自助式BI与传统型BI平分秋色"></a>(三) 新型自助式BI与传统型BI平分秋色</h1><p>得益于敏捷、自助的特征，从2013年起新型自助式BI迎来了高速发展期，这一时期也是传统型BI的衰退期。</p><p>2017年，传统型BI与新型自助式BI在国内市场中平分秋色。受访企业中，约50.2%的企业仍然在使用传统型BI，其中最典型的需求是企业常规日报、月报等汇总分析报告。约49.8%的企业应用新型自助式BI，通过报表平台+自助式BI+大数据底层平台的解决方案，来解决企业综合的数据展示和分析需求，形成经营和战略决策。在调研中我们注意到，约有18%的企业引进了新型自助式BI，部分或全部替代了传统BI。虽然传统型BI尤其自身优势和应用场景，但随着新型自助式BI的不断发展，传统型BI必将逐渐退出历史舞台，从国际传统BI巨头积极调整产品结构可见一斑。</p><p><strong>2017年中国商业智能用户状况分析</strong></p><p>根据企业的IT人员和业务人员在数据分析中的工作量和投入程度占比，我们将BI用户（企业）划分为5大类型，即BI应用金字塔模型，以更好的统计、分析企业的BI应用状况：</p><h1 id="一-BI应用金字塔模型"><a href="#一-BI应用金字塔模型" class="headerlink" title="(一) BI应用金字塔模型"></a>(一) BI应用金字塔模型</h1><h4 id="1-IT完全主导型"><a href="#1-IT完全主导型" class="headerlink" title="1. IT完全主导型"></a>1. IT完全主导型</h4><p>○其典型特征为，IT人员做底层数据仓库，以及BI工具层面的数据模型处理的所有相关工作，完成95%以上的BI分析页面（注：主要是指用于生产、经营、管理会议所需要的数据分析页面，下同）的开发。业务人员仅负责前端数据查看，完成查看报表时相关联动钻取操作。</p><p>○调研中发现，处于“IT完全主导型”这一等级的企业，约有93.2%都在使用传统型BI工具，企业的业务人员基本没有能力，也没有需求去自主完成数据分析的工作。这些企业的业务变革并不剧烈，企业管理层认为当前的日常数据报告能够满足企业管理和决策的需要，相对缺少变革的动力。</p><h4 id="2-IT强主导型"><a href="#2-IT强主导型" class="headerlink" title="2. IT强主导型"></a>2. IT强主导型</h4><p>○其典型特征为，IT人员做底层数据仓库，以及BI工具层面的数据模型处理的所有相关工作，完成80%~95%数量的BI分析页面。业务人员完成低于20%数量的BI分析页面。</p><p>○从调研数据来看，这类企业中，67.5%的企业认为当前业务人员不具备数据分析的能力。而企业需要快速完成部分数据分析工作，所以选择让IT人员更多承担工作。这类企业中普遍认为，商业智能产品本身并非能够快速上手，且业务人员仍需要统计学基础，阻碍数据分析工作从IT人员向业务人员的转移。</p><h4 id="3-业务强主导型"><a href="#3-业务强主导型" class="headerlink" title="3.业务强主导型"></a>3.业务强主导型</h4><p>○其典型特征为，IT人员做底层数据仓库，以及BI工具层面的数据模型处理的所有相关工作，完成前期示例不超过20%数量的BI分析页面。业务人员完成超过80%数量的BI分析页面。</p><p>○从调研数据来看，这类企业中，超过80.2%是曾经推行传统BI的企业，并且部分业务人员是有较高学历和能力的，能够学习和掌握商业智能工具和数据分析技能，并愿意在工作中积极使用；从帆软数据应用研究院的实地走访的部分企业来看，这些企业普遍行业排名靠前，公司从高层就重视数据分析工作。</p><h4 id="4-业务完全主导型"><a href="#4-业务完全主导型" class="headerlink" title="4.业务完全主导型"></a>4.业务完全主导型</h4><p>○其典型特征为，IT人员做底层数据仓库，以及BI工具层面的数据模型处理的部分相关工作。业务人员完成95%以上数量的BI分析页面和相当部分BI工具层面的数据模型处理。</p><p>○相比于第三类使用人群（业务强主导型），这类用户的一大特点是业务变革十分迅速，从事业务工作的人员学历普遍较高，业务经营和发展需要企业快速做出决策。而基于数据分析得出的业务判断相比个人历史经验准确度更高，是这类企业基本共识。比如在新兴的互联网企业，或者新零售领域，这个特点尤为突出。</p><h4 id="5-智能自助型"><a href="#5-智能自助型" class="headerlink" title="5.智能自助型"></a>5.智能自助型</h4><p>○其典型特征为，IT人员只做底层数据仓库、数据连接、数据字典相关工作。业务人员处理所有BI工具层面的数据处理，以及所有BI分析页面。</p><p>○IT人员搭建数据中心，业务人员完全自主处理和分析数据，这类企业有着明显的资源密集型的特点，业务人员更多的是偏向运营相关的工作。当然，因为此类受访企业占比较少，原因分析的可信度还有待进一步调研来核实。</p><h1 id="二-BI用户状况分布"><a href="#二-BI用户状况分布" class="headerlink" title="(二) BI用户状况分布"></a>(二) BI用户状况分布</h1><p>▊基于BI应用金字塔模型，2017年企业分布如下；</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-ca5424777708d452.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>○从调研数据中，我们可以得出两大结论：</p><p>1、IT人员主导企业数据分析的模式仍占据主流，也就是IT驱动仍是2017年企业商业智能平台应用现状。从数据调研的受访企业来看，有高达60.5%的企业的数据分析工作仍是第二类型（IT强主导型），甚至有21.5%的企业的数据分析工作处在第一类型（IT完全主导型），这显然和业务人员自助数据分析的目标距离遥远。</p><p>2、新型自助BI正在成为商业智能市场的主流。17.5%的企业是在2017年上线了新型自助BI，实现了让少部分业务人员自助完成BI数据分析的目标。</p><p><strong>2018年商业智能用户需求分析</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-ba5e3fe991e4769c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="一-企业多级部门数据分层次IT权限和平台管控，占受访企业97-6"><a href="#一-企业多级部门数据分层次IT权限和平台管控，占受访企业97-6" class="headerlink" title="(一) 企业多级部门数据分层次IT权限和平台管控，占受访企业97.6%"></a>(一) 企业多级部门数据分层次IT权限和平台管控，占受访企业97.6%</h1><p>○需求描述：BI工具支持企业的多级部门的数据/分析页面权限管控，使得不同层级的部门机构只能看到本部门机构和辖属部门机构的数据/分析页面。</p><p>○需求产生的原因：有的信息中心为释放压力，放权给业务部门使用数据，一旦口子打开，数据缺口就会像洪水一样泛滥，就又会走向另外一个极端，导致放权下的数据管理混乱，数据口径不统一，部门之间的数据壁垒等等问题就会出现，同时这将给企业带来极大的数据安全隐患。</p><p>○满足该需求对企业的价值和意义：在满足业务部门BI数据自助分析的同时，兼顾企业的数据权限管控，形成企业以IT部门集中管理下的良性数据分析风貌，杜绝企业数据安全隐患。</p><h1 id="二-业务人员可通过BI工具进行自助数据分析，占受访企业94-5"><a href="#二-业务人员可通过BI工具进行自助数据分析，占受访企业94-5" class="headerlink" title="(二) 业务人员可通过BI工具进行自助数据分析，占受访企业94.5%"></a>(二) 业务人员可通过BI工具进行自助数据分析，占受访企业94.5%</h1><p>○需求描述：业务人员可以在浏览器前端，对自己权限范围内的数据进行多维拖拽探索和自助分析，发掘隐含在数据中的业务价值。</p><p>○需求产生的原因：企业的传统信息化建设中，IT信息中心对公司数据进行高度集中的管控，来自企业各职能部门的数据处理以及报表就会全部由IT人员来输出，一旦业务部门需求集中扎堆，就会造成响应不足，业务部门怨声载道。信息中心自身成员熬夜加班做报表，成就感却很低。</p><p>○满足该需求对企业的价值和意义：通过高效灵活的BI工具，业务人员对自己权限范围内感兴趣数据进行多维拖拽探索和自助分析，以工具简单易上手的低学习成本，让真正对分析业务价值最熟悉的业务人员实现自助数据分析探索，最大化业务数据的分析维度和分析效率，灵活发掘数据中可能潜在的业务价值，同时也解放了IT人员的劳动力，降低企业人力成本。</p><h1 id="三-可快速搭建型自助BI业务数据模型，占受访企业87-5"><a href="#三-可快速搭建型自助BI业务数据模型，占受访企业87-5" class="headerlink" title="(三) 可快速搭建型自助BI业务数据模型，占受访企业87.5%"></a>(三) 可快速搭建型自助BI业务数据模型，占受访企业87.5%</h1><p>○需求描述：数据库表中的数据需要基于业务分析主题进行分类管理，相关数据表之间支持手动/自动构建关联模型，同时建立的关联模型支持灵活应用，无需反复编辑修改或创建新的模型，一次建立即可灵活满足多重业务场景进行数据分析使用。</p><p>○需求产生的原因：传统BI工具创建的底层数据关联相互独立，无法重复利用，一旦遇到新的业务数据计算分析场景，数据关联就需要修改或重新创建，极为麻烦，非常不利于IT人员维护。</p><p>○满足该需求对企业的价值和意义：通过BI工具快速构建的新型自助式BI业务数据模型，较传统BI工具针对不同业务分析场景需要多次、重复建模的应用痛点，极大地提高了BI工具的企业中业务数据分析应用的效率，解放了以往IT人员对数据维护的压力。</p><h1 id="四-OLAP多维分析：上卷、下钻、旋转、切片、联动、跳转等，占受访企业84-5"><a href="#四-OLAP多维分析：上卷、下钻、旋转、切片、联动、跳转等，占受访企业84-5" class="headerlink" title="(四) OLAP多维分析：上卷、下钻、旋转、切片、联动、跳转等，占受访企业84.5%"></a>(四) OLAP多维分析：上卷、下钻、旋转、切片、联动、跳转等，占受访企业84.5%</h1><p>○需求描述：BI工具支持强大的页面OLAP多维分析功能，包括分析视角的上卷、下钻，维度的旋转切换，指标的切换，分析数据的切片过滤，组件之间的联动过滤、页面超级链接跳转等。</p><p>○需求产生的原因：随着业务发展的复杂化，单一角度的数据分析往往难以再发掘出更多有价值的潜在业务信息，取而代之的是需要BI工具能够满足强大的页面OLAP多维分析功能。</p><p>○满足该需求对企业的价值和意义：通过BI工具强大的OLAP多维分析功能，以实现多角度、多关联数据之间的数据无限层次探索分析，发掘出数据中潜在的业务价值。</p><h1 id="五-大数据处理性能处理能力达到十亿数据秒级响应，占受访企业63-6"><a href="#五-大数据处理性能处理能力达到十亿数据秒级响应，占受访企业63-6" class="headerlink" title="(五) 大数据处理性能处理能力达到十亿数据秒级响应，占受访企业63.6%"></a>(五) 大数据处理性能处理能力达到十亿数据秒级响应，占受访企业63.6%</h1><p>○需求描述：BI工具可支撑处理亿级以上大数据分析计算的秒级响应，提供多维加速引擎对传统关系型数据仓库（SQLServer、Oracle、Mysql等）进行数据提速处理，同时也支持实时对接企业大数据平台（Vertical、Kylin、Greenplum等）进行数据分析计算。</p><p>○需求产生的原因：一方面，传统关系型数据库在面对上亿级别以上数据量时，容易出现性能瓶颈，长时间的查询等待往往会导致业务数据分析效率太低。另一方面，当今信息化水平飞速发展，越来越多的企业已经有了自己的高性能大数据平台，对于这部分企业来说，拥有一款能够直接对接大数据平台进行数据分析的工具尤为重要。</p><p>○满足该需求对企业的价值和意义：BI工具提供的强大数据计算处理引擎，能够降低企业数据查询等待时间成本，提高业务数据分析效率。同时，通过直接对接企业大数据平台，还可满足企业实时数据分析的需求。</p><h1 id="六-业务人员可完成工具层面的零代码数据加工处理工作，占受访企业57-5"><a href="#六-业务人员可完成工具层面的零代码数据加工处理工作，占受访企业57-5" class="headerlink" title="(六) 业务人员可完成工具层面的零代码数据加工处理工作，占受访企业57.5%"></a>(六) 业务人员可完成工具层面的零代码数据加工处理工作，占受访企业57.5%</h1><p>○需求描述：BI工具可通过快速易上手的交互方式，让业务人员也能完成工具层面的零代码数据加工处理工作，例如例如表合并、分组统计、结构数据分层、过滤、增加列、同比环比、累计值、所有值、公式运算等数据清洗和数据处理方法，实现对数据的无限层次多维透视分析统计。</p><p>○需求产生的原因：当业务需求相对偏复杂时，简单的维度和指标统计往往无法直接计算出业务所需要的计算结果，以往的处理方式往往可能是业务部门提需求给IT，然后IT经过SQL或者代码对底层数据表加工处理，然后最终导出一张excel数据表给业务部门，期间的反复沟通和等待时间往往降低了企业的业务数据分析应用效率。</p><p>○满足该需求对企业的价值和意义：通过BI工具，使得业务人员也能快速实现对数据的无限层次多维透视分和析加工统计，降低了传统模式下的沟通成本和等待时间，提高了企业业务数据分析的应用效率。</p><h1 id="七-移动端数据分析查看支持，占受访企业44-9"><a href="#七-移动端数据分析查看支持，占受访企业44-9" class="headerlink" title="(七) 移动端数据分析查看支持，占受访企业44.9%"></a>(七) 移动端数据分析查看支持，占受访企业44.9%</h1><p>○需求描述：BI工具支持移动端数据分析多维分析查看功能（兼容PC端的上卷、下钻、旋转、切片、联动、跳转等），对于BI工具的应用app支持便捷的扫码登陆、离线查看、批注、分享等功能，同时满足某些社区平台如微信、钉钉的企业公众号集成。</p><p>○需求产生的原因：在当今这个移动设备便捷时代，仅仅PC端的数据分析已经不能满足某些特定时间和场所的业务分析需求了，而BI对移动端的支持已经成了必然要满足的功能点。</p><p>○满足该需求对企业的价值和意义：通过移动端的BI分析查看，使得数据分析不仅仅局限于PC端，较大地增强了数据分析的便捷性。同时微信和钉钉的集成接入，让业务通过社区平台也能直接查看想要的数据分析页面，更是为移动端数据分析锦上添花。</p><p><strong>中国大数据BI产品功能预测</strong></p><p>结合用户需求调研，和我国BI厂商的产品计划研究，2018年如下六个大的功能模块将会得到增强：</p><h1 id="一-提升自助分析的可操作性和功能丰富度"><a href="#一-提升自助分析的可操作性和功能丰富度" class="headerlink" title="(一) 提升自助分析的可操作性和功能丰富度"></a>(一) 提升自助分析的可操作性和功能丰富度</h1><p>为满足业务人员可通过BI工具进行自助数据分析的需求，中国大数据BI产品需要改善自助分析的功能和可操作性，包括图表的丰富性。</p><p>前端布局自定义搭配，让业务人员随心所欲布置。比如仪表板自由布局，可快速拖拽生成所需要分析的页面；在全面支持常见的柱状图、条形图等图形基础上，增加支持中国（世界）地图、GIS地图、桑基图等大数据图表；</p><p>为了适应更加多样的用户，大数据BI平台需要支持强大的OLAP多维分析功能，包括分析视角的上卷、下钻，维度的旋转切换，指标的切换，分析数据的切片过滤，组件之间的联动过滤、页面超级链接跳转等。业务人员在OLAP多维分析的基础上，能够在数据分析查看时，再次对所有维度进行二次的维度指标加工，并无限层次多维透视分析统计，全面开放业务人员对数据的处理和分析操作，以满足当前中国用户多个视角、多个层级的分析需求，把传统业务分析的智慧充分沉淀到数据分析系统中来。</p><p>为了给不同用户提供个性化的视觉体验，大数据BI平台支持表格动态数值预警功能和图形设置动态警戒线，支持图表样式风格自由拖拽调整。同时，也需要大数据BI平台智能自动设置预警值和样式风格等。</p><h1 id="二-提升平台的数据挖掘能力"><a href="#二-提升平台的数据挖掘能力" class="headerlink" title="(二) 提升平台的数据挖掘能力"></a>(二) 提升平台的数据挖掘能力</h1><p>为满足企业业务人员自助数据分析和自动挖掘的需求，中国大数据BI产品需要在已有的数据可视化和数据分析的功能基础上，增强数据自动挖掘能力，使业务人员在能够掌握挖掘基本概念的基础上，深入挖掘分析业务数据，为业务运营提供数据结论支持。</p><p>大数据BI平台需要支持嵌入式高级分析功能，用户能够轻松使用平台内置的高级分析功能，也可以通过导入和集成外部开发的高级分析模型。比如平台内含数据挖掘常见算法（如线性预测、时序预测、聚类、分类等），或者提供外接其他数据挖掘平台和工具的可视化接口（如R语言或者Python语言），甚至内含适合特定业务场景的挖掘模型 。</p><h1 id="三-提升平台大数据处理能力"><a href="#三-提升平台大数据处理能力" class="headerlink" title="(三) 提升平台大数据处理能力"></a>(三) 提升平台大数据处理能力</h1><p>为满足企业对大数据BI平台实时响应的需求，中国大数据BI产品需要将当前大数据处理能力提升一个量级，达到10亿数据量秒级响应水平，同时支持丰富多样的数据源。</p><p>大数据BI平台需要支持丰富的数据源，如企业主流的关系型数据库、大数据平台、NOSQL数据库以及多维数据库，需要支持实时对接数据平台和分布式引擎拓展，同时支持跨数据源关联，同时支持对较大级别数据量进行数据抽取和索引建模，提高数据分析效率。</p><h1 id="四-提升平台的数据管理能力"><a href="#四-提升平台的数据管理能力" class="headerlink" title="(四) 提升平台的数据管理能力"></a>(四) 提升平台的数据管理能力</h1><p>为了满足中国企业业务人员用户对数据处理的需求，中国大数据BI平台需要提升自身的元数据管理能力、数据的ETL处理能力、数据存储能力。</p><p>提高元数据管理能力，使得用户能够集中管理元数据，包括对元数据进行检索、提取、处理、存储、分享复用和对外发布。中国企业的业务人员将需要在数据分析的过程中，直接操作经过IT人员标准化处理的元数据。</p><p>近几年来，中国数据分析人才迅速增加，企业中也成长出一批有一定数据分析能力的业务人才，这些中国企业业务人才更多的是需要对数据进行ETL处理和存储，这就需要平台功支持用于查询、提取、转换和加载的功能，具有索引、管理、调度数据的能力。</p><h1 id="五-提升平台分析的共享能力"><a href="#五-提升平台分析的共享能力" class="headerlink" title="(五) 提升平台分析的共享能力"></a>(五) 提升平台分析的共享能力</h1><p>随着ERP、OA、MES、HIS等常见业务系统的完善，企业少则数十套IT系统，多则上千套系统。新型自助BI需要能够与多个系统同时融合，全面分析企业的业务数据。这就需要中国大数据BI产品需要加强产品与不同软件系统的集成融合能力，这是中国企业面临的共同难题。大数据BI平台需要支持嵌入式部署，如主流的应用服务器，支持跨平台的权限集成和页面集成。</p><p>大数据BI平台不同用户创建的分析页面，可以方便地分享给其他成员。同时，在企业的分析用户设计仪表板时，可以复用仪表板中的图表、维度、指标等，支持用户分享指定页面进行给其他部门成员，便于互动沟通交流。</p><p>为满足企业人员实时办公、互通信息的需要。大数据BI平台还需要支持移动端上共享和查看分析结果，支持在移动端对分析结果进行数据层级钻取穿透、联动等。</p><h1 id="六-提升平台的安全性"><a href="#六-提升平台的安全性" class="headerlink" title="(六) 提升平台的安全性"></a>(六) 提升平台的安全性</h1><p>为了满足企业多级部门同时使用、不同权限的功能，中国大数据BI产品除了要提供灵活丰富的用户管理功能、权限控制功能，还需要内置强大的用户行为监控与分析功能，确保企业的数据安全和信息保密。</p><p>大数据BI平台将支持持批量导入用户，支持同步企业统一权限管理数据库中的用户，以企业IT系统统一的用户管理方式进行用户管理。支持用户以企业IT系统统一的用户权限认证方式进行权限管理。同时，需要支持短信平台功能，并可用于用户账号身份验证等，多种用户和权限管理方式，来满足广大中国企业的不同的安全级别要求和安全管理策略。</p><p>随着大数据BI在中国的发展，中国企业自身的大数据BI平台已有众多员工账号。这就对大数据BI平台提出新的挑战，除了要拦截非法用户，还要对大数据BI平台有效用户进行有效监控。2018年，大数据BI平台需要支持监控用户的操作行为，支持监控页面被访问的频次、访问来源，甚至是支持监控访问到的数据范围。</p><p>为了保证大数据 BI平台系统持续支持企业经营管理，需要大数据BI平台支持系统数据迁移到企业数据库，支持对系统进行备份与还原，备份可以手动或设置周期定时备份。同时，支持云端服务器部署和本地服务器部署，支持多机热备，达到企业的灾备要求。此外，为了有效避免BI平台出现严重异常，还需要支持监控自身的运行性能，遇到系统性能风险，提前给出系统预警信号。</p><p>本文来源「帆软数据应用研究院」</p><p>声明：本文来自数据观，版权归作者所有。文章内容仅代表作者独立观点，不代表安全内参立场，转载目的在于传递更多信息。如有侵权，请联系 <a href="mailto:&#97;&#x6e;&#113;&#117;&#97;&#x6e;&#110;&#x65;&#x69;&#99;&#x61;&#x6e;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#x6d;">&#97;&#x6e;&#113;&#117;&#97;&#x6e;&#110;&#x65;&#x69;&#99;&#x61;&#x6e;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#x6d;</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://www.secrss.com/articles/1114&quot;&gt;《2018年中国大数据BI行业分析报告》（全文）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近年来，随着人们的数据意识和数据素养不断提升，商业智能（BI，Business Intelligenc</summary>
      
    
    
    
    
    <category term="杂谈" scheme="https://jenna233.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>商务智能概览</title>
    <link href="https://jenna233.github.io/2023/04/07/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E6%A6%82%E8%A7%88/"/>
    <id>https://jenna233.github.io/2023/04/07/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E6%A6%82%E8%A7%88/</id>
    <published>2023-04-07T12:25:35.000Z</published>
    <updated>2023-04-07T12:26:10.263Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://www.tableau.com/learn/articles/business-intelligence">Business intelligence: A complete overview</a><br>对于企业来说，清楚地了解所有数据以保持竞争力变得越来越重要，而这正是商业智能 (BI) 工具的用武之地。毕竟，近 50% 的企业已经在使用 BI 工具，而且预测显示在持续增长 未来几年。</p><p>但对于那些尚未采用某种工具或只是想了解更多信息的人来说，可能很难准确理解什么是 BI。 我们创建了这个完整的指南来教育人们了解 BI 是什么、它是如何工作的等等。</p><p>在本文中，我们涵盖：</p><ol><li>什么是商业智能？</li><li>BI 是如何工作的？</li><li>商业智能的好处</li><li>BI的例子</li><li>如何创建 BI 策略</li><li>BI分析的分类</li><li>BI的优缺点</li><li>BI 平台</li><li>BI和大数据</li><li>BI 的未来角色</li><li>自助式BI</li><li>进一步学习</li></ol><h1 id="1-什么是商业智能？"><a href="#1-什么是商业智能？" class="headerlink" title="1. 什么是商业智能？"></a>1. 什么是商业智能？</h1><p>商业智能结合了业务分析、数据挖掘、数据可视化、数据工具和基础设施以及最佳实践，以帮助组织做出更多数据驱动的决策。在实践中，当您全面了解组织的数据并使用该数据推动变革、消除低效率并快速适应市场或供应变化时，您就知道自己拥有现代商业智能。现代 BI 解决方案优先考虑灵活的自助服务分析、受信任平台上的受控数据、授权业务用户以及快速获得洞察力。</p><p>重要的是要注意，这是对 BI 的一个非常现代的定义，而 BI 作为一个流行词有着被扼杀的历史。传统的商业智能，大写字母等等，最初出现于 1960 年代，作为跨组织共享信息的系统。商业智能一词与用于决策的计算机模型一起于 1989 年被创造出来。这些程序进一步发展，将数据转化为洞察力，然后成为具有依赖 IT 的服务解决方案的 BI 团队的特定产品。本文将作为BI的介绍，是冰山一角。</p><h1 id="2-商业智能如何运作"><a href="#2-商业智能如何运作" class="headerlink" title="2. 商业智能如何运作"></a>2. 商业智能如何运作</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-e2538062d7048afa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>企业和组织有问题和目标。 为了回答这些问题并跟踪这些目标的绩效，他们收集必要的数据，对其进行分析，并确定要采取哪些行动来实现他们的目标。</p><p>在技术方面，原始数据是从业务系统收集的。 数据经过处理，然后存储在数据仓库、云、应用程序和文件中。 存储后，用户可以访问数据，开始分析过程以回答业务问题。</p><p>BI 平台还提供数据可视化工具，可将数据转换为图表或图形，并呈现给任何关键利益相关者或决策者。</p><h1 id="3-BI方法"><a href="#3-BI方法" class="headerlink" title="3. BI方法"></a>3. BI方法</h1><p>商业智能不仅仅是一个特定的“事物”，它还是一个总称，涵盖了从业务运营或活动中收集、存储和分析数据以优化绩效的过程和方法。所有这些都汇集在一起，形成了一个全面的业务视图，帮助人们做出更好的、可操作的决策。在过去几年中，商业智能已经发展到包括更多流程和活动以帮助提高绩效。这些过程包括：</p><ul><li>数据挖掘：使用数据库、统计数据和机器学习 (ML) 来揭示大型数据集中的趋势</li><li>报告：与利益相关者共享数据分析，以便他们得出结论并做出决策</li><li>性能指标和基准测试：将当前性能数据与历史数据进行比较，以根据目标跟踪性能，通常使用自定义仪表板</li><li>描述性分析：使用初步数据分析找出发生了什么</li><li>查询：询问特定于数据的问题，BI 从数据集中提取答案</li><li>统计分析：从描述性分析中获取结果，并使用统计数据进一步探索数据，例如这种趋势是如何发生的以及为什么发生</li><li>数据可视化：将数据分析转化为图表、图形和直方图等可视化表示，以更轻松地使用数据</li><li>视觉分析：通过视觉叙事探索数据，即时交流见解并保持分析流程</li><li>数据准备：汇集多个数据源，确定维度和度量，为数据分析做准备</li></ul><h1 id="4-BI、数据分析和业务分析如何协同工作"><a href="#4-BI、数据分析和业务分析如何协同工作" class="headerlink" title="4. BI、数据分析和业务分析如何协同工作"></a>4. BI、数据分析和业务分析如何协同工作</h1><p>商业智能包括数据分析和业务分析，但仅将它们用作整个过程的一部分。 BI帮助用户从数据分析中得出结论。数据科学家深入研究数据的细节，使用高级统计和预测分析来发现模式和预测未来模式。</p><p>数据分析会问：“为什么会发生这种情况，接下来会发生什么？”商业智能采用这些模型和算<br>法并将结果分解为可操作的语言。根据 Gartner 的 IT 词汇表，“业务分析包括数据挖掘、预测分析、应用分析和统计。”简而言之，组织将业务分析作为其更大的商业智能战略的一部分。</p><p>BI 旨在回答特定查询并为决策或计划提供一目了然的分析。但是，公司可以使用分析过程来不断改进后续问题和迭代。业务分析不应该是一个线性过程，因为回答一个问题可能会导致后续问题和迭代。相反，将该过程视为数据访问、发现、探索和信息共享的循环。这称为分析周期，这是一个现代术语，解释了企业如何使用分析来应对不断变化的问题和期望。</p><h1 id="5-传统BI与现代BI的区别"><a href="#5-传统BI与现代BI的区别" class="headerlink" title="5. 传统BI与现代BI的区别"></a>5. 传统BI与现代BI的区别</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-85a1f28b66ffdbff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>现代 BI 优先考虑自助服务分析和洞察速度。</p><p>从历史上看，商业智能工具基于传统的商业智能模型。这是一种自上而下的方法，其中商业智能由 IT 组织驱动，并且大多数（如果不是全部）分析问题通过静态报告得到回答。这意味着如果有人对他们收到的报告有后续问题，他们的请求将进入报告队列的底部，他们将不得不重新开始该过程。这导致报告周期缓慢、令人沮丧，而且人们无法利用当前数据做出决策。</p><p>传统的商业智能仍然是定期报告和回答静态查询的常用方法。然而，现代商业智能是交互式的、易于理解的。虽然 IT 部门仍然是管理数据访问的重要部分，但多个级别的用户可以自定义仪表板并在很少通知的情况下创建报告。使用合适的软件，用户可以可视化数据并回答他们自己的问题。</p><h1 id="6-商业智能的好处"><a href="#6-商业智能的好处" class="headerlink" title="6. 商业智能的好处"></a>6. 商业智能的好处</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-21a34513ca7e5970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>Great BI 帮助企业和组织提出和回答有关其数据的问题。</p><p>现在您知道什么是 BI 及其工作原理了。 但是 BI 如何真正帮助企业？</p><p>BI 不仅仅是软件——它是一种保持所有相关业务数据的整体和实时视图的方法。 实施 BI 提供了无数好处，从更好的分析到增加竞争优势。 一些主要的商业智能优势包括：</p><ul><li>数据清晰度</li><li>提高效率</li><li>更好的客户体验</li><li>提高员工满意度</li></ul><h1 id="7-BI的例子"><a href="#7-BI的例子" class="headerlink" title="7. BI的例子"></a>7. BI的例子</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-6f6bbf08cb0e6128.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>Tableau 的“解释数据”功能有助于快速识别异常值和数据趋势的可能解释。</p><p>许多不同的行业都率先采用了企业 BI，包括医疗保健、信息技术和教育。所有组织都可以使用数据来转变运营。鉴于本文中和在线提供的信息如此之多，可能很难理解 BI 的确切功能。现实世界的例子可以提供帮助，这就是为什么我们根据客户的成功故事构建案例研究。</p><p>例如，金融服务公司 Charles Schwab 使用商业智能来全面了解其在美国的所有分支机构，以了解绩效指标并确定机会领域。通过访问中央商业智能平台，Schwab 可以将其分支机构数据整合到一个视图中。现在，分行经理可以识别出投资需求可能发生变化的客户。领导层可以跟踪某个地区的绩效是高于还是低于平均水平，然后点击查看推动该地区绩效的分支机构。这会带来更多的优化机会以及为客户提供更好的客户服务。</p><p>另一个例子是餐包服务 HelloFresh，它自动化了报告流程，因为它的数字营销团队每个月在这上面花费了太多时间。在 Tableau 的帮助下，HelloFresh 每天为团队节省了 10 到 20 个工作小时，并使他们能够创建更加细分和有针对性的营销活动。</p><h1 id="8-如何制定商业智能战略"><a href="#8-如何制定商业智能战略" class="headerlink" title="8. 如何制定商业智能战略"></a>8. 如何制定商业智能战略</h1><p>BI 策略是您成功的蓝图。 您需要决定如何使用数据、收集关键角色并在初始阶段定义职责。 从高层次上讲，这听起来很简单； 但是，从业务目标开始是您成功的关键。</p><p>以下是如何从头开始创建 BI 策略：</p><ul><li>了解您的业务战略和目标。</li><li>确定关键利益相关者。</li><li>从您的主要利益相关者中选择赞助商。</li><li>选择您的 BI 平台和工具。</li><li>创建一个 BI 团队。</li><li>定义你的范围。</li><li>准备您的数据基础架构。</li><li>定义您的目标和路线图。</li></ul><h1 id="9-BI分析的分类"><a href="#9-BI分析的分类" class="headerlink" title="9. BI分析的分类"></a>9. BI分析的分类</h1><p>BI 分析分为三种主要类型，涵盖许多不同的需求和用途。 这些是预测分析、描述分析和规范分析。</p><p>预测分析采用历史和实时数据并对未来结果进行建模以用于规划目的。 描述性分析是使用历史和当前数据识别数据趋势和关系的过程。 规范分析利用所有相关数据来回答“我的企业应该做什么？”这个问题。</p><h1 id="10-BI的优缺点"><a href="#10-BI的优缺点" class="headerlink" title="10. BI的优缺点"></a>10. BI的优缺点</h1><p>我们已经介绍了 BI 的许多优点。 但与任何重大业务决策一样，实施 BI 会遇到一些困难和缺点，尤其是在实施阶段。</p><p>BI 的一些优点包括：</p><ul><li>数据可见性</li><li>准确的报告</li><li>简化流程</li></ul><p>BI 的缺点包括：</p><ul><li>初始投资成本</li><li>用户抵制</li><li>数据技能差距</li></ul><h1 id="11-商业智能平台"><a href="#11-商业智能平台" class="headerlink" title="11. 商业智能平台"></a>11. 商业智能平台</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-75b6ebde766d74b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可视化分析让您处于数据分析流程中。</p><p>许多自助式商业智能工具和平台简化了分析过程。 这使人们更容易查看和理解他们的数据，而无需自己挖掘数据的技术知识。 有许多 BI 平台可用于临时报告、数据可视化以及为多个级别的用户创建自定义仪表板。 我们概述了评估现代 BI 平台的建议，以便您可以为您的组织选择合适的平台。 呈现商业智能的一种更常见的方式是通过数据可视化。</p><h1 id="12-如何选择BI平台"><a href="#12-如何选择BI平台" class="headerlink" title="12. 如何选择BI平台"></a>12. 如何选择BI平台</h1><p>成功实施 BI 的关键是为工作选择合适的平台。 在选择工具时，最好记住哪些关键功能对您的业务最有帮助。 BI 工具的一些主要功能包括：</p><ul><li>使用直观</li><li>各种仪表板和可视化选项</li><li>聪明的见解</li><li>好指标和坏指标的警报</li><li>内置人工智能 (AI)</li><li>部署灵活性</li><li>与其他平台和应用程序集成</li><li>数据连接</li><li>嵌入业务应用程序</li></ul><h1 id="13-BI-仪表板"><a href="#13-BI-仪表板" class="headerlink" title="13. BI 仪表板"></a>13. BI 仪表板</h1><p>可以说，BI 中最有用的工具之一是仪表板，它允许在一个地方聚合和查看复杂的数据。 这些仪表板可以有不同的目的，例如用于复杂的分析或利益相关者的支持。 挑战在于构建满足您需求的最佳仪表板。</p><p>BI 仪表板的主要功能是：</p><ul><li>互动性</li><li>实时数据</li><li>可定制的界面</li><li>标准模板</li><li>分享能力</li></ul><h1 id="14-BI和大数据"><a href="#14-BI和大数据" class="headerlink" title="14. BI和大数据"></a>14. BI和大数据</h1><p>随着数据环境的发展以及数据的收集、存储和分析变得更加复杂，考虑 BI 与大数据之间的关系变得很重要。 大数据最近在业界有点流行，那么大数据到底是什么呢？ 好吧，数据专家通过“四个 V”来定义它：数量、速度、价值和多样性。 这四个定义了大数据并将其区分开来。 特别是，容量是人们通常指出的主要决定因素，因为数据量不断增加并且相对容易长期存储。</p><p>可以想象，这对于 BI 很重要，因为企业每年都会创建越来越多的数据，而 BI 平台必须跟上对它们不断增长的需求。 一个好的平台会随着需求的增加而增长。 但如果不加以维护，仪表板和数据源可能会随着大数据的发展而落后。</p><h1 id="15-商业智能的未来作用"><a href="#15-商业智能的未来作用" class="headerlink" title="15. 商业智能的未来作用"></a>15. 商业智能的未来作用</h1><p>商业智能不断发展以跟上业务需求和技术的步伐，因此每年我们都会确定当前趋势，让用户了解最新的创新。 意识到人工智能和机器学习将继续发展，企业可以将 AI 的洞察力整合到更广泛的 BI 战略中。 随着公司努力变得更加数据驱动，共享数据和协作的努力将会增加。 数据可视化对于跨团队和部门的合作将更加重要。 本文只是对商业智能世界的介绍。 BI 提供近乎实时的销售跟踪功能，使用户能够深入了解客户行为、预测利润等。 零售、保险和石油等不同行业都采用了 BI，并且每年都有更多行业加入。 BI 平台适应新技术及其用户的创新。</p><h1 id="16-为您的公司使用自助式商业智能-SSBI"><a href="#16-为您的公司使用自助式商业智能-SSBI" class="headerlink" title="16. 为您的公司使用自助式商业智能 (SSBI)"></a>16. 为您的公司使用自助式商业智能 (SSBI)</h1><p>如今，越来越多的组织正在转向现代商业智能模型，其特点是对数据的自助服务方法。 自助式商业智能 (SSBI) 的特点是 IT 管理数据（安全性、准确性和访问），允许用户直接与其数据交互。 Tableau 等现代分析平台可帮助组织处理分析周期中的每一步——Tableau Prep 中的数据准备、Tableau Desktop 中的分析和发现，以及 Tableau Server 或 Tableau Cloud 中的共享和治理。 这意味着 IT 可以管理数据访问，同时让更多人能够直观地探索他们的数据并分享他们的见解。</p><h1 id="17-了解有关商务智能的更多信息"><a href="#17-了解有关商务智能的更多信息" class="headerlink" title="17. 了解有关商务智能的更多信息"></a>17. 了解有关商务智能的更多信息</h1><p>尽管本文涵盖了很多关于商业智能及其各种应用程序的基础知识，但还有很多东西需要学习。 我们的专家总是在扩展他们的知识并紧跟当前趋势。</p><p>为了鼓励数据学习，我们编制了进一步学习资源列表。 如果您想更深入地了解 BI 的理论和历史，请查看我们的最佳 BI 书籍列表。 要跟上最新的新闻和见解，请查看我们要关注的最佳 BI 博客列表。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://www.tableau.com/learn/articles/business-intelligence&quot;&gt;Business intelligence: A complete overview&lt;/a&gt;&lt;br&gt;对于企业来说，清楚地了解所</summary>
      
    
    
    
    
    <category term="杂谈" scheme="https://jenna233.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>盘点程序员必须了解的十大最佳AI库及框架</title>
    <link href="https://jenna233.github.io/2022/11/21/%E7%9B%98%E7%82%B9%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%8D%81%E5%A4%A7%E6%9C%80%E4%BD%B3AI%E5%BA%93%E5%8F%8A%E6%A1%86%E6%9E%B6/"/>
    <id>https://jenna233.github.io/2022/11/21/%E7%9B%98%E7%82%B9%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%8D%81%E5%A4%A7%E6%9C%80%E4%BD%B3AI%E5%BA%93%E5%8F%8A%E6%A1%86%E6%9E%B6/</id>
    <published>2022-11-21T08:43:15.000Z</published>
    <updated>2022-11-21T08:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://www.huoban.com/news/post/1393.html">盘点程序员必须了解的十大最佳AI库及框架</a></p><p>眼下，AI 已经成为越来越火的一个方向，程序员对于新技术是最敏感的一个人群，作为一名程序员如何转向人工智能方向?</p><p>本文将向您介绍一些在人工智能(AI)领域常被使用的优质软件库，并且分析它们的优/劣势和自身特点。</p><p>虽然 AI 曾经被称为只有书呆子和天才才去触碰的专业领域，但是现如今由于各种软件库和框架的发展，它已成为一个更加开放的 IT 领域，很多人都已投身于其中。</p><p>现在就让我们来深入了解和探索这个纷繁的 AI 库的世界吧!</p><h3 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h3><p>“通过使用数据流图的计算，来实现可扩展的<a href="https://www.huoban.com/news/tags-258.html">机器学习</a>”，语言：C++ 或 Python。<br>当提到 AI 的时候，您首先听到的框架应该就是谷歌的 TensorFlow。</p><p>TensorFlow 是使用数据流图来执行数值计算的开源库。该框架的特点是它可以利用任何 CPU 或 GPU 进行计算，无论是<a href="https://www.huoban.com/news/tags-780.html">台式机</a>、<a href="https://www.huoban.com/news/tags-16.html">服务器</a>、甚至是移动设备的架构都可以实现。这个框架中提供了 Python 语言的编程环境。</p><p>TensorFlow 通过所谓的各种节点来分类数据层，并对它所获得的任何信息做出判定。<br>想了解更多相关信息，可以参看：<a href="https://www.tensorflow.org/">https://www.tensorflow.org/</a></p><p><strong>优势：</strong></p><ul><li>使用一种简单易学的语言–Python。</li><li>采用计算图形的抽象。</li><li>由 TensorBoard 提供可视化。</li></ul><p><strong>劣势：</strong></p><ul><li>由于 Python 并非是最快的语言，因此该软件库运行起来并不快。</li><li>缺乏各种预先训练好(pre-trained)的模型。</li><li>并非完全开源。</li></ul><h3 id="微软-CNTK"><a href="#微软-CNTK" class="headerlink" title="微软 CNTK"></a>微软 CNTK</h3><p>“一个开源的深度学习工具包”，语言：C++。<br>我们可以称之为微软对于谷歌 TensorFlow 的“回应”。</p><p>微软的计算网络工具包(Microsoft’s Computational Network ToolKit，CNTK)是一种能够提高模块化和分离式计算网络的软件库，它还提供了各种学习算法和模型的描述。<br>在需要有大量服务器参与运行的时候，CNTK 可以利用多台服务器来同步实现。虽然据说它在功能上将会对谷歌 TensorFlow 有所屏蔽，但现在看来还为时过早。</p><p>想了解更多相关信息，可以参看：<a href="https://github.com/Microsoft/CNTK">https://github.com/Microsoft/CNTK</a></p><p><strong>优势：</strong></p><ul><li>非常灵活。</li><li>可实现分布式的训练。</li><li>支持 C++，C#，Java 和 Python。</li></ul><p><strong>劣势：</strong></p><ul><li><p>它是由一种新的语言–网络描述语言(NetworkDescription Language，NDL)来实现。</p></li><li><p>可视化不足。</p></li></ul><h3 id="Theano"><a href="#Theano" class="headerlink" title="Theano"></a>Theano</h3><p>“一种数值计算的软件库”，语言：Python。<br>Theano 是 TensorFlow 的强有力竞争者。它是一个功能强大的 Python 库，能够高效地实现与各种多维数组有关的数值运算。<br>该软件库能够准确地使用 GPU 来执行各种数据密集型的计算，而不会在运行中给 CPU 增加负担。<br>出于这个原因，在近十年来，Theano 一直被运用于供电系统内部各种大规模的计算密集型操作。<br>不过在 2017 年 9 月，Theano 宣布将在 2017 年 11 月的最后一次重要发布之后，对其 1.0 版本停止更新。</p><p>当然，这并不意味着它在功能上会有所逊色，只要您愿意，对它随时展开研究都是值得的。<br>想了解更多相关信息，可以参看：<a href="https://github.com/Theano/Theano">https://github.com/Theano/Theano</a></p><p><strong>优势：</strong></p><ul><li>对 CPU 和 GPU 的使用进行了适当的优化。</li><li>高效的数字任务处理能力。</li></ul><p><strong>劣势：</strong></p><ul><li>原生的 Theano 相对于其他软件库的水平较低，需要与其他软件库一起使用，以获得较高的抽象水平。</li><li>在 AWS 上运行时会有一些 Bug。</li></ul><h3 id="Caffe"><a href="#Caffe" class="headerlink" title="Caffe"></a>Caffe</h3><p>“深度学习的开放式框架，且速度快”，语言：C++。<br>Caffe 是一个功能强大的深度学习框架。和上述列表中的其他框架相比，它能够实现快速和有效的深度学习式研究。</p><p>通过Caffe，您可以非常容易地为图像分类，建立卷积神经网络(convolutional neural network，CNN)。Caffe 能够有效地工作在 GPU 上，并且在运行过程中能够发挥极快的速度。<br>想了解更多相关信息，可以参看：<a href="http://caffe.berkeleyvision.org/">http://caffe.berkeleyvision.org/</a></p><p>Caffe 的主要类包括：</p><p><strong>优势：</strong></p><ul><li>可与 Python 和 MATLAB 绑定。</li><li>运行性能极佳。</li><li>无需编写代码，便可实现对各个模型的训练。</li></ul><p><strong>劣势：</strong></p><ul><li>对复发性的网络(recurrent networks)支持不佳。</li><li>与新架构的协同性不好。</li></ul><h3 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h3><p>“为人类的深度学习而打造”，语言：Python。<br>Keras 是一个用 Python 编写的开源神经网络库。不像 TensorFlow、CNTK 和 Theano，Keras 并不服务于端到端的机器学习框架。<br>相反地，作为一个接口，它提供了一个高层次的抽象，这使得无论是在什么样的框架下，神经网络都能够方便地进行配置。<br>目前谷歌 TensorFlow 能够将 Keras 作为后端予以支持，而微软的 CNTK 是否会在将来支持 Keras，则暂无时间表。<br>想了解更多相关信息，可以参看：<a href="https://keras.io/">https://keras.io/</a></p><p><strong>优势：</strong></p><ul><li>用户友好且容易上手。</li><li>容易扩展。</li><li>无缝运行在 CPU 和 GPU 上。</li><li>能与 Theano 和 TensorFlow 无缝协作。</li></ul><p><strong>劣势：</strong></p><ul><li>无法作为一个独立的框架被使用。</li></ul><h3 id="Torch-火炬"><a href="#Torch-火炬" class="headerlink" title="Torch(火炬)"></a>Torch(火炬)</h3><p>“一个开源的机器学习库”，语言：C。<br>Torch 是一个为科研和数值运算打造的、开源的机器学习库。它基于的是 Lua 编程语言，而非 Python 库。通过提供大量的算法，它不但使得深度学习研究更为容易，而且能提高效率和速度。<br>Torch 具有强大的 N 维阵列，这对于诸如切片和索引等操作是非常有用的。它还提供了线性代数的程序和神经网络的模型。</p><p>想了解更多相关信息，可以参看：<br><a href="http://torch.ch/">http://torch.ch/</a></p><p><strong>优势：</strong></p><ul><li>非常灵活。</li><li>有极高的速度和效率。</li><li>具有大量的预先训练好的模型。</li></ul><p><strong>劣势：</strong></p><ul><li>文档不清。</li><li>缺少即插即用的代码。</li><li>基于的是一种不那么流行的语言–Lua。</li></ul><h3 id="Accord-NET"><a href="#Accord-NET" class="headerlink" title="Accord.NET"></a>Accord.NET</h3><p>“支持机器学习、计算机视觉、统计、以及使用.NET的科学计算”，语言：C#。<br>这是为C#程序员准备的软件库，Accord.NET 是一种 .NET 的机器学习框架，它方便了音频和图像的各种处理。<br>该框架可以有效地处理数值优化、人工神经网络、甚至可视化等方面。除此之外，Accord.NET 在计算机视觉和信号处理上也具有强大的功能，而且通过一些简单的算法就能实现。<br>想了解更多相关信息，可以参看：<a href="http://accord-framework.net/">http://accord-framework.net/</a></p><p><strong>优势：</strong></p><ul><li>它拥有一个庞大且活跃的开发团队。</li><li>具有非常好的文档框架。</li><li>可实现质量可视化。</li></ul><p><strong>劣势：</strong></p><ul><li>该框架并不是非常流行。</li><li>比 TensorFlow 要运行得缓慢一些。</li></ul><h3 id="Spark-MLlib"><a href="#Spark-MLlib" class="headerlink" title="Spark MLlib"></a>Spark MLlib</h3><p>“一个可扩展的机器学习库”，语言：Scala。<br>Apache 的 Spark MLlib 是一个极具扩展性的机器学习库。它支持的编程语言有 Java、Scala、Python、甚至是 R 语言。<br>它能够非常有效地通过 Python 和 R 语言的 Numpy 库(译者注：NumPy 系统是 Python 的一种开源的数值计算扩展)进行交互操作。<br>MLlib 能够很容易地被植入到 Hadoop 的工作流中。它还能提供诸如分类、回归、归并等机器学习的算法。在涉及到大规模数据处理时，这款功能强大的软件库运行起来非常快。</p><p>想了解更多相关信息，可以参看：<a href="https://spark.apache.org/mllib/">https://spark.apache.org/mllib/</a></p><p><strong>优势：</strong></p><ul><li>能极快速地处理大规模的数据。</li><li>支持多种语言。</li></ul><p><strong>劣势：</strong></p><ul><li>学习曲线“陡峭”(即不易学习)。</li><li>只能对 Hadoop 实现即插即用。</li></ul><h3 id="Sci-kitLearn"><a href="#Sci-kitLearn" class="headerlink" title="Sci-kitLearn"></a>Sci-kitLearn</h3><p>“使用 Python 进行机器学习”，语言：Python。<br>SCI-Kit 是一款主要用于在机器学习中构建各类模型的、非常强大的 Python 库。<br>通过使用诸如 Numpy、SciPy 和 Matplotlib 之类的库，它对于诸如分类、回归、归并等统计模型非常有效。SCI-Kit 还能为您带来监管式与无监管式的学习算法、以及交叉验证等功能。</p><p>想了解更多相关信息，可以参看：<a href="http://scikit-learn.org/">http://scikit-learn.org/</a></p><p><strong>优势：</strong></p><ul><li>能支持许多主流的算法。</li><li>提供有效的数据挖掘。</li></ul><p><strong>劣势：</strong></p><ul><li>对于构建模型来说并非是最好的。</li><li>使用 GPU 时，效果并非最佳。</li></ul><h3 id="MLPack"><a href="#MLPack" class="headerlink" title="MLPack"></a>MLPack</h3><p>“一个可扩展的 C++ 类型机器学习库”，语言：C++。<br>MLPack 是一款利用 C++ 来实现可扩展机器学习的软件库。由于它运行在 C++ 中，因此您完全可以想象到它对内存的高效管理。<br>由于在库中自带优质的机器学习算法，MLPack 运行起来速度极快。另外，该软件库对于新手来说十分“友好”，它提供了一个简单的 API。</p><p>想了解更多相关信息，可以参看：<a href="http://mlpack.org/">http://mlpack.org/</a></p><p><strong>优势：</strong></p><ul><li>扩展性极强。</li><li>提供 Python 和 C++ 的绑定。</li></ul><p><strong>劣势：</strong></p><ul><li>没有优质的文档。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文在此所讨论到的各种软件库都是在大家长期使用之后，备受好评且高质量的。<br>像 Facebook、谷歌、雅虎、苹果和微软这样的大公司已经将它们运用到了各自的深度学习和机器学习的项目中。您还有什么理由不去试试呢?</p><p>开发者 AI</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://www.huoban.com/news/post/1393.html&quot;&gt;盘点程序员必须了解的十大最佳AI库及框架&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;眼下，AI 已经成为越来越火的一个方向，程序员对于新技术是最敏感的一个人群，作为一名程序员如何转向</summary>
      
    
    
    
    
    <category term="架构" scheme="https://jenna233.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>十分钟了解人工智能AI的基础运作原理</title>
    <link href="https://jenna233.github.io/2022/11/21/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BDAI%E7%9A%84%E5%9F%BA%E7%A1%80%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://jenna233.github.io/2022/11/21/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BDAI%E7%9A%84%E5%9F%BA%E7%A1%80%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2022-11-21T08:42:17.000Z</published>
    <updated>2022-11-21T08:42:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://cloud.tencent.com/developer/news/296050">十分钟了解人工智能AI的基础运作原理</a></p><h2 id="人工智能是如何运作的"><a href="#人工智能是如何运作的" class="headerlink" title="人工智能是如何运作的"></a>人工智能是如何运作的</h2><p>人工智能企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。人工智能从诞生以来，理论和技术日益成熟，应用领域也不断扩大，可以预见未来几年将会进入“人工智能时代”。</p><p>目前AI已经在日常生活中产生了巨大的变化。<strong>这些AI并不是科幻电影中的那些有自我意识，计划摧毁地球的机器人。</strong>而是像我们的智能手机、智能家居、银行信用卡管家和智能汽车这些围绕我们每天生活的产品和服务都在使用AI。</p><p> AI将通过推动自动驾驶汽车的发展、改善医学图像分析、促进更好的医疗诊断和个性化医疗，从而带来社会的重大转变。<strong>AI也将是支撑未来技术发展的基础资源，就像电力和网络一样。</strong>但对大部分人来说，AI还是很诡异而且充满神秘感。</p><p><strong>那么我们今天就来聊一聊AI最重要的功能——模式识别的工作原理。</strong>希望通过简明扼要的介绍帮助大家了解这个领域。</p><p>AI是一门严谨科学而不是无所不能神话故事，有些媒体过分夸大报道AI的功能，鼓吹威胁论都是不负责任的。AI目标是设计具有智能的机器，其中的算法和技术部分借鉴了当下对人脑的研究成果。<strong>今天许多流行的AI系统使用人工神经网络来模拟由非常简单的互相连接单元组成的网络，有点像大脑中的神经元。</strong>这些网络可以通过调整单元之间的连接来学习经验，这个过程类似人类和动物的大脑通过修改神经元之间的连接来进行学习。<strong>神经网络可以学习模式识别、翻译语言、学习简单的逻辑推理，甚至创建图像或者形成新设计。</strong> 其中，<strong>模式识别是一项特别重要的功能，因为AI十分擅于识别海量数据中的隐藏的模式，而这对于依赖经验和知识的人类来说就没有那么容易。</strong>这些程序运行的神经网络具有数百万单位和数十亿的连接。我们现在所能创造出来的“智能”就是由这些电子神经元网络组成的。</p><p>机器不像人类具有感知器官和大脑，并且能够很好地协调工作，比如当我们看到一只狗的时候，就会很快的判断出来这是什么动物，并且具体什么种类。这个看似简单的过程对于机器来说都是十分困难的。而人类获得这样的能力，也是源自于生物上亿年的进化过程。<strong>而机器认识世界的方式是通过模型，需要通过复杂的算法和数据来构建模型，从而使机器获得很简单的感知和判断的能力。</strong></p><p>下面介绍一下深度学习系统中一个最重要算法——卷积神经网络。如果你之前对AI相关知识有所了解的话，那你一定听说这个概念。这种算法参考了生物学研究人类和其他动物大脑视觉皮层的结构。简单介绍一下这种特定类型的人工神经网络，<strong>它使用感知器、机器学习单元算法，用于监督学习分析数据。适用于图像处理、自然语言处理和其他类型的认知任务。</strong>与其他类型的人工神经网络一样，卷积神经网络具有输入层、输出层和各种隐藏层。其中一些层是卷积的，使用数学模型将结果传递给连续的层。这过程模拟了人类视觉皮层中的一些动作，所以称为卷积神经网路，也就是CNN。</p><p>举例子来看，当我们人类看到一只猫和一只狗时，尽管它们的体型很类似，但我们还是马上能够区分它们分别是猫和狗。<strong>对计算机而言，图像仅仅只是一串数据。</strong>在神经网络的第一层会通过特征检测物体的轮廓。神经网络的下一层将检测<strong>这些简单图案的组合所形成的简单形状</strong>，比如动物眼睛和耳朵。<strong>再下一层将检测这些形状组合所构成的物体的某些部分</strong>，例如猫和狗的头或者腿。神经网络的最后一层将检测刚才那些部分的组合：一只完整的猫、一只完整的狗等等。每一层的神经网络都会目标进行图像组合分析和特征检测，从而进行判断和组合，并将结果传递给下一层神经网络。实际使用的神经网络的层次深度会比这个例子多很多，所以神经网络能够以这种分层的方式进行复杂的模式识别。</p><p><strong>只要有大量被标记的样本数据库，就可以对神经网络进行特征训练。它对于识别图像、视频、语音、音乐甚至文本等信息特别有用。</strong>为了很好地训练AI的机器视觉，我们需要提供给这些神经网络被人标记的大量图像数据。神经网络会学习将每个图像与其相应的标签并相互关联起来。还能将以前从未见过的图像及其相应的标签配对。这样的系统可以梳理各种各样的图像，并且识别照片中的元素。同时神经网络在语音识别和文本识别中也非常有用，自动驾驶汽车和最新医学图像分析系统中也是关键组成部分，所以你可以看到神经网络的运用是非常广泛而且有效的。<strong>原来需要依赖人工标记大量有效数据来完成知识的输入，现在通过运行海量数据，让神经网络进行自我学习。</strong>大大提升的人工智能的应用范围，降低了使用的门槛。</p><p><strong>人类大脑与动物远远不同，在进化过程中高度特化并且具有明显的适应性。而当前的AI系统远远不具有人类拥有的看似一般的智能。</strong>人工智能更高级的发展将会在后面进行讨论，我们这里还是关注现在实现的AI的基本原理。</p><h2 id="AI最常见的三种学习方式"><a href="#AI最常见的三种学习方式" class="headerlink" title="AI最常见的三种学习方式"></a>AI最常见的三种学习方式</h2><p><strong>强化学习这是关于机器应该如何行动以获得最大化奖励的问题，</strong>它受行为心理学理论的启发。在特定场景下，机器挑选一个动作或一系列动作并获得奖励。<strong>机器行为每一步骤都会被标记，并且记录结果和赋予权重。</strong>强化学习通常用于教机器玩游戏和赢得比赛，比如国际象棋、围棋或简单的视频游戏。强化学习的问题是，单纯地强化学习需要海量的试错，才能学会简单的任务。好处是只要你提出一个有价值的问题，提供足够的数据输入，理论上来说强化学习最终会找到那个最优解。</p><p><strong>监督学习就是需要我们告诉机器特定输入的正确答案：</strong> 这是一幅汽车的图像，正确答案是“汽车”。它之所以被称为监督学习，是因为算法是从带标签数据学习的。这个过程类似于向年幼的孩子展示图画书。成年人预先知道正确的答案，孩子根据前面的例子做出推测。这也是训练神经网络和其他机器学习体系结构最常用的技术。</p><p><strong>无监督学习</strong>人类和大多数其他动物的学习过程，特别是刚生下来的时候，是以没有人监督的方式来进行学习的：<strong>我们通过观察和认知我们行动的结果来了解世界如何运作。</strong>没有人告诉我们刚开始所看到的每一个物体的名称和功能。但我们仍然学会非常基本的概念，当前我们还不知道如何在机器身上实现这一点，至少无法达到人类和其他动物的水平。缺乏用于无监督学习的AI技术，也是当前AI发展问题之一。</p><p>概括来说当前AI技术原理是：<strong>将大量数据与超强的运算处理能力和智能算法三者相结合起来，建立一个解决特定问题的模型，使程序能够自动地从数据中学习潜在的模式或特征，从而实现接近人类的思考方式。</strong>下面补充介绍三个AI研究领域重要的理论方法和技术以便理解：</p><h4 id="一、机器学习自动化分析建模"><a href="#一、机器学习自动化分析建模" class="headerlink" title="一、机器学习自动化分析建模"></a>一、机器学习自动化分析建模</h4><p>它使用来自神经网络、统计、数学和物理学的方法来发现数据中的隐藏模型，并且无需明确编程查找具体目标和范围。理论基础是这样的：假如我们为了研究某个复杂的科学问题，需要创建海量的机器学习模型、使用大量的算法、使用不同的参数配置，在这种情况下，我们就可以使用自动化的方式进行建模。发展自动化机器学习是为了向科学家提供帮助，而不是代替他们。这些方法使数据科学家摆脱了令人厌烦和复杂耗时的任务（比如详细的参数优化和调试），机器可以更好地解决这些任务。而后面的数据分析与结论的工作仍然需要人类专家来完成。<strong>在未来，理解行业应用领域的数据科学家，也就是数据业务架构师，仍然极其的重要。</strong>而这一项人工智能技术，将会辅助数据科学家建立模型并且加速验证的速度，从而减轻科学家的压力，让他们将精力放在那些机器无法完成的任务上面，<strong>通过更加合理的分工协作，大大加快科学技术研发速度。</strong></p><h4 id="二、深度学习领域"><a href="#二、深度学习领域" class="headerlink" title="二、深度学习领域"></a>二、深度学习领域</h4><p>这是应用非常广的技术，它使用具有多层处理单元的巨大神经网络，利用强大计算能力和改进的训练技术来学习大量数据中的复杂模式。<strong>原理是计算机在学习特定问题时，需要大量输入这个问题相关的学习材料也就是数据，然后在计算机通过算法和模型来构建对这个具体问题的认知，也就是总结出一个规律，</strong>那么在以后遇到相似问题时，计算机会把收集的数据转成特征值，如果这个特征值符合这前面规律里面的特征值，那么这个事物、行为或者模式，就可以被识别出来。常见的应用太多了，这里大概举一些例子：</p><p><strong>计算机视觉，这就像是机器的“眼睛”。</strong>依赖于模式识别和深度学习来识别图片或视频中的内容。当机器可以分析和理解图像时，他们可以实时捕捉图像或视频并解读周围环境。感知周围环境、识别可行驶区域以及识别行驶路径，这也是无人驾驶的基础技术。其中图像识别原理是通过识别图片中的对象，然后建立标签，实现对海量图片进行分类，也可以对图像中的人脸或者其他目标进行识别，运用在安防监控等领域；</p><p><strong>自然语言处理中语音识别技术就像是机器的“耳朵”：</strong>这是计算机分析、理解和生成人类语言和语音的能力。运用语音采集的技术和方法，对音频中的语言内容进行提取和识别，实现语音实时转文字的功能；下一阶段将会是自然语言交互，人们将可以使用普通的日常语言与计算机进行交流和执行任务。这也是AI语音助手和语音控制交互技术的基础。</p><p>机器翻译：模仿人脑理解语言的过程，形成更加符合语法规则同时更加容易被人理解的翻译，谷歌在线翻译功能就是运用了深度学习技术，让机器的翻译水平大大提升；</p><p>情感识别：通过识别新闻、社交媒体、论坛等文本内容中所包含的情感因素，<strong>及时了解网络用户对新闻的兴趣；</strong></p><p>医疗诊断：<strong>比如通过对各个阶段的肿瘤诊断这类医疗图像数据进行学习，总结出恶性肿瘤形状、纹理、结构等“特征”模型，从而使机器可以进行判断。</strong></p><p>可以看到深度学习在神经元网络的基础上，发展出了非常多的应用案例，并且当下各个行业的人工智能辅助工具和软件都在大力开发中，各种数据都在大量采集、清洗、输入模型训练，<strong>一旦训练成功就可以大规模部署，带来巨大的商业价值。</strong>具体有多大呢？参考一下人脸识别领域的独角企业估值和<strong>号称千亿的市场规模就知道了。如果这样的市场再乘以百倍、千倍呢，</strong>这里面的蕴含商业机会有多少呢？</p><h4 id="三、认知计算"><a href="#三、认知计算" class="headerlink" title="三、认知计算"></a>三、认知计算</h4><p>这也是人工智能的子领域，目标是与机器进行自然的、类似人类的交互。使用人工智能和认知计算，最终目标是让机器获得理解图像和语音的能力，模拟人类交流过程，从而实现与人类的自然对话。也是根据神经网络和深度学习来构建的，应用来自认知科学的知识来构建模拟人类思维过程的系统。它涵盖多个学科，包括机器学习、自然语言处理、视觉和人机交互。<strong>IBM Watson就是认知计算的一个例子，在美国答题竞赛节目上Watson展现了它先进的问答交互能力，并且打败了人类。</strong>与此，同时Watson这些服务应用接口也进行了开放，可提供其他组织用于视觉识别、语音识别、语言翻译以及对话引擎等等。</p><p>就像AI的产生是多学科发展的综合成果一样，当下AI的快速发展也是多方面技术进步综合起来取得的成果，总结里面重要的三个方面：</p><p>1.硬件方面：</p><p>直到本世纪初研究人员才意识到，为视频游戏设计的GPU图形处理单元可以被用作硬件加速器，以运行比以前更大的神经网络。这要归功于这些芯片能够进行大量并行计算，而不是像传统CPU那样按顺序处理它们。这对于同时计算构成深度学习神经网络的数百个神经元的权重特别有用。</p><p>2.通用算法：</p><p>AI这么快就流行起来，在很大程度上是因为开放的软件工具也称为框架，使得构建和训练一个神经网络实现目标应用程序变得容易起来，即使是使用各种不同的编程语言。对于已知的识别目标，可以离线定义和训练一个神经网络。<strong>一旦训练完成，神经网络可以很容易地部署到嵌入式平台上，也可以迁移到各种软件程序和硬件平台中。</strong>这是一个聪明的架构，允许<strong>借助PC或云的能力训练神经网络，而低功耗的嵌入式处理器只需使用训练好的数据来进行识别。</strong>人体和物体的能力与流行的应用密切相关，比如工业机器人和自动驾驶汽车。</p><p>3.其他技术支持：</p><p>图形处理单元是AI的关键，因为它们提供了迭代处理所需的大量计算能力。训练神经网络需要大数据和计算能力。而物联网从连接的设备生成大量数据，其中大部分未经分析。使用AI自动化模型将允许我们使用更多的物联网数据进行分析，将物流和信息流更好的结合起来。还有就是AI应用程序接口，可以将AI功能添加到现有产品和软件中。比如它们可以为安防视频中添加图像识别功能；也可以在我们观看网络视频时，自动创建翻译和字幕；或者是在相机中识别人物性别和年纪甚至是表情和状态等等，应用将会非常广泛。</p><p>总之，这都是AI经常使用的方法，<strong>即使我们创造了单个项目拥有超越人类智慧的机器，这些机器仍然能力有限。短期来看，人工智能将提供接近人类交互体验，</strong>并为特定任务提供辅助支持，但它还不能成为人类的替代品，有自我意识的AI还不会很快出现。</p><p>本篇是老张创作的课程《人工智能进化论课程》基础篇内容，转载需授权。</p><p>觉得有帮助的话请转发和评论~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://cloud.tencent.com/developer/news/296050&quot;&gt;十分钟了解人工智能AI的基础运作原理&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;人工智能是如何运作的&quot;&gt;&lt;a href=&quot;#人工智能是如何运作的&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="架构" scheme="https://jenna233.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>区块链原理</title>
    <link href="https://jenna233.github.io/2022/10/09/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/"/>
    <id>https://jenna233.github.io/2022/10/09/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/</id>
    <published>2022-10-09T08:57:54.000Z</published>
    <updated>2022-10-09T09:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://www.liaoxuefeng.com/wiki/1207298049439968/1311929706479649">区块链原理</a></p><p>区块链就是一个不断增长的全网总账本，每个完全节点都拥有完整的区块链，并且，节点总是信任最长的区块链，伪造区块链需要拥有超过51%的全网算力。</p><p>区块链的一个重要特性就是不可篡改。为什么区块链不可篡改？我们先来看区块链的结构。</p><p>区块链是由一个一个区块构成的有序链表，每一个区块都记录了一系列交易，并且，每个区块都指向前一个区块，从而形成一个链条：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-22af64eb38e7e101.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果我们观察某一个区块，就可以看到，每个区块都有一个唯一的哈希标识，被称为区块哈希，同时，区块通过记录上一个区块的哈希来指向上一个区块：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-cf83a62b422931e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>每一个区块还有一个Merkle哈希用来确保该区块的所有交易记录无法被篡改。</p><p>区块链中的主要数据就是一系列交易，第一条交易通常是Coinbase交易，也就是矿工的挖矿奖励，后续交易都是用户的交易。</p><p>区块链的不可篡改特性是由哈希算法保证的。</p><h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p>我们来简单介绍一下什么是哈希算法。</p><p>哈希算法，又称散列算法，它是一个单向函数，可以把任意长度的输入数据转化为固定长度的输出：</p><p>h=H(x)h=H(x)</p><p>例如，对morning和bitcoin两个输入进行某种哈希运算，得到的结果是固定长度的数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H(&quot;morning&quot;) &#x3D; c7c3169c21f1d92e9577871831d067c8</span><br><span class="line">H(&quot;bitcoin&quot;) &#x3D; cd5b1e4947e304476c788cd474fb579a</span><br></pre></td></tr></table></figure><p>我们通常用十六进制表示哈希输出。</p><p>因为哈希算法是一个单向函数，要设计一个安全的哈希算法，就必须满足：通过输入可以很容易地计算输出，但是，反过来，通过输出无法反推输入，只能暴力穷举。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H(&quot;???????&quot;) &#x3D; c7c3169c21f1d92e9577871831d067c8</span><br><span class="line">H(&quot;???????&quot;) &#x3D; cd5b1e4947e304476c788cd474fb579a</span><br></pre></td></tr></table></figure><p>想要根据上述结果反推输入，只能由计算机暴力穷举。</p><h1 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h1><p>一个安全的哈希算法还需要满足另一个条件：碰撞率低。</p><p>碰撞是指，如果两个输入数据不同，却恰好计算出了相同的哈希值，那么我们说发生了碰撞：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H(&quot;data-123456&quot;) &#x3D; a76b1fb579a02a476c789d9115d4b201</span><br><span class="line">H(&quot;data-ABCDEF&quot;) &#x3D; a76b1fb579a02a476c789d9115d4b201</span><br></pre></td></tr></table></figure><p>因为输入数据长度是不固定的，所以输入数据是一个无限大的集合，而输出数据长度是固定的，所以，输出数据是一个有限的集合。把一个无限的集合中的每个元素映射到一个有限的集合，就必然存在某些不同的输入得到了相同的输出。</p><p>哈希碰撞的本质是把无限的集合映射到有限的集合时必然会产生碰撞。我们需要计算的是碰撞的概率。很显然，碰撞的概率和输出的集合大小相关。输出位数越多，输出集合就越大，碰撞率就越低。</p><p>安全哈希算法还需要满足一个条件，就是输出无规律。输入数据任意一个bit（某个字节的某一个二进制位）的改动，会导致输出完全不同，从而让攻击者无法逐步猜测输入，只能依赖暴力穷举来破解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H(&quot;hello-1&quot;) &#x3D; 970db54ab8a93b7173cb48f55e67fd2c</span><br><span class="line">H(&quot;hello-2&quot;) &#x3D; 8284353b768977f05ac600baad8d3d17</span><br></pre></td></tr></table></figure><p>哈希算法有什么作用？假设我们相信一个安全的哈希算法，那么我们认为，如果两个输入的哈希相同，我们认为两个输入是相同的。</p><p>如果输入的内容就是文件内容，而两个文件的哈希相同，说明文件没有被修改过。当我们从网站上下载一个非常大的文件时，我们如何确定下载到本地的文件和官方网站发布的原始文件是完全相同，没有经过修改的呢？哈希算法就体现出了作用：我们只需要计算下载到本地的文件哈希，再和官方网站给出的哈希对比，如果一致，说明下载文件是正确的，没有经过篡改，如果不一致，则说明下载的文件肯定被篡改过。</p><p>大多数软件的官方下载页面会同时给出该文件的哈希值，以便让用户下载后验证文件是否被篡改：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-ab624ffe78b044b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>和文件类似，如果两份数据的哈希相同，则可以100%肯定，两份数据是相同的。比特币使用哈希算法来保证所有交易不可修改，就是计算并记录交易的哈希，如果交易被篡改，那么哈希验证将无法通过，说明这个区块是无效的。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-af4aa067766e2d55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="常用哈希算法"><a href="#常用哈希算法" class="headerlink" title="常用哈希算法"></a>常用哈希算法</h1><p>常用的哈希算法以及它们的输出长度如下：</p><table><thead><tr><th>哈希算法</th><th>输出长度(bit)</th><th>输出长度(字节)</th></tr></thead><tbody><tr><td>MD5</td><td>128 bit</td><td>16 bytes</td></tr><tr><td>RipeMD160</td><td>160 bits</td><td>20 bytes</td></tr><tr><td>SHA-1</td><td>160 bits</td><td>20 bytes</td></tr><tr><td>SHA-256</td><td>256 bits</td><td>32 bytes</td></tr><tr><td>SHA-512</td><td>512 bits</td><td>64 bytes</td></tr></tbody></table><p>比特币使用的哈希算法有两种：SHA-256和RipeMD160</p><p>SHA-256的理论碰撞概率是：尝试2的130次方的随机输入，有99.8%的概率碰撞。注意2130是一个非常大的数字，大约是1361万亿亿亿亿。以现有的计算机的计算能力，是不可能在短期内破解的。</p><p>比特币使用两种哈希算法，一种是对数据进行两次SHA-256计算，这种算法在比特币协议中通常被称为hash256或者dhash。</p><p>另一种算法是先计算SHA-256，再计算RipeMD160，这种算法在比特币协议中通常被称为hash160。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const</span><br><span class="line">    bitcoin &#x3D; require(&#39;bitcoinjs-lib&#39;),</span><br><span class="line">    createHash &#x3D; require(&#39;create-hash&#39;);</span><br><span class="line"></span><br><span class="line">function standardHash(name, data) &#123;</span><br><span class="line">    let h &#x3D; createHash(name);</span><br><span class="line">    return h.update(data).digest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hash160(data) &#123;</span><br><span class="line">    let h1 &#x3D; standardHash(&#39;sha256&#39;, data);</span><br><span class="line">    let h2 &#x3D; standardHash(&#39;ripemd160&#39;, h1);</span><br><span class="line">    return h2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hash256(data) &#123;</span><br><span class="line">    let h1 &#x3D; standardHash(&#39;sha256&#39;, data);</span><br><span class="line">    let h2 &#x3D; standardHash(&#39;sha256&#39;, h1);</span><br><span class="line">    return h2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let s &#x3D; &#39;bitcoin is awesome&#39;;</span><br><span class="line">console.log(&#39;ripemd160 &#x3D; &#39; + standardHash(&#39;ripemd160&#39;, s).toString(&#39;hex&#39;));</span><br><span class="line">console.log(&#39;  hash160 &#x3D; &#39; + hash160(s).toString(&#39;hex&#39;));</span><br><span class="line">console.log(&#39;   sha256 &#x3D; &#39; + standardHash(&#39;sha256&#39;, s).toString(&#39;hex&#39;));</span><br><span class="line">console.log(&#39;  hash256 &#x3D; &#39; + hash256(s).toString(&#39;hex&#39;));</span><br></pre></td></tr></table></figure><p>运行上述代码，观察对一个字符串进行SHA-256、RipeMD160、hash256和hash160的结果。</p><h1 id="区块链不可篡改特性"><a href="#区块链不可篡改特性" class="headerlink" title="区块链不可篡改特性"></a>区块链不可篡改特性</h1><p>有了哈希算法的预备知识，我们来看比特币的区块链如何使用哈希算法来防止交易记录被篡改。</p><p>区块本身记录的主要数据就是一系列交易，所以，区块链首先要保证任何交易数据都不可修改。</p><h4 id="Merkle-Hash"><a href="#Merkle-Hash" class="headerlink" title="Merkle Hash"></a>Merkle Hash</h4><p>在区块的头部，有一个Merkle Hash字段，它记录了本区块所有交易的Merkle Hash：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-03f1f2b3b0d1c194.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>Merkle Hash是把一系列数据的哈希根据一个简单算法变成一个汇总的哈希。</p><p>假设一个区块有4个交易，我们对每个交易数据做dhash，得到4个哈希值a1，a2，a3和a4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a1 &#x3D; dhash(tx1)</span><br><span class="line">a2 &#x3D; dhash(tx2)</span><br><span class="line">a3 &#x3D; dhash(tx3)</span><br><span class="line">a4 &#x3D; dhash(tx4)</span><br></pre></td></tr></table></figure><p>注意到哈希值也可以看做数据，所以可以把a1和a2拼起来，a3和a4拼起来，再计算出两个哈希值b1和b2：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-7a570060646e465d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>最后，把b1和b2这两个哈希值拼起来，计算出最终的哈希值，这个哈希就是Merkle Hash：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-c401b6b7833b8453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果交易的数量不恰好是4个怎么办？例如，只有3个交易时，第一个和第二个交易的哈希a1和a2可以拼起来算出b1，第三个交易只能算出一个哈希a3，这个时候，就把a3直接复制一份，算出b2，这样，我们也能最终计算出Merkle Hash：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-6f06e62a7fb77c6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果有5个交易，我们可以看到，a5被复制了一份，以便计算出b3，随后b3也被复制了一份，以便计算出c2。总之，在每一层计算中，如果有单数，就把最后一份数据复制，最后一定能计算出Merkle Hash：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-1c773155dea245f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从Merkle Hash的计算方法可以得出结论：修改任意一个交易哪怕一个字节，或者交换两个交易的顺序，都会导致Merkle Hash验证失败，也就会导致这个区块本身是无效的，所以，Merkle Hash记录在区块头部，它的作用就是保证交易记录永远无法修改。</p><h4 id="Block-Hash"><a href="#Block-Hash" class="headerlink" title="Block Hash"></a>Block Hash</h4><p>区块本身用Block Hash——也就是区块哈希来标识。但是，一个区块自己的区块哈希并没有记录在区块头部，而是通过计算区块头部的哈希得到的：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-b793aa3c255ea3ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>区块头部的Prev Hash记录了上一个区块的Block Hash，这样，可以通过Prev Hash追踪到上一个区块。</p><p>由于下一个区块的Prev Hash又会指向当前区块，这样，每个区块的Prev Hash都指向自己的上一个区块，这些区块串起来就形成了区块链。</p><p>区块链的第一个区块（又称创世区块）并没有上一个区块，因此，它的Prev Hash被设置为00000000…000。</p><p>如果一个恶意的攻击者修改了一个区块中的某个交易，那么Merkle Hash验证就不会通过。所以，他只能重新计算Merkle Hash，然后把区块头的Merkle Hash也修改了。这时，我们就会发现，这个区块本身的Block Hash就变了，所以，下一个区块指向它的链接就断掉了。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-ac4076ea1c4b03df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>由于比特币区块的哈希必须满足一个难度值，因此，攻击者必须先重新计算这个区块的Block Hash，然后，再把后续所有区块全部重新计算并且伪造出来，才能够修改整个区块链。</p><p>在后面的挖矿中，我们会看到，修改一个区块的成本就已经非常非常高了，要修改后续所有区块，这个攻击者必须掌握全网51%以上的算力才行，所以，修改区块链的难度是非常非常大的，并且，由于正常的区块链在不断增长，同样一个区块，修改它的难度会随着时间的推移而不断增加。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>区块链依靠安全的哈希算法保证所有区块数据不可更改；</p><p>交易数据依靠Merkle Hash确保无法修改，整个区块依靠Block Hash确保区块无法修改；</p><p>工作量证明机制（挖矿）保证修改区块链的难度非常巨大从而无法实现。</p><p>可以查看逐层揭秘：<a href="https://www.woshipm.com/blockchain/953408.html">区块链的运作原理、存在问题以及前景</a>, 这篇也写的不错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1207298049439968/1311929706479649&quot;&gt;区块链原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;区块链就是一个不断增长的全网总账本，每个完全节点都拥有完整的区块链，并且，节点总</summary>
      
    
    
    
    
    <category term="架构" scheme="https://jenna233.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>什么是区块链技术？</title>
    <link href="https://jenna233.github.io/2022/10/09/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%EF%BC%9F/"/>
    <id>https://jenna233.github.io/2022/10/09/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%EF%BC%9F/</id>
    <published>2022-10-09T08:56:46.000Z</published>
    <updated>2022-10-09T08:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是区块链技术？"><a href="#1-什么是区块链技术？" class="headerlink" title="1. 什么是区块链技术？"></a>1. 什么是区块链技术？</h1><p>区块链技术是一种高级数据库机制，允许在企业网络中透明地共享信息。区块链数据库将数据存储在区块中，而数据库则一起链接到一个链条中。数据在时间上是一致的，因为在没有网络共识的情况下，您不能删除或修改链条。因此，您可以使用区块链技术创建不可改变的分类账，以便跟踪订单、付款、账户和其他交易。系统内置的机制可以阻止未经授权的交易条目并在这些交易的共享视图中创建一致性。</p><h1 id="2-为什么区块链很重要？"><a href="#2-为什么区块链很重要？" class="headerlink" title="2. 为什么区块链很重要？"></a>2. 为什么区块链很重要？</h1><p>传统数据库技术为记录金融交易带来了很多难题。例如，在房地产销售领域。在交换资金后，房地产的所有权将转移给买方。买卖双方中的任何一方均可记录货币交易，但任何一方的来源均不可信。即便卖方已收款，也可轻松声称他们未收款；同样，即便买方未付款，也可辩称他们已付款。</p><p>为了避免潜在的法律问题，需要一个可信的第三方负责监督和验证交易。这种中央机构的存在，不仅会使交易复杂化，还会造成单点漏洞。如果该中央数据口遭到入侵，双方都有可能蒙受损失。</p><p>区块链通过创建去中心化的防篡改系统来记录交易，可以缓解此类问题。在房地产交易场景中，区块链可分别为买方和卖方创建一个分类账。所有交易都必须获得双方批准，并将在双方的分类账中实时更新。历史交易中的任何损坏都会导致整个分类账损坏。区块链技术的这些属性以使其用于各个行业部类，包括比特币 (Bitcoin) 等数字货币的创造。</p><h1 id="3-不同行业如何使用区块链？"><a href="#3-不同行业如何使用区块链？" class="headerlink" title="3. 不同行业如何使用区块链？"></a>3. 不同行业如何使用区块链？</h1><p>区块链是一种新兴技术，很多行业都以创新方式采用了此技术。我们将在以下小节中介绍不同行业中的一些使用案例：</p><h3 id="能源"><a href="#能源" class="headerlink" title="能源"></a>能源</h3><p>多家能源公司使用区块链技术创建点对点能源交易平台，并简化可再生能源的获得。例如，考虑以下用途：</p><ul><li>多家基于区块链的能源公司创建了交易平台，用于个人之间的电力销售。拥有太阳能电池板的业主使用此平台将其多余的太阳能销售给邻居。该流程大部分是自动化的：智能电表创建交易，区块链则记录交易。</li><li>借助基于区块链的众筹计划，用户可在缺乏能源获得途径的社区内赞助和拥有太阳能电池板。在太阳能电池板建好后，赞助商还可以向这些社区收取租金。</li></ul><h3 id="金融"><a href="#金融" class="headerlink" title="金融"></a>金融</h3><p>传统金融系统（如银行和证券交易所）使用区块链服务来管理在线支付、账户和市场交易。例如，<a href="https://aws.amazon.com/cn/solutions/case-studies/singapore-exchange-case-study/">新加坡交易所 (Singapore Exchange Limited)</a> 是一家在整个亚洲提供金融交易服务的投资控股公司，该公司使用区块链技术构建了更高效的跨行支付账户。通过采用区块链，该公司解决了多个难题，包括数千项金融交易的批处理和手动对账。</p><h3 id="媒体和娱乐"><a href="#媒体和娱乐" class="headerlink" title="媒体和娱乐"></a>媒体和娱乐</h3><p>多家媒体和娱乐公司使用区块链系统来管理版权数据。版权验证对于艺术家的公平补偿至关重要。需要多次交易才能记录版权内容的销售或转让。<a href="https://www.forbes.com/sites/amazonwebservices/2019/11/19/how-sony-is-protecting-rights-of-digital-creators-using-blockchain-on-aws/">日本索尼音乐娱乐公司 (Sony Music Entertainment Japan)</a> 使用区块链服务使数字版权管理更加高效。该公司成功使用区块链策略提高了版权处理效率并降低了成本。</p><h3 id="零售"><a href="#零售" class="headerlink" title="零售"></a>零售</h3><p>多家零售公司使用区块链跟踪商品在供应商与买家之间的转移。例如，Amazon 零售为一套分布式分类账技术系统申请了专利，该系统使用区块链技术来验证并确保在该平台上销售的所有商品均为正品。Amazon 卖家可以通过允许参与者（如制造商、快递公司、分销商、最终用户和二级用户）向证书颁发机构注册后将事件添加到分类账，映射其全球供应链。 </p><h1 id="4-区块链技术具有哪些功能？"><a href="#4-区块链技术具有哪些功能？" class="headerlink" title="4. 区块链技术具有哪些功能？"></a>4. 区块链技术具有哪些功能？</h1><p>区块链技术具有以下主要功能：</p><h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><p>区块链中的去中心化是指将控制权和决策权从中心化实体（个人、组织或团体）转让给分布式网络。去中心化区块链网络使用透明度来减少对参与者之间取得信任的需要。这些网络还以削弱网络功能性的方式，阻止参与者彼此施加权力或控制。</p><h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>不可变性是指某些内容不能更改或改变。一旦某个参与者将交易记录到共享分类账中，则任何参与者均不能篡改该交易。如果某个交易记录包含错误，则您必须添加新交易以修正错误，并且整个网络均可看见这两个交易。</p><h3 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h3><p>区块链系统将建立关于参与者就记录交易达成共识的规则。仅当网络中的大部分参与者都同意时，才能记录新交易。</p><h1 id="5-区块链技术包含哪些关键组件？"><a href="#5-区块链技术包含哪些关键组件？" class="headerlink" title="5. 区块链技术包含哪些关键组件？"></a>5. 区块链技术包含哪些关键组件？</h1><p>区块链架构包含以下主要组件：</p><h3 id="分布式分类账"><a href="#分布式分类账" class="headerlink" title="分布式分类账"></a>分布式分类账</h3><p>分布式分类账是区块链网络中用于存储交易的共享数据库，如团队中的每个人均可编辑的共享文件。在大多数共享文本编辑者中，任何拥有编辑权限的人员均可删除整个文件。但分布式分类账技术对于谁能编辑以及如何编辑具有严格规则。一旦条目已被记录，您就无法删除它们。</p><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>很多公司使用智能合约来自行管理业务合约，而不需要第三方的帮助。智能合约是存储在区块链系统上的程序，这些程序将在符合预先确定的条件时自动运行。这些程序将运行条件语句检查，以便能够放心地完成交易。例如，某家物流公司可能拥有一份智能合约，约定一旦商品抵达港口将自动进行付款。</p><h3 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h3><p>公钥加密是一种安全功能，用于唯一标识区块链网络中的参与者。此机制将为网络成员生成两组密钥。一组密钥是公钥，对于网络中的每个人都是公用的。另一组密钥是私钥，对于每个成员都是唯一的。私钥与公钥配合使用，解锁分类账中的数据。 </p><p>例如，John 和 Jill 是网络中的两个成员。John 记录了一项交易，并用其私钥进行了加密。Jill 可以使用其公钥解密该交易。通过这种方式，Jill 可以确信 John 进行了该交易。如果 John 的私钥已被篡改，则 Jill 的公钥不会发挥作用。</p><h1 id="6-区块链的工作原理是什么？"><a href="#6-区块链的工作原理是什么？" class="headerlink" title="6. 区块链的工作原理是什么？"></a>6. 区块链的工作原理是什么？</h1><p>虽然区块链的底层机制非常复杂，我们将通过以下步骤提供简要概述。区块链软件可以自动执行以下大部分步骤：</p><h3 id="第-1-步-–-记录交易"><a href="#第-1-步-–-记录交易" class="headerlink" title="第 1 步 – 记录交易"></a>第 1 步 – 记录交易</h3><p>区块链交易显示实体资产或数字资产从区块链网络中的一方向另一方的转移。该交易以区块的形式记录，可能包括如下细节：</p><ul><li>谁参与了该交易？</li><li>交易期间发生了什么情况？</li><li>交易是在何时进行的？</li><li>交易是在哪里进行的？</li><li>为什么进行该交易？</li><li>交换了多少资产？</li><li>交易期间符合多少前提条件？</li></ul><h3 id="第-2-步-–-达成共识"><a href="#第-2-步-–-达成共识" class="headerlink" title="第 2 步 – 达成共识"></a>第 2 步 – 达成共识</h3><p>分布式区块链网络中的大多数参与者必须就已记录的交易是有效的达成一致。根据网络类型，达成协议的规则可能有所不同，但通常是在网络开始建立时就制定好的。</p><h3 id="第-3-步-–-将区块链接起来"><a href="#第-3-步-–-将区块链接起来" class="headerlink" title="第 3 步 – 将区块链接起来"></a>第 3 步 – 将区块链接起来</h3><p>一旦参与者达成了共识，会将区块链中的交易写入区块，区块就相当于分类账账簿中的页面。连同交易一起，还会将一个加密哈希附加到新区块。该哈希作为将区块链接在一起的链条。如果有意或无意修改了区块的内容，则该哈希值也将更改，这将提供一种检测数据篡改的方式。 </p><p>因此，区块将与链条安全地链接在一起，且您无法编辑它们。每增加一个区块，都会强化前一个区块的验证，因而也会强化整个区块链的验证。这就像是堆砌木块建塔一样。您只能在前一层木块之上堆叠木块，如果您从塔的中间取出一个木块，则整座塔将垮塌。</p><h3 id="第-4-步-–-共享分类账"><a href="#第-4-步-–-共享分类账" class="headerlink" title="第 4 步 – 共享分类账"></a>第 4 步 – 共享分类账</h3><p>该系统会将中心分类账的最新副本分发给所有参与者。</p><h1 id="7-区块链网络有哪些类型？"><a href="#7-区块链网络有哪些类型？" class="headerlink" title="7. 区块链网络有哪些类型？"></a>7. 区块链网络有哪些类型？</h1><p>有四种主要类型的去中心化或分布式区块链网络：</p><h3 id="公有区块链网络"><a href="#公有区块链网络" class="headerlink" title="公有区块链网络"></a>公有区块链网络</h3><p>公有区块链无需权限，任何人均可加入它们。此类区块链的所有成员享有读取、编辑和验证区块链的平等权限。人们主要将公有区块链用于交换和挖掘加密货币，如比特币、以太坊 (Ethereum) 和莱特币 (Litecoin)。 </p><h3 id="私有区块链网络"><a href="#私有区块链网络" class="headerlink" title="私有区块链网络"></a>私有区块链网络</h3><p>一个组织可以控制多个私有区块链，又称为托管式区块链。该机构决定谁能成为成员，以及他们在该网络中拥有哪些权限。私有区块链只是部分去中心化，因为它们具有访问限制。Ripple 就是一个私有区块链的示例，它是一个面向企业的数字货币交换网络。</p><h3 id="混合区块链网络"><a href="#混合区块链网络" class="headerlink" title="混合区块链网络"></a>混合区块链网络</h3><p>混合区块链结合了私有网络和公有网络的元素。公司可随公有系统一起建立私有、基于权限的系统。通过这种方法，公司可以控制对区块链中存储的特定数据的访问，同时保持其余数据处于公开状态。公司使用智能合约允许公有成员检查私有交易是否已经完成。例如，混合区块链可以授予对数字货币的公有访问权限，同时保持银行拥有的货币处于私有状态。</p><h3 id="联盟区块链网络"><a href="#联盟区块链网络" class="headerlink" title="联盟区块链网络"></a>联盟区块链网络</h3><p>联盟区块链网络由一组组织负责监管。多家预先选择的组织共同承担维护区块链及确定数据访问权限的职责。对于其中很多组织拥有共同目标并可通过共担责任而获益的行业，通常更喜欢联盟区块链网络。例如，全球航运业务网络联盟 (Global Shipping Business Network Consortium) 是一个非营利性区块链联盟，该联盟致力于实现航运业数字化，以及加强海运业运营商之间的合作。</p><h1 id="8-什么是区块链协议？"><a href="#8-什么是区块链协议？" class="headerlink" title="8. 什么是区块链协议？"></a>8. 什么是区块链协议？</h1><p>术语区块链协议一词是指可用于应用程序开发的不同类型的区块链平台。每种区块链协议都采用基本区块链原则来适应特定行业或应用需求。以下小节提供了一些区块链协议的示例：</p><h3 id="Hyperledger-Fabric"><a href="#Hyperledger-Fabric" class="headerlink" title="Hyperledger Fabric"></a>Hyperledger Fabric</h3><p><a href="https://aws.amazon.com/cn/blockchain/what-is-hyperledger-fabric/">Hyperledger Fabric</a> 是一个开源项目，包含一套工具和库。企业可以使用它来迅速有效地构建私有区块链应用程序。它是一种模块化通用框架，提供独特的身份管理和访问控制功能。这些功能使其非常适合各种应用，如供应链的跟踪和追踪、贸易金融、忠诚度和奖励，以及金融资产的清算结算。</p><h3 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h3><p><a href="https://aws.amazon.com/cn/blockchain/what-is-ethereum/">以太坊</a>是一种去中心化开源区块链平台，人们可以将其用于构建公有区块链应用程序。企业以太坊 (Ethereum Enterprise) 专为企业使用案例而设计。</p><h3 id="Corda"><a href="#Corda" class="headerlink" title="Corda"></a>Corda</h3><p>Corda 是一种专为企业而设计的开源区块链项目。借助 Corda，您可以构建可互操作的区块链网络，用于在严格保密的情况下进行交易。企业可以使用 Corda 的智能合约技术直接进行有价值的交易。其大部分用户是金融机构。</p><h3 id="Quorum"><a href="#Quorum" class="headerlink" title="Quorum"></a>Quorum</h3><p>Quorum 是一种源自以太坊的开源区块链协议。该协议专为在两种区块链网络中使用而设计：私有区块链网络，其中只有一个成员拥有所有节点；或者联盟区块链网络，其中包含多个成员，每个成员拥有该网络的一部分。</p><h1 id="9-区块链技术是如何发展的？"><a href="#9-区块链技术是如何发展的？" class="headerlink" title="9. 区块链技术是如何发展的？"></a>9. 区块链技术是如何发展的？</h1><p>区块链技术起源于 1970 年代末，当时一位名为 Ralph Merkle 的计算机科学家申请了哈希树（又名 Merkle 树）的专利。这些树是一种计算机科学结构，通过使用加密将区块链接起来，用于存储数据。在 1990 年代末，Stuart Haber 和 W. Scott Stornetta 使用 Merkle 树实现了无法篡改文档时间戳的系统。这是区块链历史上的首个实例。</p><p>该技术一直在不断发展，已经经过以下三代：</p><h3 id="第一代-–-比特币和其他虚拟货币"><a href="#第一代-–-比特币和其他虚拟货币" class="headerlink" title="第一代 – 比特币和其他虚拟货币"></a>第一代 – 比特币和其他虚拟货币</h3><p>2008 年，一个仅知道名字为中本聪 (Satoshi Nakamoto) 的匿名个人或团体，概述了区块链技术的现代形态。中本聪的比特币区块链理念将 1 MB 信息区块用于比特币交易。比特币区块链系统的很多功能，即便是今天也仍处于区块链技术的中心地位。</p><h3 id="第二代-–-智能合约"><a href="#第二代-–-智能合约" class="headerlink" title="第二代 – 智能合约"></a>第二代 – 智能合约</h3><p>在第一代加密货币出现后的几年，开发人员开始考虑加密货币以外的区块链应用。例如，以太坊的发明者们决定在资产转让交易中使用区块链技术。他们的重要贡献就是智能合约功能。</p><h3 id="第三代-–-未来"><a href="#第三代-–-未来" class="headerlink" title="第三代 – 未来"></a>第三代 – 未来</h3><p>随着众多公司发现和实现新应用，区块链技术也在不断发展和成长。很多公司正在解决规模和计算能力的限制，在正在进行的区块链革命中，潜在机会是无限的。</p><h1 id="10-区块链技术有哪些好处？"><a href="#10-区块链技术有哪些好处？" class="headerlink" title="10. 区块链技术有哪些好处？"></a>10. 区块链技术有哪些好处？</h1><p>区块链技术可为资产交易管理带来很多好处。我们将在以下小节中列出其中部分好处：</p><h3 id="高级安全功能"><a href="#高级安全功能" class="headerlink" title="高级安全功能"></a>高级安全功能</h3><p>区块链系统可以提供现代数字交易所需的高级安全和信任功能。对于有人会操纵底层软件为自己生成假币的恐惧始终存在。但区块链使用加密、去中心化和共识三项原则，创建了高度安全、几乎不可能篡改的底层软件系统。不会有单点故障，并且单个用户也无法更改交易记录。</p><h3 id="更高的效率"><a href="#更高的效率" class="headerlink" title="更高的效率"></a>更高的效率</h3><p>企业间交易可能需要大量时间，还会造成运营瓶颈，尤其是在涉及合规和第三方监管机构时。区块链中的透明度和智能合约可使此类业务交易更快捷、更高效。</p><h3 id="更快捷的审计"><a href="#更快捷的审计" class="headerlink" title="更快捷的审计"></a>更快捷的审计</h3><p>企业必须能以可审计的方式，安全地生成、交换、归档和重建电子交易。区块链记录按时间顺序不可变，这意味着所有记录均始终按时间顺序排列。这样的数据透明使得审计过程更加快捷。</p><h1 id="11-比特币与区块链之间有什么区别？"><a href="#11-比特币与区块链之间有什么区别？" class="headerlink" title="11. 比特币与区块链之间有什么区别？"></a>11. 比特币与区块链之间有什么区别？</h1><p>比特币与区块链可以互换使用，但它们是两种不同的事物。由于比特币是区块链技术的早期应用，人们无意间开始使用比特币来指代区块链，因而造成了这种误用。但除比特币外，区块链技术还有很多应用。</p><p>比特币是一种在没有任何中心化控制的情况下运营的数字货币。最初创建比特币的目的在于在线进行金融交易，但现在已被视为可转换为任何其他全球货币（如美元或欧元）的数字资产。公有比特币区块链网络将创建和管理中心分类账。 </p><h3 id="比特币网络"><a href="#比特币网络" class="headerlink" title="比特币网络"></a>比特币网络</h3><p>公有分类账记录所有比特币交易，而世界各地的众多服务器则保存此分类账的副本。这些服务器就像银行。只是每个银行仅了解其客户兑换的资金，而比特币服务器则了解世界上的每一笔比特币交易。</p><p>任何拥有闲置计算机的人员均可搭建一台此类服务器，称为节点。这就像是开设您自己的比特币银行，而不是银行账户。</p><h3 id="比特币挖矿"><a href="#比特币挖矿" class="headerlink" title="比特币挖矿"></a>比特币挖矿</h3><p>在公有比特币网络上，成员通过求解加密方程来创建新区块，以挖掘加密货币。该系统将向该网络公开广播每一笔新交易，并在各节点间共享这一信息。每十分钟左右，挖矿者会将这些交易收集到一个新区块中，再将这些新区块永久添加到区块链中，该区块链就像比特币的最终账簿。</p><p>由于软件进程的复杂性，因此挖矿需要大量计算资源，并且需要很长时间。作为交换，挖矿者可以赚取少量加密货币。挖矿者相当于记录交易并收取交易费用的现代职员。</p><p>该网络上的所有参与者都将使用区块链加密技术，就谁拥有哪些比特币达成共识。</p><h1 id="12-数据库与区块链之间有什么区别？"><a href="#12-数据库与区块链之间有什么区别？" class="headerlink" title="12. 数据库与区块链之间有什么区别？"></a>12. 数据库与区块链之间有什么区别？</h1><p>区块链是一种特殊类型的数据库管理系统，拥有比常规数据库更多的功能。我们将在下面的列表中介绍传统数据库与区块链之间的一些重要区别：</p><ul><li>区块链去中心化控制，而不会破坏现有数据中的信任。这在其他数据库系统中是不可能实现的。</li><li>参与交易的公司无法共享其整个数据库。但在区块链网络中，每家公司都拥有其分类账副本，并且该系统将自动维护两份分类账之间的一致性。</li><li>虽然在大多数数据库系统中，您都可以编辑或删除数据，但在区块链中，您只能插入数据。</li></ul><h1 id="13-区块链与云有什么区别？"><a href="#13-区块链与云有什么区别？" class="headerlink" title="13. 区块链与云有什么区别？"></a>13. 区块链与云有什么区别？</h1><p>术语云一词是指可以在线访问的计算服务。您可以通过云访问软件即服务 (SaaS)、产品即服务 (PaaS) 和基础设施即服务 (IaaS)。云提供商负责管理其硬件和基础设施，并为您提供通过互联网访问这些计算资源的权限。他们还会提供更多其他资源，而不只是数据库管理。如果您想加入公有区块链网络，则需提供您的硬件资源，用于存储您的分类账副本。您也可以将云上的服务器用于此目的。有些云提供商也在云上提供完整的区块链即服务 (BaaS)。</p><h1 id="14-什么是区块链即服务？"><a href="#14-什么是区块链即服务？" class="headerlink" title="14. 什么是区块链即服务？"></a>14. 什么是区块链即服务？</h1><p>区块链即服务 (BaaS) 是第三方在云上提供的一种托管式区块链服务。您可以开发区块链应用程序和数字服务，而云提供商则提供基础设施和区块链构建工具。您要做的就是自定义现有区块链技术，以便更快捷、更高效地采用区块链。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-什么是区块链技术？&quot;&gt;&lt;a href=&quot;#1-什么是区块链技术？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是区块链技术？&quot;&gt;&lt;/a&gt;1. 什么是区块链技术？&lt;/h1&gt;&lt;p&gt;区块链技术是一种高级数据库机制，允许在企业网络中透明地共享信息。</summary>
      
    
    
    
    
    <category term="架构" scheme="https://jenna233.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Mobile Web Development-When, Why, and How</title>
    <link href="https://jenna233.github.io/2022/10/03/Mobile%20Web%20Development-When,%20Why,%20and%20How/"/>
    <id>https://jenna233.github.io/2022/10/03/Mobile%20Web%20Development-When,%20Why,%20and%20How/</id>
    <published>2022-10-03T08:16:22.000Z</published>
    <updated>2022-10-03T08:22:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://www.toptal.com/app/developing-mobile-web-apps-when-why-and-how">Mobile Web Development: When, Why, and How</a></p><p>根据 Statista 最近的一项研究，地球上有 77.5 亿人，其中超过 60 亿人使用智能手机。 随着移动计算的日益单一化，移动 Web 开发比以往任何时候都更加重要。</p><p><code>作为移动设备用户，没有什么比设计不佳的移动 Web 应用程序或原生应用程序更令人沮丧和难以驾驭的了。</code></p><p><code>作为一名移动应用程序开发人员，很少有事情能像努力支持尽可能广泛的移动客户端一样具有独特的挑战性，每个移动客户端都有自己的一套特质。</code> 无论您选择开发mobile Web、native还是hybrid应用程序，支持多种移动浏览器和更奇特的设备——并掌握各种平台——都可能是一种非常痛苦的体验。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-f33323c6d46b7b28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>当然，今天并不是每个开发人员都需要担心支持移动客户端。 但移动设备和应用程序日益流行的性质强烈表明，那些今天不需要支持移动客户端的人很可能需要在不远的将来这样做。 因此，如果您还没有考虑开发移动应用程序，那么您应该考虑。</p><h1 id="Mobile-Web-App-vs-Native-App-vs-Hybrid-App"><a href="#Mobile-Web-App-vs-Native-App-vs-Hybrid-App" class="headerlink" title="Mobile Web App vs. Native App vs. Hybrid App"></a>Mobile Web App vs. Native App vs. Hybrid App</h1><p>与大多数技术选择一样，对于要开发的移动应用程序类型，没有一刀切的答案。有许多 Web 应用程序最佳实践需要考虑，但并非所有这些都是技术性的。你的目标受众是谁？他们更喜欢mobile web还是native应用？native应用和hybrid应用有什么区别？您拥有哪些开发资源，他们最熟悉哪些移动技术？您为您的产品设想的许可和销售模式是什么？</p><p>一般来说（尽管总是有例外），mobile web比native 移动应用程序路由更快、更便宜，尤其是当目标是支持广泛的设备时。相反，可能存在移动设备的原生功能（例如运动传感器等），这些功能对您的应用程序至关重要，但只能通过原生应用程序访问（因此，这将使你放弃选择移动 Web 应用程序）。</p><p>除了旧的 Web 应用程序与native应用程序的问题之外，hybrid 移动应用程序可能是您的正确答案，具体取决于您的要求和资源限制。hybrid应用程序，如native应用程序一样，在设备本身上运行（而不是在浏览器内部），但使用 Web 技术（HTML5、CSS 和 JavaScript）编写，通常由hybrid应用程序框架支持。更具体地说，hybrid应用程序在本机容器内运行，并利用设备的浏览器引擎（但不是浏览器）来呈现 HTML 并在本地处理 JavaScript。 Web 到本机的抽象层允许访问在移动 Web 应用程序中无法访问的设备功能，例如加速度计、相机和本地存储。</p><p><code>但无论您做出何种选择——无论是移动 Web 应用程序、native应用程序还是hybrid应用程序——都要小心地充分研究并确认您的假设。</code>例如，出于本移动 Web 开发教程的目的，您可能已经决定为电子商务开发一个native移动应用程序来销售您的产品。然而，50% 的智能手机用户仍然更有可能使用移动网站而不是下载应用程序——根据您的目标市场，这个数字可能更大。</p><p>然后，当然，还有时间和预算的实际考虑。 正如我最喜欢的谚语之一所说，“更快、更好、更便宜：选择任何两个。” 虽然上市时间和成本限制在 Web 应用程序开发中至关重要，但在过程中不要对质量做出过分妥协也很重要。 初次体验不佳的用户很难恢复信心。</p><p>事实上，mobile web、 native和hybrid应用程序都是完全不同的野兽，每一种都有自己独特的优势和挑战。 本教程重点介绍在开发功能强大、直观且易于使用的mobile Web 应用程序时要使用的方法和工具，以及要避免的陷阱。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-45101a7eb78da8ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Mobile-Web-Development-Requires-Detailed-Planning"><a href="#Mobile-Web-Development-Requires-Detailed-Planning" class="headerlink" title="Mobile Web Development Requires Detailed Planning"></a>Mobile Web Development Requires Detailed Planning</h1><p>确定您（或您的客户）的需求是应用程序开发、移动或其他方面的基本功。仔细研究目标功能以确定它们是否可以在您的移动 Web 应用程序中实现。如果当您已经投入时间和资源来设计基于 Web 的界面和支持基础设施时，才意识到这套框架不支持您的一个或多个客户端，这样是十分低效的。</p><p><code>mobile web应用程序开发新手的另一个常见问题是预设基于pc浏览器的代码将在移动浏览器中“按原样”工作。</code>这不是真的。肯定存在差异，如果你不知道它们，它们肯定会咬你。例如，HTML5 <video> 标签的自动播放功能不适用于移动浏览器。同样，现在大多数移动浏览器不支持（或至少不始终支持）CSS 过渡和不透明度属性。您还会遇到移动平台上的某些 Web API 方法的问题，例如需要 Adobe Flash 的 SoundCloud 音乐流 API，大多数移动设备不支持该 API。</p><p>开发移动网络应用程序时一个特别复杂的因素是移动设备的寿命往往比桌面显示器的寿命短得多（美国手机的平均寿命约为 30 个月）。这些较短的设备寿命，伴随着新移动设备和技术的不断发布，产生了不断变化的目标设备格局。虽然在浏览器中工作通过使您免受许多特定于设备的问题的影响而在一定程度上缓解了这个问题，但您仍然需要设计一个支持多种屏幕分辨率的基于浏览器的视图，并针对横向和纵向进行适当调整。</p><p>还需要考虑支持 Apple 的 Retina 显示器（液晶显示器的像素密度非常高，以至于人眼无法在典型的观看距离上辨别单个像素）。包括 iPhone、iPod Touch、iPad、MacBook Pro、iPad Mini 和 iPad Air 在内的几款 Apple 产品都提供 Retina 显示屏。特别是在针对移动设备优化 Web 应用程序时，重要的是要意识到 Retina 显示屏会使通常提供给移动设备的低分辨率图像看起来很模糊，并且可能会出现像素化。在这些情况下，最好的应用程序开发解决方案是让服务器识别请求来自 Retina 设备，并向客户端提供替代的更高分辨率图像。</p><p>如果您想使用一些很酷的 HTML5 内容，<code>请记住提前验证您正在寻找的功能是否在您的客户可能使用的设备环境中受支持。 </code>例如，在 iOS 6 及更高版本中，不支持导航器 getUserMedia 功能，因为相机只能通过本机应用程序访问。 caniuse.com 和 html5test.com 是检查特定设备和浏览器支持的两个重要资源。</p><p>CSS3 媒体查询还可以帮助您为每个设备提供定制的内容。 下面是一些用于捕获不同设备特征的示例代码，例如像素密度、屏幕分辨率和方向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* For lower than 700px resolutions *&#x2F;</span><br><span class="line">@media (max-width: 700px) &#123; ... &#125;</span><br><span class="line">&#x2F;* Same as last but with the device orientation on land scape *&#x2F;</span><br><span class="line">@media (max-width: 700px) and (orientation: landscape) &#123; ... &#125;</span><br><span class="line">&#x2F;* Including width and orientation you can add a media type clause,</span><br><span class="line">   in this case &#39;tv&#39; *&#x2F;</span><br><span class="line">@media tv and (min-width: 700px) and (orientation: landscape) &#123; ... &#125;</span><br><span class="line">&#x2F;* for low resolution display with background-image *&#x2F;</span><br><span class="line">.image &#123;</span><br><span class="line">    background-image: url(&#x2F;path&#x2F;to&#x2F;my&#x2F;image.png);</span><br><span class="line">    background-size: 200px 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* for high resolution (Retina) display with background-image *&#x2F;</span><br><span class="line">@media only screen and (min--moz-device-pixel-ratio: 2),</span><br><span class="line">only screen and (-o-min-device-pixel-ratio: 2&#x2F;1),</span><br><span class="line">only screen and (-webkit-min-device-pixel-ratio: 2),</span><br><span class="line">only screen and (min-device-pixel-ratio: 2) &#123;</span><br><span class="line">    -repeat;</span><br><span class="line">        background-size: 200px 400px;</span><br><span class="line">    &#x2F;* rest of your styles... *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Optimizing-Your-Mobile-Web-Application-for-Performance"><a href="#Optimizing-Your-Mobile-Web-Application-for-Performance" class="headerlink" title="Optimizing Your Mobile Web Application for Performance"></a>Optimizing Your Mobile Web Application for Performance</h1><p>天哪，这东西太慢了！” 作为一名移动 Web 开发人员，这些可能是您最不想从您的用户那里听到的一句话。 因此，您必须仔细考虑如何减少和优化每个字节和服务器传输，以减少用户的等待时间。 期望传输总是在 Wi-Fi 网络上发生是不现实的，您应该知道，如果加载时间超过 3 秒，<code>53% 的移动站点访问将被放弃。 还值得注意的是，搜索引擎将加载时间作为其页面质量得分计算的一部分。</code></p><p>作为本移动 Web 开发教程的一部分，这里有一些技巧可以帮助优化您的移动 Web 应用程序的性能并最大限度地减少延迟：</p><ul><li><strong>图像优化</strong> 众所周知，图像加载时间是影响移动设备页面加载的最大性能问题之一。 使用在线图像优化器（例如 Kraken.io）有助于解决此问题。</li><li><strong>代码压缩</strong> 根据您拥有的代码量，压缩 JavaScript 和 CSS 文件会对性能产生重大影响。</li><li><strong>数据库查询</strong> 一些移动设备浏览器接受的 cookie 不如桌面浏览器多，这可能导致需要执行比平时更多的查询。 因此，在支持移动 Web 应用程序客户端时，服务器端缓存尤其重要。 请记住使用适当的过滤器来阻止 SQL 查询注入，否则可能会危及您的站点和服务器的安全性。</li><li><strong>内容交付网络 (CDN)</strong> 如果您计划提供大量视频、图像、音频文件或其他类型的媒体，强烈建议使用 CDN。 一些更常见的商业 CDN 包括 Amazon S3、Microsoft Azure 和 MaxCDN。 使用 CDN 的优势很多，包括：<ul><li><strong>改进的下载性能</strong> 利用 CDN 的资源，您可以分配负载、节省带宽并提高性能。更好的 CDN 提供更高的可用性、更低的网络延迟和更低的丢包率。此外，许多 CDN 提供全球分布的数据中心选择，使下载可以从更靠近用户位置的服务器进行（导致更少的网络跃点和更快的下载）。</li><li><strong>更多并发下载</strong> 浏览器通常会限制到单个域的并发连接数，之后会阻止其他下载，直到之前的下载之一完成。从同一站点下载许多大文件时，您经常可以看到此限制。每个额外的 CDN（在不同的域上）都允许额外的并发下载。</li><li><strong>增强分析</strong> 许多商业 CDN 提供使用报告，可以补充您自己的网站分析，并可能提供更好的视频观看和下载量化。例如，GTmetrix 有一个出色的网站报告工具，用于监控和优化您网站上加载的资源。</li></ul></li></ul><h1 id="Tools-for-Developing-Mobile-Web-Apps"><a href="#Tools-for-Developing-Mobile-Web-Apps" class="headerlink" title="Tools for Developing Mobile Web Apps"></a>Tools for Developing Mobile Web Apps</h1><p>“为正确的工作选择正确的工具”是一句古老的格言，它同样适用于软件开发，就像它适用于任何其他领域一样。 本教程提供并介绍了一些用于移动 Web 开发的更流行和广泛使用的工具，但请记住，很可能还有其他工具是开发移动 Web 应用程序的“正确”工具，具体取决于您的要求和 可用资源。</p><h1 id="JavaScript-Mobile-Web-App-Frameworks"><a href="#JavaScript-Mobile-Web-App-Frameworks" class="headerlink" title="JavaScript Mobile Web App Frameworks"></a>JavaScript Mobile Web App Frameworks</h1><p>由于移动 Web 开发往往会带来许多相同的常见挑战，例如跨浏览器兼容性以及移动浏览器中的 HTML 和 CSS 不一致，因此开发了专门用于解决这些问题的框架（基于 HTML5 和 CSS3）并在各种智能手机和平板电脑上尽可能完美地工作。这些移动网络应用程序框架中的大多数都是轻量级的，这有助于促进快速移动网络浏览，而不会影响您网站的外观和感觉。</p><p>将我们的视野扩展到移动领域之外，如果有一个流行的 JavaScript 框架值得一提，那就是 jQuery。如果您熟悉桌面版本，我建议您尝试将 jQuery Mobile 用于您的移动 Web 应用程序。 （注意：jQuery Mobile 最近已被弃用。）它有一个小部件库，可将语义标记转换为手势友好格式，使触摸屏上的操作变得容易。最新版本包含一个轻量级代码库，其中包含大量图形元素，可以真正改善您的 UI。</p><p>另一种替代品 Sencha Touch 也在迅速获得市场份额。 它提供了出色的整体性能，并有助于生成在很大程度上看起来和感觉像原生界面的移动 Web 用户界面。 它的全功能小部件库基于 Sencha 的 ExtJS JavaScript 库。 （注：Sencha Touch 已与 ExtJS 合并。）</p><p>以下是比较 jQuery Mobile 和 Sencha Touch 时需要考虑的一些关键差异：</p><ul><li><strong>看和感觉</strong> 一般来说，Sencha Touch 应用程序的外观和感觉比 jQuery Mobile 应用程序更清晰和优越，但重要的是要记住，这样的响应往往是高度主观的。</li><li><strong>可扩展性</strong> jQuery Mobile 提供了许多第三方扩展，并且本质上被设计为高度可扩展的，而 Sencha Touch 则更像是一个“封闭”框架。</li><li><strong>设备支持</strong> 与 Sencha Touch 相比，jQuery Mobile 面向更大范围的设备。</li><li><strong>HTML 与 JavaScrip</strong> jQuery 主要以 HTML 为中心（即在 JavaScript 中扩展和操作现有的 HTML），而 Sencha Touch 编码完全基于 JavaScript。 （顺便说一下，这是一个例子，说明为什么在选择技术时考虑开发团队的技能很重要。）</li><li><strong>外部依赖</strong> jQuery Mobile 需要 jQuery 和 jQuery UI 来进行 DOM 操作，而 Sencha Touch 没有外部依赖项。</li><li><strong>学习曲线</strong> 大多数开发人员发现 jQuery 的启动时间少于 Sencha Touch，这可能是由于大部分 Web 开发人员已经熟悉标准 jQuery 库。</li></ul><h1 id="Responsive-Frameworks-and-Mobile-Web-Applications"><a href="#Responsive-Frameworks-and-Mobile-Web-Applications" class="headerlink" title="Responsive Frameworks and Mobile Web Applications"></a>Responsive Frameworks and Mobile Web Applications</h1><p>有许多响应式框架可用，目前最流行的两个是 Bootstrap 和 Foundation。 简而言之，响应式框架简化了基于 Web 的响应式 UI 设计和实现，将最常见的布局和 UI 范例封装到一个可重用、性能优化的框架中。 这些框架大多基于 CSS 和 JavaScript，其中许多是开源的、免费下载且易于定制的。 除非您有一组非常特殊的要求，否则使用其中一个框架可能会减少设计和实现移动 Web 应用程序所需的工作量。</p><p>检查两个主要选项 Bootstrap 和 Foundation，需要考虑的一些关键差异包括：</p><ul><li><strong>目标平台</strong> 虽然 Bootstrap 确实支持移动设备、平板电脑和桌面设备，但它主要面向桌面使用。 另一方面，Foundation 专为各种屏幕尺寸和类型而设计。</li><li><strong>浏览器兼容性</strong> Bootstrap 和 Foundation 都支持大多数浏览器的最新版本。</li><li><strong>布局和组件的多样性</strong> Bootstrap 的 UI 元素集合比 Foundation 提供的要多得多。</li><li><strong>自动调整大小</strong> 使用 Foundation，网格会根据当前浏览器的高度和宽度进行收缩和拉伸，而 Bootstrap 仅支持基于一组标准屏幕尺寸的预定义网格尺寸集。</li></ul><h1 id="Debugging-and-Testing-Mobile-Web-Apps"><a href="#Debugging-and-Testing-Mobile-Web-Apps" class="headerlink" title="Debugging and Testing Mobile Web Apps"></a>Debugging and Testing Mobile Web Apps</h1><p>调试移动 Web 应用程序可能会很棘手并且有些令人沮丧，特别是如果您需要四处寻找不同的设备来测试或安装 SDK 以实现（通常不完美）目标客户端平台的仿真。</p><p>在这种情况下，移动 Web 开发（与原生应用程序开发相比）的一个明显优势是您可以利用标准的基于浏览器的开发人员工具来调试您的应用程序。 根据我个人对远程调试的偏好，我在本应用程序开发教程中推荐的是带有 DevTools 的 Chrome。 其他标准选项包括带有 Firebug 的 Firefox 或 Opera 的 Dragonfly 工具。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-4a5747fece9fedf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我喜欢 Chrome 及其 DevTools 的一些原因包括：</p><ul><li><strong>Chrome 的 DevTools 中的移动模拟器</strong> 仅这一点就可能是选择 Chrome 来调试移动 Web 应用程序的充分理由。 主要功能包括模拟触摸事件、用户代理欺骗、网络带宽限制、地理位置覆盖、设备方向覆盖和 CSS 媒体类型模拟。</li><li><strong>交互式编辑器</strong>  启用动态编辑 JavaScript 或 CSS 的能力。</li><li><strong>高级 JavaScript 调试器</strong> 允许 DOM 断点并提供分析 JavaScript 代码执行时间的能力。</li><li><strong>内置 JSON 和 XML 查看器</strong> 避免需要任何插件来检查服务器响应。</li><li><strong>直接通过 USB 支持 Android 调试桥 (ADB) 协议</strong> 便于远程调试会话的简单实例化。</li><li><strong>动态检查资源</strong> 允许您检查应用程序的本地数据源，包括 IndexedDB 或 Web SQL 数据库、本地和会话存储、cookie 和应用程序缓存资源。 您还可以快速检查应用程序的视觉资源，包括图像、字体和样式表。</li></ul><p>要测试 Web 应用的布局和跨浏览兼容性，您还可以使用一些有用的在线工具，例如 BrowserStack。 只需输入您的应用程序的 URL 并选择浏览器、版本和操作系统，您就会在该环境中获得站点的模拟视图（和加载速度）。 另一个用于此目的的有用工具是 BitBar。</p><h1 id="Choosing-Intelligent-Mobile-Development-Solutions"><a href="#Choosing-Intelligent-Mobile-Development-Solutions" class="headerlink" title="Choosing Intelligent Mobile Development Solutions"></a>Choosing Intelligent Mobile Development Solutions</h1><p>随着当今市场上和使用中的移动设备的数量、种类和复杂性的持续快速增长，对有效、用户友好、高性能的移动应用程序的需求可能会大幅增加。 能够智能高效地开发这些应用程序将继续至关重要。</p><p>在Mobile Web、 Native和Hybrid移动应用程序选项之间进行选择时，必须考虑许多因素。 每个都有自己的优势，但移动 Web 应用程序通常代表您最有效的开发（以及上市时间）选项。 如果您选择走这条路，我希望这个移动 Web 开发教程可以帮助您成功且最直接地到达目的地。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://www.toptal.com/app/developing-mobile-web-apps-when-why-and-how&quot;&gt;Mobile Web Development: When, Why, and How&lt;/a&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="架构" scheme="https://jenna233.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>关于Mobile Web开发的思考</title>
    <link href="https://jenna233.github.io/2022/10/03/%E5%8E%9F%E5%88%9B-%E5%85%B3%E4%BA%8EMobile-Web%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://jenna233.github.io/2022/10/03/%E5%8E%9F%E5%88%9B-%E5%85%B3%E4%BA%8EMobile-Web%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2022-10-03T08:14:56.000Z</published>
    <updated>2022-10-03T08:15:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名移动开发者，见证了公司的移动产品架构，从纯web 网页到native，再到hybrid的过程。hybrid 指app里一部分用native的代码实现，一部分用webview加载web 网页实现。越来越多的公司对移动app采用hybrid的开发模式，一是可以和pc端共享代码，节省资源，二是web部分有更新不用再次发布app就能实现。</p><p>对于hybrid app里的web开发，不是简单的把pc端的代码直接拿过来给hybrid app用。PC和mobile的设备有区别，这就需要我们在为二者实现web端时关注的重点不同。以下是我对mobile web开发的一点思考。</p><h1 id="1-界面布局，-css设置"><a href="#1-界面布局，-css设置" class="headerlink" title="1. 界面布局， css设置"></a>1. 界面布局， css设置</h1><p>mobile设备屏幕较小，这就意味着我们不能用pc端设置界面的思维来设计mobile的界面。mobile屏幕上只能放有限的内容，而且内容大小要易于手指操作，比如点击，滑动等等。如果要适配多种mobile 设备，那就需要界面设计师设计出能在一定范围内动态调整的界面。除此之外，mobile设备可以旋转，对于竖屏和横屏的界面，可能得设计出两套展示方案。</p><h1 id="2-用户操作"><a href="#2-用户操作" class="headerlink" title="2. 用户操作"></a>2. 用户操作</h1><p>pc端的用户操作是通过鼠标完成： 单击， 双击，右键等，对应web的处理事件是pointer event。而mobile的操作是通过手指完成：点击，长按，滑动等，对应的web处理事件是touch event。 这二者之间有可以共用的部分： 比如pc端的单击操作，在mobile端通过手指点击也能触发。 而对于mobile端的滑动手势，需要mobile端去额外处理。<br>综上所述，mobile web需要处理手势操作。</p><h1 id="3-性能"><a href="#3-性能" class="headerlink" title="3. 性能"></a>3. 性能</h1><p>pc 端和mobile端不同，除了屏幕大小以外， 还包括内存，处理器的区别。在pc端一个应用程序可以占用很多的内存，有的web app甚至能达到1-2G左右的内存。但在mobile端，一个app如果占用1-2G的内存是不可取的，容易导致mobile 设备卡顿，app被系统杀掉等。因此，对于mobile web，需要对性能进行优化，使用懒加载技术，严格限制内存使用，</p><p> web app是先请求静态资源比如js， css 文件，然后再执行js代码来加载数据渲染网页。在mobile中， app的启动速度对于用户体验十分重要，hybrid app中的web部分，如果静态资源过大，或导致加载速度过慢。这就需要我们启动的js ， css 文件尽量缩小，加快mobile web的启动速度。即使我们把静态资源绑定在app中发布，也可能遇到服务器升级，而用户未及时升级app的情况。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>对于mobile web的开发，我们需要从界面， 用户操作，性能等方面进行考虑。欢迎留言探讨。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为一名移动开发者，见证了公司的移动产品架构，从纯web 网页到native，再到hybrid的过程。hybrid 指app里一部分用native的代码实现，一部分用webview加载web 网页实现。越来越多的公司对移动app采用hybrid的开发模式，一是可以和pc端共</summary>
      
    
    
    
    
    <category term="架构" scheme="https://jenna233.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Gradle依赖之‘五种依赖配置’</title>
    <link href="https://jenna233.github.io/2022/09/25/Gradle%E4%BE%9D%E8%B5%96%E4%B9%8B%E2%80%98%E4%BA%94%E7%A7%8D%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE%E2%80%99/"/>
    <id>https://jenna233.github.io/2022/09/25/Gradle%E4%BE%9D%E8%B5%96%E4%B9%8B%E2%80%98%E4%BA%94%E7%A7%8D%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE%E2%80%99/</id>
    <published>2022-09-25T06:38:07.000Z</published>
    <updated>2022-09-25T06:39:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://zhuanlan.zhihu.com/p/110215979">Gradle依赖之‘五种依赖配置’</a></p><p>目前gradle支持的依赖配置有五种，分别是implementation, api, compileOnly, runtimeOnly和annotationProcessor。常用的依赖配置是implementation, api和compileOnly。</p><h1 id="1-第一种：implementation"><a href="#1-第一种：implementation" class="headerlink" title="1. 第一种：implementation"></a>1. 第一种：implementation</h1><p>会将指定的依赖添加到编译路径，并且会将该依赖打包到输出，如apk中，但是这个依赖在编译时不能暴露给其他模块，例如依赖此模块的其他模块。这种方式指定的依赖在编译时只能在当前模块中访问。</p><p>当前项目中有两个模块app和decoder<br><img src="https://upload-images.jianshu.io/upload_images/15531792-89028094470023c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>模块app依赖模块decoder</p><p>decoder中添加了远程二进制库依赖joda-time</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-1acb2b6a079f8cd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在decoder模块中使用这个库</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-a1ce8253c9697bf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在app模块中条用decoder模块提供的方法</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-6bea484f61e466e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>尝试在app模块中使用joda-time库</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-3a08105370a5e73a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>出现错误：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-86afca9c943ae077.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从上面的例子中我们可以看出，complementation依赖设置表示当前这个依赖在编译时只能在当前这个模块中访问，其他模块在编译时不能访问，依赖这个模块的其他模块在运行时可以访问这个库的实现。</p><h1 id="2-第二种：api"><a href="#2-第二种：api" class="headerlink" title="2. 第二种：api"></a>2. 第二种：api</h1><p>使用api配置的依赖会将对应的依赖添加到编译路径，并将依赖打包输出，但是这个依赖是可以传递的，比如模块A依赖模块B，B依赖库C，模块B在编译时能够访问到库C，但是与implemetation不同的是，在模块A中库C也是可以访问的。</p><p>我们修改decoder模块中对joda-time库的依赖配置</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-6b8b16b1e48231d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在app模块中使用joda-time库</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-63f502c097b7d750.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>输出<br><img src="https://upload-images.jianshu.io/upload_images/15531792-e079d32594c9bfc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="3-第三种：compileOnly"><a href="#3-第三种：compileOnly" class="headerlink" title="3. 第三种：compileOnly"></a>3. 第三种：compileOnly</h1><p>compileOnly修饰的依赖会添加到编译路径中，但是不会打包到apk中，因此只能在编译时访问，且compileOnly修饰的依赖不会传递。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-257d30df624ef83b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>编译时通过，运行时报错：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-9df7b40622c6f079.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>由于写Android的时间比较短，不知道这个配置的具体应用场景，希望有经验的大佬能够在评论区回复一下具体的应用场景。</p><h1 id="4-第四种：runtimeOnly"><a href="#4-第四种：runtimeOnly" class="headerlink" title="4. 第四种：runtimeOnly"></a>4. 第四种：runtimeOnly</h1><p>这个与compileOnly相反，它修饰的依赖不会添加到编译路径中，但是被打包到apk中，运行时使用。没有使用过。</p><h1 id="5-第五种：annotationProcessor"><a href="#5-第五种：annotationProcessor" class="headerlink" title="5. 第五种：annotationProcessor"></a>5. 第五种：annotationProcessor</h1><p>用于注解处理器的依赖配置，还没有使用过。</p><p>除了上面五种，还有两种testImplementation和androidTestImplementation两种，用于指定在测试代码的依赖。</p><p>对于上面这么多的依赖，其中Implementation是我们最常用的依赖配置选项。</p><p><a href="https://developer.android.com/studio/build/dependencies?hl=zh-cn">官方文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://zhuanlan.zhihu.com/p/110215979&quot;&gt;Gradle依赖之‘五种依赖配置’&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前gradle支持的依赖配置有五种，分别是implementation, api, compileOnly, </summary>
      
    
    
    
    
    <category term="Android" scheme="https://jenna233.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>互联网公司中所谓中台是怎么定义的？</title>
    <link href="https://jenna233.github.io/2022/09/11/%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E4%B8%AD%E6%89%80%E8%B0%93%E4%B8%AD%E5%8F%B0%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%E7%9A%84%EF%BC%9F/"/>
    <id>https://jenna233.github.io/2022/09/11/%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E4%B8%AD%E6%89%80%E8%B0%93%E4%B8%AD%E5%8F%B0%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%E7%9A%84%EF%BC%9F/</id>
    <published>2022-09-11T06:07:41.000Z</published>
    <updated>2022-09-11T06:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://www.zhihu.com/question/57717433">互联网公司中所谓中台是怎么定义的？</a><br>大约从去年年底(2018)开始，中台的概念开始被广泛讨论。</p><p>但与此同时，关于中台究竟是什么，却是众说纷纭。引用王健老师在《<a href="https://www.zhihu.com/search?q=%E5%BD%93%E6%88%91%E4%BB%AC%E8%B0%88%E4%B8%AD%E5%8F%B0%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88%7C+%E7%99%BD%E8%AF%9D%E4%B8%AD%E5%8F%B0%E6%88%98%E7%95%A5&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:719218827%7D">当我们谈中台时，我们在谈些什么| 白话中台战略</a>》一文中提到的关于中台的一些理解，就能看出一些端倪。</p><blockquote><p>在有些人眼里：中台就是技术平台，像微服务开发框架、Devops平台、PaaS平台，容器云之类的，人们都叫它<strong>“技术中台”</strong>。<br>在有些人眼里：中台就是微服务业务平台，像最常见的什么用户中心，订单中心，各种微服务集散地，人们都叫它<strong>“业务中台”</strong>。<br>在有些人眼里：中台应该是组织的事情，在释放潜能：类似于企业内部资源调度中心和内部创新孵化组织，人们叫它<strong>“组织中台”</strong>。</p></blockquote><p>这些理解都对，但也都有不够准确或不够完整的部分。中台，作为一个还在被定义当中的概念，正处在一个大家都有感觉，但又难以被定义的状态。而且可预见的是，这种相对模糊的状态可能还要维持相当长的一段时间。</p><p>与此同时，在查阅了大量资料、并与京东等大厂的中台相关负责人沟通后，我们发现，目前行业内对于中台讨论的视角还是多偏于战略或组织架构层面，而<strong>中台更多是因为公司业务在发展到某一阶段时，遇到瓶颈与障碍后，为解决实际问题而提出的解决方案</strong></p><p>虽然基于战略的角度去看，确实能够让大家视野开阔，从更高维度理解中台。但战略是基于实际业务而制定的，如果撇开业务去空谈，就如同空中楼阁，还是无法了解中台到底是什么。接下来，我们将会站在实际业务的角度，探讨一下中台的“前世今生”，以及如果想要成为一个中台产品经理，你应该具备哪些能力。</p><h1 id="01-为什么需要中台？"><a href="#01-为什么需要中台？" class="headerlink" title="01 为什么需要中台？"></a>01 为什么需要中台？</h1><p>市面上讲到中台，一定会提到两个例子，一个是13年马云参观supercell，然后在15年确定了阿里的中台战略；另一个是华为的中台战略转型，也就是那句著名的“让听得见炮火的人指挥战斗”。</p><p>这似乎会给大家一个错觉，似乎中台是一种自上而下的战略选择。老板觉得中台好，所以要搭建中台。</p><p>不过，现实情况，或许与绝大多数人想象不太一样，<strong>中台的产生，并非完全是自顶向下的战略设计，也并非是为了追随某种行业风口，而是随着公司业务高速发展、组织不断膨胀的过程中暴露的种种问题需要被解决。</strong>而这时，中台的概念恰好对应了这个问题，所以大家接受了中台。</p><p>过去几年中，借着移动互联网的红利，许多公司都高速发展，进行大规模业务拓展，业务拓展的速度足够快，对公司自然是好事，但是随着而来的问题就是，公司内部出现了大量的重复建设和资源浪费的现象。阿里的共享服务部发展历程就是如此。</p><p>公司刚开始只有淘宝，后来意识到B2C模式的业务也会是电商领域重要的组成部门，所以出现了天猫，随着天猫的不断发展，逐渐独立成一个部门，但是这两套都包含订单、商品、库存、价格、仓储、物流等基本业务系统。这两个系统互相独立，各自运行。</p><p>等到10年左右，阿里开始上线1688、聚划算等业务的时候发现，这些业务针对的领域虽然各不相同，但是他需要用到的系统功能也高度类似，主要也是订单、商品、库存、价格、仓储、物流等系统。如果这些新业务的系统也都要全部重新开发一遍，这无疑是很大的资源浪费。明明既有的系统调整一下就可以满足新业务的需求，为什么还要继续开发新系统呐？</p><p>在这个大的背景之下，阿里内部将共享服务部的职权不断提升，统一将各个业务业务部门重复使用，反复建设的功能和系统统一规划和管理。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-55141a7216c22c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>其实，很多公司的中台部门，或者平台业务部门的出现都有类似的背景和情况。</p><p>比如说，滴滴在15年末开始启动自己的中台战略，这与滴滴当时的业务发展阶段也是相关的。</p><p>2015 年末，滴滴在短时间内形成了包括快车、出租车、专车、顺风车、代驾等多业务的<a href="https://www.zhihu.com/search?q=%E5%9E%82%E7%9B%B4%E5%8C%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:719218827%7D">垂直化</a>架构。</p><p>这些业务虽然会有一些差别，但是核心系统和流程都是类似的。如果各自独立开发，也会出现各种各样的问题。</p><p>比如说，开发成本过高，滴滴旗下的每个业务，其实都是可以单独支撑起一家公司的，如果每个业务都独立做到极致，那么开发成本和人力成本就会非常巨大，而如果为了控制成本，就把系统的建设放缓，则意味着，无论是核心系统本身的质量，还是对外的用户体验都不太好。</p><p>在这样的背景下，滴滴也开始考虑将诸多业务，以及各个城市的系统统一规划，统一建设，提升服务前台的能力。</p><p>其实，刚刚我们提到的，以及许多正在实践中台业务的公司，都有类似的问题，这些问题，大约会是两类——</p><p><strong>一类是，许多业务需求或功能需求高度类似、通用化程度很高，但是由于没有专门的团队负责规划和开发，大量的系统重复开发、重复建设，导致<a href="https://www.zhihu.com/search?q=%E5%A4%8D%E7%94%A8%E6%80%A7&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:719218827%7D">复用性</a>低、效率低、产研资源浪费、用户体验不统一。</strong></p><p>另一类是，早期业务发展过程中，为了解决一些当下的业务问题，垂直的、个性化的业务逻辑与基础系统耦合太深，<strong>由于没有平台性质的规划，横向系统之间、上下游系统之间的交叉逻辑也非常多，这样导致在新业务、新市场的拓展过程中，系统没法直接复用，甚至没法快速迭代。</strong></p><p>这两类问题，在软件开发领域，有专门的名称，叫做“重复造轮子”和“烟囱式架构”。这两类问题本质上是企业在发展过程当中，为了解决当下的业务问题，快速上线了很多功能，而欠下了许多技术债，当企业进入成熟期之后，发现这些问题的存在，严重影响了企业的运行效率和运营成本。</p><p>如何能够<a href="https://www.zhihu.com/search?q=%E6%9C%BA%E5%88%B6%E5%8C%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:719218827%7D">机制化</a>，产品化地解决这些问题，能够更好地通过产品的形式，将企业内部具有很强的通用性的数据、功能、产品甚至经验进行统一规划和开发，进而更好地帮助前台业务部门更多地关注业务，提高业务运营效率，进而提升企业竞争力，是企业开发中台的基本出发点。</p><p>现阶段，大多数提出中台战略或是建设大中台的公司，大多都有类似的困境。业务高速发展多年，许多问题积重难返或者大量在解决“重复造轮子”的问题，中台这个概念，很多情况下是因为契合了大公司业务的发展的情况，而被大家广泛认可。</p><h1 id="02-中台能解决什么问题？"><a href="#02-中台能解决什么问题？" class="headerlink" title="02 中台能解决什么问题？"></a>02 中台能解决什么问题？</h1><p>前面的内容，我们大致介绍了中台要解决的问题。这给我们一种感觉是，中台是只有大公司才能做的事情，因为毕竟只有大公司在会有这种多条业务线，需要大量通用功能的场景，也只有只有大公司有能力拿出如此大的资源打造个中台。</p><p>现实情况也如我们所说，<strong>很多公司的中台业务，实际业务发展到一定阶段，进入一个瓶颈之后，为了能够应对接下来的问题，才一点一点从内部开始推动解决之前的问题。</strong></p><p>但这其实只是中台建设的一个层面。</p><p>中台作为一种产品设计思路，或者系统架构思路，并不受限于公司的规模，理论上讲，任何一家即将或者正在面临业务高速增长的状态时，都很值得利用和借鉴中台的思路，将目前业务当中大量可复用的功能和场景进行梳理，为业务的高速增长做好准备。</p><p>这在中小公司当中，是有现实意义的。</p><p>对于很多中小公司，当他们走出生存困境，进入到高速发展阶段时，会遇到很多的问题，但大概率会遇到的一个问题是，<strong>过往的业务模型，产品能力很有可能没法完全承接住大规模用户增长带来的压力。</strong></p><p>而当你具体到每个用户的时候，你又能发现，他们遇到的问题你之前都遇到过，只不过，因为一下来的太多，你没法像过去一样提供达预期，甚至超预期的服务时，对方就会产生不满。</p><p>这也是为什么许多公司会生于拉新，死于留存的一个原因。</p><p>很多公司在这个阶段的选择都是为了临时解决一个问题，快速上线一个功能，也不是不可以，只不过，很有可能你的解决方案会不断带来新的问题，最后陷入到功能太过复杂，以至于积重难返的地步</p><p>所以，在有可能的情况下，公司将一些大概率长期有价值的功能，专门模块化，进行开发和优化，确保即使业务规模进一步扩大，也能够满足业务需求。甚至，随着能力或方法论的不断优化，甚至有可能某一天成为整个行业的方法论。</p><p>这个过程，就很像是在高速飞行过程中修飞机一样。一方面，机翼已经千疮百孔，摇摇欲坠，另一方面，发动机还在运转，你还能往前飞，但你知道，如果再进入到下一场战斗，你不见得还能确保飞机不会坠落，所以，必须抢在下一次战斗前把飞机修好。</p><p>随着业务的发展，你对飞机的要求，也不仅仅是修好，可能会希望，能够提前预防一些问题。或者，知道你的飞机哪里战斗力最强，就把哪里做到最好。或许，就能够回避之后的一些问题。</p><p>这或许是中台这个概念，对于中小公司内部产品规划的一个启发。</p><p>当然，需要提示的一点是，对于中小公司而言，中台的理念不见得是单独拉几十人搭建一个中台产研团队，可以将一些关键流程先行标准化，把一些反复出现的场景当中的解决方案进行沉淀，部分需要产品化的功能先行<a href="https://www.zhihu.com/search?q=%E4%BA%A7%E5%93%81%E5%8C%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:719218827%7D">产品化</a>，可能对于一家业务刚刚开始起步的公司来说，就已经很重要了。</p><h1 id="03-中台产品经理的挑战"><a href="#03-中台产品经理的挑战" class="headerlink" title="03 中台产品经理的挑战"></a>03 中台产品经理的挑战</h1><p>之前的内容，我们其实花了很大的篇幅来讨论，为什么会有中台，中台解决怎样的问题，以及中台适用怎样的场景。</p><p>但是，具体到业务场景当中，中台产品经理又在做什么事情，解决怎样的问题？如果想要成为一名优秀的中台产品经理，又会遇到怎样的困难和挑战？</p><p>我们采访了一些大公司的中台部门之后，会发现，中台产品经理面对很多挑战，其中，最主要要是最困难的挑战，主要集中在这样两个方面。</p><p><strong>一方面，是思维的差异。</strong></p><p>很多产品经理并不是从一开始就从事中台相关的事宜，也不是一开始就有中台这样的定位。更多情况下，他们是从前台业务部门，或者以业务为导向的产研部门转型到中台产研部门。</p><p>这时，其实要面临很大的思维方式、做事方法的转变。</p><p>在业务部门或者以业务为导向的产研部门，最核心的目的就是达成业务目标，要求你速度足够快、功能高效地解决当下的业务问题，当前业务发展的效率是最关键的。</p><p>至于说，这个功能将来有没有可能适用于别的场景，有没有可能解决别的问题，这个问题实在是没那么重要。</p><p>但是，对于中台不能如此。</p><p><strong>对于中台产品经理来说，必须思考的问题是，这个功能在现在或者将来能满足多少业务场景？如果将来有新的业务出现，是不是能够复用？或者说，需要做多大的调整才可以复用？甚至于，这个功能有没有可能对外输出，提供<a href="https://www.zhihu.com/search?q=SaaS%E5%8C%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:719218827%7D">SaaS化</a>的服务。</strong></p><p>这些问题，是中台部门需要思考的问题。这是思维上的差异。</p><p><strong>另一方面，是环境的变化。</strong></p><p>当你在业务部门的时候，响应业务是相对轻松的。但是，在中台部门，响应多个业务，就没有那么轻松了。</p><p>就拿需求调研为例。在业务部门或以业务为导向的产研部门的时候，你只要和对接的业务人员沟通清楚需求就OK了，毕竟，你只要了解这一个或对应的多个部门的业务需求即可，业务目标相对比较明确。</p><p>但是，当你需要响应多个业务部门的时候，就没有那么容易了。</p><p>你会发现，同样一个需求，A部门的流程和B部门流程完全不同，或者，流程是相似的，但到具体细节的时候，却有很大差异。</p><p>更可怕的是，同样一个问题，由于业务的发展阶段不同，对于问题的态度也全然不同：有的部门业务已经非常成熟，自己流程也很清晰，所以不太希望你来调整他们现有的流程；但是，有的部门还处于探索期，还没有遇到你提出的问题，可能压根就不理你。这时，对于中台产品经理的挑战就非常大。</p><p>他们可能会将大量的精力耗散于不同部门之间的沟通协调，反复对同一个需求进行确认，很长时间没有明显突破。这个时候，<strong>就要求中台产品经理有很强的沟通、协调和协作能力。</strong></p><p>并且，因为他们接下来要做的解决方案，是要服务于多个业务。这个时候，<strong>需要中台产品经理有很强的逻辑思考能力，看到不同需求之间的共性需求，并提炼出一个产品化的解决方案。</strong></p><p>甚至于，对于一些尚未遇到这个问题的业务部门，可能还要帮他们前置地思考解决方案。</p><p>这又很要求产品经理的逻辑思考和抽象思考能力。</p><p><strong>既需要沟通协作的软技能，又需要逻辑抽象的硬思考，这可能才是中台产品经理最有挑战的地方。</strong></p><p>虽然有挑战，但是也不见得没有方法。对于中台产品经理来说，刚刚我们提到的内容，也只是帮助中台产品经理，对于中台产品这个岗位所要面临的挑战和工作，能够有一些初步框架性的理解。</p><p>但是，在实际业务场景当中要解决的很多复杂问题，受限于篇幅，我们还没有详细讨论。</p><p>对于中台产品而言，他们的能力要求其实跨越非常大。<strong>一方面，需要极强的逻辑思维和战略分析能力，能够看到业务当中的关键流程，理解业务接下来的发展方向，并将其转化为产品功能，与研发一起实现。另一方面，又需要极强的沟通和交流能力，能够在与多个<a href="https://www.zhihu.com/search?q=%E4%B8%9A%E5%8A%A1%E7%BA%BF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:719218827%7D">业务线</a>，需求、背景、想法各不相同的相关方一起，推动完成相关功能的实现。</strong></p><p>这背后，是技术，也是艺术。</p><p>某种意义上，能够掌握掌握这两种似乎有些对立思维，并能够灵活运用，可能距离成为一个优秀的中台产品经理，就不太远了。</p><p>最后，如果你想了解更多关于产品经理的干货和内容，欢迎关注  <a href="https://www.zhihu.com/people/b7e359ea6cd2eac48bd37f8917c50825">@三节课</a>  ！<br>如果觉得内容对你有帮助，欢迎点个赞，比心心～❤️</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://www.zhihu.com/question/57717433&quot;&gt;互联网公司中所谓中台是怎么定义的？&lt;/a&gt;&lt;br&gt;大约从去年年底(2018)开始，中台的概念开始被广泛讨论。&lt;/p&gt;
&lt;p&gt;但与此同时，关于中台究竟是什么，却是众说纷纭</summary>
      
    
    
    
    
    <category term="架构" scheme="https://jenna233.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>超详细的jenkins持续集成工作原理、功能、部署方式等介绍</title>
    <link href="https://jenna233.github.io/2022/09/11/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%81%E5%8A%9F%E8%83%BD%E3%80%81%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F%E7%AD%89%E4%BB%8B%E7%BB%8D/"/>
    <id>https://jenna233.github.io/2022/09/11/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%81%E5%8A%9F%E8%83%BD%E3%80%81%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F%E7%AD%89%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-09-11T06:06:43.000Z</published>
    <updated>2022-09-11T06:07:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://www.toutiao.com/article/6728738728178614796/">超详细的jenkins持续集成工作原理、功能、部署方式等介绍</a></p><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><p>jenkins是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实时监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。</p><p>Jenkins可以构建一个自动化的持续集成环境可以使用它来“自动化”编译、打包、分发部署应用，它兼容ant、maven、gradle等多种第三方构建工具，同时与svn、git能无缝集成，也支持直接与知名源代码托管网站，如github、bitbucket直接集成。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-898b9e36c4b4bddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="2-Jenkins的功能"><a href="#2-Jenkins的功能" class="headerlink" title="2 Jenkins的功能"></a>2 Jenkins的功能</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-aebeb0003ff1fce4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol><li><p>定时拉取代码并编译</p></li><li><p>静态代码分析</p></li><li><p>定时打包发布测试版</p></li><li><p>自定义操作，如跑单元测试等</p></li><li><p>出错提醒</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/15531792-1387a77558b6714f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="3-原理"><a href="#3-原理" class="headerlink" title="3 原理"></a>3 原理</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-c78fcf302814da8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这里是选择Gitlab作为git server。Gitlab的功能和Github差不多，但是是开源的，可以用来搭建私有git server，也提供非常强大的web GUI，比如开发者互相review源代码的时候就会很方便。系统的工作流程大概分为以下几步:</p><blockquote><p>1&gt; 开发者将新版本push到git server (Gitlab)。</p><p>2&gt; Gitlab随后触发jenkins master结点进行一次build。(通过web hook或者定时检测)</p><p>3&gt; jenkins master结点将这个build任务分配给若干个注册的slave结点中的一个，这个slave结点根据一个事先设置好的脚本进行build。这个脚本可以做的事情很多，比如编译，测试，生成测试报告等等。这些原本需要手动完成的任务都可以交给jenkins来做。</p><p>4&gt; 我们在build中要进行编译，这里使用了分布式编译器distcc来加快编译速度。</p></blockquote><p>jenkins的工作原理是先将源代码从gitlab中拷贝一份到本地，然后根据设置的脚本进行build。我们可以看出，整个系统的关键就是那个build脚本，用来告诉jenkins在一次集成中需要执行的任务。</p><p>不过我之后是用的Github作为git server。但其实差不多。</p><h1 id="4-部署方式"><a href="#4-部署方式" class="headerlink" title="4 部署方式"></a>4 部署方式</h1><p>1、jenkins触发式构建：</p><p>用于开发环境部署，开发人员push代码或者合并代码到gitlab项目的master分支，jenkins就部署代码到对应服务器。</p><p>2、jenkins参数化构建：</p><p>用于测试环境预上线环境部署，开发push代码或者合并代码到gitlab项目的master分支之后，并不会部署代码，而是需要登录到jenkins的web界面，点击构建按钮，传入对应的参数（比如参数需要构建的tag，需要部署的分支）然后才会部署。</p><p>3、jenkins定时构建：</p><p>用于APP自动打包，定时构建是在参数化构建的基础上添加的，开发人员可以登录jenkins手动传入tag进行打包，如果不手动打包，那么jenkins就每天凌晨从gitlab拉取最新的APP代码打包。</p><h1 id="5-持续集成的分类"><a href="#5-持续集成的分类" class="headerlink" title="5 持续集成的分类"></a>5 持续集成的分类</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-7669176f044df5c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol><li><p>持续集成：指程序员在代码的开发工程中，可以频繁的将代码部署到主干上，并进行自动化测试</p></li><li><p>持续交付：指在持续集成的基础之上，将代码部署到线上测试环境</p></li><li><p>持续部署：指在持续交付的基础之上，将要部署的代码实现自动部署，包括持续交互、持续部署</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://www.toutiao.com/article/6728738728178614796/&quot;&gt;超详细的jenkins持续集成工作原理、功能、部署方式等介绍&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; cl</summary>
      
    
    
    
    
    <category term="架构" scheme="https://jenna233.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>我做系统架构的一些原则</title>
    <link href="https://jenna233.github.io/2022/09/11/%E6%88%91%E5%81%9A%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%88%99/"/>
    <id>https://jenna233.github.io/2022/09/11/%E6%88%91%E5%81%9A%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%88%99/</id>
    <published>2022-09-11T06:05:44.000Z</published>
    <updated>2022-09-11T06:06:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://coolshell.cn/articles/21672.html">我做系统架构的一些原则</a></p><p>工作 20 多年了，这 20 来年看到了很多公司系统架构，也看到了很多问题，在跟这些公司进行交流和讨论的时候，包括进行实施和方案比较的时候，都有很多各种方案的比较和妥协，因为相关的经历越来越多，所以，逐渐形成了自己的逻辑和方法论。今天，想写下这篇文章，把我的这些个人的经验和想法总结下来，希望能够让更多的人可以参考和借鉴，并能够做出更好的架构来。另外，我的这些思维方式和原则都针对于现有市面上众多不合理的架构和方案，所以，也算是一种“纠正”……（注意，这篇文章所说的这些架构上的原则，一般适用于相对比较复杂的业务，如果只是一些简单和访问量不大的应用，那么你可能会得出相反的结论）</p><h2 id="原则一：关注于真正的收益而不是技术本身"><a href="#原则一：关注于真正的收益而不是技术本身" class="headerlink" title="原则一：关注于真正的收益而不是技术本身"></a>原则一：关注于真正的收益而不是技术本身</h2><p>对于软件架构来说，我觉得第一重要的是架构的收益，如果不说收益，只是为了技术而技术，而没有任何意义。对于技术收益来说，我觉得下面这几个收益是非常重要的：</p><ul><li><strong>是否可以降低技术门槛加快整个团队的开发流程</strong>。能够加快整个团队的工程流程，快速发布，是软件工程一直在解决的问题，所以，系统架构需要能够进行并行开发，并行上线和并行运维，而不会让某个团队成为瓶颈点。（注：就算拖累团队的原因是组织构架，也不妨碍我们做出并行的系统架构设计）</li><li><strong>是否可以让整个系统可以运行的更稳定</strong>。要让整个系统可以运行的更为的稳定，提升整个系统的 SLA，就需要对有计划和无计划的停机做相应的解决方案（参看《<a href="https://coolshell.cn/articles/17459.html" title="关于高可用的系统">关于高可用的架构</a>》）</li><li><strong>是否可以通过简化和自动化降低成本</strong>。最高优化的成本是人力成本，人的成本除了慢和贵，还有经常不断的 human error。如果不能降低人力成本，反而需要更多的人，那么这个架构设计一定是失败的。除此之外，是时间成本，资金成本。</li></ul><p>如果一个系统架构不能在上面三个事上起到作用，那就没有意义了。</p><h2 id="原则二：以应用服务和-API-为视角，而不是以资源和技术为视角"><a href="#原则二：以应用服务和-API-为视角，而不是以资源和技术为视角" class="headerlink" title="原则二：以应用服务和 API 为视角，而不是以资源和技术为视角"></a>原则二：以应用服务和 API 为视角，而不是以资源和技术为视角</h2><p>国内很多公司都会有很多分工，基本上都会分成运维和开发，运维又会分成基础运维和应用运维，开发则会分成基础核心开发和业务开发。不同的分工会导致完全不同的视角和出发点。比如，基础运维和开发的同学更多的只是关注资源的利用率和性能，而应用运维和业务开发则更多关注的是应用和服务上的东西。这两者本来相关无事，但是因为分布式架构的演进，导致有一些系统已经说不清楚是基础层的还是应用层的了，比如像服务治理上的东西，里面即有底层基础技术，也需要业务的同学来配合，包括 k8s 也样，里面即有底层的如网络这样的技术，也有需要业务配合的 readniess和 liveness 这样的健康检查，以及业务应用需要 configMap 等等 ……</p><p><strong>这些东西都让我感觉到所谓 DevOps，其实就是因为很多技术和组件已经分不清是 Dev 还是 Ops 的了，所以，需要合并 Dev和 Ops</strong>。而且，整个组织和架构的优化，已经不能通过调优单一分工或是单一组件能够有很大提升的了。其需要有一种自顶向下的，整体规划，统一设计的方式，才能做到整体的提升（可以试想一下城市交通的优化，当城市规模到一定程度的时候，整体的性能你是无法通过优化几条路或是几条街区来完成的，你需要对整个城市做整体的功能体的规划才可能达到整体效率的提升）。而为了做到整体的提升，需要所有的人都要有一个统一的视角和目标，这几年来，我觉得这个目标就是——<strong>要站在服务和 对外API的视角来看问题，而不是技术和底层的角度。</strong></p><h2 id="原则三：选择最主流和成熟的技术"><a href="#原则三：选择最主流和成熟的技术" class="headerlink" title="原则三：选择最主流和成熟的技术"></a>原则三：选择最主流和成熟的技术</h2><p>技术选型是一件很重要的事，技术一旦选错，那会导致整个架构需要做调整，而对架构的调整重来都不是一件简单的事，我在过去几年内，当系统越来越复杂的时候，用户把他们的  PHP，Python, .NET，或 Node.js 的架构完全都迁移到 Java + Go 的架构上来的案例不断的发生。这个过程还是非常痛苦的，但是你没有办法，当你的系统越来越复杂，越来越大时，你就再也不能在一些玩具技术上玩了，你需要的更为工业化的技术。</p><ul><li><p><strong>尽可能的使用更为成熟更为工业化的技术栈，而不是自己熟悉的技术栈。</strong> 所谓工业化的技术栈，你可以看看大多数公司使用的技术栈，比如：互联网，金融，电信……等等 ，大公司会有更多的技术投入，也需要更大规模的生产，所以，他们使用的技术通常来说都是比较工业化的。在技术选型上，千万不要被——“你看某个视频公司也在用这个技术”，或是一些在论坛上看到的一些程序员吐槽技术的观点（没有任何的数据，只有自己的喜好）来决定自己的技术，还是看看主流大多数公司实际在用的技术栈，会更靠谱一些。</p></li><li><p><strong>选择全球流行的技术，而不是中国流行的技术</strong>。技术这个东西一定是一个全球化的东西，不是一个局域化的事。所以，一定要选国际化的会更好。另外，千万不要被某些公司的“特别案例”骗过去了，那怕这个案例很性感，关键还是要看解决问题的思路和采用的技术是否具有普世性。只有普世性的技术有更强的生命力。</p></li><li><p><strong>尽可能的使用红利大的主流技术，而不要自己发明轮子，更不要魔改。</strong>我见过好些个公司魔改开源软件，比如有个公司同魔改mesos，最后改着改着发现自己发明另一个 kubernetes。我还见过很多公司或技术团队喜欢自己发明自己的专用轮子，最后都会被主流开源软件所取代。完全没有必要。不重新发明轮子，不魔改，不是因为自己技术不能，而是因为，这个世界早已不是自己干所有事的年代了，这个时代是要想尽方法跟整个产业，整个技术社区融合和合作，这样才会有最大的收益。那些试图因为某个特例需要自成一套的玩法，短期没问题，但长期来说，我都不看好。</p></li><li><p><strong>绝大多数情况下，如无非常特殊要求，选 Java基本是不会错的。</strong>一方面，这是因为 Java 的业务开发的生产力是非常好的，而且有 Spring 框架保障，代码很难写烂，另外，Java 的社区太成熟了，你需要的各种架构和技术都可以很容易获得，技术红利实在是太大。这种运行在JVM上的语言有太多太多的好处了。在 Java 的技术栈上，你的架构风险和架构的成本（无论是人力成本，时间成本和资金成本）从长期来说都是最优的</p></li></ul><p>在我见过的公司中，好些公司的架构都被技术负责人个人的喜好、擅长和个人经验给绑架了，完全不是从一个客观的角度来进行技术选型。其实，从 0 到 1 的阶段，你用什么样的技术都行，如果你做一个简单的应用，没有事务处理没有复杂的交易流程，比如一些论坛、社交之类的应用，你用任何语言都行。但是如果有一天你的系统变复杂了，需要处理交易了，量也上来了，从 1 到 10，甚至从 10 到 100，你的开发团队也变大了，需要构建的系统越来越大，你可能会发现你只有一个选择，就是 Java。想想京东从.NET 到 Java，淘宝从 PHP 到 Java……</p><p>注，一些有主观喜好的人一定会对我上述对 Java 的描述感到不适，我还用一些证据说明一下——全中国所有的电商平台，几百家银行，三大电信运营商，所有的保险公司，劵商的系统，医院里的系统，电子政府系统，等等，基本都是用 Java 开发的，包括 AWS 的主流语言也是 Java，阿里云一开始用 C++/Python 写控制系统，后面也开始用 Java ……你可能会说 B站是用 go语言，但是你可能不知道 B 站的电商和大数据是用 Java……懂着数据分析的同学，建议上各大招聘网站上搜一下 Java 的职位数量，你就知道某个技术是否主流和热门……</p><h2 id="原则四：完备性会比性能更重要"><a href="#原则四：完备性会比性能更重要" class="headerlink" title="原则四：完备性会比性能更重要"></a>原则四：完备性会比性能更重要</h2><p>我发现好些公司的架构师做架构的时候，首要考虑的是架构的性能是否能够撑得住多大多大的流量，而不是考虑系统的完备性和扩展性。所以，我已经多次见过这样的案例了，一开始直接使用 MongoDB 这样的非关系型数据库，或是把数据直接放在 Redis 里，而直接放弃关系型数据库的数据完备性的模型，而在后来需要在数据上进行关系查询的时候，发现 NoSQL 的数据库在 Join 上都表现的太差，然后就开始各种飞线，为了不做 Join 就开始冗余数据，然而自己又维护不好冗余数据后带来的数据一致性的问题，导致数据上的各种错乱丢失。</p><p>所以，我给如下的一些如下的架构原则：</p><ul><li><p><strong>使用最科学严谨的技术模型为主，并以不严谨的模型作为补充。</strong>对于上面那个案例来说，就是——永远使用完备支持 ACID 的关系型数据库，然后用 NoSQL 作补充，而不是完全放弃关系型数据库。这里的原则就是所谓的“先紧后松”，一开始紧了，你可以慢慢松，但是开始松了，以后你想紧再也紧不过来了。</p></li><li><p><strong>性能上的东西，总是有很多解的。</strong>我这么多年的经历告诉我，性能上的事，总是有解的，手段也是最多的，这个比起架构的完备性和扩展性来说真的不必太过担心。<br>为了追求所谓的性能，把整个系统的完备性丢失掉，相当地得不偿失。</p></li></ul><h2 id="原则五：制定并遵循服从标准、规范和最佳实践"><a href="#原则五：制定并遵循服从标准、规范和最佳实践" class="headerlink" title="原则五：制定并遵循服从标准、规范和最佳实践"></a>原则五：制定并遵循服从标准、规范和最佳实践</h2><p>这个原则是非常重要的，因为只有服从了标准，你的架构才能够有更好的扩展性。比如：我经常性的见到很多公司的系统既没有服从业界标准，也没有形成自己公司的标准，感觉就像一群乌合之众一样。最典型的例子就是 HTTP 调用的状态返回码。业内给你的标准是 200表示成功，3xx 跳转，4xx 表示调用端出错，5xx 表示服务端出错，我实在是不明白为什么无论成功和失败大家都喜欢返回 200，然后在 body 里指出是否error（前两年我在微信公众号里看到一个有一定名气的互联网老兵推荐使用无论正确还是出错都返回 200 的做法，我在后台再三确认后，我发现这样的架构师真是害人不浅）。这样做最大的问题是——监控系统将在一种低效的状态下工作。监控系统需要把所有的网络请求包打开后才知道是否是错误，而且完全不知道是调用端出错还是服务端出错，于是一些像重试或熔断这样的控制系统完全不知道怎么搞（如果是 4xx错，那么重试或熔断是没有意义的，只有 5xx 才有意义）。<strong>有时候，我会有种越活越退步的感觉，错误码设计这种最基本最基础的东西为什么会没有？并且一个公司会任由着大家乱来？这些基础技能怎么就这样丢掉了？</strong></p><p>还有，我还见过一些公司，他们整个组织没有一个统一的用户 ID 的设计，各个系统之间同步用户的数据是通过用户的身份证 ID，是的，就是现实世界的身份证 ID，包括在网关上设置的用户白名单居然也是用身份证 ID。我对这个公司的内的用户隐私管理有很大的担忧。一个企业，一个组织，如果没有标准和规范，也就会有抽象，这一定是要出各种乱子的。</p><p>下面，我罗列一些你需要注意的标准和规范（包括但不限于）：</p><ul><li><strong>服务间调用的协议标准和规范。</strong> 这其中包括 Restful API路径, HTTP 方法、状态码、标准头、自定义头等，返回数据 JSon Scheme……等。</li><li><strong>一些命名的标准和规范。</strong>这其中包括如：用户 ID，服务名、标签名、状态名、错误码、消息、数据库……等等</li><li><strong>日志和监控的规范。</strong>这其中包括：日志格式，监控数据，采样要求，报警……等等</li><li><strong>配置上的规范。</strong>这其中包括：操作系统配置、中间件配置，软件包……等等</li><li><strong>中间件使用的规范。</strong>数据库，缓存、消息队列……等等</li><li><strong>软件和开发库版本统一。</strong>整个组织架构内，软件或开发库的版本最好每年都升一次级，然后在各团队内统一。</li></ul><p>这里重要说一下两个事：</p><ul><li><strong>Restful API 的规范</strong>。我觉得是非常重要的，这里给两个我觉得写得最好的参考：<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md">Paypal</a> 和 <a href="https://github.com/microsoft/api-guidelines">Microsoft</a> 。Restful API 有一个标准和规范最大的好处就是监视可以很容易地做各种统计分析，控制系统可以很容易的做流量编排和调度。</li><li><strong>另一个是服务调用链追踪</strong>。对于服务调用链追踪来说，基本上都是参考于 <a href="https://research.google/pubs/pub36356/">Google Dapper</a> 这篇论文，目前有很多的实现，最严格的实现是 <a href="https://zipkin.io/">Zipkin</a>，这也是 Spring Cloud Sleuth 的底层实现。Zipkin 贴近 Google Dapper 论文的好处在于——无状态，快速地把 Span 发出来，不消耗服务应用侧的内存和 CPU。这意味着，监控系统宁可自己死了也不能干扰实际应用。</li><li><strong>软件升级</strong>。我发现很多公司包括 BAT，他们完全没有软件升级的活动，全靠开发人员自发。然而，这种成体系的活动，是永远不可能靠大众的自发形成的。一个公司至少一年要有一次软件版本升级的review，然后形成软件版本的统一和一致，这样会极太简化系统架构的复杂度。</li></ul><h2 id="原则六：重视架构扩展性和可运维性"><a href="#原则六：重视架构扩展性和可运维性" class="headerlink" title="原则六：重视架构扩展性和可运维性"></a>原则六：重视架构扩展性和可运维性</h2><p>在我见过很多架构里，技术人员只考虑当下，但从来不考虑系统的未来扩展性和可运维性。所谓的管生不管养。如果你生下来的孩子胳膊少腿，严重畸形，那么未来是很难玩的。因为架构和软件不是写好就完的，是需要不断修改不断维护的，80%的软件成本都是在维护上。所以，如何让你的架构有更好的扩展性，可以更容易地运维，这个是比较重要的。所谓的扩展性，意味着，我可以很容易地加更多的功能，或是加入更多的系统，而所谓可运维，就是说我可以对线上的系统做任意的变更。扩展性要求的是有标准规范且不耦合的业务架构，可运维性要求的则是可控的能力，也就是一组各式各样的控制系统。</p><ul><li><strong>通过服务编排架构来降低服务间的耦合</strong>。比如：通过一个业务流程的专用服务，或是像 Workflow，Event Driven Architecture ， Broker，Gateway，Service Discovery 等这类的的中间件来降低服务间的依赖关系。</li><li><strong>通过服务发现或服务网关来降低服务依赖所带来的运维复杂度</strong>。服务发现可以很好的降低相关依赖服务的运维复杂度，让你可以很轻松的上线或下线服务，或是进行服务伸缩。</li><li><strong>一定要使用各种软件设计的原则</strong>。比如：像SOLID这样的原则（参看《<a href="https://coolshell.cn/articles/4535.html" title="一些软件设计的原则">一些软件设计的原则</a>》），IoC/DIP，SOA 或 Spring Cloud 等 架构的最佳实践（参看《<a href="https://coolshell.cn/articles/5701.html" title="SteveY对Amazon和Google平台的吐槽 - 67,710 人阅读">SteveY对Amazon和Google平台的吐槽</a>》中的 Service Interface 的那几条军规），分布式系统架构的相关实践（参看：《<a href="https://coolshell.cn/articles/10910.html" title="分布式系统的事务处理">分布式系统的事务处理</a>》，或微软件的 《<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/">Cloud Design Patterns</a>》）……等等</li></ul><h2 id="原则七：对控制逻辑进行全面收口"><a href="#原则七：对控制逻辑进行全面收口" class="headerlink" title="原则七：对控制逻辑进行全面收口"></a>原则七：对控制逻辑进行全面收口</h2><p>所有的程序都会有两种逻辑，一种是业务逻辑，一种是控制逻辑，业务逻辑就是完成业务的逻辑，控制逻辑是辅助，比如你用多线程，还是用分布式，是用数据库还是用文件，如何配置、部署，运维、监控，事务控制，服务发现，弹性伸缩，灰度发布，高并发，等等，等等 ……这些都是控制逻辑，跟业务逻辑没有一毛钱关系。控制逻辑的技术深度会通常会比业务逻辑要深一些，门槛也会要高一些，所以，最好要专业的程序员来负责控制逻辑的开发，统一规划统一管理，进行收口。这其中包括：</p><ul><li><strong>流量收口。</strong>包括南北向和东西向的流量的调度，主要通过流量网关，开发框架 SDK或 Service Mesh 这样的技术。</li><li><strong>服务治理收口。</strong>包括：服务发现、健康检查，配置管理、事务、事件、重试、熔断、限流……主要通过开发框架 SDK – 如：Spring Cloud，或服务网格Service Mesh等技术。</li><li><strong>监控数据收口。</strong>包括：日志、指标、调用链……主要通过一些标准主流的探针，再加上后台的数据清洗和数据存储来完成，最好是使用无侵入式的技术。监控的数据必须统一在一个地方进行关联，这样才会产生信息。</li><li><strong>资源调度有应用部署的收口。</strong>包括：计算、网络和存储的收口，主要是通过容器化的方案，如k8s来完成。</li><li><strong>中间件的收口。</strong>包括：数据库，消息，缓存，服务发现，网关……等等。这类的收口方式一般要在企业内部统一建立一个共享的云化的中间件资源池。</li></ul><p>对此，这里的原则是：</p><ul><li><strong>你要选择容易进行业务逻辑和控制逻辑分离的技术。</strong>这里，Java 的 JVM+字节码注入+AOP 式的Spring 开发框架，会带给你太多的优势。</li><li><strong>你要选择可以享受“前人种树，后人乘凉”的有技术红利的技术。</strong>如：有庞大社区而且相互兼容的技术，如：Java, Docker,  Ansible，HTTP，Telegraf/Collectd……</li><li><strong>中间件你要使用可以 支持HA集群和多租户的技术。</strong> 这里基本上所有的主流中间件都会支持 HA 集群方式的。</li></ul><h2 id="原则八：不要迁就老旧系统的技术债务"><a href="#原则八：不要迁就老旧系统的技术债务" class="headerlink" title="原则八：不要迁就老旧系统的技术债务"></a>原则八：不要迁就老旧系统的技术债务</h2><p>我发现很多公司都很非常大的技术债务，这些债务具体表现如下：</p><ul><li><strong>使用老旧的技术。</strong> 比如，使用HTTP1.0， Java 1.6，Websphere，ESB，基于 socket的通讯协议，过时的模型……等等</li><li><strong>不合理的设计。</strong> 比如，在 gateway 中写大量的业务逻辑，单体架构，数据和业务逻辑深度耦合，错误的系统架构（把缓存当数据库，用消息队列同步数据）……等等</li><li><strong>缺少配套设施。</strong>比如，没有自动化测试，没有好的软件文档，没有质量好的代码，没有标准和规范……等等</li></ul><p>来找我寻求技术帮助的人都有各种各样的问题。我都会对他们苦口婆心地说同样的一句话——“<strong>如果你是来找我 case-by-case 解决问题，我兴趣不大，因为，你们千万不要寄希望能够很简单的把一辆夏利车改成一辆法拉利跑车，或是把一栋地基没打好的歪楼搞正。以前欠下的技术债，都得要还，没打好的地基要重新打，没建配套设施都要建。这些基础设施如果不按照正确科学的方式建立的话，你是不可能有一个好的的系统，我也没办法帮你 case-by-case 的解决问题……”</strong>，一开始，他们都会对我说，没问题，我们就是要还债，但是，最后发现要还的债真多，有点承受不了，就开始现原形了。</p><p>他们开始为自己的“欠的技术债”找各种合理化的理由——给你解释各种各样的历史原因和不得以而为之的理由。谈着谈着，让我有一种感觉——他们希望得到一种什么都不改什么都不付出的方式就可以进步的心态，他们宁可让新的技术 low 下来迁就于这些技术债，把新的技术滥用地乱七八糟的。有一个公司，他们的系统架构和技术选型基本都搞错了，使用错误的模型构建系统，导致整个系统的性能非常之差，也才几千万条数据，但他们想的不是还债，不是把地基和配套设施建好，而且要把楼修的更高，上更多的系统——他们觉得现有的系统挺好，性能问题的原因是他们没一个大数据平台，所以要建大数据平台……</p><p>我见过很多很多公司，包括大如 BAT 这样的公司，都会在原来的技术债上进行更多的建设，然后，技术债越来越大，利息越来越大，最终成为一个高利贷，再也还不了（我在《<a href="https://coolshell.cn/articles/11656.html">开发团队的效率</a>》一文中讲过一个 WatchDog 的架构模式，一个系统烂了，不是去改这个系统，而是在旁边建一个系统来看着它，我很难理解为什么会有这样的逻辑，也许是为了要解决更多的就业……）</p><p>这里有几个原则和方法我是非常坚持的，分享给大家：</p><ul><li><strong>与其花大力气迁就技术债务，不如直接还技术债。是所谓的长痛不如短痛。</strong></li><li><strong>建设没有技术债的“新城区”，并通过“<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer">防腐层</a> ”的架构模型，不要让技术债侵入“新城区”</strong>。</li></ul><h2 id="原则九：不要依赖自己的经验，要依赖于数据和学习"><a href="#原则九：不要依赖自己的经验，要依赖于数据和学习" class="headerlink" title="原则九：不要依赖自己的经验，要依赖于数据和学习"></a>原则九：不要依赖自己的经验，要依赖于数据和学习</h2><p>有好些人来找我跟我说他们的技术问题，然后希望我能够给他们一个答案。我说，我需要了解一下你现有系统的情况，也就是需要先做个诊断，我只有得到这些数据后，我才可能明白真正的原因是什么 ，我才可能给你做出一个比较好的技术方案。我个人觉得这是一种对对方负责的方法，因为技术手段太多了，所有的技术手段都有适应的场景，并且有各种 trade-off，所以，只有调研完后才能做出决定。这跟医生看病是一样的，确诊病因不能靠经验，还是要靠诊断数据。在科学面前，所有的经验都是靠不住的……</p><p>另外，如果有一天你在做技术决定的时候，开始凭自己以往的经验，那么你就已经不可能再成长了。人都是不可能通过不断重复过去而进步的，人的进步从来都是通过学习自己不知道的东西。所以，千万不要依赖于自己的经验做决定。做任何决定之前，最好花上一点时间，上网查一下相关的资料，技术博客，文章，论文等 ，同时，也看看各个公司，或是各个开源软件他们是怎么做的？然后，比较多种方案的 Pros/Cons，最终形成自己的决定，这样，才可能做出一个更好的决定。</p><h2 id="原则十：千万要小心-X-–-Y-问题，要追问原始需求"><a href="#原则十：千万要小心-X-–-Y-问题，要追问原始需求" class="headerlink" title="原则十：千万要小心 X – Y 问题，要追问原始需求"></a>原则十：千万要小心 X – Y 问题，要追问原始需求</h2><p>对于 <a href="https://coolshell.cn/articles/10804.html" title="X-Y Problem">X-Y 问题</a>，也就是说，用户为了解决 X问题，他觉得用 Y 可以解，于是问我 Y 怎么搞，结果搞到最后，发现原来要解决的 X 问题，这个时候最好的解决方案不是 Y，而是 Z。 这种 X-Y 问题真是相当之多，见的太多太多了。所以，每次用户来找我的时候，我都要不断地追问什么是 X 问题。</p><p>比如，好些用户都会来问我他们要一个大数据流式处理，结果追问具体要解决什么样的问题时，才发现他们的问题是因为服务中有大量的状态，需要把相同用户的数据请求放在同一个服务上处理，而且设计上导致一个慢函数拖慢整个应用服务。最终就是做一下性能调优就好了，根本没有必要上什么大数据的流式处理。</p><p>我很喜欢追问为什么 ，这种追问，会让客户也跟着来一起重新思考。比如，有个客户来找我评估的一个技术架构的决定，从理论上来说，好像这个架构在用户的这个场景下非常不错。但是，这个场景和这个架构是我职业生涯从来没有见过的。于是，我开始追问这个为什么会是这么一个场景？当我追问的时候，我发现用户都感到这个场景的各种不合理。最后引起了大家非常深刻的研讨，最终用户把那个场景修正后，而架构就突然就变成了一个常见且成熟的的模型……</p><h2 id="原则十一：激进胜于保守，创新与实用并不冲突"><a href="#原则十一：激进胜于保守，创新与实用并不冲突" class="headerlink" title="原则十一：激进胜于保守，创新与实用并不冲突"></a>原则十一：激进胜于保守，创新与实用并不冲突</h2><p>我对技术的态度是比较激进的，但是，所谓的激进并不是瞎搞，也不是见新技术就上，而是积极拥抱会改变未来的新技术，如：Docker/Go，我就非常快地跟进，但是像区块链或是 Rust 这样的，我就不是很积极。因为，其并没有命中我认为的技术趋势的几个特征（参看《<a href="https://coolshell.cn/articles/18190.html" title="Go语言、Docker 和新技术">Go,Docker 和新技术</a> 》）。当然，我也不是不喜欢的就不学了，我对区块链和 Rust 我一样学习，我也知道这些技术的优势，但我不会大规模使用它们。另外，我也尊重保守的决定，这里面没有对和错。但是，我个人觉得对技术激进的态度比起保守来说有太多的好处了。一方面来说，对于用户来说，很大程度上来说，新技术通常都表面有很好的竞争力，而且我见太多这样成功的公司都在积极拥抱新的技术的，而保守的通常来说都越来越不好。</p><p>有一些人会跟我说，我们是实用主义，我们不需要创新，能解决当下的问题就好，所以，我们不需要新技术，现有的技术用好就行了。这类的公司，他们的技术设计第一天就在负债，虽然可以解决当下问题，但是马上就会出现新的问题，然后他们会疲于解决各种问题。最后呢，最后还是会走到新的技术上。</p><p>这里的逻辑很简单 —— <strong>进步永远来自于探索，探索是要付出代价的，但是收益更大</strong>。对我而言，不敢冒险才是最大的冒险，不敢犯错才是最大的错误，害怕失去会让你失去的更多……</p><p>（全文完）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://coolshell.cn/articles/21672.html&quot;&gt;我做系统架构的一些原则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;工作 20 多年了，这 20 来年看到了很多公司系统架构，也看到了很多问题，在跟这些公司进行交流和讨论的时候，包括进行实</summary>
      
    
    
    
    
    <category term="架构" scheme="https://jenna233.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>如何做架构设计</title>
    <link href="https://jenna233.github.io/2022/09/11/%E5%A6%82%E4%BD%95%E5%81%9A%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://jenna233.github.io/2022/09/11/%E5%A6%82%E4%BD%95%E5%81%9A%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-09-11T06:04:28.000Z</published>
    <updated>2022-09-11T06:05:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://juejin.cn/post/6956851455999344670">如何做架构设计</a></p><p>首先要牢记一条：</p><blockquote><p>“ 不存在一个适用于所有应用的完美架构 ”</p></blockquote><p>如何去选择一个架构模式并不是首要之事，相较之下，搞清楚你想用架构解决什么问题更为重要。花一些时间去理解你所要解决的问题，这样可以帮助你聚焦于架构模式中能真正起作用的那些特性。踏实地按照以下步骤去操作，可以确保你设计的架构是有效的：</p><ul><li>掌握代码库当前所处的状态</li><li>标识出你想要解决的问题或者想要优化的代码</li><li>评估不同的架构模式</li><li>在做出选择前，先尝试其中一些模式看是否合适</li><li>为你的应用定义好架构基线，设立好相关的界限</li><li>回过头看你的架构是否可以有效地解决那些标识出来的问题</li><li>与时俱进，不断迭代和优化你的架构</li></ul><h4 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h4><p>通常好的架构设计实践所解决的问题主要有两个：<code>缓慢的研发效率</code>、<code>脆弱的代码质量</code>。当你遇到下面这些情况时，就会导致低效的低质：</p><ul><li>我能难读懂代码库中的代码</li><li>我改动代码有时会造成原有功能产生 bug</li><li>我的应用运行时表现地很脆弱</li><li>我的代码能难被复用</li><li>我的改动会导致大规模的代码重构</li><li>我的同事很难并行协同开发</li><li>我能难给代码写单元测试</li><li>我的团队很难把一个需求拆解成小的工作项</li><li>我的应用编译一次要很久</li></ul><p>导致这些问题的根本原因通常有两个：<code>强耦合</code>、<code>大类型</code>。<br><code>强耦合</code>指代码库中有大量的高度依赖代码，变量、类型、对象直接连接访问，缺少协议和接口，从而导致牵一发而动全身，读懂代码需要完全掌握所有依赖关系。<br><code>大类型</code>是指类、结构体、协议或枚举拥有很长的接口定义（属性和方法），对于开发者而言，在已有的类中加方法比重新设计一个类轻松地多，大类型应运而生，导致实现体也很长，问题也就接踵而至。</p><p>另外，好的架构可以帮助我们解耦，为应用增加灵活性，变得更敏捷。这样可以使我们快速响应技术和需求上的变化。当你面临如下情况时，就表示当前代码库不够敏捷：</p><ul><li>我发现自己被一种技术/实现束缚住了</li><li>我面临着在项目初期做出技术/实现上的重大抉择</li><li>我发现很难增加功能开关</li></ul><h4 id="架构选型"><a href="#架构选型" class="headerlink" title="架构选型"></a>架构选型</h4><p>当你定位了问题，接下来就是调研各种架构模式。好消息是，有大量的架构模式可供选择；坏消息是，有大量的架构模式可供选择。事实上，大多数模式彼此之间都非常相似。<strong>所以这里的建议是，可以先对你需要使用的特定领域中的架构模式进行分类，把设计思想上比较类似的模式归为一类，然后着重了解每一类中最具代表性的一个。</strong></p><p>当你对这些架构模式有了一定了解后，就该做出选择了。老实说，你选择哪种模式并不重要，重要的是你如何将这种模式<strong>付诸实践</strong>。因为大多数模式只是触及到表层，没有细化到每一层的定义，选择“正确的”架构并不能让你自动获得良好架构的代码库。决定使用哪种模式的最佳方法是在代码库中<strong>多尝试几种模式</strong>，这将为你提供关于该模式是否能满足需求的最宝贵信息。另外也不要忽略人的因素，团队有多大？成员的开发经验如何？他们的偏好？是否有时间限制？这些都要考虑进去。这里有一些问题可以帮助你做尝试和选择：</p><ul><li>你最终会产出很多样板代码吗？如果是，它们是否至少让代码更容易读懂？</li><li>你最终会产出很多只是把方法调用代理到其他对象的“空”文件吗？</li><li>这个模式是否很难被理解？</li><li>你需要进行多少重构才能应用该模式？</li><li>这个模式是否添加了很多新概念和词汇？</li><li>你是否需要导入一个库来应用该模式？</li></ul><p>这些问题并不代表是坏事，它们只是帮助你去思考。最后请记住，架构设计与其说是科学，不如说是一门艺术。请不断去实践、学习和创新。有很多好的架构方法，也有很多不是那么好的方法，但没有所谓正确的方法。</p><h4 id="付诸实践"><a href="#付诸实践" class="headerlink" title="付诸实践"></a>付诸实践</h4><p>每个模式都有各自不同的设计思路和细节，如何进行实践，你就起了决定性作用。这里再重复一次最重要的事：这是一门艺术。所以请放开你的想象力，不断去尝试、总结和学习。当然，在实践过程中，有一些我们需要普遍关注的东西，这里罗列了一些：</p><ul><li><code>解耦</code> 不管你使用哪种模式，请确保你的代码被分解成小的、松耦合的片段。</li><li><code>内聚</code> 确保你的类型具有高内聚性。如果你定义的小类型具有非常专一的职责，那就可能表现出高度的凝聚力。</li><li><code>模块</code> 确保你的应用被分解成多个模块。</li><li><code>依赖</code> 确保你使用了类似依赖注入 (Dependency Injection)、服务定位 (Service Locators) 等这样的模式来管理对象之间的依赖关系。</li></ul><p>最后，愿架构之神保佑，让这些年轻的架构师，把自己的艺术生命绽放在代码上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://juejin.cn/post/6956851455999344670&quot;&gt;如何做架构设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先要牢记一条：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“ 不存在一个适用于所有应用的完美架构 ”&lt;/p&gt;
&lt;/block</summary>
      
    
    
    
    
    <category term="架构" scheme="https://jenna233.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>一张图看懂开源许可协议，开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别</title>
    <link href="https://jenna233.github.io/2022/06/03/%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%9C%8B%E6%87%82%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81GPL%E3%80%81BSD%E3%80%81MIT%E3%80%81Mozilla%E3%80%81Apache%E5%92%8CLGPL%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://jenna233.github.io/2022/06/03/%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%9C%8B%E6%87%82%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81GPL%E3%80%81BSD%E3%80%81MIT%E3%80%81Mozilla%E3%80%81Apache%E5%92%8CLGPL%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-06-03T08:08:03.000Z</published>
    <updated>2022-06-03T08:08:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://blog.csdn.net/testcs_dn/article/details/38496107">一张图看懂开源许可协议，开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别</a></p><p>首先借用有心人士的一张相当直观清晰的图来划分各种协议：开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别<br><img src="https://upload-images.jianshu.io/upload_images/15531792-d34da2c07a21392a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>以下是上述协议的简单介绍：</p><h4 id="BSD开源协议"><a href="#BSD开源协议" class="headerlink" title="BSD开源协议"></a>BSD开源协议</h4><p>BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。</p><p>但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p><ul><li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li><li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li></ul><p>BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p><h4 id="Apache-Licence-2-0"><a href="#Apache-Licence-2-0" class="headerlink" title="Apache Licence 2.0"></a>Apache Licence 2.0</h4><p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似：</p><ul><li>需要给代码的用户一份Apache Licence</li><li>如果你修改了代码，需要再被修改的文件中说明。</li><li>在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li><li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。</li></ul><p>Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。</p><h4 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h4><p>我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，<code>但不允许修改后和衍生的代码做为闭源的商业软件发布和销售</code>。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。</p><p>GPL协议的主要内容是只要在一个软件中使用(”使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。</p><p>由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。</p><p>其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。</p><h4 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h4><p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。<code>LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码</code>。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p><p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p><p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品</p><h4 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h4><p>MIT是和BSD一样宽范的许可协议,作者只想保留版权,而无任何其他限制.也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的.</p><h4 id="MPL"><a href="#MPL" class="headerlink" title="MPL"></a>MPL</h4><p>MPL是The Mozilla Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA 认定的开源软件许可证）。但是，相比而言MPL还有以下几个显著的不同之处:</p><p>◆ MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL 许可证中对“发布”的定义是“以源代码方式发布的文件”，<code>这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可</code>。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口。<br>◆ MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序。<br>◆ 对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利。<br>◆ 对源代码的定义<br>而在MPL（1.1版本）许可证中，对源代码的定义是:“源代码指的是对作品进行修改最优先择取的形式，它包括:所有模块的所有源程序，加上有关的接口的定义，加上控制可执行作品的安装和编译的‘原本’（原文为‘Script’），或者不是与初始源代码显著不同的源代码就是被源代码贡献者选择的从公共领域可以得到的程序代码。”<br>◆ MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。</p><p>英文原文：<a href="http://www.mozilla.org/MPL/MPL-1.1.html">http://www.mozilla.org/MPL/MPL-1.1.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://blog.csdn.net/testcs_dn/article/details/38496107&quot;&gt;一张图看懂开源许可协议，开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先借用</summary>
      
    
    
    
    
    <category term="架构" scheme="https://jenna233.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>开源许可证教程</title>
    <link href="https://jenna233.github.io/2022/06/03/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81%E6%95%99%E7%A8%8B/"/>
    <id>https://jenna233.github.io/2022/06/03/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81%E6%95%99%E7%A8%8B/</id>
    <published>2022-06-03T08:06:03.000Z</published>
    <updated>2022-06-03T08:06:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://www.ruanyifeng.com/blog/2017/10/open-source-license-tutorial.html">开源许可证教程</a></p><p>作为一个开发者，如果你打算开源自己的代码，千万不要忘记，选择一种开源许可证（license）。</p><p>许多开发者对开源许可证了解很少，不清楚有哪些许可证，应该怎么选择。本文介绍开源许可证的基本知识，主要参考了 OpenSource.com （<a href="https://opensource.com/article/17/9/9-open-source-software-rules-startups">1</a>，<a href="https://opensource.com/article/17/9/open-source-licensing">2</a>）。</p><h1 id="一、什么是开源许可证"><a href="#一、什么是开源许可证" class="headerlink" title="一、什么是开源许可证"></a>一、什么是开源许可证</h1><p>开源许可证是一种法律许可。通过它，版权拥有人明确允许，用户可以免费地使用、修改、共享版权软件。</p><p>版权法默认禁止共享，也就是说，没有许可证的软件，就等同于保留版权，虽然开源了，用户只能看看源码，不能用，一用就会侵犯版权。所以软件开源的话，必须明确地授予用户开源许可证。</p><h1 id="二、开源许可证的种类"><a href="#二、开源许可证的种类" class="headerlink" title="二、开源许可证的种类"></a>二、开源许可证的种类</h1><p>目前，国际公认的开源许可证共有<a href="https://opensource.org/licenses/alphabetical">80多种</a>。它们的共同特征是，都允许用户免费地使用、修改、共享源码，但是都有各自的使用条件。</p><p>如果一种开源许可证没有任何使用条件，连保留作者信息都不需要，那么就等同于放弃版权了。这时，软件可以直接声明进入”公共领域”（public domain）。</p><p>根据使用条件的不同，开源许可证分成两大类。</p><blockquote><ul><li>宽松式（permissive）许可证</li><li>Copyleft 许可证</li></ul></blockquote><h1 id="三、宽松式许可证"><a href="#三、宽松式许可证" class="headerlink" title="三、宽松式许可证"></a>三、宽松式许可证</h1><h4 id="3-1-特点"><a href="#3-1-特点" class="headerlink" title="3.1 特点"></a>3.1 特点</h4><p>宽松式许可证（permissive license）是最基本的类型，对用户几乎没有限制。用户可以修改代码后闭源。</p><p>它有三个基本特点。</p><p><strong>（1）没有使用限制</strong></p><p>用户可以使用代码，做任何想做的事情。</p><p><strong>（2）没有担保</strong></p><p>不保证代码质量，用户自担风险。</p><p><strong>（3）披露要求（notice requirement）</strong></p><p>用户必须披露原始作者。</p><h4 id="3-2-常见许可证"><a href="#3-2-常见许可证" class="headerlink" title="3.2 常见许可证"></a>3.2 常见许可证</h4><p>常见的宽松式许可证有四种。它们都允许用户任意使用代码，区别在于要求用户遵守的条件不同。</p><p><strong>（1）BSD（二条款版）</strong></p><p>分发软件时，必须保留原始的许可证声明。</p><p><strong>（2） BSD（三条款版）</strong></p><p>分发软件时，必须保留原始的许可证声明。不得使用原始作者的名字为软件促销。</p><p><strong>（3）MIT</strong></p><p>分发软件时，必须保留原始的许可证声明，与 BSD（二条款版）基本一致。</p><p><strong>（4）Apache 2</strong></p><p>分发软件时，必须保留原始的许可证声明。凡是修改过的文件，必须向用户说明该文件修改过；没有修改过的文件，必须保持许可证不变。</p><h1 id="四、Copyleft-许可证"><a href="#四、Copyleft-许可证" class="headerlink" title="四、Copyleft 许可证"></a>四、Copyleft 许可证</h1><h3 id="4-1-Copyleft-的含义"><a href="#4-1-Copyleft-的含义" class="headerlink" title="4.1 Copyleft 的含义"></a>4.1 Copyleft 的含义</h3><p>Copyleft 是<a href="https://www.ruanyifeng.com/blog/2005/03/post_112.html">理查德·斯托曼</a>发明的一个词，作为 Copyright （版权）的反义词。</p><p>Copyright 直译是”复制权”，这是版权制度的核心，意为不经许可，用户无权复制。作为反义词，Copyleft 的含义是不经许可，用户可以随意复制。</p><p>但是，它带有前提条件，比宽松式许可证的限制要多。</p><blockquote><ul><li>如果分发二进制格式，必须提供源码</li><li>修改后的源码，必须与修改前保持许可证一致</li><li>不得在原始许可证以外，附加其他限制</li></ul></blockquote><p>上面三个条件的核心就是：修改后的 Copyleft 代码不得闭源。</p><h4 id="4-2-常见许可证"><a href="#4-2-常见许可证" class="headerlink" title="4.2 常见许可证"></a>4.2 常见许可证</h4><p>常见的 Copyleft 许可证也有四种（对用户的限制从最强到最弱排序）。</p><p><strong>（1）Affero GPL (AGPL)</strong></p><p>如果云服务（即 SAAS）用到的代码是该许可证，那么云服务的代码也必须开源。</p><p><strong>（2）GPL</strong></p><p>如果项目包含了 GPL 许可证的代码，那么整个项目都必须使用 GPL 许可证。</p><p><strong>（3）LGPL</strong></p><p>如果项目采用动态链接调用该许可证的库，项目可以不用开源。</p><p><strong>（4）Mozilla（MPL）</strong></p><p>只要该许可证的代码在单独的文件中，新增的其他文件可以不用开源。</p><h1 id="五、常见问题"><a href="#五、常见问题" class="headerlink" title="五、常见问题"></a>五、常见问题</h1><p>本节回答一些开源许可证的常见问题。</p><h4 id="5-1-什么叫分发（distribution）？"><a href="#5-1-什么叫分发（distribution）？" class="headerlink" title="5.1 什么叫分发（distribution）？"></a>5.1 什么叫分发（distribution）？</h4><p>除了 Affero GPL (AGPL) ，其他许可证都规定只有在”分发”时，才需要遵守许可证。换言之，如果不”分发”，就不需要遵守。</p><p>简单说，分发就是指将版权作品从一个人转移到另一个人。这意味着，如果你是自己使用，不提供给他人，就没有分发。另外，这里的”人”也指”法人”，因此如果使用方是公司，且只在公司内部使用，也不需要遵守许可证。</p><p>云服务（SaaS）是否构成”分发”呢？答案是不构成。所以你使用开源软件提供云服务，不必提供源码。但是，Affero GPL (AGPL) 许可证除外，它规定云服务也必须提供源码。</p><h4 id="5-2-开源软件的专利如何处理？"><a href="#5-2-开源软件的专利如何处理？" class="headerlink" title="5.2 开源软件的专利如何处理？"></a>5.2 开源软件的专利如何处理？</h4><p>某些许可证（Apache 2 和 GPL v3）包含明确的条款，授予用户许可，使用软件所包含的所有专利。</p><p>另一些许可证（BSD、MIT 和 GPL v2）根本没提到专利。但是一般认为，它们默认给予用户专利许可，不构成侵犯专利。</p><p>总得来说，除非有明确的”保留专利”的条款，使用开源软件都不会构成侵犯专利。</p><h4 id="5-3-什么是披露要求？"><a href="#5-3-什么是披露要求？" class="headerlink" title="5.3 什么是披露要求？"></a>5.3 什么是披露要求？</h4><p>所有的开源许可证都带有”披露要求”（notice requirement），即要求软件的分发者必须向用户披露，软件里面有开源代码。</p><p>一般来说，你只要在软件里面提供完整的原始许可证文本，并且披露原始作者，就满足了”披露要求”。</p><h4 id="5-4-GPL-病毒是真的吗？"><a href="#5-4-GPL-病毒是真的吗？" class="headerlink" title="5.4 GPL 病毒是真的吗？"></a>5.4 GPL 病毒是真的吗？</h4><p>GPL 许可证规定，只要你的项目包含了 GPL 代码，整个项目就都变成了 GPL。有人把这种传染性比喻成”GPL 病毒”。</p><p>很多公司希望避开这个条款，既使用 GPL 软件，又不把自己的专有代码开源。理论上，这是做不到的。因为 GPL 的设计目的，就是为了防止出现这种情况。</p><p>但是实际上，不遵守 GPL，最坏情况就是被起诉。如果你向法院表示无法履行 GPL 的条件，法官只会判决你停止使用 GPL 代码（法律上叫做”停止侵害”），而不会强制要求你将源码开源，因为《版权法》里面的”违约救济”没有提到违约者必须开源，只提到可以停止侵害和赔偿损失。<br>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://www.ruanyifeng.com/blog/2017/10/open-source-license-tutorial.html&quot;&gt;开源许可证教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作为一个开发者，如果你打算开源自己的代码，千万不要忘记，选择一</summary>
      
    
    
    
    
    <category term="架构" scheme="https://jenna233.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>前端核心工具：yarn、npm、cnpm三者如何优雅的在一起使用 ？</title>
    <link href="https://jenna233.github.io/2022/05/28/%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%EF%BC%9Ayarn%E3%80%81npm%E3%80%81cnpm%E4%B8%89%E8%80%85%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8-%EF%BC%9F/"/>
    <id>https://jenna233.github.io/2022/05/28/%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%EF%BC%9Ayarn%E3%80%81npm%E3%80%81cnpm%E4%B8%89%E8%80%85%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8-%EF%BC%9F/</id>
    <published>2022-05-28T08:02:52.000Z</published>
    <updated>2022-05-28T08:03:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://segmentfault.com/a/1190000019299845">前端核心工具：yarn、npm、cnpm三者如何优雅的在一起使用 ？</a></p><p>一位用不好包管理器的前端，是一个入门级前端，一个用不好<code>webpack</code>的前端，是一个初级前端</p><p>三个包管理器是可以一起用的，只要你够胆大心细，就没任何问题！</p><ul><li><p>推荐两篇文章</p><ul><li><a href="https://segmentfault.com/a/1190000019126657">手写优化版React脚手架</a></li><li><a href="https://segmentfault.com/a/1190000019207033">手写Vue的脚手架</a></li><li><a href="https://segmentfault.com/a/1190000018827395">前端性能优化不完全手册</a></li></ul><p>在<code>javeScript</code>编写中,我们尽量不要定义全局变量，封装函数尽量不要有副作用,因为全部变量的查询时间会比局部变量的查询慢,更是考虑在<code>Node</code>的环境中无法被垃圾回收的问题</p></li></ul><h3 id="老规矩-先看原理"><a href="#老规矩-先看原理" class="headerlink" title="老规矩 先看原理"></a>老规矩 先看原理</h3><h4 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h4><ul><li><code>npm</code> 是 <code>Node.js</code> 能够如此成功的主要原因之一。<code>npm</code> 团队做了很多的工作，以确保 <code>npm</code> 保持向后兼容，并在不同的环境中保持一致。</li><li><code>npm</code>是围绕着 语义版本控制（semver）的思想而设计。</li><li>给定一个版本号：主版本号.次版本号.补丁版本号， 以下这三种情况需要增加相应的版本号：</li><li>主版本号： 当API发生改变，并与之前的版本不兼容的时候</li><li>次版本号： 当增加了功能，但是向后兼容的时候</li><li>补丁版本号：当做了向后兼容的缺陷修复的时候</li><li><code>npm 2</code> 会安装每一个包所依赖的所有依赖项。如果我们有这么一个项目，它依赖项目A，项目A依赖项目B，项目B依赖项目C，那么依赖树将如下所示：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/15531792-ff0e925fc4221fd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>这个结构可能会很长。这对于基于Unix的操作系统来说只不过是一个小烦恼，但对于Windows来说却是个破坏性的东西，因为有很多程序无法处理超过260个字符的文件路径名。</li><li><code>npm 3</code>采用了扁平依赖关系树来解决这个问题，所以我们的3个项目结构现在看起来如下所示：</li></ul><p>存了已经下载的每个版本的压缩包。本地缓存的内容可以通过<code>npm cache ls</code>命令进行查看。本地缓存的设计有助于减少安装时间。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-33c913323dd0f552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>这样，一个原来很长的文件路径名就从<code>./node_modules/package-A/node_modules/package-B/node-modules/some-file-name-in-package-c.js</code>变成了<code>/node_modules/some-file-name-in-package-c.js</code>。</li><li>这种方法的缺点是，<code>npm</code>必须首先遍历所有的项目依赖关系，然后再决定如何生成扁平的<code>node_modules</code>目录结构。<code>npm</code>必须为所有使用到的模块构建一个完整的依赖关系树，这是一个耗时的操作，是<code>npm</code>安装速度慢的一个很重要的原因。</li><li>想当然的以为每次运行<code>npm install</code>命令时，<code>NPM</code>都得从互联网上下载所有内容。</li><li>但是，<code>npm</code>是有本地缓存的，它保存了已经下载的每个版本的压缩包。本地缓存的内容可以通过<code>npm cache ls</code>命令进行查看。本地缓存的设计有助于减少安装时间。</li></ul><h4 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h4><p><code>cnpm</code>跟<code>npm</code>用法完全一致，只是在执行命令时将<code>npm</code>改为<code>cnpm</code>。<br><code>npm</code>安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果<code>npm</code>的服务器在中国就好了，于是淘宝团队干了这事。来自官网：“这是一个完整 <code>npmjs.org</code> 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”<br>官方地址：<code>http://npm.taobao.org</code><br>安装： <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><h4 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h4><ul><li><code>Yarn</code>一开始的主要目标是解决上一节中描述的由于语义版本控制而导致的<code>npm</code>安装的不确定性问题。虽然可以使用<code>npm shrinkwrap</code>来实现可预测的依赖关系树，但它并不是默认选项，而是取决于所有的开发人员知道并且启用这个选项。</li><li><code>Yarn</code>采取了不同的做法。每个<code>yarn</code>安装都会生成一个类似于<code>npm-shrinkwrap.json</code>的<code>yarn.lock</code>文件，而且它是默认创建的。除了常规信息之外，<code>yarn.lock</code>文件还包含要安装的内容的校验和，以确保使用的库的版本相同。</li><li><code>yarn</code>是经过重新设计的崭新的<code>npm</code>客户端，它能让开发人员并行处理所有必须的操作，并添加了一些其他改进。</li><li>运行速度得到了显著的提升，整个安装时间也变得更少</li><li>像<code>npm</code>一样，<code>yarn</code>使用本地缓存。与<code>npm</code>不同的是，<code>yarn</code>无需互联网连接就能安装本地缓存的依赖项，它提供了离线模式。</li><li>允许合并项目中使用到的所有的包的许可证</li><li>通常情况下不建议通过<code>npm</code>进行安装。<code>npm</code>安装是非确定性的，程序包没有签名，并且<code>npm</code>除了做了基本的<code>SHA1</code>哈希之外不执行任何完整性检查，这给安装系统程序带来了安全风险。(作者曾经在一个上百个依赖包的项目中使用<code>npm</code>丢包过，代价非常大，泪水不自觉掉下来)<blockquote><p>首先看一次非常失败的包下载 竟然是从全局读取的资源(不配置<code>webpack</code>别名是因为就这一个路径这么长)</p></blockquote></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/15531792-936a9fcbd4f35058.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>首先我们从原理入手 ，我们使用 <code>npm init</code>, <code>yarn init</code> ,<code>cnpm init</code> 的时候 发生了什么 ？</p></blockquote><ul><li>生成<code>package.json</code>文件</li><li><code>json</code>文件内部声明初始的版本信息、作者信息等，如果你是需要上传到<code>npm</code>上作为命令行工具，应该配置<code>bin</code>等声明入口字段<blockquote><p>那么当我们使用<code>npm i</code> , <code>yarn add</code> ,<code>cnpm i</code> 操作时候会发生什么 ？</p></blockquote></li><li>首先会根据你的命令行后缀是否加了<code> -g</code> 或者<code>global</code>判断，下载的包是放在全局的环境，还是当前<code>package.json</code>文件对应的<code>node_module</code>文件夹目录下(这点尤其重要，有人出BUG，就是因为在用<code>npm </code>, <code>cnpm</code>时候没有注明添加的是全局依赖还是本地依赖，导致json文件上没有对应的包名，项目永远起不来)</li><li>然后根据你的指令<code>--save </code>或者<code>-D</code>、<code>--save -dev</code>判断是开发依赖还是线上依赖，其实这点在<code>yarn</code>上没有问题，因为<code>yarn</code>有自己的一套检查包完整性的机制，不会丢包，还会自动判断添加依赖，出<code>bug</code>一般是<code>cnpm</code>和<code>npm</code>，没有明确<code>-g</code>或者<code>--save</code>，<code>npm</code>只有检查程序员签名的机制，没有检查包完整性的机制，也不会自动添加依赖到<code>json</code>文件，那么就会出现丢包的假象，所以建议主要使用<code>yarn</code></li></ul><h4 id="yarn和npm对比"><a href="#yarn和npm对比" class="headerlink" title="yarn和npm对比"></a><code>yarn</code>和<code>npm</code>对比</h4><p><img src="https://upload-images.jianshu.io/upload_images/15531792-4060ca3cfed0f963.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h5 id="npm的缺点汇总："><a href="#npm的缺点汇总：" class="headerlink" title="npm的缺点汇总："></a><code>npm</code>的缺点汇总：</h5><ul><li>同一个项目，安装的时候无法保持一致性。由于<code>package.json</code>文件中版本号的特点，下面三个版本号在安装的时候代表不同的含义。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;5.0.3&quot;,</span><br><span class="line">&quot;~5.0.3&quot;,</span><br><span class="line">&quot;^5.0.3&quot;</span><br></pre></td></tr></table></figure></li><li>“5.0.3”表示安装指定的5.0.3版本，“～5.0.3”表示安装5.0.X中最新的版本，“^5.0.3”表示安装5.X.X中最新的版本。这就麻烦了，常常会出现同一个项目，有的同事是OK的，有的同事会由于安装的版本不一致出现bug。</li><li>安装的时候，包会在同一时间下载和安装，中途某个时候，一个包抛出了一个错误，但是<code>npm</code>会继续下载和安装包。因为<code>npm</code>会把所有的日志输出到终端，有关错误包的错误信息就会在一大堆<code>npm</code>打印的警告中丢失掉，并且你甚至永远不会注意到实际发生的错误。</li></ul><h5 id="yarn的优点"><a href="#yarn的优点" class="headerlink" title="yarn的优点"></a><code>yarn</code>的优点</h5><ul><li><p>速度快 。速度快主要来自以下两个方面：</p></li><li><p>并行安装：无论 <code>npm</code> 还是 <code>Yarn</code> 在执行包的安装时，都会执行一系列任务。<code>npm</code> 是按照队列执行每个 <code>package</code>，也就是说必须要等到当前 <code>package</code> 安装完成之后，才能继续后面的安装。而 <code>Yarn</code> 是并行执行所有任务，提高了性能。</p></li><li><p>离线模式：<code>如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。</code></p></li><li><p>安装版本统一：为了防止拉取到不同的版本，<code>Yarn</code> 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，<code>Yarn</code> 就会创建（或更新）<code>yarn.lock</code> 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。<code>npm</code> 其实也有办法实现处处使用相同版本的 <code>packages</code>，但需要开发者执行 <code>npm shrinkwrap</code> 命令。这个命令将会生成一个锁定文件，在执行 <code>npm install</code> 的时候，该锁定文件会先被读取，和 <code>Yarn</code> 读取 <code>yarn.lock</code> 文件一个道理。<code>npm</code> 和 <code>Yarn</code> 两者的不同之处在于，<code>Yarn</code> 默认会生成这样的锁定文件，而 <code>npm</code> 要通过 <code>shrinkwrap </code>命令生成 <code>npm-shrinkwrap.json</code> 文件，只有当这个文件存在的时候，<code>packages</code> 版本信息才会被记录和更新。</p></li><li><p>更简洁的输出：<code>npm</code> 的输出信息比较冗长。在执行 <code>npm install &lt;package&gt;</code> 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，<code>Yarn</code> 简洁太多：默认情况下，结合了 <code>emoji</code>直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。</p></li><li><p>多注册来源处理：所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 <code>npm</code> 要么是 <code>bower</code>, 防止出现混乱不一致。</p></li><li><p>更好的语义化： <code>yarn</code>改变了一些<code>npm</code>命令的名称，比如 <code>yarn add/remove</code>，感觉上比 <code>npm</code> 原本的 <code>install/uninstall</code> 要更清晰。</p></li></ul><blockquote><p>那不是标题党？ 说了<code>yarn</code>这么多优点，我们为什么还要<code>npm</code>呢？</p></blockquote><h5 id="你不用npm-publish-，你怎么上传包到npm-你不用cnpm，是下载不了一些包的"><a href="#你不用npm-publish-，你怎么上传包到npm-你不用cnpm，是下载不了一些包的" class="headerlink" title="你不用npm publish ，你怎么上传包到npm? 你不用cnpm，是下载不了一些包的"></a>你不用<code>npm publish</code> ，你怎么上传包到<code>npm</code>? 你不用<code>cnpm</code>，是下载不了一些包的</h5><blockquote><p>搞清楚三者下载包（依赖）的本质结果：</p></blockquote><ul><li>首先向对应的<code>node_module</code>文件夹下面下载包（如果你非要下到全局，那么再见）</li><li>再然后是<code>json</code>文件中添加对应的依赖字段,确定是线上依赖还是开发依赖</li><li>只要做到这两者 你就下包成功</li><li>总结就是 只要结果 过程管你是啥</li></ul><blockquote><p>使用<code>yarn</code>下载过的包，再使用<code>npm cnpm</code>下载 会重复下载，删除之前的包</p></blockquote><ul><li><code>puppeteer</code>这个包所依赖的<code>mini</code>版谷歌浏览器使用<code>cnpm</code>下载就可以完美解决</li><li><code>prerender-spa-plugin</code>这个包依赖上面的木偶戏 <code>puppeteer</code>这个包，也可以用<code>cnpm</code>下载</li><li>混合使用包管理器切记，不要重复下载依赖，<code>npm cnpm</code>下载依赖，一定要添加注明是什么依赖，是否全局安装</li><li><code>yarn</code>和<code>npm i</code>两者，选择前者，原因在上面有提到，总体来说，<code>yarn</code>是不二选择，但是其他两者也不可缺少，比如<code>electron</code>这个依赖，使用<code>cnpm</code>就可以完美一键安装</li></ul><blockquote><p>只要胆大心细，就可以把三者用得如鱼得水，不然就会被按在地上摩擦，实践过程踩坑也是正常 觉得写得好别忘了关注我的专栏，给个赞再走~</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://segmentfault.com/a/1190000019299845&quot;&gt;前端核心工具：yarn、npm、cnpm三者如何优雅的在一起使用 ？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一位用不好包管理器的前端，是一个入门级前端，一个用不好&lt;code&gt;w</summary>
      
    
    
    
    
    <category term="React &amp; JS" scheme="https://jenna233.github.io/tags/React-JS/"/>
    
  </entry>
  
  <entry>
    <title>Android ClassLoader 加载过程源码分析</title>
    <link href="https://jenna233.github.io/2022/05/22/Android-ClassLoader-%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://jenna233.github.io/2022/05/22/Android-ClassLoader-%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-05-22T06:09:20.000Z</published>
    <updated>2022-05-22T06:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转]<a href="https://www.infoq.cn/article/rczbnbwtff_qyjrqieyl">Android ClassLoader 加载过程源码分析</a><br><img src="https://upload-images.jianshu.io/upload_images/15531792-a63dd4d829899994.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="详细分析-ClassLoader-加载原理"><a href="#详细分析-ClassLoader-加载原理" class="headerlink" title="详细分析 ClassLoader 加载原理"></a>详细分析 ClassLoader 加载原理</h2><p>ClassLoader 的继承关系如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-173e82f9a9fce7de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这里我们主要分析一下 <code>BaseDexClassLoader.findClass()</code>和 <code>ClassLoader.loadClass()</code>两个函数在系统中是怎么进行查找 class 的过程。</p><p>我们看一下系统加载类<code>ClassLoader.loadClass()</code>函数实现代码，在<code>ClassLoader.java</code>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">        &#x2F;&#x2F; 首先 检测是否已经加载过</span><br><span class="line">        Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">        if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F;去调用父类的loadClass</span><br><span class="line">                    c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; ClassNotFoundException thrown if class not found</span><br><span class="line">                &#x2F;&#x2F; from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;未找到的情况下，使用findClass在当前dex查找</span><br><span class="line">                c &#x3D; findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>1， <code>loadClass()</code>先调用<code>findLoadedClass()</code>来判断当前类是否已加载;</p></li><li><p>2， 未查找到递归去父类中查找是否加载到缓存；</p></li><li><p>3， 均未缓存，去<code>BootClassLoader</code>中查找；</p></li><li><p>4， 以上未发现，自顶级父类依次向下查找，调用<code>findClass()</code>查找当前 dex。</p></li></ul><h2 id="findLoadedClass-函数分析"><a href="#findLoadedClass-函数分析" class="headerlink" title="findLoadedClass 函数分析"></a>findLoadedClass 函数分析</h2><blockquote><p>下图为<code>findLoadedClass()</code>的调用流程；根据调用流程图配合源代码进行详细的分析原理。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/15531792-a6ed94f6180c403d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>下面介绍对应的源代码实现部分:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">    ClassLoader loader;</span><br><span class="line">    if (this &#x3D;&#x3D; BootClassLoader.getInstance())</span><br><span class="line">        loader &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        loader &#x3D; this;</span><br><span class="line">    return VMClassLoader.findLoadedClass(loader, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数最终统一调用<code>VMClassLoader.findLoadedClass()</code>进行查找类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">native static Class findLoadedClass(ClassLoader cl, String name);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现在<code>java_lang_VMClassLoader.cc</code>文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">static jclass VMClassLoader_findLoadedClass(JNIEnv* env, jclass, jobject javaLoader,jstring javaName) &#123;</span><br><span class="line">  ....</span><br><span class="line">  ObjPtr&lt;mirror::ClassLoader&gt; loader &#x3D; soa.Decode&lt;mirror::ClassLoader&gt;(javaLoader);</span><br><span class="line">  ClassLinker* cl &#x3D; Runtime::Current()-&gt;GetClassLinker();</span><br><span class="line"></span><br><span class="line">  ObjPtr&lt;mirror::Class&gt; c &#x3D; VMClassLoader::LookupClass(cl,</span><br><span class="line">                                                       soa.Self(),</span><br><span class="line">                                                       descriptor.c_str(),</span><br><span class="line">                                                       descriptor_hash,</span><br><span class="line">                                                       loader);</span><br><span class="line">  if (c !&#x3D; nullptr &amp;&amp; c-&gt;IsResolved()) &#123;</span><br><span class="line">    return soa.AddLocalReference&lt;jclass&gt;(c);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  if (loader !&#x3D; nullptr) &#123;</span><br><span class="line">    &#x2F;&#x2F; Try the common case.</span><br><span class="line">    StackHandleScope&lt;1&gt; hs(soa.Self());</span><br><span class="line">    c &#x3D; VMClassLoader::FindClassInPathClassLoader(cl,</span><br><span class="line">                                                  soa,</span><br><span class="line">                                                  soa.Self(),</span><br><span class="line">                                                  descriptor.c_str(),</span><br><span class="line">                                                  descriptor_hash,</span><br><span class="line">                                                  hs.NewHandle(loader));</span><br><span class="line">    if (c !&#x3D; nullptr) &#123;</span><br><span class="line">      return soa.AddLocalReference&lt;jclass&gt;(c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  static mirror::Class* LookupClass(ClassLinker* cl,</span><br><span class="line">                                    Thread* self,</span><br><span class="line">                                    const char* descriptor,</span><br><span class="line">                                    size_t hash,</span><br><span class="line">                                    ObjPtr&lt;mirror::ClassLoader&gt; class_loader)</span><br><span class="line">      REQUIRES(!Locks::classlinker_classes_lock_)</span><br><span class="line">      REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">    return cl-&gt;LookupClass(self, descriptor, hash, class_loader);</span><br><span class="line">  &#125;</span><br><span class="line">  static ObjPtr&lt;mirror::Class&gt; FindClassInPathClassLoader(ClassLinker* cl,</span><br><span class="line">                                                          ScopedObjectAccessAlreadyRunnable&amp; soa,</span><br><span class="line">                                                          Thread* self,</span><br><span class="line">                                                          const char* descriptor,</span><br><span class="line">                                                          size_t hash,</span><br><span class="line">                                                          Handle&lt;mirror::ClassLoader&gt; class_loader)</span><br><span class="line">      REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">    ObjPtr&lt;mirror::Class&gt; result;</span><br><span class="line">    if (cl-&gt;FindClassInBaseDexClassLoader(soa, self, descriptor, hash, class_loader, &amp;result)) &#123;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码<code>findLoadedClass()</code>分为两步；</p><ul><li><p>1，通过<code>class_linker_-&amp;gt;Lookupclass()</code>进行查找加载类；</p></li><li><p>2，如果没找到再通过<code>class_linker_-&amp;gt;FindClassInPathClassLoader()</code>进行查找。</p></li></ul><blockquote><p><code>class_linker_</code>在虚拟机的启动<code>startVM()</code>函数的时候进行的初始化。</p><p><code>Runtime::class_linker_</code>在<code>Runtime::Init()</code>函数的时候做的初始化。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (UNLIKELY(IsAotCompiler())) &#123;</span><br><span class="line">  class_linker_ &#x3D; new AotClassLinker(intern_table_);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  class_linker_ &#x3D; new ClassLinker(intern_table_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续来分析<code>ClassLinker::LookupClass()</code>函数的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mirror::Class* ClassLinker::LookupClass(Thread* self,</span><br><span class="line">                                        const char* descriptor,</span><br><span class="line">                                        size_t hash,</span><br><span class="line">                                        ObjPtr&lt;mirror::ClassLoader&gt; class_loader) &#123;</span><br><span class="line">  ReaderMutexLock mu(self, *Locks::classlinker_classes_lock_);</span><br><span class="line">  ClassTable* const class_table &#x3D; ClassTableForClassLoader(class_loader);</span><br><span class="line">  if (class_table !&#x3D; nullptr) &#123;</span><br><span class="line">    ObjPtr&lt;mirror::Class&gt; result &#x3D; class_table-&gt;Lookup(descriptor, hash);</span><br><span class="line">    if (result !&#x3D; nullptr) &#123;</span><br><span class="line">      return result.Ptr();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>LookupClass()</code>函数通过<code>class_loader</code>是否为<code>nullptr</code>，<code>nullptr</code>使用<code>boot_class_table_</code>来获取<code>class_table</code>, 否则获取当前<code>ClassLoader</code>的<code>ClassTable</code>。 <code>class_table</code>存放当前已经加载过的 class，其实可以理解为 class cache。如何进行 dex 解析和 aot 等加载系统类和解析映射到内存中的不在此处展开分析。可以了解 art 虚拟机启动进行详细分析。</p><h2 id="findClass-函数分析"><a href="#findClass-函数分析" class="headerlink" title="findClass()函数分析"></a>findClass()函数分析</h2><p>下图是 findClass 的调用流程；根据调用流程图配合下面的代码进行详细的分析了解：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-1c73f823cccac179.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>下面我们介绍对应的源代码实现部分。</p></blockquote><p><code>findClass()</code>函数在<code>BaseDexClassLoader.java</code>实现, 该函数主要做的事情就是在当前 dex 中查找类。如果类在当前 dex 中即返回。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">       List&lt;Throwable&gt; suppressedExceptions &#x3D; new ArrayList&lt;Throwable&gt;();</span><br><span class="line">       Class c &#x3D; pathList.findClass(name, suppressedExceptions);</span><br><span class="line">       if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">           ...</span><br><span class="line">           throw cnfe;</span><br><span class="line">       &#125;</span><br><span class="line">       return c;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>pathList</code>类型为<code>DexPathList</code>用来保存<code>dexfile</code>文件的句柄等 dex 的操作。<code>pathList.findClass()</code>实现在当前 dex 中查找类, <code>pathList</code>在<code>new DexClassLoader()</code>构造时初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public BaseDexClassLoader(String dexPath, File optimizedDirectory,</span><br><span class="line">          String librarySearchPath, ClassLoader parent) &#123;</span><br><span class="line">      ...</span><br><span class="line">      this.pathList &#x3D; new DexPathList(this, dexPath, librarySearchPath, null);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>DexPathList.java</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public DexPathList(ClassLoader definingContext, String dexPath,</span><br><span class="line">            String librarySearchPath, File optimizedDirectory) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        this.definingContext &#x3D; definingContext;</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions &#x3D; new ArrayList&lt;IOException&gt;();</span><br><span class="line">        &#x2F;&#x2F; save dexPath for BaseDexClassLoader</span><br><span class="line">        this.dexElements &#x3D; makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                           suppressedExceptions, definingContext);</span><br><span class="line"></span><br><span class="line">        this.nativeLibraryDirectories &#x3D; splitPaths(librarySearchPath, false);</span><br><span class="line">        this.systemNativeLibraryDirectories &#x3D;</span><br><span class="line">                splitPaths(System.getProperty(&quot;java.library.path&quot;), true);</span><br><span class="line">        List&lt;File&gt; allNativeLibraryDirectories &#x3D; new ArrayList&lt;&gt;(nativeLibraryDirectories);</span><br><span class="line">        allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);</span><br><span class="line"></span><br><span class="line">        this.nativeLibraryPathElements &#x3D; makePathElements(allNativeLibraryDirectories);</span><br><span class="line"></span><br><span class="line">        if (suppressedExceptions.size() &gt; 0) &#123;</span><br><span class="line">            this.dexElementsSuppressedExceptions &#x3D;</span><br><span class="line">                suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dexElementsSuppressedExceptions &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>dexElements</code>数组保存 dexfile 文件句柄。具体实现在<code>makeDexElements()</code>函数中调用<code>loadDexFile()</code>函数加载 dex。该函数实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DexFile.java</span><br><span class="line">private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader, Element[] elements) throws IOException &#123;</span><br><span class="line">        if (optimizedDirectory &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return new DexFile(file, loader, elements);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String optimizedPath &#x3D; optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">            return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>DexFile.loadDex()</code>进行解析加载 dex 文件。关键代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private DexFile(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">    mCookie &#x3D; openDexFile(sourceName, outputName, flags, loader, elements);</span><br><span class="line">    mInternalCookie &#x3D; mCookie;</span><br><span class="line">    mFileName &#x3D; sourceName;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Object openDexFile(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; Use absolute paths to enable the use of relative paths when testing on host.</span><br><span class="line">    return openDexFileNative(new File(sourceName).getAbsolutePath(),</span><br><span class="line">                              (outputName &#x3D;&#x3D; null)</span><br><span class="line">                              ? null</span><br><span class="line">                              : new File(outputName).getAbsolutePath(),</span><br><span class="line">                              flags,loader,elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static native Object openDexFileNative(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终打开<code>dexfile</code>是通过<code>native</code>方法实现，并且返回<code>mCookie</code>, <code>mCookie</code>类型是<code>int</code>用来标识<code>dex</code>的唯一性。 <code>openDexFileNative()</code>实现代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#96;dalvik_system_DexFile.cc&#96;</span><br><span class="line">static jobject DexFile_openDexFileNative(JNIEnv* env,</span><br><span class="line">                                         jclass,</span><br><span class="line">                                         jstring javaSourceName,</span><br><span class="line">                                         jstring javaOutputName,</span><br><span class="line">                                         jint flags ATTRIBUTE_UNUSED,</span><br><span class="line">                                         jobject class_loader,</span><br><span class="line">                                         jobjectArray dex_elements)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  Runtime* const runtime &#x3D; Runtime::Current();</span><br><span class="line">  ClassLinker* linker &#x3D; runtime-&gt;GetClassLinker();</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  dex_files &#x3D; runtime-&gt;GetOatFileManager().OpenDexFilesFromOat(sourceName.c_str(), class_loader, dex_elements, &#x2F;*out*&#x2F; &amp;oat_file, &#x2F;*out*&#x2F; &amp;error_msgs);</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码通过<code>aotManager</code>打开并返回<code>mCookie</code>，进一步的打开实现不在此处展开。即上述已经填充<code>elements[]</code>,下面开始展开<code>pathList.findClass()</code>函数的查找方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BaseDexClassLoader.java</span><br><span class="line">public Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    for (Element element : dexElements) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz &#x3D; element.findClass(name, definingContext, suppressed);</span><br><span class="line">        if (clazz !&#x3D; null) &#123;</span><br><span class="line">            return clazz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dexElementsSuppressedExceptions !&#x3D; null) &#123;</span><br><span class="line">        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>findClass()</code>会遍历<code>elements[]</code>, 每个<code>element</code>保存了 dex 的<code>DexFile</code>句柄，然后调用<code>loadClassBinaryName()</code>函数进行当前 dex 查找类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;DexPathList.java</span><br><span class="line">  public Class&lt;?&gt; findClass(String name, ClassLoader definingContext,</span><br><span class="line">          List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">      return dexFile !&#x3D; null ? dexFile.loadClassBinaryName(name, definingContext, suppressed): null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    return defineClass(name, loader, mCookie, this, suppressed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Class defineClass(String name, ClassLoader loader, Object cookie, DexFile dexFile, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    Class result &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        result &#x3D; defineClassNative(name, loader, cookie, dexFile);</span><br><span class="line">    &#125; catch (NoClassDefFoundError e) &#123;</span><br><span class="line">        if (suppressed !&#x3D; null) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        if (suppressed !&#x3D; null) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>真正去 dex 或者内存中查找类的函数在<code>native</code>中<code>defineClassNative()</code>实现， 我们来分析一下真正的实现过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private static native Class defineClassNative(String name, ClassLoader loader, Object cookie, DexFile dexFile)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;dalvik_system_DexFile.cc</span><br><span class="line">static jclass DexFile_defineClassNative(JNIEnv* env,</span><br><span class="line">                                        jclass,</span><br><span class="line">                                        jstring javaName,</span><br><span class="line">                                        jobject javaLoader,</span><br><span class="line">                                        jobject cookie,</span><br><span class="line">                                        jobject dexFile) &#123;</span><br><span class="line">  std::vector&lt;const DexFile*&gt; dex_files;</span><br><span class="line">  const OatFile* oat_file;</span><br><span class="line">  if (!ConvertJavaArrayToDexFiles(env, cookie, &#x2F;*out*&#x2F; dex_files, &#x2F;*out*&#x2F; oat_file)) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ScopedUtfChars class_name(env, javaName);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  const std::string descriptor(DotToDescriptor(class_name.c_str()));</span><br><span class="line">  const size_t hash(ComputeModifiedUtf8Hash(descriptor.c_str()));</span><br><span class="line">  for (auto&amp; dex_file : dex_files) &#123;</span><br><span class="line">      ...</span><br><span class="line">      ClassLinker* class_linker &#x3D; Runtime::Current()-&gt;GetClassLinker();</span><br><span class="line">      ObjPtr&lt;mirror::Class&gt; result &#x3D; class_linker-&gt;DefineClass(soa.Self(),</span><br><span class="line">                                                               descriptor.c_str(), </span><br><span class="line">                                                               hash,</span><br><span class="line">                                                               class_loader,</span><br><span class="line">                                                               *dex_file,</span><br><span class="line">                                                               *dex_class_def);</span><br><span class="line">      &#x2F;&#x2F; Add the used dex file. This only required for the DexFile.loadClass API since normal</span><br><span class="line">      &#x2F;&#x2F; class loaders already keep their dex files live.</span><br><span class="line">      class_linker-&gt;InsertDexFileInToClassLoader(soa.Decode&lt;mirror::Object&gt;(dexFile),</span><br><span class="line">                                                 class_loader.Get());</span><br><span class="line">      ....</span><br><span class="line">        return soa.AddLocalReference&lt;jclass&gt;(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过<code>Runtime</code>拿到当前的<code>ClassLinker</code>对象，然后通过<code>class_linker-&amp;gt;DefineClass()</code>在当前 dex 中进行查找类。然后把找到的类通过<code>class_linker-&amp;gt;InsertDexFileInToClassLoader()</code>插入到 class_table 中进行缓存，返回查找到的类。这里不进一步展开分析。</p><blockquote><p>Android ClassLoader 加载过程的源代码分析到此已经分析得差不多了，如果想深入地了解具体原理，可以自己看源代码的实现。本文就介绍到这里。初次写技术分享的文章，如有错误请指正，感谢！</p></blockquote><p><strong>本文转载自公众号 360 技术（ID：qihoo_tech）</strong>。</p><p><strong>原文链接</strong>：</p><p><a href="https://mp.weixin.qq.com/s/31MGkrTTjiHfXffUDydONg"><strong>https://mp.weixin.qq.com/s/31MGkrTTjiHfXffUDydONg</strong></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[转]&lt;a href=&quot;https://www.infoq.cn/article/rczbnbwtff_qyjrqieyl&quot;&gt;Android ClassLoader 加载过程源码分析&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://upload-images.jiansh</summary>
      
    
    
    
    
    <category term="Android" scheme="https://jenna233.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
